<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangmc1024.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"db.json"};
  </script>

  <meta name="description" content="如题，结合官方文档与网络帖子，利用AI整理">
<meta property="og:type" content="article">
<meta property="og:title" content="C++并发编程核心知识体系">
<meta property="og:url" content="https://wangmc1024.github.io/2025/10/11/C++/C++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%9A%E4%BB%8E%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%88%B0%E5%93%B2%E5%AD%A6%E6%80%9D%E6%83%B3/index.html">
<meta property="og:site_name" content="Computer Science">
<meta property="og:description" content="如题，结合官方文档与网络帖子，利用AI整理">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-11T08:00:00.000Z">
<meta property="article:modified_time" content="2025-10-19T11:03:50.222Z">
<meta property="article:author" content="三子曰">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wangmc1024.github.io/2025/10/11/C++/C++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%9A%E4%BB%8E%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%88%B0%E5%93%B2%E5%AD%A6%E6%80%9D%E6%83%B3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++并发编程核心知识体系 | Computer Science</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>


<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Computer Science</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">WangMC Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时间轴</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div id="spa-content-wrap" class="content-wrap">
            

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wangmc1024.github.io/2025/10/11/C++/C++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%9A%E4%BB%8E%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%88%B0%E5%93%B2%E5%AD%A6%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/avatar.png">
      <meta itemprop="name" content="三子曰">
      <meta itemprop="description" content="欢迎来到我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Computer Science">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++并发编程核心知识体系
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-10-11 16:00:00" itemprop="dateCreated datePublished" datetime="2025-10-11T16:00:00+08:00">2025-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-19 19:03:50" itemprop="dateModified" datetime="2025-10-19T19:03:50+08:00">2025-10-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>60k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>55 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>如题，结合官方文档与网络帖子，利用AI整理</p>
</blockquote>
<span id="more"></span>
<h1>C++ 并发编程核心知识体系：从技术实现到哲学思想</h1>
<h2 id="目录">目录</h2>
<ol>
<li class="lvl-3">
<p><a href="#1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0">并发编程概述</a></p>
</li>
<li class="lvl-3">
<p><a href="#2-c%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80stdthread">C++ 线程基础：std::thread</a></p>
</li>
<li class="lvl-3">
<p><a href="#3-%E4%BA%92%E6%96%A5%E9%94%81%E6%9C%BA%E5%88%B6stdmutex%E5%AE%B6%E6%97%8F">互斥锁机制：std::mutex 家族</a></p>
</li>
<li class="lvl-3">
<p><a href="#4-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E8%89%BA%E6%9C%AF">条件变量：线程间通信的艺术</a></p>
</li>
<li class="lvl-3">
<p><a href="#5-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">并发设计模式</a></p>
</li>
<li class="lvl-3">
<p><a href="#6-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">内存模型与原子操作</a></p>
</li>
<li class="lvl-3">
<p><a href="#7-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F">异步操作：非阻塞编程范式</a></p>
</li>
<li class="lvl-3">
<p><a href="#7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%93%B2%E5%AD%A6%E6%80%9D%E6%83%B3">并发编程哲学思想</a></p>
</li>
<li class="lvl-3">
<p><a href="#8-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">最佳实践与设计原则</a></p>
</li>
<li class="lvl-4">
<p><a href="#9-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">常见问题与解决方案</a></p>
</li>
</ol>
<h2 id="1-并发编程概述">1. 并发编程概述</h2>
<h3 id="1-1-什么是并发编程">1.1 什么是并发编程</h3>
<p>并发编程是指在同一时间间隔内执行多个任务的编程范式。在 C++ 中，这主要通过多线程来实现，每个线程代表一个独立的执行路径。</p>
<h3 id="1-2-并发编程的核心挑战">1.2 并发编程的核心挑战</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数据竞争</strong>：多个线程同时访问共享数据</p>
</li>
<li class="lvl-2">
<p><strong>死锁</strong>：线程间相互等待对方释放资源</p>
</li>
<li class="lvl-2">
<p><strong>活锁</strong>：线程不断改变状态但无法继续执行</p>
</li>
<li class="lvl-2">
<p><strong>内存可见性</strong>：CPU 缓存导致的操作不可见问题</p>
</li>
<li class="lvl-2">
<p><strong>指令重排序</strong>：编译器和 CPU 的优化导致执行顺序变化</p>
</li>
</ul>
<h3 id="1-3-C-并发编程的发展历程">1.3 C++ 并发编程的发展历程</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>C++11</strong>：引入了标准的并发编程支持</p>
</li>
<li class="lvl-2">
<p><strong>C++14</strong>：完善了并发库功能</p>
</li>
<li class="lvl-2">
<p><strong>C++17</strong>：新增了共享锁等特性</p>
</li>
<li class="lvl-2">
<p><strong>C++20</strong>：引入了协程等高级特性</p>
</li>
</ul>
<h2 id="2-C-线程基础：std-thread">2. C++ 线程基础：std::thread</h2>
<h3 id="2-1-线程的创建与管理">2.1 线程的创建与管理</h3>
<h4 id="基本线程创建">基本线程创建</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">void thread_function() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello from thread!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t(thread_function);  // 创建线程</span><br><span class="line">    t.join();                        // 等待线程完成</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传递参数">传递参数</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">void print_message(const std::string&amp; message, int count) &#123;</span><br><span class="line">    for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::string msg = &quot;Hello&quot;;</span><br><span class="line">    std::thread t(print_message, msg, 5);</span><br><span class="line">    t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-线程的生命周期管理">2.2 线程的生命周期管理</h3>
<h4 id="join-vs-detach">join() vs detach()</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">void long_running_task() &#123;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(3));</span><br><span class="line">    std::cout &lt;&lt; &quot;Task completed!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t(long_running_task);</span><br><span class="line">    </span><br><span class="line">    // 使用join()：主线程等待子线程完成</span><br><span class="line">    // t.join();</span><br><span class="line">    </span><br><span class="line">    // 使用detach()：子线程在后台运行</span><br><span class="line">    t.detach();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Main thread exiting...&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-线程属性控制">2.3 线程属性控制</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">void thread_with_high_priority() &#123;</span><br><span class="line">    // 在支持的平台上设置线程优先级</span><br><span class="line">    #ifdef _WIN32</span><br><span class="line">        // Windows平台设置优先级</span><br><span class="line">        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);</span><br><span class="line">    #elif defined(__linux__)</span><br><span class="line">        // Linux平台设置优先级</span><br><span class="line">        struct sched_param param;</span><br><span class="line">        param.sched_priority = 99;</span><br><span class="line">        pthread_setschedparam(pthread_self(), SCHED_FIFO, &amp;param);</span><br><span class="line">    #endif</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;High priority thread running...&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t(thread_with_high_priority);</span><br><span class="line">    t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-互斥锁机制：std-mutex-家族">3. 互斥锁机制：std::mutex 家族</h2>
<h3 id="3-1-互斥锁的基本概念">3.1 互斥锁的基本概念</h3>
<p>互斥锁（Mutex）是保证线程间互斥访问共享资源的同步原语。</p>
<h3 id="3-2-各种互斥锁类型">3.2 各种互斥锁类型</h3>
<h4 id="std-mutex-基本互斥锁">std::mutex - 基本互斥锁</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">int shared_counter = 0;</span><br><span class="line"></span><br><span class="line">void increment_counter() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 100000; ++i) &#123;</span><br><span class="line">        mtx.lock();</span><br><span class="line">        shared_counter++;</span><br><span class="line">        mtx.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        threads.emplace_back(increment_counter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (auto&amp; t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Final counter value: &quot; &lt;&lt; shared_counter &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="std-lock-guard-RAII-风格的锁管理">std::lock_guard - RAII 风格的锁管理</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">int shared_counter = 0;</span><br><span class="line"></span><br><span class="line">void increment_counter() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 100000; ++i) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        shared_counter++;</span><br><span class="line">        // 锁会在离开作用域时自动释放</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        threads.emplace_back(increment_counter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (auto&amp; t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Final counter value: &quot; &lt;&lt; shared_counter &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="std-unique-lock-更灵活的锁管理">std::unique_lock - 更灵活的锁管理</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">int shared_counter = 0;</span><br><span class="line"></span><br><span class="line">void increment_counter() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 100000; ++i) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        shared_counter++;</span><br><span class="line">        </span><br><span class="line">        // 可以手动解锁和重新锁定</span><br><span class="line">        lock.unlock();</span><br><span class="line">        // 执行一些不需要锁的操作</span><br><span class="line">        lock.lock();</span><br><span class="line">        shared_counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        threads.emplace_back(increment_counter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (auto&amp; t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Final counter value: &quot; &lt;&lt; shared_counter &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-17-共享锁：std-shared-mutex">C++17 共享锁：std::shared_mutex</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;shared_mutex&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">std::shared_mutex rw_mutex;</span><br><span class="line">int shared_data = 0;</span><br><span class="line"></span><br><span class="line">// 读操作：可以多个线程同时进行</span><br><span class="line">void reader_thread(int id) &#123;</span><br><span class="line">    std::shared_lock&lt;std::shared_mutex&gt; lock(rw_mutex);</span><br><span class="line">    std::cout &lt;&lt; &quot;Reader &quot; &lt;&lt; id &lt;&lt; &quot; read data: &quot; &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写操作：独占访问</span><br><span class="line">void writer_thread(int id) &#123;</span><br><span class="line">    std::unique_lock&lt;std::shared_mutex&gt; lock(rw_mutex);</span><br><span class="line">    shared_data++;</span><br><span class="line">    std::cout &lt;&lt; &quot;Writer &quot; &lt;&lt; id &lt;&lt; &quot; wrote data: &quot; &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    </span><br><span class="line">    // 创建多个读者线程</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">        threads.emplace_back(reader_thread, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建写者线程</span><br><span class="line">    for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">        threads.emplace_back(writer_thread, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (auto&amp; t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-避免死锁的技术">3.3 避免死锁的技术</h3>
<h4 id="1-统一锁获取顺序">1. 统一锁获取顺序</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">std::mutex mutex1, mutex2;</span><br><span class="line"></span><br><span class="line">void thread1() &#123;</span><br><span class="line">    std::lock(mutex1, mutex2);  // 同时获取多个锁</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock1(mutex1, std::adopt_lock);</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock2(mutex2, std::adopt_lock);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Thread 1 acquired both mutexes&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void thread2() &#123;</span><br><span class="line">    std::lock(mutex1, mutex2);  // 保持相同的获取顺序</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock1(mutex1, std::adopt_lock);</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock2(mutex2, std::adopt_lock);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Thread 2 acquired both mutexes&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t1(thread1);</span><br><span class="line">    std::thread t2(thread2);</span><br><span class="line">    </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-使用-try-lock-避免死锁">2. 使用 try_lock 避免死锁</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">std::mutex mutex1, mutex2;</span><br><span class="line"></span><br><span class="line">void thread1() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (mutex1.try_lock()) &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Thread 1 acquired mutex1&quot; &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            if (mutex2.try_lock()) &#123;</span><br><span class="line">                std::cout &lt;&lt; &quot;Thread 1 acquired mutex2&quot; &lt;&lt; std::endl;</span><br><span class="line">                // 执行操作</span><br><span class="line">                mutex2.unlock();</span><br><span class="line">                mutex1.unlock();</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mutex1.unlock();</span><br><span class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(10));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t1(thread1);</span><br><span class="line">    t1.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-条件变量：线程间通信的艺术">4. 条件变量：线程间通信的艺术</h2>
<h3 id="4-1-条件变量的基本概念">4.1 条件变量的基本概念</h3>
<p>条件变量（Condition Variable）用于线程间的通信，允许一个线程等待另一个线程满足某个条件。</p>
<h3 id="4-2-std-condition-variable-的使用">4.2 std::condition_variable 的使用</h3>
<h4 id="生产者-消费者模式">生产者 - 消费者模式</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::queue&lt;int&gt; data_queue;</span><br><span class="line">bool stop_flag = false;</span><br><span class="line"></span><br><span class="line">// 生产者线程</span><br><span class="line">void producer() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">            data_queue.push(i);</span><br><span class="line">            std::cout &lt;&lt; &quot;Produced: &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.notify_one();  // 通知消费者</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(500));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 通知消费者停止</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        stop_flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者线程</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        </span><br><span class="line">        // 等待条件：队列不为空或停止标志为true</span><br><span class="line">        cv.wait(lock, []&#123; </span><br><span class="line">            return !data_queue.empty() || stop_flag; </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        // 检查是否需要停止</span><br><span class="line">        if (stop_flag &amp;&amp; data_queue.empty()) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 处理数据</span><br><span class="line">        if (!data_queue.empty()) &#123;</span><br><span class="line">            int data = data_queue.front();</span><br><span class="line">            data_queue.pop();</span><br><span class="line">            std::cout &lt;&lt; &quot;Consumed: &quot; &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;Consumer stopped&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread prod_thread(producer);</span><br><span class="line">    std::thread cons_thread(consumer);</span><br><span class="line">    </span><br><span class="line">    prod_thread.join();</span><br><span class="line">    cons_thread.join();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-条件变量的高级用法">4.3 条件变量的高级用法</h3>
<h4 id="多个条件变量的协调">多个条件变量的协调</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv_producer;</span><br><span class="line">std::condition_variable cv_consumer;</span><br><span class="line">std::queue&lt;int&gt; data_queue;</span><br><span class="line">const int MAX_QUEUE_SIZE = 5;</span><br><span class="line">bool stop_flag = false;</span><br><span class="line"></span><br><span class="line">void producer() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        </span><br><span class="line">        // 等待队列有空间</span><br><span class="line">        cv_producer.wait(lock, []&#123;</span><br><span class="line">            return data_queue.size() &lt; MAX_QUEUE_SIZE || stop_flag;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        if (stop_flag) break;</span><br><span class="line">        </span><br><span class="line">        data_queue.push(i);</span><br><span class="line">        std::cout &lt;&lt; &quot;Produced: &quot; &lt;&lt; i &lt;&lt; &quot;, Queue size: &quot; &lt;&lt; data_queue.size() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        cv_consumer.notify_one();  // 通知消费者</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 通知消费者停止</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        stop_flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">    cv_consumer.notify_all();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        </span><br><span class="line">        // 等待队列有数据</span><br><span class="line">        cv_consumer.wait(lock, []&#123;</span><br><span class="line">            return !data_queue.empty() || stop_flag;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        if (stop_flag &amp;&amp; data_queue.empty()) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (!data_queue.empty()) &#123;</span><br><span class="line">            int data = data_queue.front();</span><br><span class="line">            data_queue.pop();</span><br><span class="line">            std::cout &lt;&lt; &quot;Consumed: &quot; &lt;&lt; data &lt;&lt; &quot;, Queue size: &quot; &lt;&lt; data_queue.size() &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            cv_producer.notify_one();  // 通知生产者队列有空间</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread prod_thread(producer);</span><br><span class="line">    std::thread cons_thread1(consumer);</span><br><span class="line">    std::thread cons_thread2(consumer);</span><br><span class="line">    </span><br><span class="line">    prod_thread.join();</span><br><span class="line">    cons_thread1.join();</span><br><span class="line">    cons_thread2.join();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-并发设计模式">5. 并发设计模式</h2>
<h3 id="5-1-Fork-Join-模式">5.1 Fork-Join 模式</h3>
<p>Fork-Join 模式将大任务分解为多个小任务并行执行，然后合并结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename Iterator, typename T&gt;</span><br><span class="line">struct accumulate_block &#123;</span><br><span class="line">    void operator()(Iterator first, Iterator last, T&amp; result) &#123;</span><br><span class="line">        result = std::accumulate(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename Iterator, typename T&gt;</span><br><span class="line">T parallel_accumulate(Iterator first, Iterator last, T init) &#123;</span><br><span class="line">    unsigned long const length = std::distance(first, last);</span><br><span class="line">    </span><br><span class="line">    if (!length)</span><br><span class="line">        return init;</span><br><span class="line">    </span><br><span class="line">    unsigned long const min_per_thread = 25;</span><br><span class="line">    unsigned long const max_threads = (length + min_per_thread - 1) / min_per_thread;</span><br><span class="line">    unsigned long const hardware_threads = std::thread::hardware_concurrency();</span><br><span class="line">    unsigned long const num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads);</span><br><span class="line">    unsigned long const block_size = length / num_threads;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;T&gt; results(num_threads);</span><br><span class="line">    std::vector&lt;std::thread&gt; threads(num_threads - 1);</span><br><span class="line">    </span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    for (unsigned long i = 0; i &lt; (num_threads - 1); ++i) &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::advance(block_end, block_size);</span><br><span class="line">        threads[i] = std::thread(</span><br><span class="line">            accumulate_block&lt;Iterator, T&gt;(),</span><br><span class="line">            block_start, block_end, std::ref(results[i])</span><br><span class="line">        );</span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    accumulate_block&lt;Iterator, T&gt;()(block_start, last, results[num_threads - 1]);</span><br><span class="line">    </span><br><span class="line">    for (auto&amp; entry : threads) &#123;</span><br><span class="line">        entry.join();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return std::accumulate(results.begin(), results.end(), init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; numbers(1000000, 1);</span><br><span class="line">    </span><br><span class="line">    int result = parallel_accumulate(numbers.begin(), numbers.end(), 0);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Parallel accumulate result: &quot; &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Expected result: &quot; &lt;&lt; numbers.size() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-线程池模式">5.2 线程池模式</h3>
<p>线程池预先创建一组线程，用于执行多个任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line"></span><br><span class="line">class ThreadPool &#123;</span><br><span class="line">public:</span><br><span class="line">    ThreadPool(size_t threads);</span><br><span class="line">    </span><br><span class="line">    template&lt;class F, class... Args&gt;</span><br><span class="line">    auto enqueue(F&amp;&amp; f, Args&amp;&amp;... args) </span><br><span class="line">        -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;;</span><br><span class="line">    </span><br><span class="line">    ~ThreadPool();</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers;</span><br><span class="line">    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;</span><br><span class="line">    </span><br><span class="line">    std::mutex queue_mutex;</span><br><span class="line">    std::condition_variable condition;</span><br><span class="line">    bool stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ThreadPool::ThreadPool(size_t threads) </span><br><span class="line">    : stop(false) &#123;</span><br><span class="line">    </span><br><span class="line">    for (size_t i = 0; i &lt; threads; ++i) &#123;</span><br><span class="line">        workers.emplace_back([this] &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                std::function&lt;void()&gt; task;</span><br><span class="line">                </span><br><span class="line">                &#123;</span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex);</span><br><span class="line">                    this-&gt;condition.wait(lock, [this] &#123;</span><br><span class="line">                        return this-&gt;stop || !this-&gt;tasks.empty();</span><br><span class="line">                    &#125;);</span><br><span class="line">                    </span><br><span class="line">                    if (this-&gt;stop &amp;&amp; this-&gt;tasks.empty())</span><br><span class="line">                        return;</span><br><span class="line">                    </span><br><span class="line">                    task = std::move(this-&gt;tasks.front());</span><br><span class="line">                    this-&gt;tasks.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                task();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class F, class... Args&gt;</span><br><span class="line">auto ThreadPool::enqueue(F&amp;&amp; f, Args&amp;&amp;... args) </span><br><span class="line">    -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    using return_type = typename std::result_of&lt;F(Args...)&gt;::type;</span><br><span class="line">    </span><br><span class="line">    auto task = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(</span><br><span class="line">        std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    std::future&lt;return_type&gt; res = task-&gt;get_future();</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex);</span><br><span class="line">        </span><br><span class="line">        if (stop)</span><br><span class="line">            throw std::runtime_error(&quot;enqueue on stopped ThreadPool&quot;);</span><br><span class="line">        </span><br><span class="line">        tasks.emplace([task]() &#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    condition.notify_one();</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool::~ThreadPool() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex);</span><br><span class="line">        stop = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    condition.notify_all();</span><br><span class="line">    </span><br><span class="line">    for (std::thread&amp; worker : workers)</span><br><span class="line">        worker.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">int calculate_square(int x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ThreadPool pool(4);</span><br><span class="line">    std::vector&lt;std::future&lt;int&gt;&gt; results;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 8; ++i) &#123;</span><br><span class="line">        results.emplace_back(</span><br><span class="line">            pool.enqueue(calculate_square, i)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (auto&amp;&amp; result : results) &#123;</span><br><span class="line">        std::cout &lt;&lt; result.get() &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-读写锁模式">5.3 读写锁模式</h3>
<p>读写锁允许多个读者同时访问，但写者需要独占访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;shared_mutex&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">class SharedData &#123;</span><br><span class="line">private:</span><br><span class="line">    int data_;</span><br><span class="line">    mutable std::shared_mutex mutex_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    SharedData(int initial_data) : data_(initial_data) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 读操作：共享访问</span><br><span class="line">    int read_data() const &#123;</span><br><span class="line">        std::shared_lock&lt;std::shared_mutex&gt; lock(mutex_);</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(10));</span><br><span class="line">        return data_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 写操作：独占访问</span><br><span class="line">    void write_data(int new_value) &#123;</span><br><span class="line">        std::unique_lock&lt;std::shared_mutex&gt; lock(mutex_);</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</span><br><span class="line">        data_ = new_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void reader_thread(SharedData&amp; data, int id) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">        int value = data.read_data();</span><br><span class="line">        std::cout &lt;&lt; &quot;Reader &quot; &lt;&lt; id &lt;&lt; &quot; read: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(50));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer_thread(SharedData&amp; data, int id, int start_value) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">        int new_value = start_value + i;</span><br><span class="line">        data.write_data(new_value);</span><br><span class="line">        std::cout &lt;&lt; &quot;Writer &quot; &lt;&lt; id &lt;&lt; &quot; wrote: &quot; &lt;&lt; new_value &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(200));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    SharedData data(0);</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    </span><br><span class="line">    // 创建5个读者线程</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">        threads.emplace_back(reader_thread, std::ref(data), i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建2个写者线程</span><br><span class="line">    threads.emplace_back(writer_thread, std::ref(data), 0, 100);</span><br><span class="line">    threads.emplace_back(writer_thread, std::ref(data), 1, 200);</span><br><span class="line">    </span><br><span class="line">    for (auto&amp; t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-内存模型与原子操作">6. 内存模型与原子操作</h2>
<h3 id="6-1-C-内存模型基础">6.1 C++ 内存模型基础</h3>
<p>C++ 内存模型定义了多线程环境下内存操作的可见性和顺序性规则。</p>
<h3 id="6-2-原子操作详解">6.2 原子操作详解</h3>
<h4 id="基本原子类型">基本原子类型</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">std::atomic&lt;int&gt; atomic_counter(0);</span><br><span class="line">int normal_counter = 0;</span><br><span class="line"></span><br><span class="line">void increment_counters() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 100000; ++i) &#123;</span><br><span class="line">        atomic_counter++;</span><br><span class="line">        normal_counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        threads.emplace_back(increment_counters);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (auto&amp; t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Atomic counter: &quot; &lt;&lt; atomic_counter &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Normal counter: &quot; &lt;&lt; normal_counter &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原子操作的内存顺序">原子操作的内存顺序</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">std::atomic&lt;bool&gt; x(false), y(false);</span><br><span class="line">std::atomic&lt;int&gt; z(0);</span><br><span class="line"></span><br><span class="line">void write_x() &#123;</span><br><span class="line">    x.store(true, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_y() &#123;</span><br><span class="line">    y.store(true, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void read_x_then_y() &#123;</span><br><span class="line">    while (!x.load(std::memory_order_acquire));</span><br><span class="line">    if (y.load(std::memory_order_acquire)) &#123;</span><br><span class="line">        z++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void read_y_then_x() &#123;</span><br><span class="line">    while (!y.load(std::memory_order_acquire));</span><br><span class="line">    if (x.load(std::memory_order_acquire)) &#123;</span><br><span class="line">        z++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">        x = false;</span><br><span class="line">        y = false;</span><br><span class="line">        z = 0;</span><br><span class="line">        </span><br><span class="line">        std::thread a(write_x);</span><br><span class="line">        std::thread b(write_y);</span><br><span class="line">        std::thread c(read_x_then_y);</span><br><span class="line">        std::thread d(read_y_then_x);</span><br><span class="line">        </span><br><span class="line">        a.join();</span><br><span class="line">        b.join();</span><br><span class="line">        c.join();</span><br><span class="line">        d.join();</span><br><span class="line">        </span><br><span class="line">        if (z.load() == 0) &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;z is 0 after &quot; &lt;&lt; i + 1 &lt;&lt; &quot; iterations&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无锁数据结构">无锁数据结构</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class LockFreeStack &#123;</span><br><span class="line">private:</span><br><span class="line">    struct Node &#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node* next;</span><br><span class="line">        </span><br><span class="line">        Node(const T&amp; data) : data(data), next(nullptr) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::atomic&lt;Node*&gt; head;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    LockFreeStack() : head(nullptr) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ~LockFreeStack() &#123;</span><br><span class="line">        while (Node* old_head = head.load()) &#123;</span><br><span class="line">            head.store(old_head-&gt;next);</span><br><span class="line">            delete old_head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(const T&amp; data) &#123;</span><br><span class="line">        Node* new_node = new Node(data);</span><br><span class="line">        new_node-&gt;next = head.load();</span><br><span class="line">        </span><br><span class="line">        // 使用compare_exchange_weak处理并发</span><br><span class="line">        while (!head.compare_exchange_weak(new_node-&gt;next, new_node)) &#123;</span><br><span class="line">            // 重试直到成功</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool pop(T&amp; result) &#123;</span><br><span class="line">        Node* old_head = head.load();</span><br><span class="line">        </span><br><span class="line">        while (old_head &amp;&amp; !head.compare_exchange_weak(old_head, old_head-&gt;next)) &#123;</span><br><span class="line">            // 重试直到成功或栈为空</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (!old_head) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        result = old_head-&gt;data;</span><br><span class="line">        delete old_head;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() const &#123;</span><br><span class="line">        return head.load() == nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void push_to_stack(LockFreeStack&lt;int&gt;&amp; stack, int start, int end) &#123;</span><br><span class="line">    for (int i = start; i &lt; end; ++i) &#123;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pop_from_stack(LockFreeStack&lt;int&gt;&amp; stack, int count, std::vector&lt;int&gt;&amp; results) &#123;</span><br><span class="line">    int value;</span><br><span class="line">    for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        if (stack.pop(value)) &#123;</span><br><span class="line">            results.push_back(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    LockFreeStack&lt;int&gt; stack;</span><br><span class="line">    std::vector&lt;int&gt; results1, results2;</span><br><span class="line">    </span><br><span class="line">    std::thread pusher1(push_to_stack, std::ref(stack), 0, 1000);</span><br><span class="line">    std::thread pusher2(push_to_stack, std::ref(stack), 1000, 2000);</span><br><span class="line">    std::thread popper1(pop_from_stack, std::ref(stack), 1000, std::ref(results1));</span><br><span class="line">    std::thread popper2(pop_from_stack, std::ref(stack), 1000, std::ref(results2));</span><br><span class="line">    </span><br><span class="line">    pusher1.join();</span><br><span class="line">    pusher2.join();</span><br><span class="line">    popper1.join();</span><br><span class="line">    popper2.join();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Pushed 2000 elements&quot; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Popped &quot; &lt;&lt; results1.size() + results2.size() &lt;&lt; &quot; elements&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-异步操作：非阻塞编程范式">7. 异步操作：非阻塞编程范式</h2>
<h3 id="7-1-异步编程概述">7.1 异步编程概述</h3>
<h4 id="7-1-1-什么是异步编程">7.1.1 什么是异步编程</h4>
<p>异步编程是一种编程范式，它允许程序在等待操作完成（如网络请求、文件 I/O、数据库查询等）时继续执行其他任务。与同步编程不同，异步操作不会阻塞当前执行流程。</p>
<h4 id="7-1-2-同步-vs-异步的本质区别">7.1.2 同步 vs 异步的本质区别</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>同步 (Synchronous)</th>
<th>异步 (Asynchronous)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>执行方式</strong></td>
<td>顺序执行，一步接一步</td>
<td>并发执行，无需等待</td>
</tr>
<tr>
<td><strong>等待行为</strong></td>
<td>阻塞等待结果返回</td>
<td>非阻塞，立即返回</td>
</tr>
<tr>
<td><strong>资源利用</strong></td>
<td>低效（CPU 常闲置等待）</td>
<td>高效（CPU 持续工作）</td>
</tr>
<tr>
<td><strong>编程模型</strong></td>
<td>直线式思维，易于理解</td>
<td>事件驱动 / 回调思维</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>简单直接</td>
<td>较复杂（回调地狱风险）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>CPU 密集型任务、简单脚本</td>
<td>I/O 密集型、高并发服务</td>
</tr>
</tbody>
</table>
<h4 id="7-1-3-生活中的异步哲学">7.1.3 生活中的异步哲学</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步场景：在快餐店排队点餐 - 必须等前一个人完成才能点餐</span><br><span class="line">异步场景：在正餐厅桌边点餐 - 点餐后可以做其他事，服务员会送餐</span><br></pre></td></tr></table></figure>
<h3 id="7-2-C-异步编程组件">7.2 C++ 异步编程组件</h3>
<h4 id="7-2-1-std-future-异步结果的占位符">7.2.1 std::future - 异步结果的占位符</h4>
<p>std::future 表示一个异步操作的结果，可以在未来某个时间点获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">// 模拟耗时计算</span><br><span class="line">int expensive_calculation(int x, int y) &#123;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(2));</span><br><span class="line">    return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Main thread started&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    // 启动异步任务</span><br><span class="line">    std::future&lt;int&gt; result_future = std::async(expensive_calculation, 10, 20);</span><br><span class="line">    </span><br><span class="line">    // 主线程可以继续执行其他任务</span><br><span class="line">    std::cout &lt;&lt; &quot;Main thread is doing other work...&quot; &lt;&lt; std::endl;</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Main: &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(300));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取异步任务结果（如果未完成会阻塞）</span><br><span class="line">    std::cout &lt;&lt; &quot;Waiting for async result...&quot; &lt;&lt; std::endl;</span><br><span class="line">    int result = result_future.get();</span><br><span class="line">    std::cout &lt;&lt; &quot;Async result: &quot; &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-2-std-async-异步任务启动器">7.2.2 std::async - 异步任务启动器</h4>
<p>std::async 是启动异步任务的便捷函数，返回一个 std::future 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">// 并行计算示例</span><br><span class="line">int parallel_sum(const std::vector&lt;int&gt;&amp; data, int start, int end) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = start; i &lt; end; ++i) &#123;</span><br><span class="line">        sum += data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; large_data(1000000, 1);</span><br><span class="line">    </span><br><span class="line">    // 将数据分成4个部分并行计算</span><br><span class="line">    int mid1 = large_data.size() / 4;</span><br><span class="line">    int mid2 = large_data.size() / 2;</span><br><span class="line">    int mid3 = 3 * large_data.size() / 4;</span><br><span class="line">    </span><br><span class="line">    std::future&lt;int&gt; f1 = std::async(parallel_sum, std::ref(large_data), 0, mid1);</span><br><span class="line">    std::future&lt;int&gt; f2 = std::async(parallel_sum, std::ref(large_data), mid1, mid2);</span><br><span class="line">    std::future&lt;int&gt; f3 = std::async(parallel_sum, std::ref(large_data), mid2, mid3);</span><br><span class="line">    std::future&lt;int&gt; f4 = std::async(parallel_sum, std::ref(large_data), mid3, large_data.size());</span><br><span class="line">    </span><br><span class="line">    // 汇总结果</span><br><span class="line">    int total = f1.get() + f2.get() + f3.get() + f4.get();</span><br><span class="line">    std::cout &lt;&lt; &quot;Total sum: &quot; &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-3-std-promise-主动设置异步结果">7.2.3 std::promise - 主动设置异步结果</h4>
<p>std::promise 允许一个线程设置结果，另一个线程通过 std::future 获取结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">void worker_thread(std::promise&lt;int&gt;&amp; prom) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Worker thread started&quot; &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(2));</span><br><span class="line">        </span><br><span class="line">        // 模拟计算</span><br><span class="line">        int result = 42;</span><br><span class="line">        </span><br><span class="line">        // 设置结果</span><br><span class="line">        prom.set_value(result);</span><br><span class="line">        std::cout &lt;&lt; &quot;Worker thread finished&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        // 设置异常</span><br><span class="line">        prom.set_exception(std::current_exception());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::promise&lt;int&gt; prom;</span><br><span class="line">    std::future&lt;int&gt; fut = prom.get_future();</span><br><span class="line">    </span><br><span class="line">    // 启动工作线程</span><br><span class="line">    std::thread t(worker_thread, std::ref(prom));</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Main thread waiting for result...&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    // 获取结果</span><br><span class="line">    try &#123;</span><br><span class="line">        int result = fut.get();</span><br><span class="line">        std::cout &lt;&lt; &quot;Result from worker: &quot; &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; catch (const std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;Exception from worker: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-4-std-packaged-task-任务包装器">7.2.4 std::packaged_task - 任务包装器</h4>
<p>std::packaged_task 将可调用对象包装起来，方便作为线程函数使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">// 矩阵乘法的一部分</span><br><span class="line">void matrix_multiply_part(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; A,</span><br><span class="line">                          const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; B,</span><br><span class="line">                          std::vector&lt;std::vector&lt;int&gt;&gt;&amp; C,</span><br><span class="line">                          int start_row, int end_row) &#123;</span><br><span class="line">    int cols_B = B[0].size();</span><br><span class="line">    int cols_A = A[0].size();</span><br><span class="line">    </span><br><span class="line">    for (int i = start_row; i &lt; end_row; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; cols_B; ++j) &#123;</span><br><span class="line">            C[i][j] = 0;</span><br><span class="line">            for (int k = 0; k &lt; cols_A; ++k) &#123;</span><br><span class="line">                C[i][j] += A[i][k] * B[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const int size = 100;</span><br><span class="line">    std::vector&lt;std::vector&lt;int&gt;&gt; A(size, std::vector&lt;int&gt;(size, 1));</span><br><span class="line">    std::vector&lt;std::vector&lt;int&gt;&gt; B(size, std::vector&lt;int&gt;(size, 2));</span><br><span class="line">    std::vector&lt;std::vector&lt;int&gt;&gt; C(size, std::vector&lt;int&gt;(size, 0));</span><br><span class="line">    </span><br><span class="line">    int num_threads = std::thread::hardware_concurrency();</span><br><span class="line">    int rows_per_thread = size / num_threads;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::future&lt;void&gt;&gt; futures;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        int start = i * rows_per_thread;</span><br><span class="line">        int end = (i == num_threads - 1) ? size : (i + 1) * rows_per_thread;</span><br><span class="line">        </span><br><span class="line">        // 使用packaged_task包装任务</span><br><span class="line">        std::packaged_task&lt;void()&gt; task([&amp;, start, end]() &#123;</span><br><span class="line">            matrix_multiply_part(A, B, C, start, end);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        futures.push_back(task.get_future());</span><br><span class="line">        </span><br><span class="line">        // 启动线程执行任务</span><br><span class="line">        std::thread t(std::move(task));</span><br><span class="line">        t.detach();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 等待所有任务完成</span><br><span class="line">    for (auto&amp; fut : futures) &#123;</span><br><span class="line">        fut.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Matrix multiplication completed&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-异步编程的设计原理">7.3 异步编程的设计原理</h3>
<h4 id="7-3-1-异步编程的核心原理">7.3.1 异步编程的核心原理</h4>
<p><strong>1. 事件驱动模型</strong></p>
<p>异步编程基于事件驱动模型，程序通过响应事件来处理任务完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">class EventLoop &#123;</span><br><span class="line">private:</span><br><span class="line">    std::queue&lt;std::function&lt;void()&gt;&gt; events_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    bool running_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    EventLoop() : running_(true) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void post(std::function&lt;void()&gt; event) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        events_.push(event);</span><br><span class="line">        cv_.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void run() &#123;</span><br><span class="line">        while (running_) &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">            cv_.wait(lock, [this]&#123; return !events_.empty() || !running_; &#125;);</span><br><span class="line">            </span><br><span class="line">            if (!running_) break;</span><br><span class="line">            </span><br><span class="line">            auto event = events_.front();</span><br><span class="line">            events_.pop();</span><br><span class="line">            lock.unlock();</span><br><span class="line">            </span><br><span class="line">            event();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void stop() &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        running_ = false;</span><br><span class="line">        cv_.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用事件循环的异步任务</span><br><span class="line">void async_task(EventLoop&amp; loop, int id) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Async task &quot; &lt;&lt; id &lt;&lt; &quot; started&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    // 模拟异步操作</span><br><span class="line">    std::thread([&amp;loop, id]() &#123;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">        </span><br><span class="line">        // 任务完成后发布事件</span><br><span class="line">        loop.post([id]() &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Async task &quot; &lt;&lt; id &lt;&lt; &quot; completed&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).detach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    </span><br><span class="line">    // 启动事件循环线程</span><br><span class="line">    std::thread loop_thread([&amp;loop]() &#123;</span><br><span class="line">        loop.run();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 提交多个异步任务</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">        async_task(loop, i);</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(200));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 等待所有任务完成</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(2));</span><br><span class="line">    </span><br><span class="line">    loop.stop();</span><br><span class="line">    loop_thread.join();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 回调机制</strong></p>
<p>回调是异步编程的基础机制，当异步操作完成时调用预设的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">// 异步文件读取模拟</span><br><span class="line">void async_file_read(const std::string&amp; filename, </span><br><span class="line">                    std::function&lt;void(const std::string&amp;)&gt; callback) &#123;</span><br><span class="line">    std::thread([filename, callback]() &#123;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">        </span><br><span class="line">        // 模拟文件内容</span><br><span class="line">        std::string content = &quot;File content of &quot; + filename;</span><br><span class="line">        </span><br><span class="line">        // 调用回调函数</span><br><span class="line">        callback(content);</span><br><span class="line">    &#125;).detach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 链式异步操作</span><br><span class="line">void process_data_chain() &#123;</span><br><span class="line">    // 第一步：读取文件</span><br><span class="line">    async_file_read(&quot;data.txt&quot;, [](const std::string&amp; content) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Step 1: File read completed&quot; &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        // 第二步：处理数据</span><br><span class="line">        std::string processed = content + &quot; (processed)&quot;;</span><br><span class="line">        </span><br><span class="line">        // 第三步：保存结果</span><br><span class="line">        async_file_read(&quot;result.txt&quot;, [processed](const std::string&amp;) &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Step 3: Result saved&quot; &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; &quot;Final data: &quot; &lt;&lt; processed &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Starting async processing chain...&quot; &lt;&lt; std::endl;</span><br><span class="line">    process_data_chain();</span><br><span class="line">    </span><br><span class="line">    // 等待异步操作完成</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(3));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-3-2-异步编程模式">7.3.2 异步编程模式</h4>
<p><strong>1. 生产者 - 消费者模式的异步实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class AsyncQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    std::queue&lt;T&gt; queue_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    bool stopped_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    AsyncQueue() : stopped_(false) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void push(const T&amp; item) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        if (!stopped_) &#123;</span><br><span class="line">            queue_.push(item);</span><br><span class="line">            cv_.notify_one();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool pop(T&amp; item, std::chrono::milliseconds timeout = std::chrono::milliseconds(0)) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        </span><br><span class="line">        if (timeout.count() == 0) &#123;</span><br><span class="line">            cv_.wait(lock, [this]&#123; return !queue_.empty() || stopped_; &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (!cv_.wait_for(lock, timeout, [this]&#123; return !queue_.empty() || stopped_; &#125;)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (stopped_ &amp;&amp; queue_.empty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        item = queue_.front();</span><br><span class="line">        queue_.pop();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void stop() &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        stopped_ = true;</span><br><span class="line">        cv_.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool empty() const &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        return queue_.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 异步生产者</span><br><span class="line">void producer(AsyncQueue&lt;int&gt;&amp; queue) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Producing: &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        queue.push(i);</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(300));</span><br><span class="line">    &#125;</span><br><span class="line">    queue.stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 异步消费者</span><br><span class="line">void consumer(AsyncQueue&lt;int&gt;&amp; queue, const std::string&amp; name) &#123;</span><br><span class="line">    int item;</span><br><span class="line">    while (queue.pop(item)) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Consumer &quot; &lt;&lt; name &lt;&lt; &quot; processing: &quot; &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(500));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;Consumer &quot; &lt;&lt; name &lt;&lt; &quot; stopped&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    AsyncQueue&lt;int&gt; queue;</span><br><span class="line">    </span><br><span class="line">    // 启动生产者</span><br><span class="line">    std::thread prod_thread(producer, std::ref(queue));</span><br><span class="line">    </span><br><span class="line">    // 启动消费者</span><br><span class="line">    std::thread cons_thread1(consumer, std::ref(queue), &quot;A&quot;);</span><br><span class="line">    std::thread cons_thread2(consumer, std::ref(queue), &quot;B&quot;);</span><br><span class="line">    </span><br><span class="line">    prod_thread.join();</span><br><span class="line">    cons_thread1.join();</span><br><span class="line">    cons_thread2.join();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 异步工作池模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line"></span><br><span class="line">class AsyncWorkerPool &#123;</span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">    std::queue&lt;std::function&lt;void()&gt;&gt; tasks_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    bool stop_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    AsyncWorkerPool(size_t num_workers) : stop_(false) &#123;</span><br><span class="line">        for (size_t i = 0; i &lt; num_workers; ++i) &#123;</span><br><span class="line">            workers_.emplace_back([this] &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    std::function&lt;void()&gt; task;</span><br><span class="line">                    </span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; lock(this-&gt;mtx_);</span><br><span class="line">                        this-&gt;cv_.wait(lock, [this] &#123;</span><br><span class="line">                            return this-&gt;stop_ || !this-&gt;tasks_.empty();</span><br><span class="line">                        &#125;);</span><br><span class="line">                        </span><br><span class="line">                        if (this-&gt;stop_ &amp;&amp; this-&gt;tasks_.empty()) &#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        task = std::move(this-&gt;tasks_.front());</span><br><span class="line">                        this-&gt;tasks_.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    task();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    template&lt;class F, class... Args&gt;</span><br><span class="line">    auto enqueue(F&amp;&amp; f, Args&amp;&amp;... args) </span><br><span class="line">        -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        using return_type = typename std::result_of&lt;F(Args...)&gt;::type;</span><br><span class="line">        </span><br><span class="line">        auto task = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(</span><br><span class="line">            std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        std::future&lt;return_type&gt; res = task-&gt;get_future();</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">            </span><br><span class="line">            if (stop_) &#123;</span><br><span class="line">                throw std::runtime_error(&quot;enqueue on stopped AsyncWorkerPool&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            tasks_.emplace([task]() &#123; (*task)(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cv_.notify_one();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~AsyncWorkerPool() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">            stop_ = true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cv_.notify_all();</span><br><span class="line">        </span><br><span class="line">        for (std::thread&amp; worker : workers_) &#123;</span><br><span class="line">            worker.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 复杂计算任务</span><br><span class="line">int complex_calculation(int x, int y) &#123;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</span><br><span class="line">    return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    AsyncWorkerPool pool(4);</span><br><span class="line">    std::vector&lt;std::future&lt;int&gt;&gt; results;</span><br><span class="line">    </span><br><span class="line">    // 提交多个异步任务</span><br><span class="line">    for (int i = 0; i &lt; 16; ++i) &#123;</span><br><span class="line">        results.emplace_back(</span><br><span class="line">            pool.enqueue(complex_calculation, i, i + 1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取结果</span><br><span class="line">    for (auto&amp;&amp; result : results) &#123;</span><br><span class="line">        std::cout &lt;&lt; result.get() &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-异步编程的哲学思想">7.4 异步编程的哲学思想</h3>
<h4 id="7-4-1-异步的时间哲学">7.4.1 异步的时间哲学</h4>
<p>异步编程体现了对时间资源的深刻理解和优化利用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 同步思维：浪费时间等待</span><br><span class="line">void synchronous_thinking() &#123;</span><br><span class="line">    // 等待每个操作完成后再进行下一个</span><br><span class="line">    auto result1 = operation1();  // 等待2秒</span><br><span class="line">    auto result2 = operation2(result1);  // 等待3秒</span><br><span class="line">    auto result3 = operation3(result2);  // 等待1秒</span><br><span class="line">    </span><br><span class="line">    // 总时间：6秒，CPU利用率低</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 异步思维：充分利用等待时间</span><br><span class="line">void asynchronous_thinking() &#123;</span><br><span class="line">    // 启动所有操作，在等待时做其他事情</span><br><span class="line">    auto future1 = async_operation1();</span><br><span class="line">    auto future2 = async_operation2();</span><br><span class="line">    auto future3 = async_operation3();</span><br><span class="line">    </span><br><span class="line">    // 在等待结果时处理其他任务</span><br><span class="line">    do_other_work();</span><br><span class="line">    </span><br><span class="line">    // 获取结果</span><br><span class="line">    auto result1 = future1.get();</span><br><span class="line">    auto result2 = future2.get();</span><br><span class="line">    auto result3 = future3.get();</span><br><span class="line">    </span><br><span class="line">    // 总时间：3秒（取决于最慢的操作），CPU利用率高</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-4-2-异步的资源哲学">7.4.2 异步的资源哲学</h4>
<p>异步编程最大化了系统资源的利用效率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">// I/O密集型任务</span><br><span class="line">void io_bound_task(int id) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Task &quot; &lt;&lt; id &lt;&lt; &quot; started (I/O bound)&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    // 模拟I/O等待时间</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(2));</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Task &quot; &lt;&lt; id &lt;&lt; &quot; completed&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const int num_tasks = 100;</span><br><span class="line">    std::vector&lt;std::future&lt;void&gt;&gt; futures;</span><br><span class="line">    </span><br><span class="line">    auto start_time = std::chrono::high_resolution_clock::now();</span><br><span class="line">    </span><br><span class="line">    // 异步执行多个I/O密集型任务</span><br><span class="line">    for (int i = 0; i &lt; num_tasks; ++i) &#123;</span><br><span class="line">        futures.emplace_back(std::async(std::launch::async, io_bound_task, i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 等待所有任务完成</span><br><span class="line">    for (auto&amp; fut : futures) &#123;</span><br><span class="line">        fut.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    auto end_time = std::chrono::high_resolution_clock::now();</span><br><span class="line">    auto duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(</span><br><span class="line">        end_time - start_time</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;All &quot; &lt;&lt; num_tasks &lt;&lt; &quot; tasks completed in &quot; </span><br><span class="line">              &lt;&lt; duration.count() &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-4-3-异步的责任链哲学">7.4.3 异步的责任链哲学</h4>
<p>异步编程建立了清晰的责任边界和协作模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">// 异步处理管道</span><br><span class="line">class AsyncPipeline &#123;</span><br><span class="line">public:</span><br><span class="line">    template&lt;typename T, typename Func&gt;</span><br><span class="line">    static auto process(const T&amp; input, Func&amp;&amp; func) &#123;</span><br><span class="line">        return std::async(std::launch::async, std::forward&lt;Func&gt;(func), input);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    template&lt;typename Future, typename Func&gt;</span><br><span class="line">    static auto then(Future&amp;&amp; future, Func&amp;&amp; func) &#123;</span><br><span class="line">        return std::async(std::launch::async, [future = std::move(future), func = std::forward&lt;Func&gt;(func)]() mutable &#123;</span><br><span class="line">            return func(future.get());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 数据处理步骤</span><br><span class="line">std::string read_data(const std::string&amp; filename) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Step 1: Reading data from &quot; &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    return &quot;raw_data_from_&quot; + filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string process_data(const std::string&amp; data) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Step 2: Processing data&quot; &lt;&lt; std::endl;</span><br><span class="line">    return data + &quot;_processed&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void save_data(const std::string&amp; processed_data) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Step 3: Saving processed data&quot; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Final data: &quot; &lt;&lt; processed_data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 构建异步处理管道</span><br><span class="line">    auto final_future = AsyncPipeline::then(</span><br><span class="line">        AsyncPipeline::then(</span><br><span class="line">            AsyncPipeline::process(&quot;input.txt&quot;, read_data),</span><br><span class="line">            process_data</span><br><span class="line">        ),</span><br><span class="line">        save_data</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    // 等待整个管道完成</span><br><span class="line">    final_future.get();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-异步编程的最佳实践">7.5 异步编程的最佳实践</h3>
<h4 id="7-5-1-避免回调地狱">7.5.1 避免回调地狱</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// ❌ 回调地狱：深层嵌套的回调函数</span><br><span class="line">void callback_hell() &#123;</span><br><span class="line">    async_operation1([](Result1 res1) &#123;</span><br><span class="line">        async_operation2(res1, [](Result2 res2) &#123;</span><br><span class="line">            async_operation3(res2, [](Result3 res3) &#123;</span><br><span class="line">                async_operation4(res3, [](Result4 res4) &#123;</span><br><span class="line">                    // 更多嵌套...</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ✅ 使用future避免回调地狱</span><br><span class="line">void using_futures() &#123;</span><br><span class="line">    auto future1 = async_operation1();</span><br><span class="line">    auto future2 = future1.then([](Result1 res1) &#123;</span><br><span class="line">        return async_operation2(res1);</span><br><span class="line">    &#125;);</span><br><span class="line">    auto future3 = future2.then([](Result2 res2) &#123;</span><br><span class="line">        return async_operation3(res2);</span><br><span class="line">    &#125;);</span><br><span class="line">    auto future4 = future3.then([](Result3 res3) &#123;</span><br><span class="line">        return async_operation4(res3);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    auto final_result = future4.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-5-2-正确处理异步异常">7.5.2 正确处理异步异常</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">void may_throw(bool should_throw) &#123;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    </span><br><span class="line">    if (should_throw) &#123;</span><br><span class="line">        throw std::runtime_error(&quot;Something went wrong in async task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Async task completed successfully&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 启动可能抛出异常的异步任务</span><br><span class="line">        auto future1 = std::async(std::launch::async, may_throw, true);</span><br><span class="line">        auto future2 = std::async(std::launch::async, may_throw, false);</span><br><span class="line">        </span><br><span class="line">        // 处理异常</span><br><span class="line">        try &#123;</span><br><span class="line">            future1.get();</span><br><span class="line">        &#125; catch (const std::exception&amp; e) &#123;</span><br><span class="line">            std::cerr &lt;&lt; &quot;Caught exception from first task: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        future2.get();</span><br><span class="line">        </span><br><span class="line">    &#125; catch (const std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;Caught unexpected exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-5-3-合理设置超时">7.5.3 合理设置超时</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line"></span><br><span class="line">void long_running_task() &#123;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(5));</span><br><span class="line">    std::cout &lt;&lt; &quot;Long running task completed&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto future = std::async(std::launch::async, long_running_task);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Waiting for task with timeout...&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    // 设置2秒超时</span><br><span class="line">    auto status = future.wait_for(std::chrono::seconds(2));</span><br><span class="line">    </span><br><span class="line">    if (status == std::future_status::ready) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Task completed within timeout&quot; &lt;&lt; std::endl;</span><br><span class="line">        future.get();</span><br><span class="line">    &#125; else if (status == std::future_status::timeout) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Task timed out after 2 seconds&quot; &lt;&lt; std::endl;</span><br><span class="line">        // 注意：无法直接取消std::future任务</span><br><span class="line">    &#125; else if (status == std::future_status::deferred) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Task is deferred&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-5-4-异步任务的取消机制">7.5.4 异步任务的取消机制</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">class CancellableTask &#123;</span><br><span class="line">private:</span><br><span class="line">    std::atomic&lt;bool&gt; cancelled_;</span><br><span class="line">    std::future&lt;void&gt; future_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    template&lt;typename Func&gt;</span><br><span class="line">    CancellableTask(Func&amp;&amp; func) &#123;</span><br><span class="line">        cancelled_ = false;</span><br><span class="line">        </span><br><span class="line">        future_ = std::async(std::launch::async, [this, func = std::forward&lt;Func&gt;(func)]() &#123;</span><br><span class="line">            func([this]() &#123; return cancelled_.load(); &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void cancel() &#123;</span><br><span class="line">        cancelled_ = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void wait() &#123;</span><br><span class="line">        if (future_.valid()) &#123;</span><br><span class="line">            future_.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool is_cancelled() const &#123;</span><br><span class="line">        return cancelled_.load();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 可取消的任务函数</span><br><span class="line">void cancellable_operation(const std::function&lt;bool()&gt;&amp; is_cancelled) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        // 检查是否被取消</span><br><span class="line">        if (is_cancelled()) &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Task cancelled at iteration &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; &quot;Task iteration &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Task completed normally&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Starting cancellable task...&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    CancellableTask task(cancellable_operation);</span><br><span class="line">    </span><br><span class="line">    // 运行3秒后取消任务</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(3));</span><br><span class="line">    std::cout &lt;&lt; &quot;Cancelling task...&quot; &lt;&lt; std::endl;</span><br><span class="line">    task.cancel();</span><br><span class="line">    </span><br><span class="line">    task.wait();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Main thread exiting&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-6-异步编程的应用场景">7.6 异步编程的应用场景</h3>
<h4 id="7-6-1-I-O-密集型应用">7.6.1 I/O 密集型应用</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">// 模拟网络请求</span><br><span class="line">std::string fetch_data_from_network(const std::string&amp; url) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Fetching data from &quot; &lt;&lt; url &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(500));</span><br><span class="line">    return &quot;Data from &quot; + url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; urls = &#123;</span><br><span class="line">        &quot;http://example.com/api/data1&quot;,</span><br><span class="line">        &quot;http://example.com/api/data2&quot;, </span><br><span class="line">        &quot;http://example.com/api/data3&quot;,</span><br><span class="line">        &quot;http://example.com/api/data4&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::future&lt;std::string&gt;&gt; futures;</span><br><span class="line">    </span><br><span class="line">    auto start_time = std::chrono::high_resolution_clock::now();</span><br><span class="line">    </span><br><span class="line">    // 异步获取所有URL数据</span><br><span class="line">    for (const auto&amp; url : urls) &#123;</span><br><span class="line">        futures.emplace_back(</span><br><span class="line">            std::async(std::launch::async, fetch_data_from_network, url)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理结果</span><br><span class="line">    std::vector&lt;std::string&gt; results;</span><br><span class="line">    for (auto&amp; fut : futures) &#123;</span><br><span class="line">        results.push_back(fut.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    auto end_time = std::chrono::high_resolution_clock::now();</span><br><span class="line">    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</span><br><span class="line">        end_time - start_time</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;All data fetched in &quot; &lt;&lt; duration.count() &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    for (const auto&amp; result : results) &#123;</span><br><span class="line">        std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-6-2-并行计算">7.6.2 并行计算</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">// 并行求和</span><br><span class="line">template&lt;typename Iterator&gt;</span><br><span class="line">typename Iterator::value_type parallel_sum(Iterator begin, Iterator end) &#123;</span><br><span class="line">    auto distance = std::distance(begin, end);</span><br><span class="line">    </span><br><span class="line">    // 小数据集直接计算</span><br><span class="line">    if (distance &lt;= 1000) &#123;</span><br><span class="line">        return std::accumulate(begin, end, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    auto mid = begin;</span><br><span class="line">    std::advance(mid, distance / 2);</span><br><span class="line">    </span><br><span class="line">    // 递归并行计算</span><br><span class="line">    auto future_left = std::async(std::launch::async, parallel_sum&lt;Iterator&gt;, begin, mid);</span><br><span class="line">    auto right_sum = parallel_sum(mid, end);</span><br><span class="line">    auto left_sum = future_left.get();</span><br><span class="line">    </span><br><span class="line">    return left_sum + right_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; large_data(10000000, 1);</span><br><span class="line">    </span><br><span class="line">    auto start_time = std::chrono::high_resolution_clock::now();</span><br><span class="line">    </span><br><span class="line">    int total = parallel_sum(large_data.begin(), large_data.end());</span><br><span class="line">    </span><br><span class="line">    auto end_time = std::chrono::high_resolution_clock::now();</span><br><span class="line">    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</span><br><span class="line">        end_time - start_time</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Total sum: &quot; &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;Time taken: &quot; &lt;&lt; duration.count() &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-6-3-异步事件处理">7.6.3 异步事件处理</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;random&gt;</span><br><span class="line"></span><br><span class="line">class EventDispatcher &#123;</span><br><span class="line">private:</span><br><span class="line">    std::queue&lt;std::function&lt;void()&gt;&gt; events_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    std::thread dispatcher_thread_;</span><br><span class="line">    bool running_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    EventDispatcher() : running_(true) &#123;</span><br><span class="line">        dispatcher_thread_ = std::thread([this] &#123;</span><br><span class="line">            dispatch_loop();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~EventDispatcher() &#123;</span><br><span class="line">        stop();</span><br><span class="line">        if (dispatcher_thread_.joinable()) &#123;</span><br><span class="line">            dispatcher_thread_.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    template&lt;typename Func&gt;</span><br><span class="line">    void post(Func&amp;&amp; func) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        if (running_) &#123;</span><br><span class="line">            events_.emplace(std::forward&lt;Func&gt;(func));</span><br><span class="line">            cv_.notify_one();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void stop() &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        running_ = false;</span><br><span class="line">        cv_.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    void dispatch_loop() &#123;</span><br><span class="line">        while (running_) &#123;</span><br><span class="line">            std::function&lt;void()&gt; event;</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                std::unique_lock&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">                cv_.wait(lock, [this] &#123;</span><br><span class="line">                    return !events_.empty() || !running_;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">                if (!running_ &amp;&amp; events_.empty()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if (!events_.empty()) &#123;</span><br><span class="line">                    event = std::move(events_.front());</span><br><span class="line">                    events_.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (event) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    event();</span><br><span class="line">                &#125; catch (const std::exception&amp; e) &#123;</span><br><span class="line">                    std::cerr &lt;&lt; &quot;Event processing error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 事件源</span><br><span class="line">class EventSource &#123;</span><br><span class="line">private:</span><br><span class="line">    EventDispatcher&amp; dispatcher_;</span><br><span class="line">    std::thread event_thread_;</span><br><span class="line">    std::atomic&lt;bool&gt; running_;</span><br><span class="line">    std::mt19937 rng_;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; dist_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    EventSource(EventDispatcher&amp; dispatcher) </span><br><span class="line">        : dispatcher_(dispatcher), running_(true), rng_(std::random_device&#123;&#125;()), dist_(100, 1000) &#123;</span><br><span class="line">        </span><br><span class="line">        event_thread_ = std::thread([this] &#123;</span><br><span class="line">            generate_events();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~EventSource() &#123;</span><br><span class="line">        running_ = false;</span><br><span class="line">        if (event_thread_.joinable()) &#123;</span><br><span class="line">            event_thread_.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    void generate_events() &#123;</span><br><span class="line">        int event_id = 0;</span><br><span class="line">        </span><br><span class="line">        while (running_) &#123;</span><br><span class="line">            int delay = dist_(rng_);</span><br><span class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(delay));</span><br><span class="line">            </span><br><span class="line">            // 发布事件</span><br><span class="line">            dispatcher_.post([event_id, delay] &#123;</span><br><span class="line">                std::cout &lt;&lt; &quot;Processing event &quot; &lt;&lt; event_id </span><br><span class="line">                          &lt;&lt; &quot; (generated after &quot; &lt;&lt; delay &lt;&lt; &quot;ms)&quot; &lt;&lt; std::endl;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            event_id++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    EventDispatcher dispatcher;</span><br><span class="line">    EventSource source(dispatcher);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Event system running. Press Enter to exit...&quot; &lt;&lt; std::endl;</span><br><span class="line">    std::cin.get();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-并发编程哲学思想">8. 并发编程哲学思想</h2>
<h3 id="8-1-并发编程的哲学基础">8.1 并发编程的哲学基础</h3>
<h4 id="8-1-1-共享内存-vs-消息传递">8.1.1 共享内存 vs 消息传递</h4>
<p><strong>共享内存模型</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线程通过共享内存进行通信</p>
</li>
<li class="lvl-2">
<p>需要显式同步机制（锁、原子操作）</p>
</li>
<li class="lvl-2">
<p>C++ 标准采用的主要模型</p>
</li>
</ul>
<p><strong>消息传递模型</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线程通过发送消息进行通信</p>
</li>
<li class="lvl-2">
<p>数据在传递过程中所有权转移</p>
</li>
<li class="lvl-2">
<p>Go 语言的 goroutine+channel 是典型代表</p>
</li>
</ul>
<h4 id="8-1-2-并发的本质：时间与空间的权衡">8.1.2 并发的本质：时间与空间的权衡</h4>
<p>并发编程本质上是在有限的物理资源（CPU 核心）上，通过时间分片来模拟并行执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 时间分片的哲学体现</span><br><span class="line">void concurrent_tasks() &#123;</span><br><span class="line">    // 任务A和任务B在同一个CPU核心上交替执行</span><br><span class="line">    std::thread t1([]&#123;</span><br><span class="line">        for (int i = 0; i &lt; 1000; ++i) &#123;</span><br><span class="line">            // 任务A的计算</span><br><span class="line">            std::this_thread::yield();  // 主动让出CPU时间片</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::thread t2([]&#123;</span><br><span class="line">        for (int i = 0; i &lt; 1000; ++i) &#123;</span><br><span class="line">            // 任务B的计算</span><br><span class="line">            std::this_thread::yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-并发编程的设计哲学">8.2 并发编程的设计哲学</h3>
<h4 id="8-2-1-最小同步原则">8.2.1 最小同步原则</h4>
<p>只在必要时使用同步机制，减少锁竞争。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 不好的设计：过度同步</span><br><span class="line">class BadDesign &#123;</span><br><span class="line">private:</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    void update_all(int new_a, int new_b, int new_c) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        a = new_a;</span><br><span class="line">        b = new_b;</span><br><span class="line">        c = new_c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 即使只需要读取一个变量，也要获取整个对象的锁</span><br><span class="line">    int get_a() const &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 更好的设计：细粒度同步</span><br><span class="line">class BetterDesign &#123;</span><br><span class="line">private:</span><br><span class="line">    std::mutex mtx_a, mtx_b, mtx_c;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    void update_a(int new_a) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_a);</span><br><span class="line">        a = new_a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get_a() const &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_a);</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他成员的类似方法...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="8-2-2-不可变性原则">8.2.2 不可变性原则</h4>
<p>使用不可变对象减少同步需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 不可变对象：创建后状态不再改变</span><br><span class="line">class ImmutableData &#123;</span><br><span class="line">private:</span><br><span class="line">    const int value_;</span><br><span class="line">    const std::string name_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    ImmutableData(int value, const std::string&amp; name)</span><br><span class="line">        : value_(value), name_(name) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    int get_value() const &#123; return value_; &#125;</span><br><span class="line">    std::string get_name() const &#123; return name_; &#125;</span><br><span class="line">    </span><br><span class="line">    // 没有修改状态的方法</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不可变对象可以安全地在多个线程间共享</span><br><span class="line">void process_data(const ImmutableData&amp; data) &#123;</span><br><span class="line">    // 读取操作不需要同步</span><br><span class="line">    std::cout &lt;&lt; data.get_name() &lt;&lt; &quot;: &quot; &lt;&lt; data.get_value() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-2-3-单一职责原则在并发中的应用">8.2.3 单一职责原则在并发中的应用</h4>
<p>每个线程应该有明确的职责，避免功能耦合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 职责分离的设计</span><br><span class="line">class DataProducer &#123;</span><br><span class="line">private:</span><br><span class="line">    std::queue&lt;int&gt; data_queue_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    void produce_data(int data) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        data_queue_.push(data);</span><br><span class="line">        cv_.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool consume_data(int&amp; data) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        if (cv_.wait_for(lock, std::chrono::seconds(1), </span><br><span class="line">            [this]&#123; return !data_queue_.empty(); &#125;)) &#123;</span><br><span class="line">            data = data_queue_.front();</span><br><span class="line">            data_queue_.pop();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 专门的生产者线程</span><br><span class="line">void producer_task(DataProducer&amp; producer) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 100; ++i) &#123;</span><br><span class="line">        producer.produce_data(i);</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(10));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 专门的消费者线程</span><br><span class="line">void consumer_task(DataProducer&amp; producer) &#123;</span><br><span class="line">    int data;</span><br><span class="line">    while (producer.consume_data(data)) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Consumed: &quot; &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-异步编程的哲学深化">8.3 异步编程的哲学深化</h3>
<h4 id="8-3-1-异步的-“等待哲学”">8.3.1 异步的 “等待哲学”</h4>
<p>异步编程重新定义了 “等待” 的概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 同步等待：消极等待，浪费时间</span><br><span class="line">void synchronous_waiting() &#123;</span><br><span class="line">    auto result = blocking_operation();  // 等待时什么都做不了</span><br><span class="line">    process_result(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 异步等待：积极等待，充分利用时间</span><br><span class="line">void asynchronous_waiting() &#123;</span><br><span class="line">    auto future = async_operation();</span><br><span class="line">    </span><br><span class="line">    // 在等待结果时做其他有意义的事情</span><br><span class="line">    do_other_useful_work();</span><br><span class="line">    </span><br><span class="line">    auto result = future.get();</span><br><span class="line">    process_result(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-2-异步的-“责任转移”-哲学">8.3.2 异步的 “责任转移” 哲学</h4>
<p>异步操作体现了责任的转移和委托：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 同步模式：调用者承担所有责任</span><br><span class="line">Result synchronous_mode() &#123;</span><br><span class="line">    // 调用者必须等待并处理所有细节</span><br><span class="line">    return perform_complex_operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 异步模式：责任转移给系统</span><br><span class="line">std::future&lt;Result&gt; asynchronous_mode() &#123;</span><br><span class="line">    // 系统承担执行和通知的责任</span><br><span class="line">    return std::async(perform_complex_operation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-3-异步的-“事件驱动”-哲学">8.3.3 异步的 “事件驱动” 哲学</h4>
<p>异步编程基于事件驱动的世界观：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 事件驱动的思维模式</span><br><span class="line">class EventDrivenSystem &#123;</span><br><span class="line">private:</span><br><span class="line">    EventDispatcher dispatcher_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    void initialize() &#123;</span><br><span class="line">        // 注册事件处理器</span><br><span class="line">        dispatcher_.register_handler&lt;DataReceivedEvent&gt;(</span><br><span class="line">            [this](const DataReceivedEvent&amp; event) &#123;</span><br><span class="line">                this-&gt;handle_data(event.data);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        dispatcher_.register_handler&lt;TimeoutEvent&gt;(</span><br><span class="line">            [this](const TimeoutEvent&amp; event) &#123;</span><br><span class="line">                this-&gt;handle_timeout(event.timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void start() &#123;</span><br><span class="line">        // 启动事件循环</span><br><span class="line">        dispatcher_.run();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    void handle_data(const std::string&amp; data) &#123;</span><br><span class="line">        // 处理收到的数据</span><br><span class="line">        auto processed = process_data(data);</span><br><span class="line">        </span><br><span class="line">        // 触发新事件</span><br><span class="line">        dispatcher_.post_event(DataProcessedEvent&#123;processed&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void handle_timeout(int timeout) &#123;</span><br><span class="line">        // 处理超时事件</span><br><span class="line">        dispatcher_.post_event(TimeoutHandledEvent&#123;timeout&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-并发编程的性能哲学">8.4 并发编程的性能哲学</h3>
<h4 id="8-4-1-Amdahl-定律：串行部分的限制">8.4.1 Amdahl 定律：串行部分的限制</h4>
<p>Amdahl 定律指出，程序的加速比受限于串行执行部分的比例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 假设程序有80%的并行部分和20%的串行部分</span><br><span class="line">void parallelizable_task() &#123;</span><br><span class="line">    // 80%的计算可以并行执行</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">        threads.emplace_back([]&#123;</span><br><span class="line">            // 并行计算</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (auto&amp; t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void serial_task() &#123;</span><br><span class="line">    // 20%的计算必须串行执行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main_task() &#123;</span><br><span class="line">    serial_task();          // 串行部分（20%）</span><br><span class="line">    parallelizable_task();  // 并行部分（80%）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-2-Gustafson-定律：问题规模的影响">8.4.2 Gustafson 定律：问题规模的影响</h4>
<p>Gustafson 定律表明，随着问题规模的增加，并行计算的收益也会增加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 处理更大规模的数据时，并行的优势更明显</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void process_large_data(const std::vector&lt;T&gt;&amp; data) &#123;</span><br><span class="line">    const size_t num_threads = std::thread::hardware_concurrency();</span><br><span class="line">    const size_t chunk_size = data.size() / num_threads;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    </span><br><span class="line">    for (size_t i = 0; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        size_t start = i * chunk_size;</span><br><span class="line">        size_t end = (i == num_threads - 1) ? data.size() : (i + 1) * chunk_size;</span><br><span class="line">        </span><br><span class="line">        threads.emplace_back([start, end, &amp;data]&#123;</span><br><span class="line">            for (size_t j = start; j &lt; end; ++j) &#123;</span><br><span class="line">                // 处理单个数据元素</span><br><span class="line">                process_element(data[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (auto&amp; t : threads) &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-最佳实践与设计原则">9. 最佳实践与设计原则</h2>
<h3 id="9-1-线程安全设计原则">9.1 线程安全设计原则</h3>
<h4 id="9-1-1-优先使用高层抽象">9.1.1 优先使用高层抽象</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 不好的做法：手动管理线程和共享数据</span><br><span class="line">void bad_example() &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    </span><br><span class="line">    std::thread t([&amp;]&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        result = expensive_calculation();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    t.join();</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 好的做法：使用std::async</span><br><span class="line">void good_example() &#123;</span><br><span class="line">    auto future = std::async(std::launch::async, expensive_calculation);</span><br><span class="line">    std::cout &lt;&lt; future.get() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-1-2-始终使用-RAII-管理资源">9.1.2 始终使用 RAII 管理资源</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 不好的做法：手动管理锁</span><br><span class="line">void bad_lock_management() &#123;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    mtx.lock();</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        // 可能抛出异常的操作</span><br><span class="line">        risky_operation();</span><br><span class="line">        mtx.unlock();</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        mtx.unlock();</span><br><span class="line">        throw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 好的做法：使用RAII锁</span><br><span class="line">void good_lock_management() &#123;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">    </span><br><span class="line">    // 即使抛出异常，锁也会自动释放</span><br><span class="line">    risky_operation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-1-3-避免共享可变状态">9.1.3 避免共享可变状态</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 不好的做法：共享可变状态</span><br><span class="line">class SharedState &#123;</span><br><span class="line">private:</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    int state_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    void update_state(int new_state) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx);</span><br><span class="line">        state_ = new_state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 好的做法：使用消息传递</span><br><span class="line">class MessagePassing &#123;</span><br><span class="line">private:</span><br><span class="line">    std::queue&lt;int&gt; messages_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    void send_message(int message) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        messages_.push(message);</span><br><span class="line">        cv_.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int receive_message() &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        cv_.wait(lock, [this]&#123; return !messages_.empty(); &#125;);</span><br><span class="line">        </span><br><span class="line">        int message = messages_.front();</span><br><span class="line">        messages_.pop();</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="9-2-异步编程最佳实践">9.2 异步编程最佳实践</h3>
<h4 id="9-2-1-选择合适的异步模型">9.2.1 选择合适的异步模型</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 根据场景选择不同的异步模型</span><br><span class="line"></span><br><span class="line">// 1. 简单的异步计算：使用std::async</span><br><span class="line">auto async_result = std::async(std::launch::async, []&#123;</span><br><span class="line">    return expensive_calculation();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 2. 需要主动设置结果：使用std::promise</span><br><span class="line">std::promise&lt;int&gt; prom;</span><br><span class="line">std::future&lt;int&gt; fut = prom.get_future();</span><br><span class="line"></span><br><span class="line">std::thread([&amp;prom]&#123;</span><br><span class="line">    prom.set_value(calculate_result());</span><br><span class="line">&#125;).detach();</span><br><span class="line"></span><br><span class="line">// 3. 复杂的异步工作流：使用事件循环</span><br><span class="line">EventLoop loop;</span><br><span class="line">loop.post([]&#123;</span><br><span class="line">    // 异步任务</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="9-2-2-正确处理异步错误">9.2.2 正确处理异步错误</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 异步操作中的异常处理</span><br><span class="line">void async_with_exception_handling() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        auto future = std::async(std::launch::async, []&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 可能抛出异常的操作</span><br><span class="line">                return risky_operation();</span><br><span class="line">            &#125; catch (...) &#123;</span><br><span class="line">                // 在异步任务中处理或重新抛出</span><br><span class="line">                std::throw_with_nested(std::runtime_error(&quot;Async operation failed&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        auto result = future.get();</span><br><span class="line">    &#125; catch (const std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;Async error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-3-避免过度异步化">9.2.3 避免过度异步化</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 不是所有操作都需要异步化</span><br><span class="line"></span><br><span class="line">// 适合异步的场景：I/O密集型操作</span><br><span class="line">auto io_future = std::async(std::launch::async, []&#123;</span><br><span class="line">    return read_large_file();  // I/O操作，适合异步</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 不适合异步的场景：简单计算</span><br><span class="line">int simple_calc = add_numbers(1, 2);  // 直接同步调用更高效</span><br><span class="line"></span><br><span class="line">// 权衡异步的开销</span><br><span class="line">if (operation_is_io_bound() &amp;&amp; operation_will_take_long_time()) &#123;</span><br><span class="line">    use_async();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    use_sync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-性能优化原则">9.3 性能优化原则</h3>
<h4 id="9-3-1-减少锁竞争">9.3.1 减少锁竞争</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 高竞争场景的优化</span><br><span class="line">class HighContentionData &#123;</span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;std::mutex&gt; mutexes_;</span><br><span class="line">    std::vector&lt;int&gt; data_;</span><br><span class="line">    size_t num_shards_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    HighContentionData(size_t size, size_t num_shards)</span><br><span class="line">        : num_shards_(num_shards), mutexes_(num_shards), data_(size) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void update(size_t index, int value) &#123;</span><br><span class="line">        size_t shard = index % num_shards_;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutexes_[shard]);</span><br><span class="line">        data_[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(size_t index) const &#123;</span><br><span class="line">        size_t shard = index % num_shards_;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutexes_[shard]);</span><br><span class="line">        return data_[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="9-3-2-使用无锁数据结构">9.3.2 使用无锁数据结构</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 当适用时，无锁结构可以提供更好的性能</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line"></span><br><span class="line">class LockFreeCounter &#123;</span><br><span class="line">private:</span><br><span class="line">    std::atomic&lt;int&gt; count_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    LockFreeCounter() : count_(0) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void increment() &#123;</span><br><span class="line">        count_.fetch_add(1, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get_count() const &#123;</span><br><span class="line">        return count_.load(std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="9-3-3-合理使用线程局部存储">9.3.3 合理使用线程局部存储</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 线程局部存储可以避免共享数据</span><br><span class="line">thread_local int thread_specific_data = 0;</span><br><span class="line"></span><br><span class="line">void thread_function(int id) &#123;</span><br><span class="line">    thread_specific_data = id;</span><br><span class="line">    // 每个线程都有自己的副本</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; has data: &quot; &lt;&lt; thread_specific_data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t1(thread_function, 1);</span><br><span class="line">    std::thread t2(thread_function, 2);</span><br><span class="line">    </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-4-错误处理原则">9.4 错误处理原则</h3>
<h4 id="9-4-1-线程内异常处理">9.4.1 线程内异常处理</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void thread_with_exception_handling() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 可能抛出异常的操作</span><br><span class="line">        risky_operation();</span><br><span class="line">    &#125; catch (const std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;Thread caught exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">        // 适当的清理和错误处理</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;Thread caught unknown exception&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t(thread_with_exception_handling);</span><br><span class="line">    t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-4-2-优雅的线程终止">9.4.2 优雅的线程终止</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class GracefulShutdown &#123;</span><br><span class="line">private:</span><br><span class="line">    std::atomic&lt;bool&gt; stop_flag_;</span><br><span class="line">    std::thread worker_thread_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    GracefulShutdown() : stop_flag_(false) &#123;</span><br><span class="line">        worker_thread_ = std::thread([this]&#123;</span><br><span class="line">            while (!stop_flag_.load(std::memory_order_acquire)) &#123;</span><br><span class="line">                // 执行工作</span><br><span class="line">                do_work();</span><br><span class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(100));</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; &quot;Thread shutting down gracefully&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~GracefulShutdown() &#123;</span><br><span class="line">        stop_flag_.store(true, std::memory_order_release);</span><br><span class="line">        if (worker_thread_.joinable()) &#123;</span><br><span class="line">            worker_thread_.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    void do_work() &#123;</span><br><span class="line">        // 实际的工作内容</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="10-常见问题与解决方案">10. 常见问题与解决方案</h2>
<h3 id="10-1-死锁问题">10.1 死锁问题</h3>
<h4 id="10-1-1-死锁的产生条件">10.1.1 死锁的产生条件</h4>
<ol>
<li class="lvl-3">
<p><strong>互斥条件</strong>：资源只能被一个线程持有</p>
</li>
<li class="lvl-3">
<p><strong>持有并等待</strong>：线程持有资源并等待其他资源</p>
</li>
<li class="lvl-3">
<p><strong>不可剥夺</strong>：资源不能被强制剥夺</p>
</li>
<li class="lvl-3">
<p><strong>循环等待</strong>：线程间形成等待循环</p>
</li>
</ol>
<h4 id="10-1-2-死锁检测与避免">10.1.2 死锁检测与避免</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 死锁示例</span><br><span class="line">std::mutex mutex1, mutex2;</span><br><span class="line"></span><br><span class="line">void deadlock_example1() &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock1(mutex1);</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(10));</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock2(mutex2);  // 可能死锁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void deadlock_example2() &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock2(mutex2);</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(10));</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock1(mutex1);  // 可能死锁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 死锁解决方案：统一锁获取顺序</span><br><span class="line">void deadlock_solution1() &#123;</span><br><span class="line">    std::lock(mutex1, mutex2);</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock1(mutex1, std::adopt_lock);</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock2(mutex2, std::adopt_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 死锁解决方案：使用try_lock</span><br><span class="line">void deadlock_solution2() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (mutex1.try_lock()) &#123;</span><br><span class="line">            if (mutex2.try_lock()) &#123;</span><br><span class="line">                // 成功获取两个锁</span><br><span class="line">                std::lock_guard&lt;std::mutex&gt; lock1(mutex1, std::adopt_lock);</span><br><span class="line">                std::lock_guard&lt;std::mutex&gt; lock2(mutex2, std::adopt_lock);</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mutex1.unlock();</span><br><span class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(10));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-数据竞争问题">10.2 数据竞争问题</h3>
<h4 id="10-2-1-数据竞争的检测">10.2.1 数据竞争的检测</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 数据竞争示例</span><br><span class="line">int shared_data = 0;</span><br><span class="line"></span><br><span class="line">void竞争_condition() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 100000; ++i) &#123;</span><br><span class="line">        shared_data++;  // 数据竞争！</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解决方案：使用原子操作</span><br><span class="line">std::atomic&lt;int&gt; atomic_data(0);</span><br><span class="line"></span><br><span class="line">void no_race_condition() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 100000; ++i) &#123;</span><br><span class="line">        atomic_data++;  // 原子操作，无数据竞争</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-3-异步编程常见问题">10.3 异步编程常见问题</h3>
<h4 id="10-3-1-异步任务的取消问题">10.3.1 异步任务的取消问题</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// std::future不支持直接取消，需要自己实现</span><br><span class="line">class CancellableFuture &#123;</span><br><span class="line">private:</span><br><span class="line">    std::future&lt;void&gt; future_;</span><br><span class="line">    std::atomic&lt;bool&gt;&amp; cancelled_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    CancellableFuture(std::future&lt;void&gt;&amp;&amp; future, std::atomic&lt;bool&gt;&amp; cancelled)</span><br><span class="line">        : future_(std::move(future)), cancelled_(cancelled) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    bool wait_for(const std::chrono::milliseconds&amp; timeout) &#123;</span><br><span class="line">        auto status = future_.wait_for(timeout);</span><br><span class="line">        </span><br><span class="line">        if (status == std::future_status::ready) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (cancelled_.load()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return status == std::future_status::ready;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="10-3-2-异步结果的生命周期管理">10.3.2 异步结果的生命周期管理</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 确保异步结果的正确生命周期管理</span><br><span class="line">class AsyncResultManager &#123;</span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;std::future&lt;void&gt;&gt; active_futures_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    template&lt;typename Func&gt;</span><br><span class="line">    void start_async_task(Func&amp;&amp; func) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        </span><br><span class="line">        auto future = std::async(std::launch::async, [this, func = std::forward&lt;Func&gt;(func)]() &#123;</span><br><span class="line">            func();</span><br><span class="line">            cleanup_completed_tasks();</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        active_futures_.emplace_back(std::move(future));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    void cleanup_completed_tasks() &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(mtx_);</span><br><span class="line">        </span><br><span class="line">        active_futures_.erase(</span><br><span class="line">            std::remove_if(active_futures_.begin(), active_futures_.end(),</span><br><span class="line">                [](auto&amp; future) &#123;</span><br><span class="line">                    return future.wait_for(std::chrono::seconds(0)) == std::future_status::ready;</span><br><span class="line">                &#125;),</span><br><span class="line">            active_futures_.end()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="10-4-调试技巧">10.4 调试技巧</h3>
<h4 id="10-4-1-线程安全的调试宏">10.4.1 线程安全的调试宏</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#define LOCK_GUARD(mutex) \</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(mutex); \</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; locked &quot; &lt;&lt; #mutex &lt;&lt; &quot; at &quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; std::endl;</span><br><span class="line">#else</span><br><span class="line">#define LOCK_GUARD(mutex) \</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(mutex);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">class DebuggableData &#123;</span><br><span class="line">private:</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    int data_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    void update(int value) &#123;</span><br><span class="line">        LOCK_GUARD(mtx_);</span><br><span class="line">        data_ = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-2-异步操作的调试">10.4.2 异步操作的调试</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 异步操作的调试辅助</span><br><span class="line">class AsyncDebugger &#123;</span><br><span class="line">public:</span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    static std::future&lt;T&gt; debug_future(std::future&lt;T&gt;&amp;&amp; future, const std::string&amp; name) &#123;</span><br><span class="line">        return std::async(std::launch::async, [future = std::move(future), name]() mutable &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Waiting for future: &quot; &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">                auto result = future.get();</span><br><span class="line">                std::cout &lt;&lt; &quot;Future completed: &quot; &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">                return result;</span><br><span class="line">            &#125; catch (const std::exception&amp; e) &#123;</span><br><span class="line">                std::cerr &lt;&lt; &quot;Future failed: &quot; &lt;&lt; name &lt;&lt; &quot; - &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span><br><span class="line">                throw;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>C++ 并发编程是一个复杂而强大的领域，需要开发者同时掌握：</p>
<h3 id="技术层面">技术层面</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>线程管理</strong>：std::thread 的创建、销毁和同步</p>
</li>
<li class="lvl-2">
<p><strong>同步机制</strong>：mutex、condition_variable 的正确使用</p>
</li>
<li class="lvl-2">
<p><strong>异步编程</strong>：future、promise、async 的灵活应用</p>
</li>
<li class="lvl-2">
<p><strong>内存模型</strong>：原子操作和内存顺序的理解</p>
</li>
<li class="lvl-2">
<p><strong>设计模式</strong>：各种并发和异步设计模式的应用</p>
</li>
</ul>
<h3 id="哲学思想层面">哲学思想层面</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>并发本质</strong>：时间分片与空间共享的权衡</p>
</li>
<li class="lvl-2">
<p><strong>异步哲学</strong>：重新定义等待，最大化资源利用</p>
</li>
<li class="lvl-2">
<p><strong>设计原则</strong>：最小同步、不可变性、单一职责</p>
</li>
<li class="lvl-2">
<p><strong>性能权衡</strong>：在正确性和性能之间找到平衡点</p>
</li>
</ul>
<h3 id="最佳实践">最佳实践</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>始终使用 RAII 管理资源</p>
</li>
<li class="lvl-2">
<p>优先选择高层抽象</p>
</li>
<li class="lvl-2">
<p>避免共享可变状态</p>
</li>
<li class="lvl-2">
<p>合理处理异常和错误</p>
</li>
<li class="lvl-2">
<p>重视测试和调试</p>
</li>
</ul>
<p>掌握这些知识和思想，能够帮助开发者编写出安全、高效、可维护的并发 C++ 程序。并发编程不仅是技术问题，更是一种思维方式和设计哲学的体现。</p>
<p><strong>Date</strong>: October 17, 2025</p>
<p><strong>Code</strong>: <a target="_blank" rel="noopener" href="https://github.com/cplusplus-concurrency">https://github.com/cplusplus-concurrency</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/cpp/" rel="tag"><i class="fa fa-tag"></i> C++</a>
          </div>

        



        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/10/10/web/Pinia%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" rel="prev" title="Pinia学习笔记">
      <i class="fa fa-chevron-left"></i> Pinia学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/10/16/web/Vuex%20%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/" rel="next" title="Vuex学习笔记">
      Vuex学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
            
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">C++ 并发编程核心知识体系：从技术实现到哲学思想</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-number">1.1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.</span> <span class="nav-text">1. 并发编程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.1 什么是并发编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2 并发编程的核心挑战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.3 C++ 并发编程的发展历程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-C-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%9Astd-thread"><span class="nav-number">1.3.</span> <span class="nav-text">2. C++ 线程基础：std::thread</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.1.</span> <span class="nav-text">2.1 线程的创建与管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">基本线程创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">传递参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.2 线程的生命周期管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#join-vs-detach"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">join() vs detach()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.3.</span> <span class="nav-text">2.3 线程属性控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BA%92%E6%96%A5%E9%94%81%E6%9C%BA%E5%88%B6%EF%BC%9Astd-mutex-%E5%AE%B6%E6%97%8F"><span class="nav-number">1.4.</span> <span class="nav-text">3. 互斥锁机制：std::mutex 家族</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.1 互斥锁的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%90%84%E7%A7%8D%E4%BA%92%E6%96%A5%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.2.</span> <span class="nav-text">3.2 各种互斥锁类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#std-mutex-%E5%9F%BA%E6%9C%AC%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">std::mutex - 基本互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-lock-guard-RAII-%E9%A3%8E%E6%A0%BC%E7%9A%84%E9%94%81%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">std::lock_guard - RAII 风格的锁管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-unique-lock-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E9%94%81%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">std::unique_lock - 更灵活的锁管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-17-%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%9Astd-shared-mutex"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">C++17 共享锁：std::shared_mutex</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="nav-number">1.4.3.</span> <span class="nav-text">3.3 避免死锁的技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BB%9F%E4%B8%80%E9%94%81%E8%8E%B7%E5%8F%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">1. 统一锁获取顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-try-lock-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">2. 使用 try_lock 避免死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="nav-number">1.5.</span> <span class="nav-text">4. 条件变量：线程间通信的艺术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.1.</span> <span class="nav-text">4.1 条件变量的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-std-condition-variable-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">4.2 std::condition_variable 的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">生产者 - 消费者模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="nav-number">1.5.3.</span> <span class="nav-text">4.3 条件变量的高级用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%8D%8F%E8%B0%83"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">多个条件变量的协调</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.</span> <span class="nav-text">5. 并发设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Fork-Join-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.1.</span> <span class="nav-text">5.1 Fork-Join 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">5.2 线程池模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E8%AF%BB%E5%86%99%E9%94%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.3.</span> <span class="nav-text">5.3 读写锁模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.</span> <span class="nav-text">6. 内存模型与原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-C-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.7.1.</span> <span class="nav-text">6.1 C++ 内存模型基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.2.</span> <span class="nav-text">6.2 原子操作详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">基本原子类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">原子操作的内存顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">无锁数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9A%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="nav-number">1.8.</span> <span class="nav-text">7. 异步操作：非阻塞编程范式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">1.8.1.</span> <span class="nav-text">7.1 异步编程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">7.1.1 什么是异步编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-%E5%90%8C%E6%AD%A5-vs-%E5%BC%82%E6%AD%A5%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">7.1.2 同步 vs 异步的本质区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-3-%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%93%B2%E5%AD%A6"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">7.1.3 生活中的异步哲学</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-C-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%BB%84%E4%BB%B6"><span class="nav-number">1.8.2.</span> <span class="nav-text">7.2 C++ 异步编程组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-std-future-%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">7.2.1 std::future - 异步结果的占位符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-std-async-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%99%A8"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">7.2.2 std::async - 异步任务启动器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3-std-promise-%E4%B8%BB%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">7.2.3 std::promise - 主动设置异步结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-4-std-packaged-task-%E4%BB%BB%E5%8A%A1%E5%8C%85%E8%A3%85%E5%99%A8"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">7.2.4 std::packaged_task - 任务包装器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="nav-number">1.8.3.</span> <span class="nav-text">7.3 异步编程的设计原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">7.3.1 异步编程的核心原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">7.3.2 异步编程模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%93%B2%E5%AD%A6%E6%80%9D%E6%83%B3"><span class="nav-number">1.8.4.</span> <span class="nav-text">7.4 异步编程的哲学思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-1-%E5%BC%82%E6%AD%A5%E7%9A%84%E6%97%B6%E9%97%B4%E5%93%B2%E5%AD%A6"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">7.4.1 异步的时间哲学</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-2-%E5%BC%82%E6%AD%A5%E7%9A%84%E8%B5%84%E6%BA%90%E5%93%B2%E5%AD%A6"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">7.4.2 异步的资源哲学</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-3-%E5%BC%82%E6%AD%A5%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%93%B2%E5%AD%A6"><span class="nav-number">1.8.4.3.</span> <span class="nav-text">7.4.3 异步的责任链哲学</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.8.5.</span> <span class="nav-text">7.5 异步编程的最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-1-%E9%81%BF%E5%85%8D%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="nav-number">1.8.5.1.</span> <span class="nav-text">7.5.1 避免回调地狱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-2-%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E5%BC%82%E5%B8%B8"><span class="nav-number">1.8.5.2.</span> <span class="nav-text">7.5.2 正确处理异步异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-3-%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE%E8%B6%85%E6%97%B6"><span class="nav-number">1.8.5.3.</span> <span class="nav-text">7.5.3 合理设置超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-4-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8F%96%E6%B6%88%E6%9C%BA%E5%88%B6"><span class="nav-number">1.8.5.4.</span> <span class="nav-text">7.5.4 异步任务的取消机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.8.6.</span> <span class="nav-text">7.6 异步编程的应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-1-I-O-%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">7.6.1 I&#x2F;O 密集型应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-2-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="nav-number">1.8.6.2.</span> <span class="nav-text">7.6.2 并行计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-3-%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">1.8.6.3.</span> <span class="nav-text">7.6.3 异步事件处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%93%B2%E5%AD%A6%E6%80%9D%E6%83%B3"><span class="nav-number">1.9.</span> <span class="nav-text">8. 并发编程哲学思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%93%B2%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="nav-number">1.9.1.</span> <span class="nav-text">8.1 并发编程的哲学基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-1-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-vs-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">8.1.1 共享内存 vs 消息传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-2-%E5%B9%B6%E5%8F%91%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">8.1.2 并发的本质：时间与空间的权衡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="nav-number">1.9.2.</span> <span class="nav-text">8.2 并发编程的设计哲学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-%E6%9C%80%E5%B0%8F%E5%90%8C%E6%AD%A5%E5%8E%9F%E5%88%99"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">8.2.1 最小同步原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E5%8E%9F%E5%88%99"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">8.2.2 不可变性原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-3-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E5%9C%A8%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">8.2.3 单一职责原则在并发中的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%93%B2%E5%AD%A6%E6%B7%B1%E5%8C%96"><span class="nav-number">1.9.3.</span> <span class="nav-text">8.3 异步编程的哲学深化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-1-%E5%BC%82%E6%AD%A5%E7%9A%84-%E2%80%9C%E7%AD%89%E5%BE%85%E5%93%B2%E5%AD%A6%E2%80%9D"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">8.3.1 异步的 “等待哲学”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-2-%E5%BC%82%E6%AD%A5%E7%9A%84-%E2%80%9C%E8%B4%A3%E4%BB%BB%E8%BD%AC%E7%A7%BB%E2%80%9D-%E5%93%B2%E5%AD%A6"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">8.3.2 异步的 “责任转移” 哲学</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-3-%E5%BC%82%E6%AD%A5%E7%9A%84-%E2%80%9C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E2%80%9D-%E5%93%B2%E5%AD%A6"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">8.3.3 异步的 “事件驱动” 哲学</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E5%93%B2%E5%AD%A6"><span class="nav-number">1.9.4.</span> <span class="nav-text">8.4 并发编程的性能哲学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-1-Amdahl-%E5%AE%9A%E5%BE%8B%EF%BC%9A%E4%B8%B2%E8%A1%8C%E9%83%A8%E5%88%86%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">8.4.1 Amdahl 定律：串行部分的限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-2-Gustafson-%E5%AE%9A%E5%BE%8B%EF%BC%9A%E9%97%AE%E9%A2%98%E8%A7%84%E6%A8%A1%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">1.9.4.2.</span> <span class="nav-text">8.4.2 Gustafson 定律：问题规模的影响</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.10.</span> <span class="nav-text">9. 最佳实践与设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.10.1.</span> <span class="nav-text">9.1 线程安全设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-1-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E9%AB%98%E5%B1%82%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">9.1.1 优先使用高层抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-2-%E5%A7%8B%E7%BB%88%E4%BD%BF%E7%94%A8-RAII-%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">9.1.2 始终使用 RAII 管理资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-3-%E9%81%BF%E5%85%8D%E5%85%B1%E4%BA%AB%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">9.1.3 避免共享可变状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.10.2.</span> <span class="nav-text">9.2 异步编程最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-1-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">9.2.1 选择合适的异步模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-2-%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E9%94%99%E8%AF%AF"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">9.2.2 正确处理异步错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-3-%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E5%BC%82%E6%AD%A5%E5%8C%96"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">9.2.3 避免过度异步化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99"><span class="nav-number">1.10.3.</span> <span class="nav-text">9.3 性能优化原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-1-%E5%87%8F%E5%B0%91%E9%94%81%E7%AB%9E%E4%BA%89"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">9.3.1 减少锁竞争</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-2-%E4%BD%BF%E7%94%A8%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">9.3.2 使用无锁数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-3-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="nav-number">1.10.3.3.</span> <span class="nav-text">9.3.3 合理使用线程局部存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%8E%9F%E5%88%99"><span class="nav-number">1.10.4.</span> <span class="nav-text">9.4 错误处理原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-1-%E7%BA%BF%E7%A8%8B%E5%86%85%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.10.4.1.</span> <span class="nav-text">9.4.1 线程内异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-2-%E4%BC%98%E9%9B%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">1.10.4.2.</span> <span class="nav-text">9.4.2 优雅的线程终止</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.11.</span> <span class="nav-text">10. 常见问题与解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.11.1.</span> <span class="nav-text">10.1 死锁问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-1-%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">10.1.1 死锁的产生条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-2-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">10.1.2 死锁检测与避免</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98"><span class="nav-number">1.11.2.</span> <span class="nav-text">10.2 数据竞争问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-1-%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">10.2.1 数据竞争的检测</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.11.3.</span> <span class="nav-text">10.3 异步编程常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-1-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8F%96%E6%B6%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">10.3.1 异步任务的取消问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-2-%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">10.3.2 异步结果的生命周期管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">1.11.4.</span> <span class="nav-text">10.4 调试技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E8%B0%83%E8%AF%95%E5%AE%8F"><span class="nav-number">1.11.4.1.</span> <span class="nav-text">10.4.1 线程安全的调试宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-2-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E8%B0%83%E8%AF%95"><span class="nav-number">1.11.4.2.</span> <span class="nav-text">10.4.2 异步操作的调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.12.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E5%B1%82%E9%9D%A2"><span class="nav-number">1.12.1.</span> <span class="nav-text">技术层面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E6%80%9D%E6%83%B3%E5%B1%82%E9%9D%A2"><span class="nav-number">1.12.2.</span> <span class="nav-text">哲学思想层面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.12.3.</span> <span class="nav-text">最佳实践</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="三子曰"
      src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/avatar.png">
  <p class="site-author-name" itemprop="name">三子曰</p>
  <div class="site-description" itemprop="description">欢迎来到我的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangmc1024" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangmc1024" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangmc1024@gmail.com" title="E-Mail → mailto:wangmc1024@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Wed Mar 27 2024 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三子曰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">559k</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '2719e26e1ea715ee8429',
      clientSecret: '77a4ce8e9410a002f05c8f2c2b398c952a012d7c',
      repo        : 'mengchangwang.github.io',
      owner       : 'MengChangWang',
      admin       : ['MengChangWang'],
      id          : '6d99c05dee8267017ae2de02a8334eea',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>



</body>
</html>
