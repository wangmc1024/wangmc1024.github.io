<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Computer Science</title>
    <link>https://wangmc1024.github.io/</link>
    
    <atom:link href="https://wangmc1024.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>欢迎来到我的博客</description>
    <pubDate>Wed, 20 Aug 2025 09:53:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C++/Linux 创建daemon进程</title>
      <link>https://wangmc1024.github.io/2025/08/15/C++Linux%20%E5%88%9B%E5%BB%BAdaemon%E8%BF%9B%E7%A8%8B/</link>
      <guid>https://wangmc1024.github.io/2025/08/15/C++Linux%20%E5%88%9B%E5%BB%BAdaemon%E8%BF%9B%E7%A8%8B/</guid>
      <pubDate>Fri, 15 Aug 2025 08:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;如何使用 C++ 在 Linux 环境下创建一个守护进程&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如何使用 C++ 在 Linux 环境下创建一个守护进程</p><span id="more"></span><p>在 Linux 环境下，守护进程是一种在后台运行，不与任何终端关联，独立于控制终端并且周期性执行任务或等待处理某些事件的进程。以下是使用 C++ 编写将一个进程转换为守护进程的示例代码，并对关键步骤进行解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于将当前进程转换为守护进程</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">daemonize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步：创建子进程，父进程退出</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;fork error: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程直接退出，让子进程继续执行</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时子进程成为新的会话组长和进程组长</span></span><br><span class="line">    <span class="comment">// 第二步：创建新会话</span></span><br><span class="line">    pid = <span class="built_in">setsid</span>();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;setsid error: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：改变工作目录</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;chdir error: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步：设置文件权限掩码</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第五步：关闭标准输入、输出和错误输出，并重新定向到/dev/null</span></span><br><span class="line">    <span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd != STDIN_FILENO) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dup2</span>(fd, STDOUT_FILENO) != STDOUT_FILENO) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dup2</span>(fd, STDERR_FILENO) != STDERR_FILENO) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; STDERR_FILENO) &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">daemonize</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Process has been daemonized successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 这里可以编写守护进程的具体任务逻辑，比如定时执行某些操作</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 模拟守护进程执行任务，这里简单睡眠10秒</span></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Daemon is working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to daemonize the process.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释">代码解释</h3><ol><li class="lvl-3"><p><strong>创建子进程并退出父进程</strong>：使用 <code>fork()</code> 函数创建一个子进程。父进程调用 <code>exit(EXIT_SUCCESS)</code> 退出，这样子进程就不再是控制终端的前台进程，并且可以避免在父进程退出时，子进程成为孤儿进程而被 <code>init</code> 进程收养并受到不必要的终端控制。</p></li><li class="lvl-3"><p><strong>创建新会话</strong>：调用 <code>setsid()</code> 函数，使子进程成为新会话的组长，同时也是新进程组的组长。这样做可以让守护进程脱离原会话的控制，并且不再有控制终端，从而实现后台独立运行。</p></li><li class="lvl-3"><p><strong>改变工作目录</strong>：使用 <code>chdir(&quot;/&quot;)</code> 将当前工作目录更改为根目录 <code>/</code> 。这是为了防止守护进程长时间运行时，其工作目录所在的文件系统被卸载而导致进程出现异常。也可以根据实际需求将工作目录设置为其他合适的目录。</p></li><li class="lvl-3"><p><strong>设置文件权限掩码</strong>：通过 <code>umask(0)</code> 将文件权限掩码设置为 0，这样守护进程在创建文件或目录时，可以完全按照指定的权限来创建，而不会受到默认掩码的影响。</p></li><li class="lvl-3"><p><strong>关闭并重新定向标准文件描述符</strong>：守护进程不应该与终端有交互，所以关闭标准输入（<code>STDIN_FILENO</code>）、标准输出（<code>STDOUT_FILENO</code>）和标准错误输出（<code>STDERR_FILENO</code>），并将它们重新定向到 <code>/dev/null</code> 。<code>/dev/null</code> 是一个特殊的设备文件，写入它的数据会被丢弃，读取它会立即返回文件结束标志。</p></li></ol><h3 id="int-daemon-int-nochdir-int-noclose"><code>int daemon(int nochdir,int noclose)</code></h3><p><strong>nochdir:</strong> 用于指定是否改变当前的工作目录, 如果 为0 则将工作目录设置为根目录（”/“), 否则依旧使用当前目录作为工作目录</p><p><strong>noclose:</strong> 参数为0，则将标准输入输出和标准错误输出重定向至”/dev/null“文件</p>]]></content:encoded>
      
      
      <category domain="https://wangmc1024.github.io/categories/C/">C++</category>
      
      
      <category domain="https://wangmc1024.github.io/tags/C/">C++</category>
      
      
      <comments>https://wangmc1024.github.io/2025/08/15/C++Linux%20%E5%88%9B%E5%BB%BAdaemon%E8%BF%9B%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Socket基础概念</title>
      <link>https://wangmc1024.github.io/2025/08/15/Socket%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</link>
      <guid>https://wangmc1024.github.io/2025/08/15/Socket%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</guid>
      <pubDate>Fri, 15 Aug 2025 08:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;socket基础概念&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>socket基础概念</p> <span id="more"></span><p>在网络编程中，<strong>Socket（套接字）</strong> 是进程间通信的抽象接口，用于实现不同主机或同一主机内不同进程之间的网络数据传输。它是 TCP/IP 协议栈的编程接口，现代 C++ 网络开发中依然是核心基础（尽管常被封装为更高层库如 Boost.Asio）。</p><h3 id="一、Socket-基础概念">一、Socket 基础概念</h3><ol><li class="lvl-3"><p><strong>本质</strong>：Socket 是一个 “文件描述符”（Linux/Unix）或 “句柄”（Windows），代表一个网络通信端点，通过它可进行数据的发送 / 接收。</p></li><li class="lvl-3"><p><strong>分类</strong>：</p><ul class="lvl-2"><li class="lvl-5"><strong>流式套接字（SOCK_STREAM）</strong>：基于 TCP 协议，提供可靠、有序、双向的字节流传输（无数据丢失 / 重复，适合文件传输、HTTP 等）。</li><li class="lvl-5"><strong>数据报套接字（SOCK_DGRAM）</strong>：基于 UDP 协议，提供无连接、不可靠的数据包传输（速度快，适合视频通话、DNS 等）。</li><li class="lvl-5"><strong>原始套接字（SOCK_RAW）</strong>：直接操作底层协议（如 IP），用于网络诊断或自定义协议（需管理员权限）。</li></ul></li><li class="lvl-3"><p><strong>通信模型</strong>：</p><ul class="lvl-2"><li class="lvl-5">TCP 采用 “客户端 - 服务器” 模型，需先建立连接（三次握手），再传输数据。</li><li class="lvl-5">UDP 无连接，直接发送数据包，无需提前建立连接。</li></ul></li></ol><h3 id="二、核心函数解析（基于-TCP，现代-C-视角）">二、核心函数解析（基于 TCP，现代 C++ 视角）</h3><p>以下函数是 TCP 通信的核心，主要用于服务器端和客户端的连接建立过程。</p><h4 id="1-socket-：创建套接字">1. <code>socket()</code>：创建套接字</h4><p><strong>作用</strong>：初始化一个套接字，返回其描述符（后续操作的句柄）。</p><p><strong>函数原型</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数解析</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><code>domain</code>：地址族（协议族），指定网络层协议。常见值：</p><ul class="lvl-2"><li class="lvl-4"><code>AF_INET</code>：IPv4 协议（最常用）。</li><li class="lvl-4"><code>AF_INET6</code>：IPv6 协议。</li><li class="lvl-4"><code>AF_UNIX</code>：本地进程间通信（Unix 域套接字）。</li></ul></li><li class="lvl-2"><p><code>type</code>：套接字类型，指定传输层协议特性：</p><ul class="lvl-2"><li class="lvl-4"><code>SOCK_STREAM</code>：TCP 流式套接字。</li><li class="lvl-4"><code>SOCK_DGRAM</code>：UDP 数据报套接字。</li></ul></li><li class="lvl-2"><p><code>protocol</code>：具体协议（通常为 0，由系统根据前两个参数自动选择）。</p></li></ul><p><strong>返回值</strong>：成功返回非负套接字描述符（<code>sockfd</code>），失败返回 - 1（需检查<code>errno</code>）。</p><p><strong>现代 C++ 实践</strong>：用智能指针（如<code>std::unique_ptr</code>）配合自定义删除器管理<code>sockfd</code>，避免资源泄漏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义删除器：关闭套接字</span></span><br><span class="line"><span class="keyword">auto</span> socket_deleter = [](<span class="type">int</span> fd) &#123; </span><br><span class="line">  <span class="keyword">if</span> (fd != <span class="number">-1</span>) ::<span class="built_in">close</span>(fd); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> UniqueSocket = std::unique_ptr&lt;<span class="type">int</span>, <span class="keyword">decltype</span>(socket_deleter)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line"><span class="function">UniqueSocket <span class="title">create_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;socket creation failed: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UniqueSocket</span>(<span class="keyword">new</span> <span class="built_in">int</span>(sockfd), socket_deleter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-bind-：绑定地址与端口">2. <code>bind()</code>：绑定地址与端口</h4><p><strong>作用</strong>：将套接字与特定的 IP 地址和端口号绑定（主要用于服务器端，客户端通常不绑定，由系统自动分配端口）。</p><p><strong>函数原型</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数解析</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><code>sockfd</code>：<code>socket()</code>返回的套接字描述符。</p></li><li class="lvl-2"><p><code>addr</code>：指向地址结构的指针（需根据<code>domain</code>选择对应类型，如 IPv4 用<code>sockaddr_in</code>）。</p></li><li class="lvl-2"><p><code>addrlen</code>：地址结构的大小（字节数）。</p></li></ul><p><strong>地址结构处理</strong>（以 IPv4 为例）：<code>sockaddr</code>是通用地址结构，实际使用时需转换为具体协议的结构（如<code>sockaddr_in</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">  <span class="type">sa_family_t</span>     sin_family;  <span class="comment">// 地址族（必须为AF_INET）</span></span><br><span class="line">  <span class="type">uint16_t</span>        sin_port;    <span class="comment">// 端口号（需转换为网络字节序）</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">in_addr</span>  sin_addr;    <span class="comment">// IP地址（需转换为网络字节序）</span></span><br><span class="line">  <span class="type">char</span>            sin_zero[<span class="number">8</span>]; <span class="comment">// 填充字段（通常为0）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>字节序转换</strong>：网络协议使用<strong>大端字节序</strong>（网络字节序），而主机可能是小端 / 大端，需用函数转换：</p><ul class="lvl-0"><li class="lvl-2"><p><code>htons()</code>：主机字节序→网络字节序（16 位，用于端口）。</p></li><li class="lvl-2"><p><code>htonl()</code>：主机字节序→网络字节序（32 位，用于 IPv4 地址）。</p></li><li class="lvl-2"><p><code>inet_pton()</code>：字符串 IP（如 “127.0.0.1”）→网络字节序的整数（现代 C++ 推荐，替代旧的<code>inet_addr()</code>）。</p></li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定到IPv4地址127.0.0.1:8080</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>); <span class="comment">// 端口转换为网络字节序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址转换（&quot;0.0.0.0&quot;表示监听所有网络接口）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;server_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid IP address: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="keyword">if</span> (::<span class="built_in">bind</span>(sockfd, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr*&gt;(&amp;server_addr), <span class="built_in">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;bind failed: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-listen-：监听连接（服务器端）">3. <code>listen()</code>：监听连接（服务器端）</h4><p><strong>作用</strong>：将套接字转为 “监听状态”，允许接收客户端的连接请求（仅用于 TCP 服务器端的<code>sockfd</code>）。</p><p><strong>函数原型</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数解析</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><code>sockfd</code>：已绑定的套接字描述符（<code>bind()</code>之后）。</p></li><li class="lvl-2"><p><code>backlog</code>：未完成连接队列（三次握手未完成）的最大长度（超过则客户端连接失败）。实际值受系统限制（如<code>/proc/sys/net/core/somaxconn</code>），现代系统通常建议设为 128 或更高。</p></li></ul><p><strong>返回值</strong>：成功返回 0，失败返回 - 1。</p><p><strong>注意</strong>：<code>listen()</code>不阻塞，仅设置套接字状态。后续需通过<code>accept()</code>获取实际连接。</p><h4 id="4-accept-：接受连接（服务器端）">4. <code>accept()</code>：接受连接（服务器端）</h4><p><strong>作用</strong>：从<code>listen()</code>创建的连接队列中取出一个已完成的连接，返回一个<strong>新的套接字描述符</strong>（用于与该客户端通信）。</p><p><strong>函数原型</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数解析</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><code>sockfd</code>：处于监听状态的套接字（监听套接字）。</p></li><li class="lvl-2"><p><code>addr</code>：输出参数，用于存储客户端的地址信息（可设为<code>nullptr</code>忽略）。</p></li><li class="lvl-2"><p><code>addrlen</code>：输入输出参数，传入<code>addr</code>的大小，输出实际存储的地址长度（可设为<code>nullptr</code>）。</p></li></ul><p><strong>返回值</strong>：成功返回新的套接字描述符（<code>client_fd</code>，用于与客户端通信），失败返回 - 1。</p><p><strong>特性</strong>：<code>accept()</code>默认是<strong>阻塞函数</strong>，直到有客户端连接到达才返回。现代 C++ 中可结合非阻塞 I/O 或多线程处理（如用<code>std::thread</code>为每个新连接创建线程）。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line"><span class="type">socklen_t</span> client_addr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞等待客户端连接</span></span><br><span class="line"><span class="type">int</span> client_fd = ::<span class="built_in">accept</span>(listen_fd, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr*&gt;(&amp;client_addr), &amp;client_addr_len);</span><br><span class="line"><span class="keyword">if</span> (client_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;accept failed: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印客户端信息（将网络字节序转为字符串）</span></span><br><span class="line"><span class="type">char</span> client_ip[INET_ADDRSTRLEN];</span><br><span class="line"><span class="built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);</span><br><span class="line"><span class="type">uint16_t</span> client_port = <span class="built_in">ntohs</span>(client_addr.sin_port); <span class="comment">// 网络字节序→主机字节序</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;New connection from &quot;</span> &lt;&lt; client_ip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; client_port &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h4 id="5-connect-：发起连接（客户端）">5. <code>connect()</code>：发起连接（客户端）</h4><p><strong>作用</strong>：客户端通过该函数向服务器发起 TCP 连接（三次握手的触发点）。</p><p><strong>函数原型</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数解析</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><code>sockfd</code>：客户端的套接字描述符（<code>socket()</code>创建，通常不<code>bind()</code>）。</p></li><li class="lvl-2"><p><code>addr</code>：服务器的地址结构（包含服务器 IP 和端口）。</p></li><li class="lvl-2"><p><code>addrlen</code>：服务器地址结构的大小。</p></li></ul><p><strong>返回值</strong>：成功返回 0（连接建立），失败返回 - 1（如服务器未监听、网络不可达等）。</p><p><strong>特性</strong>：默认是阻塞函数，直到连接建立或失败才返回。非阻塞模式下，可能返回<code>EINPROGRESS</code>（连接正在建立），需通过<code>select()</code>/<code>poll()</code>等检查状态。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端连接服务器（127.0.0.1:8080）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换服务器IP</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid server IP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line"><span class="keyword">if</span> (::<span class="built_in">connect</span>(client_fd, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr*&gt;(&amp;server_addr), <span class="built_in">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;connect failed: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、现代-C-最佳实践">三、现代 C++ 最佳实践</h3><ol><li class="lvl-3"><p><strong>资源管理</strong>：用 RAII（如智能指针、自定义封装类）管理<code>sockfd</code>，避免手动<code>close()</code>导致的泄漏。</p></li><li class="lvl-3"><p><strong>错误处理</strong>：用异常（<code>std::runtime_error</code>）替代传统的<code>if-else</code>检查，提高代码可读性。</p></li><li class="lvl-3"><p><strong>类型安全</strong>：用<code>reinterpret_cast</code>显式转换地址结构，避免隐式转换错误。</p></li><li class="lvl-3"><p><strong>异步操作</strong>：结合 Boost.Asio 或 C++20 的<code>std::net</code>（提案阶段）实现非阻塞 I/O，避免线程阻塞。</p></li><li class="lvl-3"><p><strong>跨平台</strong>：封装系统差异（如 Windows 的<code>WSASend</code>与 Linux 的<code>send</code>），用条件编译或跨平台库。</p></li></ol><h3 id="总结">总结</h3><p><code>socket()</code>/<code>bind()</code>/<code>listen()</code>/<code>accept()</code>/<code>connect()</code>是 TCP 通信的 “骨架”：服务器通过<code>socket()</code>创建套接字→<code>bind()</code>绑定地址→<code>listen()</code>监听→<code>accept()</code>接受连接；客户端通过<code>socket()</code>创建套接字→<code>connect()</code>连接服务器。理解这些函数的参数和交互流程，是掌握网络编程的基础。现代 C++ 通过封装和抽象（如智能指针、异常），可让这些底层操作更安全、易维护。</p>]]></content:encoded>
      
      
      <category domain="https://wangmc1024.github.io/categories/C/">C++</category>
      
      
      <category domain="https://wangmc1024.github.io/tags/C/">C++</category>
      
      
      <comments>https://wangmc1024.github.io/2025/08/15/Socket%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>常用套接字函数原型及说明</title>
      <link>https://wangmc1024.github.io/2025/08/15/%E5%B8%B8%E7%94%A8%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%AF%B4%E6%98%8E/</link>
      <guid>https://wangmc1024.github.io/2025/08/15/%E5%B8%B8%E7%94%A8%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%AF%B4%E6%98%8E/</guid>
      <pubDate>Fri, 15 Aug 2025 08:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;正向和反向获取主机和服务信息的函数，以及套接字选项设置和获取的函数原型及说明。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>正向和反向获取主机和服务信息的函数，以及套接字选项设置和获取的函数原型及说明。</p> <span id="more"></span><h3 id="一、早期套接字函数原型及说明">一、早期套接字函数原型及说明</h3><blockquote><p>[!NOTE]</p><p>以下仅支持解析IPv4 且 不是线程安全的</p></blockquote><ol><li class="lvl-3"><p><strong>getsockname</strong><br>功能：获取套接字本地端的地址信息原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p>说明：<code>sockfd</code>为套接字描述符，<code>addr</code>用于存储本地地址，<code>addrlen</code>传入地址结构体长度，传出实际长度。成功返回 0，失败返回 - 1（设置<code>errno</code>）。</p></li><li class="lvl-3"><p><strong>getpeername</strong><br>功能：获取套接字对端的地址信息原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p>说明：仅适用于已连接的 TCP 套接字（<code>connect</code>或<code>accept</code>后），参数含义同<code>getsockname</code>。</p></li><li class="lvl-3"><p><strong>getsockopt</strong><br>功能：获取套接字的选项值原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br></pre></td></tr></table></figure><p>说明：<code>level</code>为选项级别（如<code>SOL_SOCKET</code>、<code>IPPROTO_TCP</code>），<code>optname</code>为选项名，<code>optval</code>存储结果，<code>optlen</code>传入缓冲区长度并传出实际使用长度。</p></li><li class="lvl-3"><p><strong>setsockopt</strong><br>功能：设置套接字的选项值原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><p>说明：<code>optval</code>为待设置的值，<code>optlen</code>为值的长度，其他参数同<code>getsockopt</code>。部分选项需在<code>bind</code>/<code>connect</code>前设置。</p></li><li class="lvl-3"><p><strong>gethostbyname</strong><br>功能：通过主机名获取主机信息（IPv4）原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>说明：已过时（仅支持 IPv4），推荐使用<code>getaddrinfo</code>。返回<code>struct hostent</code>指针，失败返回<code>NULL</code>（设置<code>h_errno</code>）。</p></li><li class="lvl-3"><p><strong>gethostbyaddr</strong><br>功能：通过 IP 地址获取主机名（IPv4）原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">socklen_t</span> len, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure><p>说明：<code>addr</code>为网络字节序的 IP 地址，<code>len</code>为地址长度（如<code>sizeof(struct in_addr)</code>），<code>type</code>为地址族（如<code>AF_INET</code>）。已过时。</p></li><li class="lvl-3"><p><strong>getservbyname</strong><br>功能：通过服务名和协议获取服务信息原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br></pre></td></tr></table></figure><p>说明：<code>name</code>为服务名（如<code>&quot;http&quot;</code>），<code>proto</code>为协议（如<code>&quot;tcp&quot;</code>，可为<code>NULL</code>）。返回<code>struct servent</code>指针，包含端口号（网络字节序）。</p></li><li class="lvl-3"><p><strong>getservbyport</strong><br>功能：通过端口号和协议获取服务信息原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br></pre></td></tr></table></figure><p>说明：<code>port</code>为网络字节序的端口号（需用<code>htons</code>转换），其他参数同<code>getservbyname</code>。</p><h5 id="struct-hostent（主机信息结构体）"><strong><code>struct hostent</code>（主机信息结构体）</strong></h5><p>用于存储主机的相关信息（如主机名、IP 地址列表等），定义在<code>&lt;netdb.h&gt;</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>  *h_name;        <span class="comment">// 主机的官方名称（规范名）</span></span><br><span class="line">    <span class="type">char</span> **h_aliases;     <span class="comment">// 主机的别名列表（以NULL结尾的字符串数组）</span></span><br><span class="line">    <span class="type">int</span>    h_addrtype;    <span class="comment">// 地址类型（如AF_INET表示IPv4，AF_INET6表示IPv6）</span></span><br><span class="line">    <span class="type">int</span>    h_length;      <span class="comment">// 每个地址的长度（字节），如IPv4为4，IPv6为16</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list;   <span class="comment">// 主机的IP地址列表（网络字节序，以NULL结尾的指针数组）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>字段说明</strong>：</p><ul class="lvl-2"><li class="lvl-5"><p><code>h_name</code>：主机的正式名称（如<code>www.example.com</code>）。</p></li><li class="lvl-5"><p><code>h_aliases</code>：主机的其他别名（如<code>example.com</code>可能是<code>www.example.com</code>的别名），最后一个元素为<code>NULL</code>。</p></li><li class="lvl-5"><p><code>h_addrtype</code>：地址族类型，通常为<code>AF_INET</code>（IPv4），但现代系统也可能支持<code>AF_INET6</code>（IPv6）。</p></li><li class="lvl-5"><p><code>h_length</code>：每个 IP 地址的长度（IPv4 为 4 字节，IPv6 为 16 字节）。</p></li><li class="lvl-5"><p><code>h_addr_list</code>：存储主机的 IP 地址数组（网络字节序），每个元素是<code>in_addr</code>（IPv4）或<code>in6_addr</code>（IPv6）结构体的指针。为方便使用，通常用宏<code>h_addr</code>指代<code>h_addr_list[0]</code>（第一个 IP 地址）。</p></li></ul><h5 id="struct-servent（服务信息结构体）"><strong><code>struct servent</code>（服务信息结构体）</strong></h5><p>用于存储网络服务的相关信息（如服务名、端口号、协议等），同样定义在<code>&lt;netdb.h&gt;</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>  *s_name;        <span class="comment">// 服务的官方名称（规范名）</span></span><br><span class="line">    <span class="type">char</span> **s_aliases;     <span class="comment">// 服务的别名列表（以NULL结尾的字符串数组）</span></span><br><span class="line">    <span class="type">int</span>    s_port;        <span class="comment">// 服务对应的端口号（网络字节序）</span></span><br><span class="line">    <span class="type">char</span>  *s_proto;       <span class="comment">// 服务使用的协议（如&quot;tcp&quot;或&quot;udp&quot;）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>字段说明</strong>：</p><ul class="lvl-2"><li class="lvl-5"><p><code>s_name</code>：服务的正式名称（如<code>&quot;http&quot;</code>、<code>&quot;ftp&quot;</code>）。</p></li><li class="lvl-5"><p><code>s_aliases</code>：服务的其他别名（如<code>&quot;www&quot;</code>可能是<code>&quot;http&quot;</code>的别名），最后一个元素为<code>NULL</code>。</p></li><li class="lvl-5"><p><code>s_port</code>：服务对应的端口号，以网络字节序（大端序）存储，使用时需通过<code>ntohs</code>转换为主机字节序。</p></li><li class="lvl-5"><p><code>s_proto</code>：服务使用的协议类型（如<code>&quot;tcp&quot;</code>用于面向连接的服务，<code>&quot;udp&quot;</code>用于无连接服务）。</p></li></ul></li></ol><h3 id="二、现代套接字函数原型及说明">二、现代套接字函数原型及说明</h3><h4 id="getaddrinfo-函数：正向解析（主机名→IP-地址，服务名→端口号）">getaddrinfo 函数：正向解析（主机名→IP 地址，服务名→端口号）</h4><p><code>getaddrinfo</code>的核心功能是将<strong>主机名（或 IP 字符串）</strong> 和<strong>服务名（或端口号字符串）</strong> 转换为一组用于创建套接字的<code>struct sockaddr</code>结构（套接字地址结构），方便后续的<code>bind</code>、<code>connect</code>等操作。</p><h5 id="1-函数原型">1. 函数原型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">struct</span> addrinfo **res)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="2-参数详解">2. 参数详解</h5><table><thead><tr><th>参数名</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code>node</code></td><td><code>const char*</code></td><td>输入参数：主机名（如<code>&quot;www.example.com&quot;</code>）或 IP 地址字符串（如<code>&quot;192.168.1.1&quot;</code>）。若为<code>NULL</code>，结合<code>hints.ai_flags</code>的<code>AI_PASSIVE</code>可用于服务器绑定通配地址（<code>INADDR_ANY</code>）。</td></tr><tr><td><code>service</code></td><td><code>const char*</code></td><td>输入参数：服务名（如<code>&quot;http&quot;</code>、<code>&quot;ssh&quot;</code>）或端口号字符串（如<code>&quot;80&quot;</code>、<code>&quot;22&quot;</code>）。若为<code>NULL</code>，则不指定端口号（需手动在返回的<code>struct sockaddr</code>中设置）。</td></tr><tr><td><code>hints</code></td><td><code>const struct addrinfo*</code></td><td>输入参数：用于过滤和指定返回结果的 “提示” 结构体。若为<code>NULL</code>，则默认返回所有可能的地址类型（IPv4/IPv6，TCP/UDP 等）。</td></tr><tr><td><code>res</code></td><td><code>struct addrinfo**</code></td><td>输出参数：指向<code>struct addrinfo</code>链表的指针，存储解析结果。需通过<code>freeaddrinfo</code>释放内存。</td></tr></tbody></table><h5 id="3-关键结构体：struct-addrinfo">3. 关键结构体：struct addrinfo</h5><p><code>hints</code>和<code>res</code>均为<code>struct addrinfo</code>类型，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">addrinfo</span> &#123;</span><br><span class="line">    <span class="type">int</span> ai_flags;           <span class="comment">// 标志位（见下文）</span></span><br><span class="line">    <span class="type">int</span> ai_family;          <span class="comment">// 地址族（如AF_INET、AF_INET6、AF_UNSPEC）</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;        <span class="comment">// 套接字类型（如SOCK_STREAM、SOCK_DGRAM）</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;        <span class="comment">// 协议（如IPPROTO_TCP、IPPROTO_UDP，0表示任意）</span></span><br><span class="line">    <span class="type">socklen_t</span> ai_addrlen;   <span class="comment">// ai_addr指向的地址结构的长度</span></span><br><span class="line">    <span class="type">char</span> *ai_canonname;     <span class="comment">// 主机的规范名称（若指定AI_CANONNAME标志）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr</span> *ai_addr; <span class="comment">// 指向套接字地址结构（sockaddr_in或sockaddr_in6）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> *ai_next; <span class="comment">// 链表下一个节点（可能有多个解析结果）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中核心字段说明：</p><ul class="lvl-0"><li class="lvl-2"><p><code>ai_family</code>：指定地址族，<code>AF_INET</code>（仅 IPv4）、<code>AF_INET6</code>（仅 IPv6）、<code>AF_UNSPEC</code>（不限制，返回所有可能）。</p></li><li class="lvl-2"><p><code>ai_socktype</code>：指定套接字类型，<code>SOCK_STREAM</code>（TCP）、<code>SOCK_DGRAM</code>（UDP）、0（任意类型）。</p></li><li class="lvl-2"><p><code>ai_protocol</code>：指定协议，<code>IPPROTO_TCP</code>（TCP）、<code>IPPROTO_UDP</code>（UDP）、0（任意协议）。</p></li><li class="lvl-2"><p><code>ai_flags</code>：常用标志（可组合使用，按位或）：</p><ul class="lvl-2"><li class="lvl-4"><code>AI_PASSIVE</code>：用于服务器，<code>node</code>为<code>NULL</code>时，返回的地址将是通配地址（<code>INADDR_ANY</code> for IPv4，<code>in6addr_any</code> for IPv6），适合<code>bind</code>。</li><li class="lvl-4"><code>AI_CANONNAME</code>：要求返回主机的规范名称（存储在<code>ai_canonname</code>）。</li><li class="lvl-4"><code>AI_NUMERICHOST</code>：<code>node</code>必须是 IP 地址字符串（不进行域名解析），否则返回错误。</li><li class="lvl-4"><code>AI_NUMERICSERV</code>：<code>service</code>必须是端口号字符串（不解析服务名），否则返回错误。</li></ul></li></ul><h5 id="4-返回值">4. 返回值</h5><ul class="lvl-0"><li class="lvl-2"><p>成功：返回<code>0</code>，<code>res</code>指向解析结果链表（可能有多个地址，需遍历处理）。</p></li><li class="lvl-2"><p>失败：返回非 0 错误码（如<code>EAI_NONAME</code>表示主机名无效），可通过<code>gai_strerror(err)</code>获取错误信息字符串。</p></li></ul><h5 id="5-内存释放">5. 内存释放</h5><p>解析完成后，必须通过<code>freeaddrinfo</code>释放<code>res</code>指向的链表内存，避免泄漏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *res)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="6-使用场景">6. 使用场景</h5><ul class="lvl-0"><li class="lvl-2"><p>客户端：将服务器主机名（如<code>&quot;www.baidu.com&quot;</code>）和服务名（如<code>&quot;http&quot;</code>）解析为<code>struct sockaddr</code>，用于<code>connect</code>。</p></li><li class="lvl-2"><p>服务器：将<code>NULL</code>（主机名）和服务名（如<code>&quot;8080&quot;</code>）解析为通配地址（结合<code>AI_PASSIVE</code>），用于<code>bind</code>。</p></li></ul><h4 id="getnameinfo-函数：反向解析（IP-地址→主机名，端口号→服务名）">getnameinfo 函数：反向解析（IP 地址→主机名，端口号→服务名）</h4><p><code>getnameinfo</code>是<code>getaddrinfo</code>的反向操作：将<code>struct sockaddr</code>（套接字地址结构，包含 IP 和端口）转换为<strong>主机名</strong>和<strong>服务名</strong>。</p><h5 id="1-函数原型-2">1. 函数原型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> *host, <span class="type">socklen_t</span> hostlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> *serv, <span class="type">socklen_t</span> servlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="2-参数详解-2">2. 参数详解</h5><table><thead><tr><th>参数名</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code>addr</code></td><td><code>const struct sockaddr*</code></td><td>输入参数：指向<code>struct sockaddr</code>（或<code>sockaddr_in</code>/<code>sockaddr_in6</code>）的指针，包含待解析的 IP 和端口。</td></tr><tr><td><code>addrlen</code></td><td><code>socklen_t</code></td><td>输入参数：<code>addr</code>指向的地址结构的长度（如<code>sizeof(struct sockaddr_in)</code>）。</td></tr><tr><td><code>host</code></td><td><code>char*</code></td><td>输出参数：存储主机名的缓冲区（若为<code>NULL</code>，则不获取主机名）。</td></tr><tr><td><code>hostlen</code></td><td><code>socklen_t</code></td><td>输入参数：<code>host</code>缓冲区的大小（字节）。</td></tr><tr><td><code>serv</code></td><td><code>char*</code></td><td>输出参数：存储服务名的缓冲区（若为<code>NULL</code>，则不获取服务名）。</td></tr><tr><td><code>servlen</code></td><td><code>socklen_t</code></td><td>输入参数：<code>serv</code>缓冲区的大小（字节）。</td></tr><tr><td><code>flags</code></td><td><code>int</code></td><td>输入参数：控制解析行为的标志（见下文）。</td></tr></tbody></table><h5 id="3-关键标志（flags）">3. 关键标志（flags）</h5><ul class="lvl-0"><li class="lvl-2"><p><code>NI_NAMEREQD</code>：若无法解析主机名（如无 DNS 记录），则返回错误（<code>EAI_NONAME</code>），不返回 IP 字符串。</p></li><li class="lvl-2"><p><code>NI_NUMERICHOST</code>：强制返回 IP 地址字符串（不解析为主机名）。</p></li><li class="lvl-2"><p><code>NI_NUMERICSERV</code>：强制返回端口号字符串（不解析为服务名）。</p></li><li class="lvl-2"><p><code>NI_DGRAM</code>：表示是 UDP 服务（默认假设是 TCP，某些服务名在 TCP 和 UDP 中可能不同）。</p></li></ul><h5 id="4-返回值-2">4. 返回值</h5><ul class="lvl-0"><li class="lvl-2"><p>成功：返回<code>0</code>，<code>host</code>和<code>serv</code>缓冲区分别存储主机名和服务名（若对应参数非<code>NULL</code>）。</p></li><li class="lvl-2"><p>失败：返回非 0 错误码，可通过<code>gai_strerror(err)</code>获取错误信息。</p></li></ul><h5 id="5-使用场景">5. 使用场景</h5><ul class="lvl-0"><li class="lvl-2"><p>服务器：获取客户端连接的 IP 对应的主机名（如日志记录）。</p></li><li class="lvl-2"><p>网络工具：将套接字地址转换为人类可读的主机名和服务名（如<code>netstat</code>显示<code>www.baidu.com:http</code>而非<code>180.101.50.242:80</code>）。</p></li></ul><h4 id="示例代码片段">示例代码片段</h4><h5 id="1-getaddrinfo-示例（解析主机名和服务名）">1. getaddrinfo 示例（解析主机名和服务名）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* host = <span class="string">&quot;www.baidu.com&quot;</span>; <span class="comment">// 主机名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* service = <span class="string">&quot;http&quot;</span>;       <span class="comment">// 服务名（对应80端口）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints, *res, *p;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;    <span class="comment">// 不限制IPv4/IPv6</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// TCP</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> status = <span class="built_in">getaddrinfo</span>(host, service, &amp;hints, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;getaddrinfo error: &quot;</span> &lt;&lt; <span class="built_in">gai_strerror</span>(status) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历解析结果</span></span><br><span class="line">    <span class="keyword">for</span> (p = res; p != <span class="literal">nullptr</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="type">char</span> ipstr[INET6_ADDRSTRLEN]; <span class="comment">// 足够存储IPv6地址的缓冲区</span></span><br><span class="line">        <span class="type">void</span>* addr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是IPv4还是IPv6</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ai_family == AF_INET) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>* ipv4 = (<span class="keyword">struct</span> sockaddr_in*)p-&gt;ai_addr;</span><br><span class="line">            addr = &amp;(ipv4-&gt;sin_addr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">struct</span> sockaddr_in6* ipv6 = (<span class="keyword">struct</span> sockaddr_in6*)p-&gt;ai_addr;</span><br><span class="line">            addr = &amp;(ipv6-&gt;sin6_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为字符串</span></span><br><span class="line">        <span class="built_in">inet_ntop</span>(p-&gt;ai_family, addr, ipstr, <span class="built_in">sizeof</span>(ipstr));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;IP地址: &quot;</span> &lt;&lt; ipstr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">freeaddrinfo</span>(res); <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-getnameinfo-示例（解析-IP-地址和端口）">2. getnameinfo 示例（解析 IP 地址和端口）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr; <span class="comment">// IPv4地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">80</span>); <span class="comment">// 端口80</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;180.101.50.242&quot;</span>, &amp;addr.sin_addr); <span class="comment">// 百度的一个IP</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> host[NI_MAXHOST];   <span class="comment">// 主机名缓冲区</span></span><br><span class="line">    <span class="type">char</span> serv[NI_MAXSERV];   <span class="comment">// 服务名缓冲区</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析：获取主机名和服务名</span></span><br><span class="line">    <span class="type">int</span> status = <span class="built_in">getnameinfo</span>((<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr),</span><br><span class="line">                             host, <span class="built_in">sizeof</span>(host),</span><br><span class="line">                             serv, <span class="built_in">sizeof</span>(serv),</span><br><span class="line">                             <span class="number">0</span>); <span class="comment">// 不使用特殊标志</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;getnameinfo error: &quot;</span> &lt;&lt; <span class="built_in">gai_strerror</span>(status) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;主机名: &quot;</span> &lt;&lt; host &lt;&lt; std::endl; <span class="comment">// 可能输出&quot;www.baidu.com&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;服务名: &quot;</span> &lt;&lt; serv &lt;&lt; std::endl; <span class="comment">// 输出&quot;http&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、-socket-选项">三、 socket 选项</h3><table><thead><tr><th>选项名</th><th>级别</th><th>数据类型</th><th>功能描述</th><th>可操作（get/set）</th><th>备注</th></tr></thead><tbody><tr><td><strong>SOL_SOCKET 级别（通用选项）</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SO_DEBUG</td><td>SOL_SOCKET</td><td>int (0 / 非 0)</td><td>启用调试模式，内核记录套接字调试信息</td><td>get/set</td><td>仅超级用户可设置</td></tr><tr><td>SO_REUSEADDR</td><td>SOL_SOCKET</td><td>int (0 / 非 0)</td><td>允许重用本地地址和端口（如 TIME_WAIT 状态端口复用）</td><td>get/set</td><td>需在 bind 前设置，解决 “地址已被使用” 错误</td></tr><tr><td>SO_REUSEPORT</td><td>SOL_SOCKET</td><td>int (0 / 非 0)</td><td>允许多个套接字绑定到同一端口（需同 UID，内核分发数据）</td><td>get/set</td><td>部分系统支持（如 Linux 3.9+），常用于多进程监听同一端口</td></tr><tr><td>SO_KEEPALIVE</td><td>SOL_SOCKET</td><td>int (0 / 非 0)</td><td>启用 TCP 保活机制，定期检测对端是否存活</td><td>get/set</td><td>超时时间由系统配置（通常 2 小时无活动后触发）</td></tr><tr><td>SO_DONTROUTE</td><td>SOL_SOCKET</td><td>int (0 / 非 0)</td><td>禁止路由，数据仅在本地子网传输</td><td>get/set</td><td>用于本地通信或诊断</td></tr><tr><td>SO_BROADCAST</td><td>SOL_SOCKET</td><td>int (0 / 非 0)</td><td>允许发送广播报文</td><td>get/set</td><td>仅适用于 UDP，需在 sendto 前设置</td></tr><tr><td>SO_SNDBUF</td><td>SOL_SOCKET</td><td>int</td><td>设置 / 获取发送缓冲区大小（字节）</td><td>get/set</td><td>内核可能调整实际大小（不超过系统上限）</td></tr><tr><td>SO_RCVBUF</td><td>SOL_SOCKET</td><td>int</td><td>设置 / 获取接收缓冲区大小（字节）</td><td>get/set</td><td>影响接收性能和拥塞控制，建议在 connect/bind 前设置</td></tr><tr><td>SO_SNDTIMEO</td><td>SOL_SOCKET</td><td>struct timeval</td><td>设置发送操作（send/sendto）的超时时间</td><td>get/set</td><td>超时后返回 EAGAIN/EWOULDBLOCK</td></tr><tr><td>SO_RCVTIMEO</td><td>SOL_SOCKET</td><td>struct timeval</td><td>设置接收操作（recv/recvfrom）的超时时间</td><td>get/set</td><td>同 SO_SNDTIMEO</td></tr><tr><td>SO_TYPE</td><td>SOL_SOCKET</td><td>int</td><td>获取套接字类型（如 SOCK_STREAM、SOCK_DGRAM）</td><td>get（不可 set）</td><td>用于判断套接字是 TCP 还是 UDP</td></tr><tr><td>SO_ERROR</td><td>SOL_SOCKET</td><td>int</td><td>获取套接字上的待处理错误（如连接失败原因）</td><td>get（不可 set）</td><td>常用于非阻塞 connect 后的错误检查</td></tr><tr><td>SO_LINGER</td><td>SOL_SOCKET</td><td>struct linger</td><td>控制 close 时的延迟关闭行为（等待未发送数据）</td><td>get/set</td><td>struct linger {int l_onoff; int l_linger;}，l_onoff=1 启用，l_linger 为等待秒数</td></tr><tr><td>SO_PASSCRED</td><td>SOL_SOCKET</td><td>int (0 / 非 0)</td><td>允许接收辅助数据中的凭证信息（如 UID/GID）</td><td>get/set</td><td>用于 Unix 域套接字的权限验证</td></tr><tr><td>SO_PEERCRED</td><td>SOL_SOCKET</td><td>struct ucred</td><td>获取对端 Unix 域套接字的用户凭证（UID/GID/PID）</td><td>get（不可 set）</td><td>仅适用于已连接的 Unix 域套接字</td></tr><tr><td><strong>IPPROTO_IP 级别（IPv4 选项）</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IP_HDRINCL</td><td>IPPROTO_IP</td><td>int (0 / 非 0)</td><td>应用程序自行构造 IP 头部，不依赖内核</td><td>get/set</td><td>仅超级用户可设置，用于自定义 IP 报文</td></tr><tr><td>IP_OPTIONS</td><td>IPPROTO_IP</td><td>void *</td><td>设置 / 获取 IP 选项（如源路由、记录路由）</td><td>get/set</td><td>选项数据需符合 IP 协议规范，长度有限制</td></tr><tr><td>IP_TOS</td><td>IPPROTO_IP</td><td>int</td><td>设置 / 获取 IP 服务类型（TOS），控制路由优先级</td><td>get/set</td><td>值为 0~255，具体含义见 RFC 规范</td></tr><tr><td>IP_TTL</td><td>IPPROTO_IP</td><td>int</td><td>设置 / 获取 IP 生存时间（TTL），限制报文转发跳数</td><td>get/set</td><td>通常设为 64、128 等，超过 TTL 则报文被丢弃</td></tr><tr><td>IP_MULTICAST_TTL</td><td>IPPROTO_IP</td><td>u_char</td><td>设置多播报文的 TTL 值</td><td>get/set</td><td>控制多播范围（0 = 本地，1 = 同一子网，…，255 = 全局）</td></tr><tr><td>IP_MULTICAST_LOOP</td><td>IPPROTO_IP</td><td>u_char (0/1)</td><td>启用多播报文回环（本地发送的多播自己能否接收）</td><td>get/set</td><td>默认 1（启用），多播应用需根据需求关闭</td></tr><tr><td>IP_ADD_MEMBERSHIP</td><td>IPPROTO_IP</td><td>struct ip_mreq</td><td>加入多播组</td><td>set（不可 get）</td><td>struct ip_mreq 包含多播组 IP 和本地接口 IP</td></tr><tr><td>IP_DROP_MEMBERSHIP</td><td>IPPROTO_IP</td><td>struct ip_mreq</td><td>退出多播组</td><td>set（不可 get）</td><td>同 IP_ADD_MEMBERSHIP</td></tr><tr><td><strong>IPPROTO_TCP 级别（TCP 选项）</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>TCP_NODELAY</td><td>IPPROTO_TCP</td><td>int (0 / 非 0)</td><td>禁用 Nagle 算法（立即发送小数据包，不延迟合并）</td><td>get/set</td><td>适用于低延迟场景（如实时通信），可能增加网络拥塞</td></tr><tr><td>TCP_MAXSEG</td><td>IPPROTO_TCP</td><td>int</td><td>设置 / 获取 TCP 最大段大小（MSS）</td><td>get/set</td><td>通常由内核协商，手动设置需谨慎</td></tr><tr><td>TCP_CORK</td><td>IPPROTO_TCP</td><td>int (0 / 非 0)</td><td>启用 “塞子” 模式，累积数据后一次性发送（类似 Nagle 但更激进）</td><td>get/set</td><td>适用于批量数据发送，需在完成后关闭（避免延迟）</td></tr><tr><td>TCP_KEEPIDLE</td><td>IPPROTO_TCP</td><td>int</td><td>设置 TCP 保活探测的空闲时间（秒）</td><td>get/set</td><td>需 SO_KEEPALIVE 启用，默认 7200 秒（2 小时）</td></tr><tr><td>TCP_KEEPINTVL</td><td>IPPROTO_TCP</td><td>int</td><td>设置 TCP 保活探测的间隔时间（秒）</td><td>get/set</td><td>探测未响应时，间隔多久再次发送，默认 75 秒</td></tr><tr><td>TCP_KEEPCNT</td><td>IPPROTO_TCP</td><td>int</td><td>设置 TCP 保活探测的最大重试次数</td><td>get/set</td><td>超过次数则判定对端不可达，默认 9 次</td></tr></tbody></table><h3 id="说明">说明</h3><ol><li class="lvl-3"><p>选项级别说明：<code>SOL_SOCKET</code>为通用选项，<code>IPPROTO_IP</code>为 IPv4 协议选项，<code>IPPROTO_TCP</code>为 TCP 协议选项，还有<code>IPPROTO_UDP</code>（UDP 选项，较少用）等。</p></li><li class="lvl-3"><p>部分选项为系统特定（如<code>SO_REUSEPORT</code>在不同 OS 上行为可能不同），使用前需参考目标系统的<code>man</code>手册。</p></li><li class="lvl-3"><p>多播相关选项（如<code>IP_ADD_MEMBERSHIP</code>）需结合多播地址（224.0.0.0~239.255.255.255）使用。</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://wangmc1024.github.io/categories/C/">C++</category>
      
      
      <category domain="https://wangmc1024.github.io/tags/C/">C++</category>
      
      
      <comments>https://wangmc1024.github.io/2025/08/15/%E5%B8%B8%E7%94%A8%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%AF%B4%E6%98%8E/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ASan的使用</title>
      <link>https://wangmc1024.github.io/2025/08/11/ASan%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <guid>https://wangmc1024.github.io/2025/08/11/ASan%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Mon, 11 Aug 2025 11:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;如何使用ASan检测内存错误及其使用方法&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如何使用ASan检测内存错误及其使用方法</p> <span id="more"></span><h3 id="AddressSanitizer（ASan）详解：使用场景、注意事项及扩展知识">AddressSanitizer（ASan）详解：使用场景、注意事项及扩展知识</h3><p>AddressSanitizer（简称 ASan）是由 Google 开发的<strong>基于编译器的内存错误检测工具</strong>，集成于 GCC 4.8+、Clang 3.1 + 及 MSVC 2019 + 中。它能精准检测多种内存安全问题（如缓冲区溢出、使用已释放内存等），是 C/C++ 开发中排查内存错误的核心工具</p><h2 id="一、ASan-的核心功能">一、ASan 的核心功能</h2><p>ASan 主要检测以下内存错误类型：</p><ul class="lvl-0"><li class="lvl-2"><p>栈 / 堆 / 全局缓冲区溢出（越界读写）；</p></li><li class="lvl-2"><p>使用已释放内存（use-after-free）；</p></li><li class="lvl-2"><p>双重释放（double-free）或释放无效指针；</p></li><li class="lvl-2"><p>内存泄漏（需配合 LeakSanitizer，LSan）；</p></li><li class="lvl-2"><p>部分未初始化内存的使用（更全面的检测需 MemorySanitizer，MSan）；</p></li><li class="lvl-2"><p>栈 - use-after-return/scope（离开作用域后使用栈内存）。</p></li></ul><h2 id="二、不同场景下的使用方法">二、不同场景下的使用方法</h2><h3 id="1-基础编译场景（直接编译单个文件）">1. 基础编译场景（直接编译单个文件）</h3><p>ASan 的使用依赖编译器插桩，需在<strong>编译和链接阶段同时添加选项</strong>。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>核心编译选项</strong>：<code>-fsanitize=address</code>：启用 ASan 检测；<code>-g</code>：生成调试信息（用于定位错误位置）；<br><code>-O1</code>/<code>-O2</code>：优化级别（<code>-O0</code>可使用但性能差，<code>-O3</code>可能因优化掩盖部分错误，推荐<code>-O1</code>）。</p></li><li class="lvl-2"><p><strong>示例（Clang/GCC）</strong>：假设有文件<code>test.c</code>（含堆缓冲区溢出）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配4个int（16字节）</span></span><br><span class="line">  arr[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">// 越界写入（索引4超出范围）</span></span><br><span class="line">  <span class="built_in">free</span>(arr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -fsanitize=address -g -O1 test.c -o <span class="built_in">test</span>  <span class="comment"># 编译</span></span><br><span class="line">./test                                          <span class="comment"># 运行</span></span><br></pre></td></tr></table></figure><p>输出将直接提示 “堆缓冲区溢出”，并显示错误位置（<code>test.c:4</code>）、调用栈及内存分配信息。</p></li></ul><h3 id="2-与构建工具集成（CMake-Makefile）">2. 与构建工具集成（CMake/Makefile）</h3><p>在大型项目中，需通过构建工具统一配置 ASan 选项。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>CMake 集成</strong>：在<code>CMakeLists.txt</code>中添加：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对C/C++均启用ASan</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -fsanitize=address -g -O1&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fsanitize=address -g -O1&quot;</span>)</span><br><span class="line"><span class="comment"># 链接阶段同样需要ASan选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -fsanitize=address&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -fsanitize=address&quot;</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>Makefile 集成</strong>：在<code>Makefile</code>中添加：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS += -fsanitize=address -g -O1   <span class="comment"># C编译选项</span></span><br><span class="line">CXXFLAGS += -fsanitize=address -g -O1 <span class="comment"># C++编译选项</span></span><br><span class="line">LDFLAGS += -fsanitize=address         <span class="comment"># 链接选项</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-多线程程序检测">3. 多线程程序检测</h3><p>ASan 对多线程程序同样有效，可检测线程中的内存越界、use-after-free 等问题（但线程竞争需 ThreadSanitizer，TSan）。</p><ul class="lvl-0"><li class="lvl-2"><p>示例：多线程堆越界</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *arr;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  arr[<span class="number">10</span>] = <span class="number">0</span>; <span class="comment">// 越界写入（假设仅分配8个int）</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="type">pthread_t</span> t;</span><br><span class="line">  pthread_create(&amp;t, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(t, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">free</span>(arr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fsanitize=address -g -O1 -pthread test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>运行后 ASan 会定位到线程函数中的越界位置。</p></li></ul><h3 id="4-与调试工具（GDB）结合">4. 与调试工具（GDB）结合</h3><p>当 ASan 检测到错误时，程序会崩溃，此时可通过 GDB 进一步调试。</p><ul class="lvl-0"><li class="lvl-2"><p>步骤：</p><ol><li class="lvl-5">用 ASan 编译程序（保留<code>-g</code>选项）；</li><li class="lvl-5">用 GDB 启动程序：<code>gdb ./test</code>；</li><li class="lvl-5">在 GDB 中运行：<code>(gdb) run</code>；</li><li class="lvl-5">触发错误后，使用<code>bt</code>（查看调用栈）、<code>frame N</code>（切换到第 N 帧）定位代码细节。</li></ol></li></ul><h3 id="5-平台差异（Linux-macOS-Windows）">5. 平台差异（Linux/macOS/Windows）</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>Linux</strong>：支持最完善，GCC/Clang 均无显著限制；</p></li><li class="lvl-2"><p><strong>macOS</strong>：需使用 Clang（系统默认编译器），GCC 支持有限；</p></li><li class="lvl-2"><p>Windows：</p><ul class="lvl-2"><li class="lvl-4">Clang：与 Linux 用法一致（需安装 LLVM）；</li><li class="lvl-4">MSVC 2019+：通过<code>/fsanitize=address</code>启用（选项格式与 GCC/Clang 不同，且部分功能有差异）。</li></ul></li></ul><h3 id="6-内存泄漏检测（配合-LSan）">6. 内存泄漏检测（配合 LSan）</h3><p>ASan 默认不检测内存泄漏，需手动启用 LeakSanitizer（LSan）。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>启用方法</strong>：</p><ul class="lvl-2"><li class="lvl-4">Clang：直接添加<code>-fsanitize=address,leak</code>；</li><li class="lvl-4">GCC：通过环境变量启用：<code>export ASAN_OPTIONS=detect_leaks=1</code>。</li></ul></li><li class="lvl-2"><p><strong>示例</strong>：检测内存泄漏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>); <span class="comment">// 未释放</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -fsanitize=address,leak -g test.c -o <span class="built_in">test</span></span><br><span class="line">./test</span><br></pre></td></tr></table></figure><p>输出会提示 “2 个字节的内存泄漏”，并显示分配位置。</p></li></ul><h2 id="三、注意事项">三、注意事项</h2><h3 id="1-性能开销不可忽视">1. 性能开销不可忽视</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>运行速度</strong>：程序会慢 2-5 倍（因插入大量检测代码）；</p></li><li class="lvl-2"><p><strong>内存占用</strong>：增加 2-3 倍（需维护 “影子内存”）；</p></li><li class="lvl-2"><p><strong>适用场景</strong>：仅用于开发 / 测试环境，<strong>禁止在生产环境启用</strong>。</p></li></ul><h3 id="2-编译选项必须完整">2. 编译选项必须完整</h3><ul class="lvl-0"><li class="lvl-2"><p>编译（<code>-c</code>）和链接（<code>-o</code>）阶段均需添加<code>-fsanitize=address</code>，否则会出现链接错误（如 “undefined reference to `__asan_init’”）。</p></li></ul><h3 id="3-优化级别影响检测效果">3. 优化级别影响检测效果</h3><ul class="lvl-0"><li class="lvl-2"><p>避免使用<code>-O3</code>：高优化可能导致编译器重排代码，掩盖内存错误（如合并相邻内存访问）；</p></li><li class="lvl-2"><p>推荐<code>-O1</code>或<code>-O2</code>：平衡性能与检测精度。</p></li></ul><h3 id="4-符号表是定位错误的关键">4. 符号表是定位错误的关键</h3><ul class="lvl-0"><li class="lvl-2"><p>必须添加<code>-g</code>选项：否则 ASan 报告仅显示内存地址，无法关联到文件名和行号；</p></li><li class="lvl-2"><p>若依赖第三方库，需确保其编译时也带<code>-g</code>（否则调用栈中库函数位置可能显示为 “unknown”）。</p></li></ul><h3 id="5-与其他工具的冲突与兼容">5. 与其他工具的冲突与兼容</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>冲突</strong>：不能与 TSan（<code>-fsanitize=thread</code>）同时使用（两者插桩逻辑冲突）；</p></li><li class="lvl-2"><p>兼容：可与 UBSan（<code>-fsanitize=undefined</code>）同时使用（检测未定义行为，如整数溢出），例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsanitize=address,undefined -g test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-环境变量配置（ASAN-OPTIONS）">6. 环境变量配置（ASAN_OPTIONS）</h3><p>ASan 通过环境变量<code>ASAN_OPTIONS</code>调整行为，常用参数：</p><ul class="lvl-0"><li class="lvl-2"><p><code>detect_leaks=1</code>：启用内存泄漏检测（默认 0）；</p></li><li class="lvl-2"><p><code>malloc_context_size=30</code>：设置内存分配 / 释放的调用栈深度（默认 10，加深可更清晰定位来源）；</p></li><li class="lvl-2"><p><code>fast_unwind_on_malloc=0</code>：使用精确 unwind（而非快速），调用栈更准确但速度慢（默认 1）；</p></li><li class="lvl-2"><p><code>quarantine_size_mb=1024</code>：设置 “隔离区” 大小（已释放内存暂存区域，调大可检测更多 use-after-free）。</p></li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ASAN_OPTIONS=<span class="string">&quot;detect_leaks=1:malloc_context_size=20:fast_unwind_on_malloc=0&quot;</span></span><br></pre></td></tr></table></figure><h3 id="7-部分错误可能漏检">7. 部分错误可能漏检</h3><ul class="lvl-0"><li class="lvl-2"><p>微小越界（如 1 字节）：若未触及影子内存的 “红色区域”（标记为无效的内存），可能不被检测；</p></li><li class="lvl-2"><p>复杂未初始化内存使用：需 MSan（<code>-fsanitize=memory</code>）补充检测（但需重新编译所有依赖库）。</p></li></ul><h2 id="四、扩展知识">四、扩展知识</h2><h3 id="1-ASan-工作原理（影子内存机制）">1. ASan 工作原理（影子内存机制）</h3><p>ASan 通过 “影子内存（shadow memory）” 跟踪用户内存状态：</p><ul class="lvl-0"><li class="lvl-2"><p>每 8 字节用户内存对应 1 字节影子内存（影子内存总大小为用户内存的 1/8）；</p></li><li class="lvl-2"><p>影子内存标记内存状态：0（可访问）、1-7（部分可访问）、0xF1（已释放）、0xF2（越界区域）等；</p></li><li class="lvl-2"><p>编译器在内存访问（读 / 写）处插入检测代码，检查对应影子内存状态，若非法则触发错误并输出报告。</p></li></ul><h3 id="2-与其他-Sanitizer-的区别">2. 与其他 Sanitizer 的区别</h3><table><thead><tr><th>工具</th><th>检测目标</th><th>与 ASan 兼容性</th><th>特点</th></tr></thead><tbody><tr><td>LSan</td><td>内存泄漏</td><td>兼容（可联合使用）</td><td>轻量，依赖 ASan 基础</td></tr><tr><td>MSan</td><td>使用未初始化内存</td><td>不兼容</td><td>需全链路重编译，精度高</td></tr><tr><td>TSan</td><td>线程竞争</td><td>不兼容</td><td>专用于多线程同步错误</td></tr><tr><td>UBSan</td><td>未定义行为（如整数溢出）</td><td>兼容</td><td>可与 ASan 联合使用，覆盖更广</td></tr></tbody></table><h3 id="3-最佳实践">3. 最佳实践</h3><ul class="lvl-0"><li class="lvl-2"><p>开发阶段：对核心模块启用 ASan，定期运行单元测试；</p></li><li class="lvl-2"><p>CI/CD 流程：将 ASan 检测作为代码提交的 “门禁”，提前拦截内存错误；</p></li><li class="lvl-2"><p>结合调试：用 GDB 解析 ASan 崩溃现场，定位错误根源；</p></li><li class="lvl-2"><p>多工具协同：先用 ASan 检测基础内存错误，再用 TSan 检测线程问题，最后用 LSan 查漏内存泄漏。</p></li></ul><h3 id="4-局限性">4. 局限性</h3><ul class="lvl-0"><li class="lvl-2"><p>无法检测逻辑错误（如内存访问正确但值错误）；</p></li><li class="lvl-2"><p>对自定义内存分配器（如<code>jemalloc</code>）支持有限，可能需要额外配置；</p></li><li class="lvl-2"><p>性能开销大，无法用于生产环境的性能测试。</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://wangmc1024.github.io/categories/C/">C++</category>
      
      
      <category domain="https://wangmc1024.github.io/tags/C/">C++</category>
      
      
      <comments>https://wangmc1024.github.io/2025/08/11/ASan%E7%9A%84%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>分散 / 聚集 IO</title>
      <link>https://wangmc1024.github.io/2025/07/29/%E5%88%86%E6%95%A3%20%20%E8%81%9A%E9%9B%86%20IO/</link>
      <guid>https://wangmc1024.github.io/2025/07/29/%E5%88%86%E6%95%A3%20%20%E8%81%9A%E9%9B%86%20IO/</guid>
      <pubDate>Tue, 29 Jul 2025 05:18:00 GMT</pubDate>
      
      <description>&lt;p&gt;网络编程中常用的分散 / 聚集 IO 技术&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>网络编程中常用的分散 / 聚集 IO 技术</p> <span id="more"></span><h3 id="1-readv-与-writev：分散-聚集-I-O">1. <code>readv</code> 与 <code>writev</code>：分散 / 聚集 I/O</h3><p><code>readv</code>（分散读）和 <code>writev</code>（聚集写）是用于处理<strong>分散缓冲区</strong>的 I/O 函数，核心作用是通过一次系统调用完成对多个不连续缓冲区的读写操作，减少系统调用次数（系统调用存在上下文切换开销）。</p><h4 id="函数原型">函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从fd读取数据，分散存储到iov指向的多个缓冲区</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将iov指向的多个缓冲区数据聚集后写入fd</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure><h4 id="关键参数">关键参数</h4><ul class="lvl-0"><li class="lvl-2"><p><code>struct iovec</code>描述一个缓冲区的结构，定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>  *iov_base;  <span class="comment">// 缓冲区起始地址</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;   <span class="comment">// 缓冲区长度（字节数）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><code>iovcnt</code>：缓冲区数量，上限由系统限制（通常<code>IOV_MAX</code>，如 Linux 为 1024）。</p></li></ul><h4 id="功能与适用场景">功能与适用场景</h4><ul class="lvl-0"><li class="lvl-2"><p><strong><code>readv</code></strong>：从文件描述符<code>fd</code>读取数据，按顺序填充<code>iov</code>数组中的缓冲区（前一个填满后再填下一个），返回实际读取的字节数。</p></li><li class="lvl-2"><p><strong><code>writev</code></strong>：将<code>iov</code>数组中所有缓冲区的数据按顺序拼接后写入<code>fd</code>，返回实际写入的字节数。</p></li></ul><p><strong>网络编程场景</strong>：在构造协议报文时（如 HTTP 响应包含状态行、头部字段、正文等多个独立部分），可通过<code>writev</code>一次发送所有部分，避免多次<code>write</code>调用的开销；同理，接收报文时若需拆分到不同缓冲区（如头部和正文分离），可使用<code>readv</code>。</p><h4 id="注意事项">注意事项</h4><ul class="lvl-0"><li class="lvl-2"><p>若读取 / 写入中途发生错误，仍会返回已成功处理的字节数（部分成功）。</p></li><li class="lvl-2"><p>对于非阻塞<code>fd</code>，行为与<code>read</code>/<code>write</code>一致（可能返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>）。</p></li></ul><h3 id="2-dup-与-dup2：文件描述符复制">2. <code>dup</code> 与 <code>dup2</code>：文件描述符复制</h3><p><code>dup</code> 和 <code>dup2</code> 用于复制文件描述符，使新的描述符与原描述符指向<strong>同一个文件表项</strong>（共享文件偏移量、文件状态标志等），核心作用是实现 I/O 重定向。</p><h4 id="函数原型-2">函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制oldfd，返回最小的未使用描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将newfd重定向为oldfd的副本（若newfd已打开则先关闭）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><h4 id="功能差异">功能差异</h4><ul class="lvl-0"><li class="lvl-2"><p><strong><code>dup</code></strong>：自动选择一个<strong>最小的未被使用的描述符</strong>作为新描述符，与<code>oldfd</code>指向同一文件。</p></li><li class="lvl-2"><p><strong><code>dup2</code></strong>：显式指定新描述符<code>newfd</code>，若<code>newfd</code>已打开，则先关闭它（若<code>newfd == oldfd</code>，则直接返回<code>newfd</code>，不关闭）。</p></li></ul><h4 id="网络编程场景">网络编程场景</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>重定向标准 I/O</strong>：例如在网络服务中，将客户端<code>socket</code>的描述符通过<code>dup2(client_fd, STDOUT_FILENO)</code>重定向为标准输出，此时<code>printf</code>的内容会直接发送给客户端。</p></li><li class="lvl-2"><p><strong>简化接口适配</strong>：某些库函数仅支持固定描述符（如标准输出），通过<code>dup2</code>可将其适配到 socket 描述符。</p></li></ul><h4 id="注意事项-2">注意事项</h4><ul class="lvl-0"><li class="lvl-2"><p>若<code>oldfd</code>无效（未打开），两函数均返回<code>-1</code>并设置<code>errno</code>为<code>EBADF</code>。</p></li><li class="lvl-2"><p><code>dup2</code>关闭<code>newfd</code>时若失败（如权限问题），会返回<code>-1</code>，但此时<code>newfd</code>可能已处于关闭状态，需注意错误处理。</p></li></ul><h3 id="3-sendfile：零拷贝文件传输">3. <code>sendfile</code>：零拷贝文件传输</h3><p><code>sendfile</code> 用于在两个文件描述符之间直接传输数据，数据无需经过用户空间，全程在内核空间处理，属于<strong>零拷贝（zero-copy）</strong> 技术，可大幅提升大文件传输效率。</p><h4 id="函数原型（Linux）">函数原型（Linux）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将in_fd的数据传输到out_fd，返回实际传输的字节数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><h4 id="关键参数与限制">关键参数与限制</h4><ul class="lvl-0"><li class="lvl-2"><p><code>in_fd</code>：源文件描述符，<strong>必须是支持<code>mmap</code>的常规文件</strong>（不能是 socket 或管道）。</p></li><li class="lvl-2"><p><code>out_fd</code>：目标文件描述符，在 Linux 中<strong>必须是 socket</strong>（其他系统可能支持更多类型）。</p></li><li class="lvl-2"><p><code>offset</code>：指定<code>in_fd</code>的起始读取位置，若不为<code>NULL</code>，传输后会更新为实际结束位置（原子操作，避免多线程竞争）。</p></li><li class="lvl-2"><p><code>count</code>：计划传输的字节数。</p></li></ul><h4 id="功能与优势">功能与优势</h4><p>传统文件传输流程（<code>read + write</code>）需要 4 次数据拷贝（磁盘→内核缓冲区→用户缓冲区→socket 缓冲区→网卡）和 2 次系统调用；而<code>sendfile</code>通过内核直接将文件数据从页缓存传输到 socket 缓冲区，仅需 2 次拷贝（磁盘→内核缓冲区→socket 缓冲区）和 1 次系统调用，显著减少开销。</p><p><strong>网络编程场景</strong>：在文件服务器中（如 HTTP 服务器传输静态资源），<code>sendfile</code>是高效传输文件的首选方式，比<code>read + write</code>组合性能提升明显。</p><h4 id="注意事项-3">注意事项</h4><ul class="lvl-0"><li class="lvl-2"><p>跨平台差异大：Linux 的<code>sendfile</code>与 BSD 的<code>sendfile</code>参数和行为不同，移植时需注意。</p></li><li class="lvl-2"><p>不支持非阻塞 I/O：若<code>out_fd</code>为非阻塞 socket 且暂时无法写入，<code>sendfile</code>可能返回<code>-1</code>并设置<code>errno</code>为<code>EAGAIN</code>，但部分实现可能不支持。</p></li><li class="lvl-2"><p><code>in_fd</code>必须是常规文件：不能用于 socket 之间的数据转发（需用<code>splice</code>等其他函数）。</p></li></ul><h3 id="总结">总结</h3><ul class="lvl-0"><li class="lvl-2"><p><code>readv</code>/<code>writev</code>：优化多缓冲区 I/O，减少系统调用次数，适合协议报文的拼接 / 拆分。</p></li><li class="lvl-2"><p><code>dup</code>/<code>dup2</code>：实现文件描述符重定向，简化 I/O 接口适配。</p></li><li class="lvl-2"><p><code>sendfile</code>：利用零拷贝技术高效传输文件，是大文件网络传输的核心优化手段。</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://wangmc1024.github.io/categories/C/">C++</category>
      
      
      <category domain="https://wangmc1024.github.io/tags/C/">C++</category>
      
      
      <comments>https://wangmc1024.github.io/2025/07/29/%E5%88%86%E6%95%A3%20%20%E8%81%9A%E9%9B%86%20IO/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TCP、UDP数据读写基础</title>
      <link>https://wangmc1024.github.io/2025/07/28/TCP,UDP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E5%9F%BA%E7%A1%80/</link>
      <guid>https://wangmc1024.github.io/2025/07/28/TCP,UDP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E5%9F%BA%E7%A1%80/</guid>
      <pubDate>Mon, 28 Jul 2025 09:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;如何使用 C++ 进行 TCP 和 UDP 数据读写的基础知识&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如何使用 C++ 进行 TCP 和 UDP 数据读写的基础知识</p> <span id="more"></span><h3 id="一、通用数据读写基础（TCP-UDP-均需掌握）">一、通用数据读写基础（TCP/UDP 均需掌握）</h3><p>无论使用何种协议，网络数据读写都需处理字节序转换、数据序列化和错误处理，这是跨平台通信的基础。</p><h4 id="1-字节序转换（解决主机与网络字节序差异）">1. 字节序转换（解决主机与网络字节序差异）</h4><p>网络协议规定使用<strong>大端字节序</strong>（网络字节序），主机字节序可能为大端或小端（如 x86 为小端），需通过以下函数转换：</p><ul class="lvl-0"><li class="lvl-2"><p><code>uint16_t htons(uint16_t hostshort)</code>：主机→网络字节序（16 位，如端口号）</p></li><li class="lvl-2"><p><code>uint32_t htonl(uint32_t hostlong)</code>：主机→网络字节序（32 位，如 IPv4 地址）</p></li><li class="lvl-2"><p><code>uint16_t ntohs(uint16_t netshort)</code>：网络→主机字节序（16 位）</p></li><li class="lvl-2"><p><code>uint32_t ntohl(uint32_t netlong)</code>：网络→主机字节序（32 位）</p></li></ul><p><strong>进阶场景</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>64 位数据：POSIX 提供<code>htobe64</code>/<code>be64toh</code>（大端）、<code>htole64</code>/<code>le64toh</code>（小端），Windows 需手动实现。</p></li><li class="lvl-2"><p>浮点数：无标准转换函数，需通过指针转换为字节数组传输（依赖 IEEE 754 兼容）。</p></li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> port = <span class="number">8080</span>;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 端口必须用网络字节序</span></span><br></pre></td></tr></table></figure><h4 id="2-数据序列化与缓冲区管理">2. 数据序列化与缓冲区管理</h4><p>网络传输的是字节流，需通过缓冲区处理，结构化数据需序列化以避免对齐和字节序问题。</p><p><strong>核心函数</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><code>memcpy(void *dest, const void *src, size_t n)</code>：拷贝字节（用于序列化）</p></li><li class="lvl-2"><p><code>memset(void *s, int c, size_t n)</code>：初始化缓冲区（如清空接收缓冲区）</p></li><li class="lvl-2"><p><code>strlen(const char *s)</code>：计算字符串长度（用于发送字符串）</p></li></ul><p><strong>序列化方案</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>手动序列化：拆分结构体成员，转换字节序后写入缓冲区：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Msg</span> &#123; <span class="type">int</span> len; <span class="type">short</span> type; &#125;;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> net_len = <span class="built_in">htonl</span>(msg.len);</span><br><span class="line"><span class="type">short</span> net_type = <span class="built_in">htons</span>(msg.type);</span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;net_len, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(buf+<span class="number">4</span>, &amp;net_type, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>协议库：Protobuf、FlatBuffers 等自动处理对齐和字节序。</p></li></ul><p><strong>缓冲区策略</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>动态缓冲区：使用<code>vector&lt;char&gt;</code>避免栈溢出，适合接收未知长度数据。</p></li><li class="lvl-2"><p>分散 - 聚集 IO：通过<code>iovec</code>和<code>sendmsg</code>/<code>recvmsg</code>减少内存拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">2</span>];  <span class="comment">// 分散发送消息头和消息体</span></span><br><span class="line">iov[<span class="number">0</span>].iov_base = &amp;header;</span><br><span class="line">iov[<span class="number">0</span>].iov_len = <span class="built_in">sizeof</span>(header);</span><br><span class="line">iov[<span class="number">1</span>].iov_base = data;</span><br><span class="line">iov[<span class="number">1</span>].iov_len = data_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> msg;</span><br><span class="line">msg.msg_iov = iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">sendmsg</span>(sockfd, &amp;msg, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-通用错误处理">3. 通用错误处理</h4><p>网络函数失败时返回 - 1，需通过错误码定位问题：</p><ul class="lvl-0"><li class="lvl-2"><p>Linux：<code>errno</code>（如<code>EINTR</code>、<code>ECONNRESET</code>）</p></li><li class="lvl-2"><p>Windows：<code>WSAGetLastError()</code>（如<code>WSAECONNRESET</code>）</p></li></ul><p>常见错误：</p><ul class="lvl-0"><li class="lvl-2"><p><code>EINTR</code>：操作被信号中断（需重试）</p></li><li class="lvl-2"><p><code>EWOULDBLOCK</code>：非阻塞模式下无数据（需等待）</p></li><li class="lvl-2"><p><code>ECONNRESET</code>：连接被对方重置</p></li><li class="lvl-2"><p><code>ENOTCONN</code>：TCP 未连接或 UDP 未指定目标</p></li></ul><h3 id="二、TCP-数据读写（面向连接的字节流）">二、TCP 数据读写（面向连接的字节流）</h3><p>TCP 是可靠的面向连接协议，数据无边界，需通过应用层协议界定消息边界。</p><h4 id="1-核心读写函数">1. 核心读写函数</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>发送：<code>ssize_t send(int sockfd, const void *buf, size_t len, int flags)</code></strong></p><ul class="lvl-2"><li class="lvl-4">参数：<code>sockfd</code>（已连接的 TCP socket）、缓冲区、长度、标志（通常 0）。</li><li class="lvl-4">返回值：实际发送字节数（可能小于<code>len</code>）；失败返回 - 1。</li><li class="lvl-4">标志：<code>MSG_NOSIGNAL</code>（Linux）：避免对方关闭时触发 SIGPIPE。</li></ul></li><li class="lvl-2"><p><strong>接收：<code>ssize_t recv(int sockfd, void *buf, size_t len, int flags)</code></strong></p><ul class="lvl-2"><li class="lvl-4">参数：<code>sockfd</code>、接收缓冲区、长度、标志（通常 0）。</li><li class="lvl-4">返回值：实际接收字节数；0 表示对方正常关闭；-1 表示错误。</li><li class="lvl-4">标志：<code>MSG_PEEK</code>（预览数据不移除）。</li></ul></li></ul><h4 id="2-关键特性与实现">2. 关键特性与实现</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>字节流无边界</strong>：需应用层定义消息格式，常见方案：</p><ol><li class="lvl-5"><p>**固定长度:**累计读取到指定长度后处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv_fixed</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">char</span> *buf, <span class="type">size_t</span> fixed_len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (total &lt; fixed_len) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buf + total, fixed_len - total, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> n;  <span class="comment">// 错误或连接关闭</span></span><br><span class="line">        total += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li class="lvl-5"><p>**长度前缀:**先读长度字段，再读对应数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">recv_with_header</span><span class="params">(<span class="type">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> net_len;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv_fixed</span>(sockfd, (<span class="type">char</span>*)&amp;net_len, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">ntohl</span>(net_len);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">data</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="built_in">recv_fixed</span>(sockfd, data.<span class="built_in">data</span>(), len);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li class="lvl-5"><p><strong>分隔符</strong>：如<code>\r\n</code>（HTTP 头部方式）。</p></li></ol></li><li class="lvl-2"><p><strong>循环读写</strong>：<code>send</code>/<code>recv</code>可能不一次性处理全部数据，需循环调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send_all</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> total_sent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (total_sent &lt; len) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> sent = <span class="built_in">send</span>(sockfd, (<span class="type">char</span>*)buf + total_sent, len - total_sent, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sent == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        total_sent += sent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_sent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-连接异常处理">3. 连接异常处理</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>半关闭</strong>：对方<code>shutdown(SHUT_WR)</code>后，<code>recv</code>返回 0（可继续发送数据）。</p></li><li class="lvl-2"><p><strong>重置连接</strong>：<code>recv</code>返回 - 1 且<code>errno=ECONNRESET</code>，需关闭 socket 并重连。</p></li><li class="lvl-2"><p><strong>超时设置:</strong>  通过<code>SO_RCVTIMEO</code>/<code>SO_SNDTIMEO</code>设置读写超时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> timeout = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;;  <span class="comment">// 5秒超时</span></span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, <span class="built_in">sizeof</span>(timeout));</span><br></pre></td></tr></table></figure></li></ul><h3 id="三、UDP-数据读写（无连接的数据包）">三、UDP 数据读写（无连接的数据包）</h3><p>UDP 是不可靠的无连接协议，数据有边界（一次发送对应一次接收），无需建立连接。</p><h4 id="1-核心读写函数-2">1. 核心读写函数</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>发送：<code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)</code></strong></p><ul class="lvl-2"><li class="lvl-4">参数：<code>sockfd</code>（UDP socket）、缓冲区、长度、标志、目标地址及长度。</li><li class="lvl-4">返回值：成功返回发送字节数（等于<code>len</code>）；失败返回 - 1。</li></ul></li><li class="lvl-2"><p><strong>接收：<code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)</code></strong></p><ul class="lvl-2"><li class="lvl-4">参数：<code>sockfd</code>、接收缓冲区、长度、标志、发送方地址（输出）及长度（输入输出）。</li><li class="lvl-4">返回值：接收字节数（≤<code>len</code>）；失败返回 - 1。</li></ul></li></ul><h4 id="2-关键特性与实现-2">2. 关键特性与实现</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>数据报边界</strong>：一次<code>sendto</code>的数据可被<code>recvfrom</code>完整接收（缓冲区足够时）。</p></li><li class="lvl-2"><p><strong>长度限制</strong>：超过 MTU（通常 1500 字节）会分片，建议单包≤1472 字节（1500-20IP 头 - 8UDP 头）。</p></li><li class="lvl-2"><p>截断检测：<code>MSG_TRUNC</code>标志可检测数据是否被截断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(addr);</span><br><span class="line"><span class="type">ssize_t</span> n = <span class="built_in">recvfrom</span>(sockfd, buf, len, MSG_TRUNC, &amp;addr, &amp;addrlen);</span><br><span class="line"><span class="keyword">if</span> (n == len &amp;&amp; (flags &amp; MSG_TRUNC)) &#123; <span class="comment">/* 数据被截断 */</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-连接化-UDP（Connected-UDP）">3. 连接化 UDP（Connected UDP）</h4><p>通过<code>connect</code>绑定固定目标地址后，可使用<code>send</code>/<code>recv</code>简化操作（仍为 UDP 特性）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> dest_addr;</span><br><span class="line"><span class="comment">// 初始化目标地址...</span></span><br><span class="line"><span class="built_in">connect</span>(udp_sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;dest_addr, <span class="built_in">sizeof</span>(dest_addr));</span><br><span class="line"><span class="built_in">send</span>(udp_sockfd, buf, len, <span class="number">0</span>);  <span class="comment">// 无需重复指定地址</span></span><br></pre></td></tr></table></figure><h4 id="4-可靠性增强">4. 可靠性增强</h4><p>UDP 本身不可靠，需应用层补充机制：</p><ul class="lvl-0"><li class="lvl-2"><p>序号与确认（重传超时未确认的包）</p></li><li class="lvl-2"><p>校验和（检测数据损坏）</p></li><li class="lvl-2"><p>流量控制（避免接收方溢出）</p></li></ul><h3 id="四、高级函数与性能优化">四、高级函数与性能优化</h3><ul class="lvl-0"><li class="lvl-2"><p><strong><code>ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)</code></strong>：支持分散发送（多个缓冲区数据合并发送），适合发送复杂数据结构。</p></li><li class="lvl-2"><p><strong><code>ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags)</code></strong>：支持聚集接收（将数据分散到多个缓冲区），常用于接收带辅助数据（如控制信息）的数据包。</p></li><li class="lvl-2"><p><strong><code>ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)</code></strong>（Linux）：零拷贝发送文件，直接从文件描述符<code>in_fd</code>发送到<code>socket</code>（<code>out_fd</code>），减少用户态与内核态拷贝，效率极高。</p></li></ul><p><strong>性能优化</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>TCP：禁用 Nagle 算法（<code>TCP_NODELAY</code>）减少延迟；增大缓冲区（<code>SO_SNDBUF</code>/<code>SO_RCVBUF</code>）提高吞吐量。</p></li><li class="lvl-2"><p>UDP：避免碎片化；批量发送减少系统调用。</p></li><li class="lvl-2"><p>IO 模型：高并发场景使用非阻塞 IO+<code>epoll</code>（Linux）/<code>kqueue</code>（BSD）。</p></li></ul><h3 id="五、跨平台兼容性">五、跨平台兼容性</h3><ul class="lvl-0"><li class="lvl-2"><p>Windows 需初始化套接字库（<code>WSAStartup</code>），Linux 无需。</p></li><li class="lvl-2"><p>错误处理：Windows 用<code>WSAGetLastError()</code>，Linux 用<code>errno</code>。</p></li><li class="lvl-2"><p>关闭 socket：Windows 用<code>closesocket</code>，Linux 用<code>close</code>。</p></li></ul><p><strong>兼容代码示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> close closesocket</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_last_error</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WSAGetLastError</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> errno;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>TCP</strong>：用<code>send</code>/<code>recv</code>，面向连接，需处理字节流无边界问题，适合可靠传输（如 HTTP）。</p></li><li class="lvl-2"><p><strong>UDP</strong>：用<code>sendto</code>/<code>recvfrom</code>，无连接，保留数据报边界，适合实时场景（如视频流）。</p></li><li class="lvl-2"><p>通用基础：字节序转换、序列化、缓冲区管理和错误处理是核心前提。</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://wangmc1024.github.io/categories/C/">C++</category>
      
      
      <category domain="https://wangmc1024.github.io/tags/C/">C++</category>
      
      
      <comments>https://wangmc1024.github.io/2025/07/28/TCP,UDP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E5%9F%BA%E7%A1%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>linux管道(pipe)系统调用</title>
      <link>https://wangmc1024.github.io/2025/07/12/pipe()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <guid>https://wangmc1024.github.io/2025/07/12/pipe()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid>
      <pubDate>Sat, 12 Jul 2025 10:30:00 GMT</pubDate>
      
      <description>&lt;p&gt;如何使用 C++ 在 Linux 环境下进行管道(pipe)系统调用&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如何使用 C++ 在 Linux 环境下进行管道(pipe)系统调用</p> <span id="more"></span><h1>pipe() 系统调用</h1><p>在 Linux 系统编程中，<code>pipe()</code> 是一个系统调用，用于创建一个<strong>匿名管道</strong>，实现同一进程或父子进程间的单向通信。管道有两个文件描述符：一个用于读取（读端），一个用于写入（写端）。</p><h3 id="pipe-函数原型"><code>pipe()</code> 函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>pipefd是一个包含两个整数的数组，用于存储管道的文件描述符</p><ul class="lvl-2"><li class="lvl-4"><code>pipefd[0]</code>：管道的<strong>读端</strong>，用于读取数据</li><li class="lvl-4"><code>pipefd[1]</code>：管道的<strong>写端</strong>，用于写入数据</li></ul></li><li class="lvl-2"><p>返回值：成功返回 0，失败返回 -1 并设置 <code>errno</code></p></li></ul><h3 id="使用步骤">使用步骤</h3><ol><li class="lvl-3"><p>创建管道：调用 <code>pipe()</code> 函数</p></li><li class="lvl-3"><p>创建子进程：使用 <code>fork()</code> 创建子进程（管道通常用于父子进程间通信）</p></li><li class="lvl-3"><p>关闭不需要的端：</p><ul class="lvl-2"><li class="lvl-5">父进程关闭读端（<code>pipefd[0]</code>），只写</li><li class="lvl-5">子进程关闭写端（<code>pipefd[1]</code>），只读（或根据需求调整，如父进程读、子进程写）</li></ul></li><li class="lvl-3"><p>通信：通过 <code>write()</code> 写入数据，<code>read()</code> 读取数据</p></li><li class="lvl-3"><p>关闭管道：通信完成后关闭所有文件描述符</p></li></ol><h3 id="示例代码">示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;管道创建失败: &quot;</span> &lt;&lt; std::<span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;进程创建失败: &quot;</span> &lt;&lt; std::<span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 子进程：读数据</span></span><br><span class="line">        <span class="comment">// 3. 关闭子进程不需要的写端</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 从管道读取数据</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;读取失败: &quot;</span> &lt;&lt; std::<span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        buf[n] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子进程收到: &quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭读端</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程：写数据</span></span><br><span class="line">        <span class="comment">// 3. 关闭父进程不需要的读端</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 向管道写入数据</span></span><br><span class="line">        std::string msg = <span class="string">&quot;Hello from parent!&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(pipefd[<span class="number">1</span>], msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>()) == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;写入失败: &quot;</span> &lt;&lt; std::<span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭写端（触发子进程的read()返回0）</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代码说明">代码说明</h3><ol><li class="lvl-3"><p><strong>管道创建</strong>：<code>pipe(pipefd)</code> 成功后，<code>pipefd[0]</code> 和 <code>pipefd[1]</code> 分别代表读端和写端</p></li><li class="lvl-3"><p>进程通信</p><ul class="lvl-2"><li class="lvl-5">父进程通过 <code>write(pipefd[1], ...)</code> 向管道写入数据</li><li class="lvl-5">子进程通过 <code>read(pipefd[0], ...)</code> 从管道读取数据</li></ul></li><li class="lvl-3"><p>关闭端的重要性</p><ul class="lvl-2"><li class="lvl-5">不使用的端必须关闭，否则可能导致 <code>read()</code> 阻塞（等待数据）</li><li class="lvl-5">所有写端关闭后，<code>read()</code> 会返回 0（表示数据结束）</li></ul></li><li class="lvl-3"><p><strong>单向性</strong>：管道是单向的，数据只能从写端流向读端</p></li></ol><h3 id="核心原则：按需保留，及时关闭，全量清理">核心原则：<strong>按需保留，及时关闭，全量清理</strong></h3><ol><li class="lvl-3"><p><strong>“先关闭，后通信” 的原则</strong>：进程创建后（如 <code>fork()</code> 后），应立即关闭不需要的端，再进行读写操作。例如：</p><ul class="lvl-2"><li class="lvl-5">父进程若负责写数据，应先关闭读端（<code>pipefd[0]</code>），仅保留写端（<code>pipefd[1]</code>）；</li><li class="lvl-5">子进程若负责读数据，应先关闭写端（<code>pipefd[1]</code>），仅保留读端（<code>pipefd[0]</code>）。避免因 “未及时关闭” 导致的意外数据交互（如子进程误写数据到本应关闭的写端）。</li></ul></li><li class="lvl-3"><p><strong>写端关闭的 “触发信号” 作用</strong>：写端完成数据发送后，<strong>必须主动关闭写端</strong>，这是告知读端 “数据已发送完毕” 的唯一方式。读端通过 <code>read()</code> 返回 0 感知 “所有写端已关闭”，从而正常退出读取逻辑。</p><ul class="lvl-2"><li class="lvl-5">反例：若父进程写完数据后未关闭写端，子进程的 <code>read()</code> 会一直阻塞（等待更多数据），导致子进程无法退出。</li></ul></li><li class="lvl-3"><p><strong>多进程协作时的 “全关闭” 检查</strong>：若多个进程共享同一管道的写端（如父进程和多个子进程都向管道写数据），<strong>必须确保所有写端都关闭后，读端才能收到 EOF（<code>read()</code> 返回 0）</strong>。</p><ul class="lvl-2"><li class="lvl-5">需通过进程同步（如 <code>waitpid</code>）确保所有写进程都已关闭写端，避免读端提前退出或阻塞。</li></ul></li></ol>]]></content:encoded>
      
      
      <category domain="https://wangmc1024.github.io/categories/C/">C++</category>
      
      
      <category domain="https://wangmc1024.github.io/tags/C/">C++</category>
      
      
      <comments>https://wangmc1024.github.io/2025/07/12/pipe()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>linux文件操作</title>
      <link>https://wangmc1024.github.io/2025/07/12/open()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <guid>https://wangmc1024.github.io/2025/07/12/open()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid>
      <pubDate>Sat, 12 Jul 2025 10:25:00 GMT</pubDate>
      
      <description>&lt;p&gt;如何使用 C++ 在 Linux 环境下进行文件操作&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如何使用 C++ 在 Linux 环境下进行文件操作</p><span id="more"></span><h3 id="一、open-系统调用（Unix-Linux）"><strong>一、<code>open()</code> 系统调用（Unix/Linux）</strong></h3><h4 id="1-核心知识点回顾"><strong>1. 核心知识点回顾</strong></h4><ul class="lvl-0"><li class="lvl-2"><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>    <span class="comment">// 定义 O_RDONLY、O_WRONLY 等标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  <span class="comment">// 定义 mode_t 类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>   <span class="comment">// 定义文件权限宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>参数</p><ul class="lvl-2"><li class="lvl-4"><code>pathname</code>：要打开或创建的文件路径（绝对或相对路径）</li><li class="lvl-4"><code>flags</code>：必选标志，只能选其一（<code>O_RDONLY</code>/<code>O_WRONLY</code>/<code>O_RDWR</code>）和可选标志（<code>O_CREAT</code>、<code>O_EXCL</code>、<code>O_APPEND</code>、<code>O_TRUNC</code> 等）。</li><li class="lvl-4"><code>mode</code>：当使用 <code>O_CREAT</code> 标志时需指定权限。创建文件时的权限（如 <code>0644</code>）。</li></ul></li><li class="lvl-2"><p><strong>返回值</strong>：文件描述符（整数）或 <code>-1</code>（失败）。</p></li><li class="lvl-2"><p><strong>特点</strong>：无缓冲的底层操作，适合设备驱动、非阻塞 I/O 等场景。</p></li></ul><h4 id="2-关键标志位"><strong>2. 关键标志位</strong></h4><table><thead><tr><th>标志</th><th>功能描述</th></tr></thead><tbody><tr><td><code>O_CREAT</code></td><td>文件不存在时创建</td></tr><tr><td><code>O_EXCL</code></td><td>与 <code>O_CREAT</code> 联用，文件存在则报错</td></tr><tr><td><code>O_TRUNC</code></td><td>打开时截断文件</td></tr><tr><td><code>O_APPEND</code></td><td>追加模式</td></tr><tr><td><code>O_NONBLOCK</code></td><td>非阻塞模式</td></tr></tbody></table><h4 id="3-错误处理"><strong>3. 错误处理</strong></h4><p><code>open()</code> 失败时会设置 <code>errno</code>，常见错误码：</p><ul class="lvl-0"><li class="lvl-2"><p><code>ENOENT</code>：路径不存在（无 <code>O_CREAT</code> 标志时）。</p></li><li class="lvl-2"><p><code>EACCES</code>：权限不足（如尝试写入只读文件）。</p></li><li class="lvl-2"><p><code>EEXIST</code>：文件已存在（使用 <code>O_CREAT | O_EXCL</code> 时）。</p></li><li class="lvl-2"><p><code>EISDIR</code>：路径是目录而非文件。</p></li></ul><h4 id="4-相关系统调用"><strong>4. 相关系统调用</strong></h4><ul class="lvl-0"><li class="lvl-2"><p><code>close(int fd)</code>：关闭文件描述符。</p></li><li class="lvl-2"><p><code>read(int fd, void *buf, size_t count)</code>：从文件读取数据。</p></li><li class="lvl-2"><p><code>write(int fd, const void *buf, size_t count)</code>：向文件写入数据。</p></li><li class="lvl-2"><p><code>lseek(int fd, off_t offset, int whence)</code>：移动文件读写位置。</p></li><li class="lvl-2"><p><code>creat(const char *pathname, mode_t mode)</code>：等价于 <code>open(pathname, O_CREAT | O_WRONLY | O_TRUNC, mode)</code>。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件（不存在则创建，存在则截断）</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDWR | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;Hello, open()!\n&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_written = <span class="built_in">write</span>(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动文件指针到开头</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;lseek failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 确保字符串以 &#x27;\0&#x27; 结尾</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read: %s&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">close</span>(fd);  <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、C-标准库中的文件操作"><strong>二、C++ 标准库中的文件操作</strong></h3><p>C++ 提供了更高级的文件流类，基于对象和异常处理，避免了直接使用系统调用的复杂性。</p><h4 id="1-fstream-库（推荐方案）"><strong>1. <code>&lt;fstream&gt;</code> 库（推荐方案）</strong></h4><ul class="lvl-0"><li class="lvl-2"><p>主要类</p><ul class="lvl-2"><li class="lvl-4"><code>std::ifstream</code>：输入文件流（只读）。</li><li class="lvl-4"><code>std::ofstream</code>：输出文件流（只写）。</li><li class="lvl-4"><code>std::fstream</code>：输入 / 输出文件流（读写）。</li></ul></li></ul><p><strong>示例：打开文件并读写</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件（不存在则创建，存在则截断）</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, std::ios::out | std::ios::trunc)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!outfile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    outfile &lt;&lt; <span class="string">&quot;Hello, C++ file stream!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">if</span> (infile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">getline</span>(infile, line)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Read: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        infile.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-文件打开模式（std-ios-base-openmode）"><strong>2. 文件打开模式（<code>std::ios_base::openmode</code>）</strong></h4><table><thead><tr><th>模式</th><th>功能描述</th></tr></thead><tbody><tr><td><code>std::ios::in</code></td><td>输入模式（读取）</td></tr><tr><td><code>std::ios::out</code></td><td>输出模式（写入，默认截断文件）</td></tr><tr><td><code>std::ios::app</code></td><td>追加模式（写入到文件末尾）</td></tr><tr><td><code>std::ios::ate</code></td><td>打开后定位到文件末尾</td></tr><tr><td><code>std::ios::trunc</code></td><td>打开时截断文件（若已存在）</td></tr><tr><td><code>std::ios::binary</code></td><td>二进制模式（避免文本模式转换）</td></tr></tbody></table><h3 id="三、C-17-及以后的文件系统库（-filesystem-）"><strong>三、C++17 及以后的文件系统库（<code>&lt;filesystem&gt;</code>）</strong></h3><p>C++17 引入了更现代化的文件系统操作 API，提供路径处理、文件状态检查等功能。</p><h4 id="1-文件操作示例"><strong>1. 文件操作示例</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fs::path filePath = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件并写入</span></span><br><span class="line">    <span class="keyword">if</span> (std::ofstream <span class="built_in">file</span>(filePath); file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        file &lt;&lt; <span class="string">&quot;Hello, C++17 filesystem!&quot;</span>;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件状态</span></span><br><span class="line">    <span class="keyword">if</span> (fs::<span class="built_in">exists</span>(filePath)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File size: &quot;</span> &lt;&lt; fs::<span class="built_in">file_size</span>(filePath) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        fs::<span class="built_in">remove</span>(filePath);  <span class="comment">// 删除文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-优势"><strong>2. 优势</strong></h4><ul class="lvl-0"><li class="lvl-2"><p><strong>跨平台</strong>：自动处理不同操作系统的路径分隔符（如 <code>/</code> 和 <code>\</code>）。</p></li><li class="lvl-2"><p><strong>异常安全</strong>：使用 RAII 管理资源，避免手动关闭文件。</p></li><li class="lvl-2"><p><strong>功能丰富</strong>：支持文件遍历、权限管理、硬链接操作等。</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://wangmc1024.github.io/categories/C/">C++</category>
      
      
      <category domain="https://wangmc1024.github.io/tags/C/">C++</category>
      
      
      <comments>https://wangmc1024.github.io/2025/07/12/open()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>GDB的使用及常用命令</title>
      <link>https://wangmc1024.github.io/2025/07/12/GDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <guid>https://wangmc1024.github.io/2025/07/12/GDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Sat, 12 Jul 2025 10:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;如何使用 GDB 调试 C/C++ 程序及常用命令详解&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如何使用 GDB 调试 C/C++ 程序及常用命令详解</p> <span id="more"></span><p>GDB（GNU Debugger）是一款功能强大的命令行调试工具，主要用于调试 C、C++、Fortran 等编译型语言的程序。它支持断点设置、变量查看、单步执行、内存检查等核心调试功能，在程序开发、故障定位（如崩溃、逻辑错误）等场景中不可或缺。以下结合不同使用场景、常用命令、注意事项及扩展知识点进行详细介绍。</p><h3 id="一、GDB-在不同场景下的使用方法及常用命令">一、GDB 在不同场景下的使用方法及常用命令</h3><h4 id="场景-1：基础程序调试（单进程、无复杂逻辑）">场景 1：基础程序调试（单进程、无复杂逻辑）</h4><p>适用于调试简单的单文件程序，定位语法外的逻辑错误（如变量计算错误、循环异常等）。</p><p><strong>核心流程与命令：</strong></p><ol><li class="lvl-3"><p><strong>编译带调试信息的程序</strong><br>必须在编译时添加<code>-g</code>选项（生成调试符号，包含变量名、行号等信息），否则 GDB 无法正常调试。示例：<code>gcc -g -o test test.c</code>（C 程序）；<code>g++ -g -o test test.cpp</code>（C++ 程序）。</p></li><li class="lvl-3"><p><strong>启动 GDB</strong></p><ul class="lvl-2"><li class="lvl-5">命令：<code>gdb ./test</code>（直接启动调试）；或<code>gdb -q ./test</code>（安静模式，不显示 GDB 版本信息）。</li><li class="lvl-5">退出 GDB：<code>quit</code>（缩写<code>q</code>）。</li><li class="lvl-5">查看命令帮助：<code>help &lt;命令&gt;</code>（缩写<code>h</code>），如<code>help break</code>可查看断点命令说明。</li></ul></li><li class="lvl-3"><p><strong>查看源代码</strong></p><ul class="lvl-2"><li class="lvl-5"><code>list &lt;位置&gt;</code>（缩写<code>l</code>）：显示指定位置的源代码，如<code>l 10</code>显示第 10 行附近代码，<code>l main</code>显示 main 函数代码，默认每次显示 10 行。</li><li class="lvl-5"><code>list &lt;start&gt;,&lt;end&gt;</code>：显示从 start 到 end 的源代码，如<code>l 5,20</code>显示 5-20 行。</li><li class="lvl-5"><code>show listsize</code>：查看<code>list</code>命令每次显示的行数（默认 10 行）；<code>set listsize &lt;N&gt;</code>：设置每次显示 N 行，如<code>set listsize 20</code>。</li></ul></li><li class="lvl-3"><p><strong>设置断点</strong><br>断点是调试的核心，用于在指定位置暂停程序执行。</p><ul class="lvl-2"><li class="lvl-5"><p>基础断点：<code>break 位置</code>（缩写<code>b</code>），位置支持行号（<code>b 10</code>）、文件名 + 行号（<code>b test.c:20</code>）、函数名（<code>b main</code>）、地址（<code>b *0x400520</code>）。</p></li><li class="lvl-5"><p>临时断点：<code>tbreak 位置</code>（缩写<code>tb</code>），触发一次后自动删除。</p></li><li class="lvl-5"><p>条件断点：<code>break 位置 if 条件</code>，仅当条件满足时中断，如<code>break test.c:20 if i == 10</code>。</p></li><li class="lvl-5"><p>断点触发后自动执行命令：<code>break 位置 command &lt;命令序列&gt; end</code>, 如在 test.c:10 设置断点后，自动打印 i 和调用栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b test.c:10</span><br><span class="line">command</span><br><span class="line">p i</span><br><span class="line">bt</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul></li><li class="lvl-3"><p><strong>断点管理</strong></p><ul class="lvl-2"><li class="lvl-5">查看断点：<code>info breakpoints</code>（缩写<code>info b</code>），显示所有断点编号、状态、命中次数等。</li><li class="lvl-5">删除断点：<code>delete 断点编号</code>（缩写<code>d</code>），如<code>d 1</code>删除编号 1 的断点；<code>d</code>不带参数删除所有。</li><li class="lvl-5">禁用 / 启用断点：<code>disable 断点编号</code>（缩写<code>dis</code>）、<code>enable 断点编号</code>（缩写<code>en</code>）；<code>enable once 断点编号</code>仅生效一次。</li><li class="lvl-5">清除指定位置断点：<code>clear &lt;位置&gt;</code>，如<code>clear main</code>删除 main 函数入口的断点。</li></ul></li><li class="lvl-3"><p><strong>运行程序</strong></p><ul class="lvl-2"><li class="lvl-5">启动程序：<code>run [参数]</code>（缩写<code>r</code>），如<code>run 10 20</code>传递命令行参数。</li><li class="lvl-5">启动并在 main 函数第一行中断：<code>start</code>。</li><li class="lvl-5">程序中断后继续执行：<code>continue</code>（缩写<code>c</code>），执行到下一个断点。</li></ul></li><li class="lvl-3"><p><strong>单步执行</strong></p><ul class="lvl-2"><li class="lvl-5"><code>next</code>（缩写<code>n</code>）：执行当前行，<strong>不进入函数调用</strong>。</li><li class="lvl-5"><code>step</code>（缩写<code>s</code>）：执行当前行，<strong>进入函数调用</strong>。</li><li class="lvl-5">按汇编指令单步：<code>nexti</code>（<code>ni</code>）、<code>stepi</code>（<code>si</code>），分别对应不进入和进入函数的汇编级执行。</li><li class="lvl-5">跳出当前函数：<code>finish</code>，执行完当前函数并返回到调用处。</li><li class="lvl-5">执行到指定行：<code>until &lt;行号&gt;</code>（缩写<code>u</code>），适合快速跳过循环。</li></ul></li><li class="lvl-3"><p><strong>查看 / 修改变量</strong></p><ul class="lvl-2"><li class="lvl-5">查看变量 / 表达式：<code>print 变量/表达式</code>（缩写<code>p</code>），如<code>p a + b</code>；按格式打印（<code>x</code>十六进制、<code>d</code>十进制等）：<code>p /x num</code>。</li><li class="lvl-5">打印数组：<code>print *数组名@长度</code>，如<code>p *arr@5</code>打印数组前 5 个元素。</li><li class="lvl-5">修改变量：<code>set variable 变量名=值</code>（缩写<code>set var</code>），如<code>set var i=5</code>。</li><li class="lvl-5">自动显示变量：<code>display 变量名</code>（缩写<code>disp</code>），程序每次中断时自动打印；<code>undisplay 编号</code>取消。</li><li class="lvl-5">查看局部变量：<code>info locals</code>；查看函数参数：<code>info args</code>。</li><li class="lvl-5">查看变量类型：<code>whatis 变量</code>（如<code>whatis ptr</code>）；查看详细类型定义：<code>ptype 变量/类型</code>（如<code>ptype struct Student</code>）。</li></ul></li><li class="lvl-3"><p><strong>查看调用栈</strong></p><ul class="lvl-2"><li class="lvl-5"><code>backtrace</code>（缩写<code>bt</code>）：查看函数调用链；<code>bt N</code>显示前 N 层，<code>bt -N</code>显示后 N 层。</li><li class="lvl-5">切换栈帧：<code>frame N</code>（缩写<code>f N</code>），查看第 N 层栈的局部变量；<code>up &lt;N&gt;</code>、<code>down &lt;N&gt;</code>上下移动栈帧。</li><li class="lvl-5">查看当前栈帧详情：<code>info frame</code>（缩写<code>info f</code>）。</li></ul></li></ol><h4 id="场景-2：多线程程序调试">场景 2：多线程程序调试</h4><p>多线程程序易出现竞态条件、死锁等问题，GDB 提供专门的多线程调试命令。</p><p><strong>核心命令：</strong></p><ol><li class="lvl-3"><p><strong>查看线程信息</strong>：<code>info threads</code>，显示所有线程编号、状态、当前执行位置（<code>*</code>标记当前线程）。</p></li><li class="lvl-3"><p><strong>切换线程</strong>：<code>thread 线程编号</code>，如<code>thread 2</code>切换到线程 2。</p></li><li class="lvl-3"><p><strong>对线程执行命令</strong>：<code>thread apply &lt;线程号&gt; &lt;命令&gt;</code>，如<code>thread apply 2 bt</code>打印线程 2 的调用栈；<code>thread apply all bt</code>打印所有线程栈。</p></li><li class="lvl-3"><p>控制线程调度：<code>set scheduler-locking [on|off|step]</code></p><ul class="lvl-2"><li class="lvl-5"><code>on</code>：仅当前线程执行，其他线程暂停（避免干扰）；</li><li class="lvl-5"><code>off</code>：所有线程正常调度（默认）；</li><li class="lvl-5"><code>step</code>：单步执行时仅当前线程移动。</li></ul></li></ol><h4 id="场景-3：程序崩溃定位（Core-Dump-调试）">场景 3：程序崩溃定位（Core Dump 调试）</h4><p>当程序因内存错误（如段错误）崩溃时，可生成<code>core</code>文件（内存转储），通过 GDB 分析崩溃原因。</p><p><strong>核心流程：</strong></p><ol><li class="lvl-3"><p><strong>开启 Core Dump 功能</strong></p><ul class="lvl-2"><li class="lvl-5">临时开启：<code>ulimit -c unlimited</code>（当前终端有效）；</li><li class="lvl-5">永久开启：修改<code>/etc/security/limits.conf</code>，添加<code>* soft core unlimited</code>（需重启）。</li></ul></li><li class="lvl-3"><p><strong>生成并分析 core 文件</strong><br>程序崩溃后生成<code>core.PID</code>文件，用 GDB 加载：<code>gdb ./程序名 core文件</code>（如<code>gdb ./test core.12345</code>）。加载后执行<code>backtrace</code>（<code>bt</code>），查看崩溃时的调用栈，定位崩溃位置。</p><ul class="lvl-2"><li class="lvl-5">补充命令：<code>core-file &lt;core文件&gt;</code>，在 GDB 交互界面中加载 core 文件。</li></ul></li></ol><h4 id="场景-4：远程调试（如嵌入式设备、服务器程序）">场景 4：远程调试（如嵌入式设备、服务器程序）</h4><p>适用于调试运行在远程设备上的程序，本地通过 GDB 连接远程进程。</p><p><strong>核心流程：</strong></p><ol><li class="lvl-3"><p><strong>远程端启动 GDB Server</strong><br>远程设备安装<code>gdbserver</code>，启动命令：<code>gdbserver 远程IP:端口 程序名</code>（如<code>gdbserver 192.168.1.100:1234 ./test</code>）。</p></li><li class="lvl-3"><p><strong>本地 GDB 连接远程</strong><br>本地启动 GDB：<code>gdb ./test</code>，执行<code>target remote 远程IP:端口</code>（如<code>target remote 192.168.1.100:1234</code>），连接后即可像调试本地程序一样操作。</p></li></ol><h4 id="场景-5：内存与寄存器调试">场景 5：内存与寄存器调试</h4><p>用于直接检查内存数据或 CPU 寄存器状态，适合调试内存错误（如越界、野指针）。</p><p><strong>核心命令：</strong></p><ol><li class="lvl-3"><p><strong>查看内存</strong>：<code>x/&lt;n&gt;&lt;f&gt;&lt;u&gt; 地址</code>（<code>x</code>即 examine）</p><ul class="lvl-2"><li class="lvl-5"><code>n</code>：单元数；<code>f</code>：格式（x/d/u/o/t/c/f）；<code>u</code>：单元大小（b/h/w/g）。</li><li class="lvl-5">示例：<code>x/10xw 0x7fffffffde40</code>（以 16 进制显示 10 个 4 字节单元）；<code>x/s 地址</code>以字符串格式查看。</li></ul></li><li class="lvl-3"><p><strong>查看寄存器</strong></p><ul class="lvl-2"><li class="lvl-5"><code>info registers</code>：显示所有通用寄存器；<code>info registers &lt;寄存器名&gt;</code>：显示指定寄存器（如<code>info registers rip</code>）。</li><li class="lvl-5">修改寄存器：<code>set $&lt;寄存器&gt;=&lt;值&gt;</code>，如<code>set $rip=0x400520</code>（谨慎使用）。</li></ul></li></ol><h4 id="场景-6：多进程调试">场景 6：多进程调试</h4><p>针对<code>fork()</code>创建的多进程程序，控制跟踪父进程或子进程。</p><p><strong>核心命令：</strong></p><ol><li class="lvl-3"><p><code>set follow-fork-mode [parent|child]</code>：设置<code>fork()</code>后跟踪的进程（默认跟踪父进程）。</p></li><li class="lvl-3"><p><code>set detach-on-fork [on|off]</code>：设置是否分离未跟踪的进程（默认分离，未跟踪进程继续运行）。</p></li><li class="lvl-3"><p><code>info inferiors</code>：显示所有进程信息；<code>inferior &lt;进程号&gt;</code>：切换到指定进程。</p></li></ol><h3 id="二、GDB-使用注意事项">二、GDB 使用注意事项</h3><ol><li class="lvl-3"><p><strong>编译必须带<code>-g</code>选项</strong><br>若未加<code>-g</code>，GDB 无法识别行号、变量名等调试信息，只能看到汇编代码，失去调试意义。</p></li><li class="lvl-3"><p><strong>避免高优化级别编译</strong><br>用<code>-O2</code>、<code>-O3</code>等优化选项编译时，编译器可能删除变量、重排代码，导致 GDB 无法查看变量或单步混乱。<strong>调试时建议用<code>-O0</code>（无优化）</strong>。</p></li><li class="lvl-3"><p><strong>处理信号时需谨慎</strong><br>程序可能收到信号（如<code>SIGINT</code>、<code>SIGSEGV</code>），默认 GDB 会捕获并中断。可通过<code>handle 信号 动作</code>设置：</p><ul class="lvl-2"><li class="lvl-5">如<code>handle SIGINT nostop</code>（收到<code>Ctrl+C</code>时不中断）；<code>handle SIGSEGV stop print</code>（段错误时中断并打印）。</li></ul></li><li class="lvl-3"><p><strong>区分<code>next</code>与<code>step</code></strong></p><ul class="lvl-2"><li class="lvl-5"><code>next</code>：不进入函数，适合快速跳过；<code>step</code>：进入函数，适合调试函数内部逻辑。新手易混淆导致效率低。</li></ul></li><li class="lvl-3"><p><strong>Core 文件的存储与清理</strong><br>core 文件可能很大（与程序内存占用一致），生产环境需限制大小（如<code>ulimit -c 1024</code>），并及时清理无用文件。</p></li><li class="lvl-3"><p><strong>远程调试需保持程序一致性</strong><br>本地与远程程序需为同一源码、同一编译选项编译，否则调试信息不匹配。</p></li></ol><h3 id="三、GDB-扩展知识点">三、GDB 扩展知识点</h3><h4 id="1-监视点（高级断点）">1. 监视点（高级断点）</h4><ul class="lvl-0"><li class="lvl-2"><p><code>watch 变量</code>：变量被<strong>修改</strong>时中断；</p></li><li class="lvl-2"><p><code>rwatch 变量</code>：变量被<strong>读取</strong>时中断；</p></li><li class="lvl-2"><p><code>awatch 变量</code>：变量被<strong>读取或修改</strong>时中断。示例：<code>watch count</code>，当<code>count</code>值变化时自动中断，无需手动设置断点。</p></li></ul><h4 id="2-GDB-脚本与自动化">2. GDB 脚本与自动化</h4><ul class="lvl-0"><li class="lvl-2"><p><strong><code>.gdbinit</code>配置文件</strong>：启动 GDB 时自动加载，可定义别名或自动执行命令。示例：在<code>~/.gdbinit</code>中添加<code>alias ll = info locals</code>（用<code>ll</code>快速查看局部变量）。</p></li><li class="lvl-2"><p>自定义命令：通过 <code>define</code> 命令名</p><p>定义批量操作，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define dbg</span><br><span class="line">  bt          # 打印调用栈</span><br><span class="line">  info locals # 打印局部变量</span><br><span class="line">  print i     # 打印变量i</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>执行<code>dbg</code>即可一次性执行上述命令。</p></li></ul><h4 id="3-宏调试">3. 宏调试</h4><p>C/C++ 宏在预处理阶段展开，默认 GDB 无法调试。需编译时添加<code>-ggdb3</code>（更详细调试信息）和<code>-fmacro-prefix-map=.=</code>（保留宏路径），然后：</p><ul class="lvl-0"><li class="lvl-2"><p><code>info macro 宏名</code>：查看宏定义；</p></li><li class="lvl-2"><p><code>macro expand 宏调用</code>：查看宏展开结果。</p></li></ul><h4 id="4-断点保存与恢复">4. 断点保存与恢复</h4><ul class="lvl-0"><li class="lvl-2"><p><code>save breakpoints &lt;文件&gt;</code>：将当前断点保存到文件（如<code>save breakpoints bps.txt</code>）；</p></li><li class="lvl-2"><p><code>source &lt;文件&gt;</code>：恢复断点（如<code>source bps.txt</code>）。</p></li></ul><h4 id="5-与-IDE-集成">5. 与 IDE 集成</h4><p>GDB 可与 VS Code、Clion 等 IDE 集成，通过图形界面操作（点击设置断点、单步），底层依赖 GDB 核心功能。以 VS Code 为例，需在<code>.vscode/launch.json</code>中配置<code>miDebuggerPath</code>为 GDB 路径。</p>]]></content:encoded>
      
      
      <category domain="https://wangmc1024.github.io/categories/C/">C++</category>
      
      
      <category domain="https://wangmc1024.github.io/tags/C/">C++</category>
      
      
      <comments>https://wangmc1024.github.io/2025/07/12/GDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://wangmc1024.github.io/2025/05/15/hello-world/</link>
      <guid>https://wangmc1024.github.io/2025/05/15/hello-world/</guid>
      <pubDate>Thu, 15 May 2025 15:58:56 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Welcome to my personal blog, this is the first attemp.&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Welcome to my personal blog, this is the first attemp.</p>]]></content:encoded>
      
      
      
      
      <comments>https://wangmc1024.github.io/2025/05/15/hello-world/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
