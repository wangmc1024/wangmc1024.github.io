<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/05/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to my personal blog, this is the first attemp.</p>
]]></content>
  </entry>
  <entry>
    <title>C++/Linux 创建daemon进程</title>
    <url>/2025/08/15/C++Linux%20%E5%88%9B%E5%BB%BAdaemon%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>如何使用 C++ 在 Linux 环境下创建一个守护进程</p>
<span id="more"></span>
<p>在 Linux 环境下，守护进程是一种在后台运行，不与任何终端关联，独立于控制终端并且周期性执行任务或等待处理某些事件的进程。以下是使用 C++ 编写将一个进程转换为守护进程的示例代码，并对关键步骤进行解释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于将当前进程转换为守护进程</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">daemonize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步：创建子进程，父进程退出</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;fork error: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程直接退出，让子进程继续执行</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时子进程成为新的会话组长和进程组长</span></span><br><span class="line">    <span class="comment">// 第二步：创建新会话</span></span><br><span class="line">    pid = <span class="built_in">setsid</span>();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;setsid error: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：改变工作目录</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;chdir error: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步：设置文件权限掩码</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第五步：关闭标准输入、输出和错误输出，并重新定向到/dev/null</span></span><br><span class="line">    <span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd != STDIN_FILENO) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dup2</span>(fd, STDOUT_FILENO) != STDOUT_FILENO) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dup2</span>(fd, STDERR_FILENO) != STDERR_FILENO) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; STDERR_FILENO) &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">daemonize</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Process has been daemonized successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 这里可以编写守护进程的具体任务逻辑，比如定时执行某些操作</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 模拟守护进程执行任务，这里简单睡眠10秒</span></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Daemon is working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to daemonize the process.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码解释">代码解释</h3>
<ol>
<li class="lvl-3">
<p><strong>创建子进程并退出父进程</strong>：使用 <code>fork()</code> 函数创建一个子进程。父进程调用 <code>exit(EXIT_SUCCESS)</code> 退出，这样子进程就不再是控制终端的前台进程，并且可以避免在父进程退出时，子进程成为孤儿进程而被 <code>init</code> 进程收养并受到不必要的终端控制。</p>
</li>
<li class="lvl-3">
<p><strong>创建新会话</strong>：调用 <code>setsid()</code> 函数，使子进程成为新会话的组长，同时也是新进程组的组长。这样做可以让守护进程脱离原会话的控制，并且不再有控制终端，从而实现后台独立运行。</p>
</li>
<li class="lvl-3">
<p><strong>改变工作目录</strong>：使用 <code>chdir(&quot;/&quot;)</code> 将当前工作目录更改为根目录 <code>/</code> 。这是为了防止守护进程长时间运行时，其工作目录所在的文件系统被卸载而导致进程出现异常。也可以根据实际需求将工作目录设置为其他合适的目录。</p>
</li>
<li class="lvl-3">
<p><strong>设置文件权限掩码</strong>：通过 <code>umask(0)</code> 将文件权限掩码设置为 0，这样守护进程在创建文件或目录时，可以完全按照指定的权限来创建，而不会受到默认掩码的影响。</p>
</li>
<li class="lvl-3">
<p><strong>关闭并重新定向标准文件描述符</strong>：守护进程不应该与终端有交互，所以关闭标准输入（<code>STDIN_FILENO</code>）、标准输出（<code>STDOUT_FILENO</code>）和标准错误输出（<code>STDERR_FILENO</code>），并将它们重新定向到 <code>/dev/null</code> 。<code>/dev/null</code> 是一个特殊的设备文件，写入它的数据会被丢弃，读取它会立即返回文件结束标志。</p>
</li>
</ol>
<h3 id="int-daemon-int-nochdir-int-noclose"><code>int daemon(int nochdir,int noclose)</code></h3>
<p><strong>nochdir:</strong> 用于指定是否改变当前的工作目录, 如果 为0 则将工作目录设置为根目录（”/“), 否则依旧使用当前目录作为工作目录</p>
<p><strong>noclose:</strong> 参数为0，则将标准输入输出和标准错误输出重定向至”/dev/null“文件</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket基础概念</title>
    <url>/2025/08/15/Socket%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>socket基础概念</p>
 <span id="more"></span>
<p>在网络编程中，<strong>Socket（套接字）</strong> 是进程间通信的抽象接口，用于实现不同主机或同一主机内不同进程之间的网络数据传输。它是 TCP/IP 协议栈的编程接口，现代 C++ 网络开发中依然是核心基础（尽管常被封装为更高层库如 Boost.Asio）。</p>
<h3 id="一、Socket-基础概念">一、Socket 基础概念</h3>
<ol>
<li class="lvl-3">
<p><strong>本质</strong>：Socket 是一个 “文件描述符”（Linux/Unix）或 “句柄”（Windows），代表一个网络通信端点，通过它可进行数据的发送 / 接收。</p>
</li>
<li class="lvl-3">
<p><strong>分类</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>流式套接字（SOCK_STREAM）</strong>：基于 TCP 协议，提供可靠、有序、双向的字节流传输（无数据丢失 / 重复，适合文件传输、HTTP 等）。</li>
<li class="lvl-5"><strong>数据报套接字（SOCK_DGRAM）</strong>：基于 UDP 协议，提供无连接、不可靠的数据包传输（速度快，适合视频通话、DNS 等）。</li>
<li class="lvl-5"><strong>原始套接字（SOCK_RAW）</strong>：直接操作底层协议（如 IP），用于网络诊断或自定义协议（需管理员权限）。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>通信模型</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">TCP 采用 “客户端 - 服务器” 模型，需先建立连接（三次握手），再传输数据。</li>
<li class="lvl-5">UDP 无连接，直接发送数据包，无需提前建立连接。</li>
</ul>
</li>
</ol>
<h3 id="二、核心函数解析（基于-TCP，现代-C-视角）">二、核心函数解析（基于 TCP，现代 C++ 视角）</h3>
<p>以下函数是 TCP 通信的核心，主要用于服务器端和客户端的连接建立过程。</p>
<h4 id="1-socket-：创建套接字">1. <code>socket()</code>：创建套接字</h4>
<p><strong>作用</strong>：初始化一个套接字，返回其描述符（后续操作的句柄）。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数解析</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>domain</code>：地址族（协议族），指定网络层协议。常见值：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>AF_INET</code>：IPv4 协议（最常用）。</li>
<li class="lvl-4"><code>AF_INET6</code>：IPv6 协议。</li>
<li class="lvl-4"><code>AF_UNIX</code>：本地进程间通信（Unix 域套接字）。</li>
</ul>
</li>
<li class="lvl-2">
<p><code>type</code>：套接字类型，指定传输层协议特性：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>SOCK_STREAM</code>：TCP 流式套接字。</li>
<li class="lvl-4"><code>SOCK_DGRAM</code>：UDP 数据报套接字。</li>
</ul>
</li>
<li class="lvl-2">
<p><code>protocol</code>：具体协议（通常为 0，由系统根据前两个参数自动选择）。</p>
</li>
</ul>
<p><strong>返回值</strong>：成功返回非负套接字描述符（<code>sockfd</code>），失败返回 - 1（需检查<code>errno</code>）。</p>
<p><strong>现代 C++ 实践</strong>：用智能指针（如<code>std::unique_ptr</code>）配合自定义删除器管理<code>sockfd</code>，避免资源泄漏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义删除器：关闭套接字</span></span><br><span class="line"><span class="keyword">auto</span> socket_deleter = [](<span class="type">int</span> fd) &#123; </span><br><span class="line">  <span class="keyword">if</span> (fd != <span class="number">-1</span>) ::<span class="built_in">close</span>(fd); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> UniqueSocket = std::unique_ptr&lt;<span class="type">int</span>, <span class="keyword">decltype</span>(socket_deleter)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line"><span class="function">UniqueSocket <span class="title">create_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;socket creation failed: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UniqueSocket</span>(<span class="keyword">new</span> <span class="built_in">int</span>(sockfd), socket_deleter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-bind-：绑定地址与端口">2. <code>bind()</code>：绑定地址与端口</h4>
<p><strong>作用</strong>：将套接字与特定的 IP 地址和端口号绑定（主要用于服务器端，客户端通常不绑定，由系统自动分配端口）。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数解析</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>sockfd</code>：<code>socket()</code>返回的套接字描述符。</p>
</li>
<li class="lvl-2">
<p><code>addr</code>：指向地址结构的指针（需根据<code>domain</code>选择对应类型，如 IPv4 用<code>sockaddr_in</code>）。</p>
</li>
<li class="lvl-2">
<p><code>addrlen</code>：地址结构的大小（字节数）。</p>
</li>
</ul>
<p><strong>地址结构处理</strong>（以 IPv4 为例）：<code>sockaddr</code>是通用地址结构，实际使用时需转换为具体协议的结构（如<code>sockaddr_in</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">  <span class="type">sa_family_t</span>     sin_family;  <span class="comment">// 地址族（必须为AF_INET）</span></span><br><span class="line">  <span class="type">uint16_t</span>        sin_port;    <span class="comment">// 端口号（需转换为网络字节序）</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">in_addr</span>  sin_addr;    <span class="comment">// IP地址（需转换为网络字节序）</span></span><br><span class="line">  <span class="type">char</span>            sin_zero[<span class="number">8</span>]; <span class="comment">// 填充字段（通常为0）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>字节序转换</strong>：网络协议使用<strong>大端字节序</strong>（网络字节序），而主机可能是小端 / 大端，需用函数转换：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>htons()</code>：主机字节序→网络字节序（16 位，用于端口）。</p>
</li>
<li class="lvl-2">
<p><code>htonl()</code>：主机字节序→网络字节序（32 位，用于 IPv4 地址）。</p>
</li>
<li class="lvl-2">
<p><code>inet_pton()</code>：字符串 IP（如 “127.0.0.1”）→网络字节序的整数（现代 C++ 推荐，替代旧的<code>inet_addr()</code>）。</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定到IPv4地址127.0.0.1:8080</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>); <span class="comment">// 端口转换为网络字节序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址转换（&quot;0.0.0.0&quot;表示监听所有网络接口）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;0.0.0.0&quot;</span>, &amp;server_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid IP address: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="keyword">if</span> (::<span class="built_in">bind</span>(sockfd, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr*&gt;(&amp;server_addr), <span class="built_in">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;bind failed: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-listen-：监听连接（服务器端）">3. <code>listen()</code>：监听连接（服务器端）</h4>
<p><strong>作用</strong>：将套接字转为 “监听状态”，允许接收客户端的连接请求（仅用于 TCP 服务器端的<code>sockfd</code>）。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数解析</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>sockfd</code>：已绑定的套接字描述符（<code>bind()</code>之后）。</p>
</li>
<li class="lvl-2">
<p><code>backlog</code>：未完成连接队列（三次握手未完成）的最大长度（超过则客户端连接失败）。实际值受系统限制（如<code>/proc/sys/net/core/somaxconn</code>），现代系统通常建议设为 128 或更高。</p>
</li>
</ul>
<p><strong>返回值</strong>：成功返回 0，失败返回 - 1。</p>
<p><strong>注意</strong>：<code>listen()</code>不阻塞，仅设置套接字状态。后续需通过<code>accept()</code>获取实际连接。</p>
<h4 id="4-accept-：接受连接（服务器端）">4. <code>accept()</code>：接受连接（服务器端）</h4>
<p><strong>作用</strong>：从<code>listen()</code>创建的连接队列中取出一个已完成的连接，返回一个<strong>新的套接字描述符</strong>（用于与该客户端通信）。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数解析</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>sockfd</code>：处于监听状态的套接字（监听套接字）。</p>
</li>
<li class="lvl-2">
<p><code>addr</code>：输出参数，用于存储客户端的地址信息（可设为<code>nullptr</code>忽略）。</p>
</li>
<li class="lvl-2">
<p><code>addrlen</code>：输入输出参数，传入<code>addr</code>的大小，输出实际存储的地址长度（可设为<code>nullptr</code>）。</p>
</li>
</ul>
<p><strong>返回值</strong>：成功返回新的套接字描述符（<code>client_fd</code>，用于与客户端通信），失败返回 - 1。</p>
<p><strong>特性</strong>：<code>accept()</code>默认是<strong>阻塞函数</strong>，直到有客户端连接到达才返回。现代 C++ 中可结合非阻塞 I/O 或多线程处理（如用<code>std::thread</code>为每个新连接创建线程）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line"><span class="type">socklen_t</span> client_addr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞等待客户端连接</span></span><br><span class="line"><span class="type">int</span> client_fd = ::<span class="built_in">accept</span>(listen_fd, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr*&gt;(&amp;client_addr), &amp;client_addr_len);</span><br><span class="line"><span class="keyword">if</span> (client_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;accept failed: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印客户端信息（将网络字节序转为字符串）</span></span><br><span class="line"><span class="type">char</span> client_ip[INET_ADDRSTRLEN];</span><br><span class="line"><span class="built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);</span><br><span class="line"><span class="type">uint16_t</span> client_port = <span class="built_in">ntohs</span>(client_addr.sin_port); <span class="comment">// 网络字节序→主机字节序</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;New connection from &quot;</span> &lt;&lt; client_ip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; client_port &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h4 id="5-connect-：发起连接（客户端）">5. <code>connect()</code>：发起连接（客户端）</h4>
<p><strong>作用</strong>：客户端通过该函数向服务器发起 TCP 连接（三次握手的触发点）。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数解析</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>sockfd</code>：客户端的套接字描述符（<code>socket()</code>创建，通常不<code>bind()</code>）。</p>
</li>
<li class="lvl-2">
<p><code>addr</code>：服务器的地址结构（包含服务器 IP 和端口）。</p>
</li>
<li class="lvl-2">
<p><code>addrlen</code>：服务器地址结构的大小。</p>
</li>
</ul>
<p><strong>返回值</strong>：成功返回 0（连接建立），失败返回 - 1（如服务器未监听、网络不可达等）。</p>
<p><strong>特性</strong>：默认是阻塞函数，直到连接建立或失败才返回。非阻塞模式下，可能返回<code>EINPROGRESS</code>（连接正在建立），需通过<code>select()</code>/<code>poll()</code>等检查状态。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端连接服务器（127.0.0.1:8080）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换服务器IP</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid server IP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line"><span class="keyword">if</span> (::<span class="built_in">connect</span>(client_fd, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr*&gt;(&amp;server_addr), <span class="built_in">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;connect failed: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、现代-C-最佳实践">三、现代 C++ 最佳实践</h3>
<ol>
<li class="lvl-3">
<p><strong>资源管理</strong>：用 RAII（如智能指针、自定义封装类）管理<code>sockfd</code>，避免手动<code>close()</code>导致的泄漏。</p>
</li>
<li class="lvl-3">
<p><strong>错误处理</strong>：用异常（<code>std::runtime_error</code>）替代传统的<code>if-else</code>检查，提高代码可读性。</p>
</li>
<li class="lvl-3">
<p><strong>类型安全</strong>：用<code>reinterpret_cast</code>显式转换地址结构，避免隐式转换错误。</p>
</li>
<li class="lvl-3">
<p><strong>异步操作</strong>：结合 Boost.Asio 或 C++20 的<code>std::net</code>（提案阶段）实现非阻塞 I/O，避免线程阻塞。</p>
</li>
<li class="lvl-3">
<p><strong>跨平台</strong>：封装系统差异（如 Windows 的<code>WSASend</code>与 Linux 的<code>send</code>），用条件编译或跨平台库。</p>
</li>
</ol>
<h3 id="总结">总结</h3>
<p><code>socket()</code>/<code>bind()</code>/<code>listen()</code>/<code>accept()</code>/<code>connect()</code>是 TCP 通信的 “骨架”：服务器通过<code>socket()</code>创建套接字→<code>bind()</code>绑定地址→<code>listen()</code>监听→<code>accept()</code>接受连接；客户端通过<code>socket()</code>创建套接字→<code>connect()</code>连接服务器。理解这些函数的参数和交互流程，是掌握网络编程的基础。现代 C++ 通过封装和抽象（如智能指针、异常），可让这些底层操作更安全、易维护。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>常用套接字函数原型及说明</title>
    <url>/2025/08/15/%E5%B8%B8%E7%94%A8%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>正向和反向获取主机和服务信息的函数，以及套接字选项设置和获取的函数原型及说明。</p>
 <span id="more"></span>
<h3 id="一、早期套接字函数原型及说明">一、早期套接字函数原型及说明</h3>
<blockquote>
<p>[!NOTE]</p>
<p>以下仅支持解析IPv4 且 不是线程安全的</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><strong>getsockname</strong><br>
功能：获取套接字本地端的地址信息原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>说明：<code>sockfd</code>为套接字描述符，<code>addr</code>用于存储本地地址，<code>addrlen</code>传入地址结构体长度，传出实际长度。成功返回 0，失败返回 - 1（设置<code>errno</code>）。</p>
</li>
<li class="lvl-3">
<p><strong>getpeername</strong><br>
功能：获取套接字对端的地址信息原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>说明：仅适用于已连接的 TCP 套接字（<code>connect</code>或<code>accept</code>后），参数含义同<code>getsockname</code>。</p>
</li>
<li class="lvl-3">
<p><strong>getsockopt</strong><br>
功能：获取套接字的选项值原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br></pre></td></tr></table></figure>
<p>说明：<code>level</code>为选项级别（如<code>SOL_SOCKET</code>、<code>IPPROTO_TCP</code>），<code>optname</code>为选项名，<code>optval</code>存储结果，<code>optlen</code>传入缓冲区长度并传出实际使用长度。</p>
</li>
<li class="lvl-3">
<p><strong>setsockopt</strong><br>
功能：设置套接字的选项值原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>
<p>说明：<code>optval</code>为待设置的值，<code>optlen</code>为值的长度，其他参数同<code>getsockopt</code>。部分选项需在<code>bind</code>/<code>connect</code>前设置。</p>
</li>
<li class="lvl-3">
<p><strong>gethostbyname</strong><br>
功能：通过主机名获取主机信息（IPv4）原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>说明：已过时（仅支持 IPv4），推荐使用<code>getaddrinfo</code>。返回<code>struct hostent</code>指针，失败返回<code>NULL</code>（设置<code>h_errno</code>）。</p>
</li>
<li class="lvl-3">
<p><strong>gethostbyaddr</strong><br>
功能：通过 IP 地址获取主机名（IPv4）原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">socklen_t</span> len, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure>
<p>说明：<code>addr</code>为网络字节序的 IP 地址，<code>len</code>为地址长度（如<code>sizeof(struct in_addr)</code>），<code>type</code>为地址族（如<code>AF_INET</code>）。已过时。</p>
</li>
<li class="lvl-3">
<p><strong>getservbyname</strong><br>
功能：通过服务名和协议获取服务信息原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br></pre></td></tr></table></figure>
<p>说明：<code>name</code>为服务名（如<code>&quot;http&quot;</code>），<code>proto</code>为协议（如<code>&quot;tcp&quot;</code>，可为<code>NULL</code>）。返回<code>struct servent</code>指针，包含端口号（网络字节序）。</p>
</li>
<li class="lvl-3">
<p><strong>getservbyport</strong><br>
功能：通过端口号和协议获取服务信息原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br></pre></td></tr></table></figure>
<p>说明：<code>port</code>为网络字节序的端口号（需用<code>htons</code>转换），其他参数同<code>getservbyname</code>。</p>
<h5 id="struct-hostent（主机信息结构体）"><strong><code>struct hostent</code>（主机信息结构体）</strong></h5>
<p>用于存储主机的相关信息（如主机名、IP 地址列表等），定义在<code>&lt;netdb.h&gt;</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>  *h_name;        <span class="comment">// 主机的官方名称（规范名）</span></span><br><span class="line">    <span class="type">char</span> **h_aliases;     <span class="comment">// 主机的别名列表（以NULL结尾的字符串数组）</span></span><br><span class="line">    <span class="type">int</span>    h_addrtype;    <span class="comment">// 地址类型（如AF_INET表示IPv4，AF_INET6表示IPv6）</span></span><br><span class="line">    <span class="type">int</span>    h_length;      <span class="comment">// 每个地址的长度（字节），如IPv4为4，IPv6为16</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list;   <span class="comment">// 主机的IP地址列表（网络字节序，以NULL结尾的指针数组）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>字段说明</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><code>h_name</code>：主机的正式名称（如<code>www.example.com</code>）。</p>
</li>
<li class="lvl-5">
<p><code>h_aliases</code>：主机的其他别名（如<code>example.com</code>可能是<code>www.example.com</code>的别名），最后一个元素为<code>NULL</code>。</p>
</li>
<li class="lvl-5">
<p><code>h_addrtype</code>：地址族类型，通常为<code>AF_INET</code>（IPv4），但现代系统也可能支持<code>AF_INET6</code>（IPv6）。</p>
</li>
<li class="lvl-5">
<p><code>h_length</code>：每个 IP 地址的长度（IPv4 为 4 字节，IPv6 为 16 字节）。</p>
</li>
<li class="lvl-5">
<p><code>h_addr_list</code>：存储主机的 IP 地址数组（网络字节序），每个元素是<code>in_addr</code>（IPv4）或<code>in6_addr</code>（IPv6）结构体的指针。为方便使用，通常用宏<code>h_addr</code>指代<code>h_addr_list[0]</code>（第一个 IP 地址）。</p>
</li>
</ul>
<h5 id="struct-servent（服务信息结构体）"><strong><code>struct servent</code>（服务信息结构体）</strong></h5>
<p>用于存储网络服务的相关信息（如服务名、端口号、协议等），同样定义在<code>&lt;netdb.h&gt;</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>  *s_name;        <span class="comment">// 服务的官方名称（规范名）</span></span><br><span class="line">    <span class="type">char</span> **s_aliases;     <span class="comment">// 服务的别名列表（以NULL结尾的字符串数组）</span></span><br><span class="line">    <span class="type">int</span>    s_port;        <span class="comment">// 服务对应的端口号（网络字节序）</span></span><br><span class="line">    <span class="type">char</span>  *s_proto;       <span class="comment">// 服务使用的协议（如&quot;tcp&quot;或&quot;udp&quot;）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>字段说明</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><code>s_name</code>：服务的正式名称（如<code>&quot;http&quot;</code>、<code>&quot;ftp&quot;</code>）。</p>
</li>
<li class="lvl-5">
<p><code>s_aliases</code>：服务的其他别名（如<code>&quot;www&quot;</code>可能是<code>&quot;http&quot;</code>的别名），最后一个元素为<code>NULL</code>。</p>
</li>
<li class="lvl-5">
<p><code>s_port</code>：服务对应的端口号，以网络字节序（大端序）存储，使用时需通过<code>ntohs</code>转换为主机字节序。</p>
</li>
<li class="lvl-5">
<p><code>s_proto</code>：服务使用的协议类型（如<code>&quot;tcp&quot;</code>用于面向连接的服务，<code>&quot;udp&quot;</code>用于无连接服务）。</p>
</li>
</ul>
</li>
</ol>
<h3 id="二、现代套接字函数原型及说明">二、现代套接字函数原型及说明</h3>
<h4 id="getaddrinfo-函数：正向解析（主机名→IP-地址，服务名→端口号）">getaddrinfo 函数：正向解析（主机名→IP 地址，服务名→端口号）</h4>
<p><code>getaddrinfo</code>的核心功能是将<strong>主机名（或 IP 字符串）</strong> 和<strong>服务名（或端口号字符串）</strong> 转换为一组用于创建套接字的<code>struct sockaddr</code>结构（套接字地址结构），方便后续的<code>bind</code>、<code>connect</code>等操作。</p>
<h5 id="1-函数原型">1. 函数原型</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node, <span class="type">const</span> <span class="type">char</span> *service,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">struct</span> addrinfo **res)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-参数详解">2. 参数详解</h5>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>node</code></td>
<td><code>const char*</code></td>
<td>输入参数：主机名（如<code>&quot;www.example.com&quot;</code>）或 IP 地址字符串（如<code>&quot;192.168.1.1&quot;</code>）。若为<code>NULL</code>，结合<code>hints.ai_flags</code>的<code>AI_PASSIVE</code>可用于服务器绑定通配地址（<code>INADDR_ANY</code>）。</td>
</tr>
<tr>
<td><code>service</code></td>
<td><code>const char*</code></td>
<td>输入参数：服务名（如<code>&quot;http&quot;</code>、<code>&quot;ssh&quot;</code>）或端口号字符串（如<code>&quot;80&quot;</code>、<code>&quot;22&quot;</code>）。若为<code>NULL</code>，则不指定端口号（需手动在返回的<code>struct sockaddr</code>中设置）。</td>
</tr>
<tr>
<td><code>hints</code></td>
<td><code>const struct addrinfo*</code></td>
<td>输入参数：用于过滤和指定返回结果的 “提示” 结构体。若为<code>NULL</code>，则默认返回所有可能的地址类型（IPv4/IPv6，TCP/UDP 等）。</td>
</tr>
<tr>
<td><code>res</code></td>
<td><code>struct addrinfo**</code></td>
<td>输出参数：指向<code>struct addrinfo</code>链表的指针，存储解析结果。需通过<code>freeaddrinfo</code>释放内存。</td>
</tr>
</tbody>
</table>
<h5 id="3-关键结构体：struct-addrinfo">3. 关键结构体：struct addrinfo</h5>
<p><code>hints</code>和<code>res</code>均为<code>struct addrinfo</code>类型，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">addrinfo</span> &#123;</span><br><span class="line">    <span class="type">int</span> ai_flags;           <span class="comment">// 标志位（见下文）</span></span><br><span class="line">    <span class="type">int</span> ai_family;          <span class="comment">// 地址族（如AF_INET、AF_INET6、AF_UNSPEC）</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;        <span class="comment">// 套接字类型（如SOCK_STREAM、SOCK_DGRAM）</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;        <span class="comment">// 协议（如IPPROTO_TCP、IPPROTO_UDP，0表示任意）</span></span><br><span class="line">    <span class="type">socklen_t</span> ai_addrlen;   <span class="comment">// ai_addr指向的地址结构的长度</span></span><br><span class="line">    <span class="type">char</span> *ai_canonname;     <span class="comment">// 主机的规范名称（若指定AI_CANONNAME标志）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr</span> *ai_addr; <span class="comment">// 指向套接字地址结构（sockaddr_in或sockaddr_in6）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> *ai_next; <span class="comment">// 链表下一个节点（可能有多个解析结果）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中核心字段说明：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>ai_family</code>：指定地址族，<code>AF_INET</code>（仅 IPv4）、<code>AF_INET6</code>（仅 IPv6）、<code>AF_UNSPEC</code>（不限制，返回所有可能）。</p>
</li>
<li class="lvl-2">
<p><code>ai_socktype</code>：指定套接字类型，<code>SOCK_STREAM</code>（TCP）、<code>SOCK_DGRAM</code>（UDP）、0（任意类型）。</p>
</li>
<li class="lvl-2">
<p><code>ai_protocol</code>：指定协议，<code>IPPROTO_TCP</code>（TCP）、<code>IPPROTO_UDP</code>（UDP）、0（任意协议）。</p>
</li>
<li class="lvl-2">
<p><code>ai_flags</code>：常用标志（可组合使用，按位或）：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>AI_PASSIVE</code>：用于服务器，<code>node</code>为<code>NULL</code>时，返回的地址将是通配地址（<code>INADDR_ANY</code> for IPv4，<code>in6addr_any</code> for IPv6），适合<code>bind</code>。</li>
<li class="lvl-4"><code>AI_CANONNAME</code>：要求返回主机的规范名称（存储在<code>ai_canonname</code>）。</li>
<li class="lvl-4"><code>AI_NUMERICHOST</code>：<code>node</code>必须是 IP 地址字符串（不进行域名解析），否则返回错误。</li>
<li class="lvl-4"><code>AI_NUMERICSERV</code>：<code>service</code>必须是端口号字符串（不解析服务名），否则返回错误。</li>
</ul>
</li>
</ul>
<h5 id="4-返回值">4. 返回值</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>成功：返回<code>0</code>，<code>res</code>指向解析结果链表（可能有多个地址，需遍历处理）。</p>
</li>
<li class="lvl-2">
<p>失败：返回非 0 错误码（如<code>EAI_NONAME</code>表示主机名无效），可通过<code>gai_strerror(err)</code>获取错误信息字符串。</p>
</li>
</ul>
<h5 id="5-内存释放">5. 内存释放</h5>
<p>解析完成后，必须通过<code>freeaddrinfo</code>释放<code>res</code>指向的链表内存，避免泄漏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *res)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="6-使用场景">6. 使用场景</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端：将服务器主机名（如<code>&quot;www.baidu.com&quot;</code>）和服务名（如<code>&quot;http&quot;</code>）解析为<code>struct sockaddr</code>，用于<code>connect</code>。</p>
</li>
<li class="lvl-2">
<p>服务器：将<code>NULL</code>（主机名）和服务名（如<code>&quot;8080&quot;</code>）解析为通配地址（结合<code>AI_PASSIVE</code>），用于<code>bind</code>。</p>
</li>
</ul>
<h4 id="getnameinfo-函数：反向解析（IP-地址→主机名，端口号→服务名）">getnameinfo 函数：反向解析（IP 地址→主机名，端口号→服务名）</h4>
<p><code>getnameinfo</code>是<code>getaddrinfo</code>的反向操作：将<code>struct sockaddr</code>（套接字地址结构，包含 IP 和端口）转换为<strong>主机名</strong>和<strong>服务名</strong>。</p>
<h5 id="1-函数原型-2">1. 函数原型</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> *host, <span class="type">socklen_t</span> hostlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">char</span> *serv, <span class="type">socklen_t</span> servlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-参数详解-2">2. 参数详解</h5>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>addr</code></td>
<td><code>const struct sockaddr*</code></td>
<td>输入参数：指向<code>struct sockaddr</code>（或<code>sockaddr_in</code>/<code>sockaddr_in6</code>）的指针，包含待解析的 IP 和端口。</td>
</tr>
<tr>
<td><code>addrlen</code></td>
<td><code>socklen_t</code></td>
<td>输入参数：<code>addr</code>指向的地址结构的长度（如<code>sizeof(struct sockaddr_in)</code>）。</td>
</tr>
<tr>
<td><code>host</code></td>
<td><code>char*</code></td>
<td>输出参数：存储主机名的缓冲区（若为<code>NULL</code>，则不获取主机名）。</td>
</tr>
<tr>
<td><code>hostlen</code></td>
<td><code>socklen_t</code></td>
<td>输入参数：<code>host</code>缓冲区的大小（字节）。</td>
</tr>
<tr>
<td><code>serv</code></td>
<td><code>char*</code></td>
<td>输出参数：存储服务名的缓冲区（若为<code>NULL</code>，则不获取服务名）。</td>
</tr>
<tr>
<td><code>servlen</code></td>
<td><code>socklen_t</code></td>
<td>输入参数：<code>serv</code>缓冲区的大小（字节）。</td>
</tr>
<tr>
<td><code>flags</code></td>
<td><code>int</code></td>
<td>输入参数：控制解析行为的标志（见下文）。</td>
</tr>
</tbody>
</table>
<h5 id="3-关键标志（flags）">3. 关键标志（flags）</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>NI_NAMEREQD</code>：若无法解析主机名（如无 DNS 记录），则返回错误（<code>EAI_NONAME</code>），不返回 IP 字符串。</p>
</li>
<li class="lvl-2">
<p><code>NI_NUMERICHOST</code>：强制返回 IP 地址字符串（不解析为主机名）。</p>
</li>
<li class="lvl-2">
<p><code>NI_NUMERICSERV</code>：强制返回端口号字符串（不解析为服务名）。</p>
</li>
<li class="lvl-2">
<p><code>NI_DGRAM</code>：表示是 UDP 服务（默认假设是 TCP，某些服务名在 TCP 和 UDP 中可能不同）。</p>
</li>
</ul>
<h5 id="4-返回值-2">4. 返回值</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>成功：返回<code>0</code>，<code>host</code>和<code>serv</code>缓冲区分别存储主机名和服务名（若对应参数非<code>NULL</code>）。</p>
</li>
<li class="lvl-2">
<p>失败：返回非 0 错误码，可通过<code>gai_strerror(err)</code>获取错误信息。</p>
</li>
</ul>
<h5 id="5-使用场景">5. 使用场景</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>服务器：获取客户端连接的 IP 对应的主机名（如日志记录）。</p>
</li>
<li class="lvl-2">
<p>网络工具：将套接字地址转换为人类可读的主机名和服务名（如<code>netstat</code>显示<code>www.baidu.com:http</code>而非<code>180.101.50.242:80</code>）。</p>
</li>
</ul>
<h4 id="示例代码片段">示例代码片段</h4>
<h5 id="1-getaddrinfo-示例（解析主机名和服务名）">1. getaddrinfo 示例（解析主机名和服务名）</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* host = <span class="string">&quot;www.baidu.com&quot;</span>; <span class="comment">// 主机名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* service = <span class="string">&quot;http&quot;</span>;       <span class="comment">// 服务名（对应80端口）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints, *res, *p;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = AF_UNSPEC;    <span class="comment">// 不限制IPv4/IPv6</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// TCP</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> status = <span class="built_in">getaddrinfo</span>(host, service, &amp;hints, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;getaddrinfo error: &quot;</span> &lt;&lt; <span class="built_in">gai_strerror</span>(status) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历解析结果</span></span><br><span class="line">    <span class="keyword">for</span> (p = res; p != <span class="literal">nullptr</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="type">char</span> ipstr[INET6_ADDRSTRLEN]; <span class="comment">// 足够存储IPv6地址的缓冲区</span></span><br><span class="line">        <span class="type">void</span>* addr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是IPv4还是IPv6</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ai_family == AF_INET) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>* ipv4 = (<span class="keyword">struct</span> sockaddr_in*)p-&gt;ai_addr;</span><br><span class="line">            addr = &amp;(ipv4-&gt;sin_addr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">struct</span> sockaddr_in6* ipv6 = (<span class="keyword">struct</span> sockaddr_in6*)p-&gt;ai_addr;</span><br><span class="line">            addr = &amp;(ipv6-&gt;sin6_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为字符串</span></span><br><span class="line">        <span class="built_in">inet_ntop</span>(p-&gt;ai_family, addr, ipstr, <span class="built_in">sizeof</span>(ipstr));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;IP地址: &quot;</span> &lt;&lt; ipstr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">freeaddrinfo</span>(res); <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-getnameinfo-示例（解析-IP-地址和端口）">2. getnameinfo 示例（解析 IP 地址和端口）</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr; <span class="comment">// IPv4地址结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">80</span>); <span class="comment">// 端口80</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;180.101.50.242&quot;</span>, &amp;addr.sin_addr); <span class="comment">// 百度的一个IP</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> host[NI_MAXHOST];   <span class="comment">// 主机名缓冲区</span></span><br><span class="line">    <span class="type">char</span> serv[NI_MAXSERV];   <span class="comment">// 服务名缓冲区</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析：获取主机名和服务名</span></span><br><span class="line">    <span class="type">int</span> status = <span class="built_in">getnameinfo</span>((<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr),</span><br><span class="line">                             host, <span class="built_in">sizeof</span>(host),</span><br><span class="line">                             serv, <span class="built_in">sizeof</span>(serv),</span><br><span class="line">                             <span class="number">0</span>); <span class="comment">// 不使用特殊标志</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;getnameinfo error: &quot;</span> &lt;&lt; <span class="built_in">gai_strerror</span>(status) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;主机名: &quot;</span> &lt;&lt; host &lt;&lt; std::endl; <span class="comment">// 可能输出&quot;www.baidu.com&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;服务名: &quot;</span> &lt;&lt; serv &lt;&lt; std::endl; <span class="comment">// 输出&quot;http&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、-socket-选项">三、 socket 选项</h3>
<table>
<thead>
<tr>
<th>选项名</th>
<th>级别</th>
<th>数据类型</th>
<th>功能描述</th>
<th>可操作（get/set）</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SOL_SOCKET 级别（通用选项）</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SO_DEBUG</td>
<td>SOL_SOCKET</td>
<td>int (0 / 非 0)</td>
<td>启用调试模式，内核记录套接字调试信息</td>
<td>get/set</td>
<td>仅超级用户可设置</td>
</tr>
<tr>
<td>SO_REUSEADDR</td>
<td>SOL_SOCKET</td>
<td>int (0 / 非 0)</td>
<td>允许重用本地地址和端口（如 TIME_WAIT 状态端口复用）</td>
<td>get/set</td>
<td>需在 bind 前设置，解决 “地址已被使用” 错误</td>
</tr>
<tr>
<td>SO_REUSEPORT</td>
<td>SOL_SOCKET</td>
<td>int (0 / 非 0)</td>
<td>允许多个套接字绑定到同一端口（需同 UID，内核分发数据）</td>
<td>get/set</td>
<td>部分系统支持（如 Linux 3.9+），常用于多进程监听同一端口</td>
</tr>
<tr>
<td>SO_KEEPALIVE</td>
<td>SOL_SOCKET</td>
<td>int (0 / 非 0)</td>
<td>启用 TCP 保活机制，定期检测对端是否存活</td>
<td>get/set</td>
<td>超时时间由系统配置（通常 2 小时无活动后触发）</td>
</tr>
<tr>
<td>SO_DONTROUTE</td>
<td>SOL_SOCKET</td>
<td>int (0 / 非 0)</td>
<td>禁止路由，数据仅在本地子网传输</td>
<td>get/set</td>
<td>用于本地通信或诊断</td>
</tr>
<tr>
<td>SO_BROADCAST</td>
<td>SOL_SOCKET</td>
<td>int (0 / 非 0)</td>
<td>允许发送广播报文</td>
<td>get/set</td>
<td>仅适用于 UDP，需在 sendto 前设置</td>
</tr>
<tr>
<td>SO_SNDBUF</td>
<td>SOL_SOCKET</td>
<td>int</td>
<td>设置 / 获取发送缓冲区大小（字节）</td>
<td>get/set</td>
<td>内核可能调整实际大小（不超过系统上限）</td>
</tr>
<tr>
<td>SO_RCVBUF</td>
<td>SOL_SOCKET</td>
<td>int</td>
<td>设置 / 获取接收缓冲区大小（字节）</td>
<td>get/set</td>
<td>影响接收性能和拥塞控制，建议在 connect/bind 前设置</td>
</tr>
<tr>
<td>SO_SNDTIMEO</td>
<td>SOL_SOCKET</td>
<td>struct timeval</td>
<td>设置发送操作（send/sendto）的超时时间</td>
<td>get/set</td>
<td>超时后返回 EAGAIN/EWOULDBLOCK</td>
</tr>
<tr>
<td>SO_RCVTIMEO</td>
<td>SOL_SOCKET</td>
<td>struct timeval</td>
<td>设置接收操作（recv/recvfrom）的超时时间</td>
<td>get/set</td>
<td>同 SO_SNDTIMEO</td>
</tr>
<tr>
<td>SO_TYPE</td>
<td>SOL_SOCKET</td>
<td>int</td>
<td>获取套接字类型（如 SOCK_STREAM、SOCK_DGRAM）</td>
<td>get（不可 set）</td>
<td>用于判断套接字是 TCP 还是 UDP</td>
</tr>
<tr>
<td>SO_ERROR</td>
<td>SOL_SOCKET</td>
<td>int</td>
<td>获取套接字上的待处理错误（如连接失败原因）</td>
<td>get（不可 set）</td>
<td>常用于非阻塞 connect 后的错误检查</td>
</tr>
<tr>
<td>SO_LINGER</td>
<td>SOL_SOCKET</td>
<td>struct linger</td>
<td>控制 close 时的延迟关闭行为（等待未发送数据）</td>
<td>get/set</td>
<td>struct linger {int l_onoff; int l_linger;}，l_onoff=1 启用，l_linger 为等待秒数</td>
</tr>
<tr>
<td>SO_PASSCRED</td>
<td>SOL_SOCKET</td>
<td>int (0 / 非 0)</td>
<td>允许接收辅助数据中的凭证信息（如 UID/GID）</td>
<td>get/set</td>
<td>用于 Unix 域套接字的权限验证</td>
</tr>
<tr>
<td>SO_PEERCRED</td>
<td>SOL_SOCKET</td>
<td>struct ucred</td>
<td>获取对端 Unix 域套接字的用户凭证（UID/GID/PID）</td>
<td>get（不可 set）</td>
<td>仅适用于已连接的 Unix 域套接字</td>
</tr>
<tr>
<td><strong>IPPROTO_IP 级别（IPv4 选项）</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IP_HDRINCL</td>
<td>IPPROTO_IP</td>
<td>int (0 / 非 0)</td>
<td>应用程序自行构造 IP 头部，不依赖内核</td>
<td>get/set</td>
<td>仅超级用户可设置，用于自定义 IP 报文</td>
</tr>
<tr>
<td>IP_OPTIONS</td>
<td>IPPROTO_IP</td>
<td>void *</td>
<td>设置 / 获取 IP 选项（如源路由、记录路由）</td>
<td>get/set</td>
<td>选项数据需符合 IP 协议规范，长度有限制</td>
</tr>
<tr>
<td>IP_TOS</td>
<td>IPPROTO_IP</td>
<td>int</td>
<td>设置 / 获取 IP 服务类型（TOS），控制路由优先级</td>
<td>get/set</td>
<td>值为 0~255，具体含义见 RFC 规范</td>
</tr>
<tr>
<td>IP_TTL</td>
<td>IPPROTO_IP</td>
<td>int</td>
<td>设置 / 获取 IP 生存时间（TTL），限制报文转发跳数</td>
<td>get/set</td>
<td>通常设为 64、128 等，超过 TTL 则报文被丢弃</td>
</tr>
<tr>
<td>IP_MULTICAST_TTL</td>
<td>IPPROTO_IP</td>
<td>u_char</td>
<td>设置多播报文的 TTL 值</td>
<td>get/set</td>
<td>控制多播范围（0 = 本地，1 = 同一子网，…，255 = 全局）</td>
</tr>
<tr>
<td>IP_MULTICAST_LOOP</td>
<td>IPPROTO_IP</td>
<td>u_char (0/1)</td>
<td>启用多播报文回环（本地发送的多播自己能否接收）</td>
<td>get/set</td>
<td>默认 1（启用），多播应用需根据需求关闭</td>
</tr>
<tr>
<td>IP_ADD_MEMBERSHIP</td>
<td>IPPROTO_IP</td>
<td>struct ip_mreq</td>
<td>加入多播组</td>
<td>set（不可 get）</td>
<td>struct ip_mreq 包含多播组 IP 和本地接口 IP</td>
</tr>
<tr>
<td>IP_DROP_MEMBERSHIP</td>
<td>IPPROTO_IP</td>
<td>struct ip_mreq</td>
<td>退出多播组</td>
<td>set（不可 get）</td>
<td>同 IP_ADD_MEMBERSHIP</td>
</tr>
<tr>
<td><strong>IPPROTO_TCP 级别（TCP 选项）</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TCP_NODELAY</td>
<td>IPPROTO_TCP</td>
<td>int (0 / 非 0)</td>
<td>禁用 Nagle 算法（立即发送小数据包，不延迟合并）</td>
<td>get/set</td>
<td>适用于低延迟场景（如实时通信），可能增加网络拥塞</td>
</tr>
<tr>
<td>TCP_MAXSEG</td>
<td>IPPROTO_TCP</td>
<td>int</td>
<td>设置 / 获取 TCP 最大段大小（MSS）</td>
<td>get/set</td>
<td>通常由内核协商，手动设置需谨慎</td>
</tr>
<tr>
<td>TCP_CORK</td>
<td>IPPROTO_TCP</td>
<td>int (0 / 非 0)</td>
<td>启用 “塞子” 模式，累积数据后一次性发送（类似 Nagle 但更激进）</td>
<td>get/set</td>
<td>适用于批量数据发送，需在完成后关闭（避免延迟）</td>
</tr>
<tr>
<td>TCP_KEEPIDLE</td>
<td>IPPROTO_TCP</td>
<td>int</td>
<td>设置 TCP 保活探测的空闲时间（秒）</td>
<td>get/set</td>
<td>需 SO_KEEPALIVE 启用，默认 7200 秒（2 小时）</td>
</tr>
<tr>
<td>TCP_KEEPINTVL</td>
<td>IPPROTO_TCP</td>
<td>int</td>
<td>设置 TCP 保活探测的间隔时间（秒）</td>
<td>get/set</td>
<td>探测未响应时，间隔多久再次发送，默认 75 秒</td>
</tr>
<tr>
<td>TCP_KEEPCNT</td>
<td>IPPROTO_TCP</td>
<td>int</td>
<td>设置 TCP 保活探测的最大重试次数</td>
<td>get/set</td>
<td>超过次数则判定对端不可达，默认 9 次</td>
</tr>
</tbody>
</table>
<h3 id="说明">说明</h3>
<ol>
<li class="lvl-3">
<p>选项级别说明：<code>SOL_SOCKET</code>为通用选项，<code>IPPROTO_IP</code>为 IPv4 协议选项，<code>IPPROTO_TCP</code>为 TCP 协议选项，还有<code>IPPROTO_UDP</code>（UDP 选项，较少用）等。</p>
</li>
<li class="lvl-3">
<p>部分选项为系统特定（如<code>SO_REUSEPORT</code>在不同 OS 上行为可能不同），使用前需参考目标系统的<code>man</code>手册。</p>
</li>
<li class="lvl-3">
<p>多播相关选项（如<code>IP_ADD_MEMBERSHIP</code>）需结合多播地址（224.0.0.0~239.255.255.255）使用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ASan的使用</title>
    <url>/2025/08/11/ASan%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>如何使用ASan检测内存错误及其使用方法</p>
 <span id="more"></span>
<h3 id="AddressSanitizer（ASan）详解：使用场景、注意事项及扩展知识">AddressSanitizer（ASan）详解：使用场景、注意事项及扩展知识</h3>
<p>AddressSanitizer（简称 ASan）是由 Google 开发的<strong>基于编译器的内存错误检测工具</strong>，集成于 GCC 4.8+、Clang 3.1 + 及 MSVC 2019 + 中。它能精准检测多种内存安全问题（如缓冲区溢出、使用已释放内存等），是 C/C++ 开发中排查内存错误的核心工具</p>
<h2 id="一、ASan-的核心功能">一、ASan 的核心功能</h2>
<p>ASan 主要检测以下内存错误类型：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>栈 / 堆 / 全局缓冲区溢出（越界读写）；</p>
</li>
<li class="lvl-2">
<p>使用已释放内存（use-after-free）；</p>
</li>
<li class="lvl-2">
<p>双重释放（double-free）或释放无效指针；</p>
</li>
<li class="lvl-2">
<p>内存泄漏（需配合 LeakSanitizer，LSan）；</p>
</li>
<li class="lvl-2">
<p>部分未初始化内存的使用（更全面的检测需 MemorySanitizer，MSan）；</p>
</li>
<li class="lvl-2">
<p>栈 - use-after-return/scope（离开作用域后使用栈内存）。</p>
</li>
</ul>
<h2 id="二、不同场景下的使用方法">二、不同场景下的使用方法</h2>
<h3 id="1-基础编译场景（直接编译单个文件）">1. 基础编译场景（直接编译单个文件）</h3>
<p>ASan 的使用依赖编译器插桩，需在<strong>编译和链接阶段同时添加选项</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>核心编译选项</strong>：<code>-fsanitize=address</code>：启用 ASan 检测；<code>-g</code>：生成调试信息（用于定位错误位置）；<br>
<code>-O1</code>/<code>-O2</code>：优化级别（<code>-O0</code>可使用但性能差，<code>-O3</code>可能因优化掩盖部分错误，推荐<code>-O1</code>）。</p>
</li>
<li class="lvl-2">
<p><strong>示例（Clang/GCC）</strong>：假设有文件<code>test.c</code>（含堆缓冲区溢出）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配4个int（16字节）</span></span><br><span class="line">  arr[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">// 越界写入（索引4超出范围）</span></span><br><span class="line">  <span class="built_in">free</span>(arr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -fsanitize=address -g -O1 test.c -o <span class="built_in">test</span>  <span class="comment"># 编译</span></span><br><span class="line">./test                                          <span class="comment"># 运行</span></span><br></pre></td></tr></table></figure>
<p>输出将直接提示 “堆缓冲区溢出”，并显示错误位置（<code>test.c:4</code>）、调用栈及内存分配信息。</p>
</li>
</ul>
<h3 id="2-与构建工具集成（CMake-Makefile）">2. 与构建工具集成（CMake/Makefile）</h3>
<p>在大型项目中，需通过构建工具统一配置 ASan 选项。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>CMake 集成</strong>：在<code>CMakeLists.txt</code>中添加：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对C/C++均启用ASan</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -fsanitize=address -g -O1&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fsanitize=address -g -O1&quot;</span>)</span><br><span class="line"><span class="comment"># 链接阶段同样需要ASan选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -fsanitize=address&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">&quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -fsanitize=address&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><strong>Makefile 集成</strong>：在<code>Makefile</code>中添加：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS += -fsanitize=address -g -O1   <span class="comment"># C编译选项</span></span><br><span class="line">CXXFLAGS += -fsanitize=address -g -O1 <span class="comment"># C++编译选项</span></span><br><span class="line">LDFLAGS += -fsanitize=address         <span class="comment"># 链接选项</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-多线程程序检测">3. 多线程程序检测</h3>
<p>ASan 对多线程程序同样有效，可检测线程中的内存越界、use-after-free 等问题（但线程竞争需 ThreadSanitizer，TSan）。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>示例：多线程堆越界</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *arr;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  arr[<span class="number">10</span>] = <span class="number">0</span>; <span class="comment">// 越界写入（假设仅分配8个int）</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="type">pthread_t</span> t;</span><br><span class="line">  pthread_create(&amp;t, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(t, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">free</span>(arr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fsanitize=address -g -O1 -pthread test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>运行后 ASan 会定位到线程函数中的越界位置。</p>
</li>
</ul>
<h3 id="4-与调试工具（GDB）结合">4. 与调试工具（GDB）结合</h3>
<p>当 ASan 检测到错误时，程序会崩溃，此时可通过 GDB 进一步调试。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>步骤：</p>
<ol>
<li class="lvl-5">用 ASan 编译程序（保留<code>-g</code>选项）；</li>
<li class="lvl-5">用 GDB 启动程序：<code>gdb ./test</code>；</li>
<li class="lvl-5">在 GDB 中运行：<code>(gdb) run</code>；</li>
<li class="lvl-5">触发错误后，使用<code>bt</code>（查看调用栈）、<code>frame N</code>（切换到第 N 帧）定位代码细节。</li>
</ol>
</li>
</ul>
<h3 id="5-平台差异（Linux-macOS-Windows）">5. 平台差异（Linux/macOS/Windows）</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Linux</strong>：支持最完善，GCC/Clang 均无显著限制；</p>
</li>
<li class="lvl-2">
<p><strong>macOS</strong>：需使用 Clang（系统默认编译器），GCC 支持有限；</p>
</li>
<li class="lvl-2">
<p>Windows：</p>
<ul class="lvl-2">
<li class="lvl-4">Clang：与 Linux 用法一致（需安装 LLVM）；</li>
<li class="lvl-4">MSVC 2019+：通过<code>/fsanitize=address</code>启用（选项格式与 GCC/Clang 不同，且部分功能有差异）。</li>
</ul>
</li>
</ul>
<h3 id="6-内存泄漏检测（配合-LSan）">6. 内存泄漏检测（配合 LSan）</h3>
<p>ASan 默认不检测内存泄漏，需手动启用 LeakSanitizer（LSan）。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>启用方法</strong>：</p>
<ul class="lvl-2">
<li class="lvl-4">Clang：直接添加<code>-fsanitize=address,leak</code>；</li>
<li class="lvl-4">GCC：通过环境变量启用：<code>export ASAN_OPTIONS=detect_leaks=1</code>。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>示例</strong>：检测内存泄漏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>); <span class="comment">// 未释放</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -fsanitize=address,leak -g test.c -o <span class="built_in">test</span></span><br><span class="line">./test</span><br></pre></td></tr></table></figure>
<p>输出会提示 “2 个字节的内存泄漏”，并显示分配位置。</p>
</li>
</ul>
<h2 id="三、注意事项">三、注意事项</h2>
<h3 id="1-性能开销不可忽视">1. 性能开销不可忽视</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>运行速度</strong>：程序会慢 2-5 倍（因插入大量检测代码）；</p>
</li>
<li class="lvl-2">
<p><strong>内存占用</strong>：增加 2-3 倍（需维护 “影子内存”）；</p>
</li>
<li class="lvl-2">
<p><strong>适用场景</strong>：仅用于开发 / 测试环境，<strong>禁止在生产环境启用</strong>。</p>
</li>
</ul>
<h3 id="2-编译选项必须完整">2. 编译选项必须完整</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>编译（<code>-c</code>）和链接（<code>-o</code>）阶段均需添加<code>-fsanitize=address</code>，否则会出现链接错误（如 “undefined reference to `__asan_init’”）。</p>
</li>
</ul>
<h3 id="3-优化级别影响检测效果">3. 优化级别影响检测效果</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>避免使用<code>-O3</code>：高优化可能导致编译器重排代码，掩盖内存错误（如合并相邻内存访问）；</p>
</li>
<li class="lvl-2">
<p>推荐<code>-O1</code>或<code>-O2</code>：平衡性能与检测精度。</p>
</li>
</ul>
<h3 id="4-符号表是定位错误的关键">4. 符号表是定位错误的关键</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>必须添加<code>-g</code>选项：否则 ASan 报告仅显示内存地址，无法关联到文件名和行号；</p>
</li>
<li class="lvl-2">
<p>若依赖第三方库，需确保其编译时也带<code>-g</code>（否则调用栈中库函数位置可能显示为 “unknown”）。</p>
</li>
</ul>
<h3 id="5-与其他工具的冲突与兼容">5. 与其他工具的冲突与兼容</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>冲突</strong>：不能与 TSan（<code>-fsanitize=thread</code>）同时使用（两者插桩逻辑冲突）；</p>
</li>
<li class="lvl-2">
<p>兼容：可与 UBSan（<code>-fsanitize=undefined</code>）同时使用（检测未定义行为，如整数溢出），例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -fsanitize=address,undefined -g test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-环境变量配置（ASAN-OPTIONS）">6. 环境变量配置（ASAN_OPTIONS）</h3>
<p>ASan 通过环境变量<code>ASAN_OPTIONS</code>调整行为，常用参数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>detect_leaks=1</code>：启用内存泄漏检测（默认 0）；</p>
</li>
<li class="lvl-2">
<p><code>malloc_context_size=30</code>：设置内存分配 / 释放的调用栈深度（默认 10，加深可更清晰定位来源）；</p>
</li>
<li class="lvl-2">
<p><code>fast_unwind_on_malloc=0</code>：使用精确 unwind（而非快速），调用栈更准确但速度慢（默认 1）；</p>
</li>
<li class="lvl-2">
<p><code>quarantine_size_mb=1024</code>：设置 “隔离区” 大小（已释放内存暂存区域，调大可检测更多 use-after-free）。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ASAN_OPTIONS=<span class="string">&quot;detect_leaks=1:malloc_context_size=20:fast_unwind_on_malloc=0&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-部分错误可能漏检">7. 部分错误可能漏检</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>微小越界（如 1 字节）：若未触及影子内存的 “红色区域”（标记为无效的内存），可能不被检测；</p>
</li>
<li class="lvl-2">
<p>复杂未初始化内存使用：需 MSan（<code>-fsanitize=memory</code>）补充检测（但需重新编译所有依赖库）。</p>
</li>
</ul>
<h2 id="四、扩展知识">四、扩展知识</h2>
<h3 id="1-ASan-工作原理（影子内存机制）">1. ASan 工作原理（影子内存机制）</h3>
<p>ASan 通过 “影子内存（shadow memory）” 跟踪用户内存状态：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每 8 字节用户内存对应 1 字节影子内存（影子内存总大小为用户内存的 1/8）；</p>
</li>
<li class="lvl-2">
<p>影子内存标记内存状态：0（可访问）、1-7（部分可访问）、0xF1（已释放）、0xF2（越界区域）等；</p>
</li>
<li class="lvl-2">
<p>编译器在内存访问（读 / 写）处插入检测代码，检查对应影子内存状态，若非法则触发错误并输出报告。</p>
</li>
</ul>
<h3 id="2-与其他-Sanitizer-的区别">2. 与其他 Sanitizer 的区别</h3>
<table>
<thead>
<tr>
<th>工具</th>
<th>检测目标</th>
<th>与 ASan 兼容性</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>LSan</td>
<td>内存泄漏</td>
<td>兼容（可联合使用）</td>
<td>轻量，依赖 ASan 基础</td>
</tr>
<tr>
<td>MSan</td>
<td>使用未初始化内存</td>
<td>不兼容</td>
<td>需全链路重编译，精度高</td>
</tr>
<tr>
<td>TSan</td>
<td>线程竞争</td>
<td>不兼容</td>
<td>专用于多线程同步错误</td>
</tr>
<tr>
<td>UBSan</td>
<td>未定义行为（如整数溢出）</td>
<td>兼容</td>
<td>可与 ASan 联合使用，覆盖更广</td>
</tr>
</tbody>
</table>
<h3 id="3-最佳实践">3. 最佳实践</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>开发阶段：对核心模块启用 ASan，定期运行单元测试；</p>
</li>
<li class="lvl-2">
<p>CI/CD 流程：将 ASan 检测作为代码提交的 “门禁”，提前拦截内存错误；</p>
</li>
<li class="lvl-2">
<p>结合调试：用 GDB 解析 ASan 崩溃现场，定位错误根源；</p>
</li>
<li class="lvl-2">
<p>多工具协同：先用 ASan 检测基础内存错误，再用 TSan 检测线程问题，最后用 LSan 查漏内存泄漏。</p>
</li>
</ul>
<h3 id="4-局限性">4. 局限性</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>无法检测逻辑错误（如内存访问正确但值错误）；</p>
</li>
<li class="lvl-2">
<p>对自定义内存分配器（如<code>jemalloc</code>）支持有限，可能需要额外配置；</p>
</li>
<li class="lvl-2">
<p>性能开销大，无法用于生产环境的性能测试。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>分散 / 聚集 IO</title>
    <url>/2025/07/29/%E5%88%86%E6%95%A3%20%20%E8%81%9A%E9%9B%86%20IO/</url>
    <content><![CDATA[<p>网络编程中常用的分散 / 聚集 IO 技术</p>
 <span id="more"></span>
<h3 id="1-readv-与-writev：分散-聚集-I-O">1. <code>readv</code> 与 <code>writev</code>：分散 / 聚集 I/O</h3>
<p><code>readv</code>（分散读）和 <code>writev</code>（聚集写）是用于处理<strong>分散缓冲区</strong>的 I/O 函数，核心作用是通过一次系统调用完成对多个不连续缓冲区的读写操作，减少系统调用次数（系统调用存在上下文切换开销）。</p>
<h4 id="函数原型">函数原型</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从fd读取数据，分散存储到iov指向的多个缓冲区</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将iov指向的多个缓冲区数据聚集后写入fd</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="关键参数">关键参数</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>struct iovec</code>描述一个缓冲区的结构，定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>  *iov_base;  <span class="comment">// 缓冲区起始地址</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;   <span class="comment">// 缓冲区长度（字节数）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><code>iovcnt</code>：缓冲区数量，上限由系统限制（通常<code>IOV_MAX</code>，如 Linux 为 1024）。</p>
</li>
</ul>
<h4 id="功能与适用场景">功能与适用场景</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>readv</code></strong>：从文件描述符<code>fd</code>读取数据，按顺序填充<code>iov</code>数组中的缓冲区（前一个填满后再填下一个），返回实际读取的字节数。</p>
</li>
<li class="lvl-2">
<p><strong><code>writev</code></strong>：将<code>iov</code>数组中所有缓冲区的数据按顺序拼接后写入<code>fd</code>，返回实际写入的字节数。</p>
</li>
</ul>
<p><strong>网络编程场景</strong>：在构造协议报文时（如 HTTP 响应包含状态行、头部字段、正文等多个独立部分），可通过<code>writev</code>一次发送所有部分，避免多次<code>write</code>调用的开销；同理，接收报文时若需拆分到不同缓冲区（如头部和正文分离），可使用<code>readv</code>。</p>
<h4 id="注意事项">注意事项</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>若读取 / 写入中途发生错误，仍会返回已成功处理的字节数（部分成功）。</p>
</li>
<li class="lvl-2">
<p>对于非阻塞<code>fd</code>，行为与<code>read</code>/<code>write</code>一致（可能返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>）。</p>
</li>
</ul>
<h3 id="2-dup-与-dup2：文件描述符复制">2. <code>dup</code> 与 <code>dup2</code>：文件描述符复制</h3>
<p><code>dup</code> 和 <code>dup2</code> 用于复制文件描述符，使新的描述符与原描述符指向<strong>同一个文件表项</strong>（共享文件偏移量、文件状态标志等），核心作用是实现 I/O 重定向。</p>
<h4 id="函数原型-2">函数原型</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制oldfd，返回最小的未使用描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将newfd重定向为oldfd的副本（若newfd已打开则先关闭）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="功能差异">功能差异</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>dup</code></strong>：自动选择一个<strong>最小的未被使用的描述符</strong>作为新描述符，与<code>oldfd</code>指向同一文件。</p>
</li>
<li class="lvl-2">
<p><strong><code>dup2</code></strong>：显式指定新描述符<code>newfd</code>，若<code>newfd</code>已打开，则先关闭它（若<code>newfd == oldfd</code>，则直接返回<code>newfd</code>，不关闭）。</p>
</li>
</ul>
<h4 id="网络编程场景">网络编程场景</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>重定向标准 I/O</strong>：例如在网络服务中，将客户端<code>socket</code>的描述符通过<code>dup2(client_fd, STDOUT_FILENO)</code>重定向为标准输出，此时<code>printf</code>的内容会直接发送给客户端。</p>
</li>
<li class="lvl-2">
<p><strong>简化接口适配</strong>：某些库函数仅支持固定描述符（如标准输出），通过<code>dup2</code>可将其适配到 socket 描述符。</p>
</li>
</ul>
<h4 id="注意事项-2">注意事项</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>若<code>oldfd</code>无效（未打开），两函数均返回<code>-1</code>并设置<code>errno</code>为<code>EBADF</code>。</p>
</li>
<li class="lvl-2">
<p><code>dup2</code>关闭<code>newfd</code>时若失败（如权限问题），会返回<code>-1</code>，但此时<code>newfd</code>可能已处于关闭状态，需注意错误处理。</p>
</li>
</ul>
<h3 id="3-sendfile：零拷贝文件传输">3. <code>sendfile</code>：零拷贝文件传输</h3>
<p><code>sendfile</code> 用于在两个文件描述符之间直接传输数据，数据无需经过用户空间，全程在内核空间处理，属于<strong>零拷贝（zero-copy）</strong> 技术，可大幅提升大文件传输效率。</p>
<h4 id="函数原型（Linux）">函数原型（Linux）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将in_fd的数据传输到out_fd，返回实际传输的字节数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="关键参数与限制">关键参数与限制</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>in_fd</code>：源文件描述符，<strong>必须是支持<code>mmap</code>的常规文件</strong>（不能是 socket 或管道）。</p>
</li>
<li class="lvl-2">
<p><code>out_fd</code>：目标文件描述符，在 Linux 中<strong>必须是 socket</strong>（其他系统可能支持更多类型）。</p>
</li>
<li class="lvl-2">
<p><code>offset</code>：指定<code>in_fd</code>的起始读取位置，若不为<code>NULL</code>，传输后会更新为实际结束位置（原子操作，避免多线程竞争）。</p>
</li>
<li class="lvl-2">
<p><code>count</code>：计划传输的字节数。</p>
</li>
</ul>
<h4 id="功能与优势">功能与优势</h4>
<p>传统文件传输流程（<code>read + write</code>）需要 4 次数据拷贝（磁盘→内核缓冲区→用户缓冲区→socket 缓冲区→网卡）和 2 次系统调用；而<code>sendfile</code>通过内核直接将文件数据从页缓存传输到 socket 缓冲区，仅需 2 次拷贝（磁盘→内核缓冲区→socket 缓冲区）和 1 次系统调用，显著减少开销。</p>
<p><strong>网络编程场景</strong>：在文件服务器中（如 HTTP 服务器传输静态资源），<code>sendfile</code>是高效传输文件的首选方式，比<code>read + write</code>组合性能提升明显。</p>
<h4 id="注意事项-3">注意事项</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>跨平台差异大：Linux 的<code>sendfile</code>与 BSD 的<code>sendfile</code>参数和行为不同，移植时需注意。</p>
</li>
<li class="lvl-2">
<p>不支持非阻塞 I/O：若<code>out_fd</code>为非阻塞 socket 且暂时无法写入，<code>sendfile</code>可能返回<code>-1</code>并设置<code>errno</code>为<code>EAGAIN</code>，但部分实现可能不支持。</p>
</li>
<li class="lvl-2">
<p><code>in_fd</code>必须是常规文件：不能用于 socket 之间的数据转发（需用<code>splice</code>等其他函数）。</p>
</li>
</ul>
<h3 id="总结">总结</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>readv</code>/<code>writev</code>：优化多缓冲区 I/O，减少系统调用次数，适合协议报文的拼接 / 拆分。</p>
</li>
<li class="lvl-2">
<p><code>dup</code>/<code>dup2</code>：实现文件描述符重定向，简化 I/O 接口适配。</p>
</li>
<li class="lvl-2">
<p><code>sendfile</code>：利用零拷贝技术高效传输文件，是大文件网络传输的核心优化手段。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP、UDP数据读写基础</title>
    <url>/2025/07/28/TCP,UDP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>如何使用 C++ 进行 TCP 和 UDP 数据读写的基础知识</p>
 <span id="more"></span>
<h3 id="一、通用数据读写基础（TCP-UDP-均需掌握）">一、通用数据读写基础（TCP/UDP 均需掌握）</h3>
<p>无论使用何种协议，网络数据读写都需处理字节序转换、数据序列化和错误处理，这是跨平台通信的基础。</p>
<h4 id="1-字节序转换（解决主机与网络字节序差异）">1. 字节序转换（解决主机与网络字节序差异）</h4>
<p>网络协议规定使用<strong>大端字节序</strong>（网络字节序），主机字节序可能为大端或小端（如 x86 为小端），需通过以下函数转换：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>uint16_t htons(uint16_t hostshort)</code>：主机→网络字节序（16 位，如端口号）</p>
</li>
<li class="lvl-2">
<p><code>uint32_t htonl(uint32_t hostlong)</code>：主机→网络字节序（32 位，如 IPv4 地址）</p>
</li>
<li class="lvl-2">
<p><code>uint16_t ntohs(uint16_t netshort)</code>：网络→主机字节序（16 位）</p>
</li>
<li class="lvl-2">
<p><code>uint32_t ntohl(uint32_t netlong)</code>：网络→主机字节序（32 位）</p>
</li>
</ul>
<p><strong>进阶场景</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>64 位数据：POSIX 提供<code>htobe64</code>/<code>be64toh</code>（大端）、<code>htole64</code>/<code>le64toh</code>（小端），Windows 需手动实现。</p>
</li>
<li class="lvl-2">
<p>浮点数：无标准转换函数，需通过指针转换为字节数组传输（依赖 IEEE 754 兼容）。</p>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> port = <span class="number">8080</span>;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(port);  <span class="comment">// 端口必须用网络字节序</span></span><br></pre></td></tr></table></figure>
<h4 id="2-数据序列化与缓冲区管理">2. 数据序列化与缓冲区管理</h4>
<p>网络传输的是字节流，需通过缓冲区处理，结构化数据需序列化以避免对齐和字节序问题。</p>
<p><strong>核心函数</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>memcpy(void *dest, const void *src, size_t n)</code>：拷贝字节（用于序列化）</p>
</li>
<li class="lvl-2">
<p><code>memset(void *s, int c, size_t n)</code>：初始化缓冲区（如清空接收缓冲区）</p>
</li>
<li class="lvl-2">
<p><code>strlen(const char *s)</code>：计算字符串长度（用于发送字符串）</p>
</li>
</ul>
<p><strong>序列化方案</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>手动序列化：拆分结构体成员，转换字节序后写入缓冲区：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Msg</span> &#123; <span class="type">int</span> len; <span class="type">short</span> type; &#125;;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> net_len = <span class="built_in">htonl</span>(msg.len);</span><br><span class="line"><span class="type">short</span> net_type = <span class="built_in">htons</span>(msg.type);</span><br><span class="line"><span class="built_in">memcpy</span>(buf, &amp;net_len, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(buf+<span class="number">4</span>, &amp;net_type, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>协议库：Protobuf、FlatBuffers 等自动处理对齐和字节序。</p>
</li>
</ul>
<p><strong>缓冲区策略</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>动态缓冲区：使用<code>vector&lt;char&gt;</code>避免栈溢出，适合接收未知长度数据。</p>
</li>
<li class="lvl-2">
<p>分散 - 聚集 IO：通过<code>iovec</code>和<code>sendmsg</code>/<code>recvmsg</code>减少内存拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">2</span>];  <span class="comment">// 分散发送消息头和消息体</span></span><br><span class="line">iov[<span class="number">0</span>].iov_base = &amp;header;</span><br><span class="line">iov[<span class="number">0</span>].iov_len = <span class="built_in">sizeof</span>(header);</span><br><span class="line">iov[<span class="number">1</span>].iov_base = data;</span><br><span class="line">iov[<span class="number">1</span>].iov_len = data_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> msg;</span><br><span class="line">msg.msg_iov = iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">sendmsg</span>(sockfd, &amp;msg, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-通用错误处理">3. 通用错误处理</h4>
<p>网络函数失败时返回 - 1，需通过错误码定位问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Linux：<code>errno</code>（如<code>EINTR</code>、<code>ECONNRESET</code>）</p>
</li>
<li class="lvl-2">
<p>Windows：<code>WSAGetLastError()</code>（如<code>WSAECONNRESET</code>）</p>
</li>
</ul>
<p>常见错误：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>EINTR</code>：操作被信号中断（需重试）</p>
</li>
<li class="lvl-2">
<p><code>EWOULDBLOCK</code>：非阻塞模式下无数据（需等待）</p>
</li>
<li class="lvl-2">
<p><code>ECONNRESET</code>：连接被对方重置</p>
</li>
<li class="lvl-2">
<p><code>ENOTCONN</code>：TCP 未连接或 UDP 未指定目标</p>
</li>
</ul>
<h3 id="二、TCP-数据读写（面向连接的字节流）">二、TCP 数据读写（面向连接的字节流）</h3>
<p>TCP 是可靠的面向连接协议，数据无边界，需通过应用层协议界定消息边界。</p>
<h4 id="1-核心读写函数">1. 核心读写函数</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>发送：<code>ssize_t send(int sockfd, const void *buf, size_t len, int flags)</code></strong></p>
<ul class="lvl-2">
<li class="lvl-4">参数：<code>sockfd</code>（已连接的 TCP socket）、缓冲区、长度、标志（通常 0）。</li>
<li class="lvl-4">返回值：实际发送字节数（可能小于<code>len</code>）；失败返回 - 1。</li>
<li class="lvl-4">标志：<code>MSG_NOSIGNAL</code>（Linux）：避免对方关闭时触发 SIGPIPE。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>接收：<code>ssize_t recv(int sockfd, void *buf, size_t len, int flags)</code></strong></p>
<ul class="lvl-2">
<li class="lvl-4">参数：<code>sockfd</code>、接收缓冲区、长度、标志（通常 0）。</li>
<li class="lvl-4">返回值：实际接收字节数；0 表示对方正常关闭；-1 表示错误。</li>
<li class="lvl-4">标志：<code>MSG_PEEK</code>（预览数据不移除）。</li>
</ul>
</li>
</ul>
<h4 id="2-关键特性与实现">2. 关键特性与实现</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>字节流无边界</strong>：需应用层定义消息格式，常见方案：</p>
<ol>
<li class="lvl-5">
<p>**固定长度:**累计读取到指定长度后处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv_fixed</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">char</span> *buf, <span class="type">size_t</span> fixed_len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (total &lt; fixed_len) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recv</span>(sockfd, buf + total, fixed_len - total, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> n;  <span class="comment">// 错误或连接关闭</span></span><br><span class="line">        total += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p>**长度前缀:**先读长度字段，再读对应数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">recv_with_header</span><span class="params">(<span class="type">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> net_len;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">recv_fixed</span>(sockfd, (<span class="type">char</span>*)&amp;net_len, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">ntohl</span>(net_len);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">data</span><span class="params">(len)</span></span>;</span><br><span class="line">    <span class="built_in">recv_fixed</span>(sockfd, data.<span class="built_in">data</span>(), len);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-5">
<p><strong>分隔符</strong>：如<code>\r\n</code>（HTTP 头部方式）。</p>
</li>
</ol>
</li>
<li class="lvl-2">
<p><strong>循环读写</strong>：<code>send</code>/<code>recv</code>可能不一次性处理全部数据，需循环调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send_all</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> total_sent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (total_sent &lt; len) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> sent = <span class="built_in">send</span>(sockfd, (<span class="type">char</span>*)buf + total_sent, len - total_sent, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sent == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        total_sent += sent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_sent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-连接异常处理">3. 连接异常处理</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>半关闭</strong>：对方<code>shutdown(SHUT_WR)</code>后，<code>recv</code>返回 0（可继续发送数据）。</p>
</li>
<li class="lvl-2">
<p><strong>重置连接</strong>：<code>recv</code>返回 - 1 且<code>errno=ECONNRESET</code>，需关闭 socket 并重连。</p>
</li>
<li class="lvl-2">
<p><strong>超时设置:</strong>  通过<code>SO_RCVTIMEO</code>/<code>SO_SNDTIMEO</code>设置读写超时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> timeout = &#123;<span class="number">5</span>, <span class="number">0</span>&#125;;  <span class="comment">// 5秒超时</span></span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, <span class="built_in">sizeof</span>(timeout));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="三、UDP-数据读写（无连接的数据包）">三、UDP 数据读写（无连接的数据包）</h3>
<p>UDP 是不可靠的无连接协议，数据有边界（一次发送对应一次接收），无需建立连接。</p>
<h4 id="1-核心读写函数-2">1. 核心读写函数</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>发送：<code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)</code></strong></p>
<ul class="lvl-2">
<li class="lvl-4">参数：<code>sockfd</code>（UDP socket）、缓冲区、长度、标志、目标地址及长度。</li>
<li class="lvl-4">返回值：成功返回发送字节数（等于<code>len</code>）；失败返回 - 1。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>接收：<code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)</code></strong></p>
<ul class="lvl-2">
<li class="lvl-4">参数：<code>sockfd</code>、接收缓冲区、长度、标志、发送方地址（输出）及长度（输入输出）。</li>
<li class="lvl-4">返回值：接收字节数（≤<code>len</code>）；失败返回 - 1。</li>
</ul>
</li>
</ul>
<h4 id="2-关键特性与实现-2">2. 关键特性与实现</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数据报边界</strong>：一次<code>sendto</code>的数据可被<code>recvfrom</code>完整接收（缓冲区足够时）。</p>
</li>
<li class="lvl-2">
<p><strong>长度限制</strong>：超过 MTU（通常 1500 字节）会分片，建议单包≤1472 字节（1500-20IP 头 - 8UDP 头）。</p>
</li>
<li class="lvl-2">
<p>截断检测：<code>MSG_TRUNC</code>标志可检测数据是否被截断：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">socklen_t</span> addrlen = <span class="built_in">sizeof</span>(addr);</span><br><span class="line"><span class="type">ssize_t</span> n = <span class="built_in">recvfrom</span>(sockfd, buf, len, MSG_TRUNC, &amp;addr, &amp;addrlen);</span><br><span class="line"><span class="keyword">if</span> (n == len &amp;&amp; (flags &amp; MSG_TRUNC)) &#123; <span class="comment">/* 数据被截断 */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-连接化-UDP（Connected-UDP）">3. 连接化 UDP（Connected UDP）</h4>
<p>通过<code>connect</code>绑定固定目标地址后，可使用<code>send</code>/<code>recv</code>简化操作（仍为 UDP 特性）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> dest_addr;</span><br><span class="line"><span class="comment">// 初始化目标地址...</span></span><br><span class="line"><span class="built_in">connect</span>(udp_sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;dest_addr, <span class="built_in">sizeof</span>(dest_addr));</span><br><span class="line"><span class="built_in">send</span>(udp_sockfd, buf, len, <span class="number">0</span>);  <span class="comment">// 无需重复指定地址</span></span><br></pre></td></tr></table></figure>
<h4 id="4-可靠性增强">4. 可靠性增强</h4>
<p>UDP 本身不可靠，需应用层补充机制：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>序号与确认（重传超时未确认的包）</p>
</li>
<li class="lvl-2">
<p>校验和（检测数据损坏）</p>
</li>
<li class="lvl-2">
<p>流量控制（避免接收方溢出）</p>
</li>
</ul>
<h3 id="四、高级函数与性能优化">四、高级函数与性能优化</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)</code></strong>：支持分散发送（多个缓冲区数据合并发送），适合发送复杂数据结构。</p>
</li>
<li class="lvl-2">
<p><strong><code>ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags)</code></strong>：支持聚集接收（将数据分散到多个缓冲区），常用于接收带辅助数据（如控制信息）的数据包。</p>
</li>
<li class="lvl-2">
<p><strong><code>ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)</code></strong>（Linux）：零拷贝发送文件，直接从文件描述符<code>in_fd</code>发送到<code>socket</code>（<code>out_fd</code>），减少用户态与内核态拷贝，效率极高。</p>
</li>
</ul>
<p><strong>性能优化</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>TCP：禁用 Nagle 算法（<code>TCP_NODELAY</code>）减少延迟；增大缓冲区（<code>SO_SNDBUF</code>/<code>SO_RCVBUF</code>）提高吞吐量。</p>
</li>
<li class="lvl-2">
<p>UDP：避免碎片化；批量发送减少系统调用。</p>
</li>
<li class="lvl-2">
<p>IO 模型：高并发场景使用非阻塞 IO+<code>epoll</code>（Linux）/<code>kqueue</code>（BSD）。</p>
</li>
</ul>
<h3 id="五、跨平台兼容性">五、跨平台兼容性</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Windows 需初始化套接字库（<code>WSAStartup</code>），Linux 无需。</p>
</li>
<li class="lvl-2">
<p>错误处理：Windows 用<code>WSAGetLastError()</code>，Linux 用<code>errno</code>。</p>
</li>
<li class="lvl-2">
<p>关闭 socket：Windows 用<code>closesocket</code>，Linux 用<code>close</code>。</p>
</li>
</ul>
<p><strong>兼容代码示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> close closesocket</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_last_error</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WSAGetLastError</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> errno;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>TCP</strong>：用<code>send</code>/<code>recv</code>，面向连接，需处理字节流无边界问题，适合可靠传输（如 HTTP）。</p>
</li>
<li class="lvl-2">
<p><strong>UDP</strong>：用<code>sendto</code>/<code>recvfrom</code>，无连接，保留数据报边界，适合实时场景（如视频流）。</p>
</li>
<li class="lvl-2">
<p>通用基础：字节序转换、序列化、缓冲区管理和错误处理是核心前提。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>linux管道(pipe)系统调用</title>
    <url>/2025/07/12/pipe()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>如何使用 C++ 在 Linux 环境下进行管道(pipe)系统调用</p>
 <span id="more"></span>
<h1>pipe() 系统调用</h1>
<p>在 Linux 系统编程中，<code>pipe()</code> 是一个系统调用，用于创建一个<strong>匿名管道</strong>，实现同一进程或父子进程间的单向通信。管道有两个文件描述符：一个用于读取（读端），一个用于写入（写端）。</p>
<h3 id="pipe-函数原型"><code>pipe()</code> 函数原型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>pipefd是一个包含两个整数的数组，用于存储管道的文件描述符</p>
<ul class="lvl-2">
<li class="lvl-4"><code>pipefd[0]</code>：管道的<strong>读端</strong>，用于读取数据</li>
<li class="lvl-4"><code>pipefd[1]</code>：管道的<strong>写端</strong>，用于写入数据</li>
</ul>
</li>
<li class="lvl-2">
<p>返回值：成功返回 0，失败返回 -1 并设置 <code>errno</code></p>
</li>
</ul>
<h3 id="使用步骤">使用步骤</h3>
<ol>
<li class="lvl-3">
<p>创建管道：调用 <code>pipe()</code> 函数</p>
</li>
<li class="lvl-3">
<p>创建子进程：使用 <code>fork()</code> 创建子进程（管道通常用于父子进程间通信）</p>
</li>
<li class="lvl-3">
<p>关闭不需要的端：</p>
<ul class="lvl-2">
<li class="lvl-5">父进程关闭读端（<code>pipefd[0]</code>），只写</li>
<li class="lvl-5">子进程关闭写端（<code>pipefd[1]</code>），只读（或根据需求调整，如父进程读、子进程写）</li>
</ul>
</li>
<li class="lvl-3">
<p>通信：通过 <code>write()</code> 写入数据，<code>read()</code> 读取数据</p>
</li>
<li class="lvl-3">
<p>关闭管道：通信完成后关闭所有文件描述符</p>
</li>
</ol>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;管道创建失败: &quot;</span> &lt;&lt; std::<span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;进程创建失败: &quot;</span> &lt;&lt; std::<span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 子进程：读数据</span></span><br><span class="line">        <span class="comment">// 3. 关闭子进程不需要的写端</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 从管道读取数据</span></span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;读取失败: &quot;</span> &lt;&lt; std::<span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        buf[n] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子进程收到: &quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭读端</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 父进程：写数据</span></span><br><span class="line">        <span class="comment">// 3. 关闭父进程不需要的读端</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 向管道写入数据</span></span><br><span class="line">        std::string msg = <span class="string">&quot;Hello from parent!&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(pipefd[<span class="number">1</span>], msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>()) == <span class="number">-1</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;写入失败: &quot;</span> &lt;&lt; std::<span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭写端（触发子进程的read()返回0）</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子进程结束</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代码说明">代码说明</h3>
<ol>
<li class="lvl-3">
<p><strong>管道创建</strong>：<code>pipe(pipefd)</code> 成功后，<code>pipefd[0]</code> 和 <code>pipefd[1]</code> 分别代表读端和写端</p>
</li>
<li class="lvl-3">
<p>进程通信</p>
<ul class="lvl-2">
<li class="lvl-5">父进程通过 <code>write(pipefd[1], ...)</code> 向管道写入数据</li>
<li class="lvl-5">子进程通过 <code>read(pipefd[0], ...)</code> 从管道读取数据</li>
</ul>
</li>
<li class="lvl-3">
<p>关闭端的重要性</p>
<ul class="lvl-2">
<li class="lvl-5">不使用的端必须关闭，否则可能导致 <code>read()</code> 阻塞（等待数据）</li>
<li class="lvl-5">所有写端关闭后，<code>read()</code> 会返回 0（表示数据结束）</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>单向性</strong>：管道是单向的，数据只能从写端流向读端</p>
</li>
</ol>
<h3 id="核心原则：按需保留，及时关闭，全量清理">核心原则：<strong>按需保留，及时关闭，全量清理</strong></h3>
<ol>
<li class="lvl-3">
<p><strong>“先关闭，后通信” 的原则</strong>：进程创建后（如 <code>fork()</code> 后），应立即关闭不需要的端，再进行读写操作。例如：</p>
<ul class="lvl-2">
<li class="lvl-5">父进程若负责写数据，应先关闭读端（<code>pipefd[0]</code>），仅保留写端（<code>pipefd[1]</code>）；</li>
<li class="lvl-5">子进程若负责读数据，应先关闭写端（<code>pipefd[1]</code>），仅保留读端（<code>pipefd[0]</code>）。避免因 “未及时关闭” 导致的意外数据交互（如子进程误写数据到本应关闭的写端）。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>写端关闭的 “触发信号” 作用</strong>：写端完成数据发送后，<strong>必须主动关闭写端</strong>，这是告知读端 “数据已发送完毕” 的唯一方式。读端通过 <code>read()</code> 返回 0 感知 “所有写端已关闭”，从而正常退出读取逻辑。</p>
<ul class="lvl-2">
<li class="lvl-5">反例：若父进程写完数据后未关闭写端，子进程的 <code>read()</code> 会一直阻塞（等待更多数据），导致子进程无法退出。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>多进程协作时的 “全关闭” 检查</strong>：若多个进程共享同一管道的写端（如父进程和多个子进程都向管道写数据），<strong>必须确保所有写端都关闭后，读端才能收到 EOF（<code>read()</code> 返回 0）</strong>。</p>
<ul class="lvl-2">
<li class="lvl-5">需通过进程同步（如 <code>waitpid</code>）确保所有写进程都已关闭写端，避免读端提前退出或阻塞。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>linux文件操作</title>
    <url>/2025/07/12/open()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>如何使用 C++ 在 Linux 环境下进行文件操作</p>
<span id="more"></span>
<h3 id="一、open-系统调用（Unix-Linux）"><strong>一、<code>open()</code> 系统调用（Unix/Linux）</strong></h3>
<h4 id="1-核心知识点回顾"><strong>1. 核心知识点回顾</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>    <span class="comment">// 定义 O_RDONLY、O_WRONLY 等标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  <span class="comment">// 定义 mode_t 类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>   <span class="comment">// 定义文件权限宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>参数</p>
<ul class="lvl-2">
<li class="lvl-4"><code>pathname</code>：要打开或创建的文件路径（绝对或相对路径）</li>
<li class="lvl-4"><code>flags</code>：必选标志，只能选其一（<code>O_RDONLY</code>/<code>O_WRONLY</code>/<code>O_RDWR</code>）和可选标志（<code>O_CREAT</code>、<code>O_EXCL</code>、<code>O_APPEND</code>、<code>O_TRUNC</code> 等）。</li>
<li class="lvl-4"><code>mode</code>：当使用 <code>O_CREAT</code> 标志时需指定权限。创建文件时的权限（如 <code>0644</code>）。</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>返回值</strong>：文件描述符（整数）或 <code>-1</code>（失败）。</p>
</li>
<li class="lvl-2">
<p><strong>特点</strong>：无缓冲的底层操作，适合设备驱动、非阻塞 I/O 等场景。</p>
</li>
</ul>
<h4 id="2-关键标志位"><strong>2. 关键标志位</strong></h4>
<table>
<thead>
<tr>
<th>标志</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_CREAT</code></td>
<td>文件不存在时创建</td>
</tr>
<tr>
<td><code>O_EXCL</code></td>
<td>与 <code>O_CREAT</code> 联用，文件存在则报错</td>
</tr>
<tr>
<td><code>O_TRUNC</code></td>
<td>打开时截断文件</td>
</tr>
<tr>
<td><code>O_APPEND</code></td>
<td>追加模式</td>
</tr>
<tr>
<td><code>O_NONBLOCK</code></td>
<td>非阻塞模式</td>
</tr>
</tbody>
</table>
<h4 id="3-错误处理"><strong>3. 错误处理</strong></h4>
<p><code>open()</code> 失败时会设置 <code>errno</code>，常见错误码：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>ENOENT</code>：路径不存在（无 <code>O_CREAT</code> 标志时）。</p>
</li>
<li class="lvl-2">
<p><code>EACCES</code>：权限不足（如尝试写入只读文件）。</p>
</li>
<li class="lvl-2">
<p><code>EEXIST</code>：文件已存在（使用 <code>O_CREAT | O_EXCL</code> 时）。</p>
</li>
<li class="lvl-2">
<p><code>EISDIR</code>：路径是目录而非文件。</p>
</li>
</ul>
<h4 id="4-相关系统调用"><strong>4. 相关系统调用</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>close(int fd)</code>：关闭文件描述符。</p>
</li>
<li class="lvl-2">
<p><code>read(int fd, void *buf, size_t count)</code>：从文件读取数据。</p>
</li>
<li class="lvl-2">
<p><code>write(int fd, const void *buf, size_t count)</code>：向文件写入数据。</p>
</li>
<li class="lvl-2">
<p><code>lseek(int fd, off_t offset, int whence)</code>：移动文件读写位置。</p>
</li>
<li class="lvl-2">
<p><code>creat(const char *pathname, mode_t mode)</code>：等价于 <code>open(pathname, O_CREAT | O_WRONLY | O_TRUNC, mode)</code>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件（不存在则创建，存在则截断）</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDWR | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;Hello, open()!\n&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_written = <span class="built_in">write</span>(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动文件指针到开头</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;lseek failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[bytes_read] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 确保字符串以 &#x27;\0&#x27; 结尾</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read: %s&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">close</span>(fd);  <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、C-标准库中的文件操作"><strong>二、C++ 标准库中的文件操作</strong></h3>
<p>C++ 提供了更高级的文件流类，基于对象和异常处理，避免了直接使用系统调用的复杂性。</p>
<h4 id="1-fstream-库（推荐方案）"><strong>1. <code>&lt;fstream&gt;</code> 库（推荐方案）</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>主要类</p>
<ul class="lvl-2">
<li class="lvl-4"><code>std::ifstream</code>：输入文件流（只读）。</li>
<li class="lvl-4"><code>std::ofstream</code>：输出文件流（只写）。</li>
<li class="lvl-4"><code>std::fstream</code>：输入 / 输出文件流（读写）。</li>
</ul>
</li>
</ul>
<p><strong>示例：打开文件并读写</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件（不存在则创建，存在则截断）</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, std::ios::out | std::ios::trunc)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!outfile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    outfile &lt;&lt; <span class="string">&quot;Hello, C++ file stream!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">if</span> (infile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">getline</span>(infile, line)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Read: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        infile.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-文件打开模式（std-ios-base-openmode）"><strong>2. 文件打开模式（<code>std::ios_base::openmode</code>）</strong></h4>
<table>
<thead>
<tr>
<th>模式</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::ios::in</code></td>
<td>输入模式（读取）</td>
</tr>
<tr>
<td><code>std::ios::out</code></td>
<td>输出模式（写入，默认截断文件）</td>
</tr>
<tr>
<td><code>std::ios::app</code></td>
<td>追加模式（写入到文件末尾）</td>
</tr>
<tr>
<td><code>std::ios::ate</code></td>
<td>打开后定位到文件末尾</td>
</tr>
<tr>
<td><code>std::ios::trunc</code></td>
<td>打开时截断文件（若已存在）</td>
</tr>
<tr>
<td><code>std::ios::binary</code></td>
<td>二进制模式（避免文本模式转换）</td>
</tr>
</tbody>
</table>
<h3 id="三、C-17-及以后的文件系统库（-filesystem-）"><strong>三、C++17 及以后的文件系统库（<code>&lt;filesystem&gt;</code>）</strong></h3>
<p>C++17 引入了更现代化的文件系统操作 API，提供路径处理、文件状态检查等功能。</p>
<h4 id="1-文件操作示例"><strong>1. 文件操作示例</strong></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fs::path filePath = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件并写入</span></span><br><span class="line">    <span class="keyword">if</span> (std::ofstream <span class="built_in">file</span>(filePath); file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        file &lt;&lt; <span class="string">&quot;Hello, C++17 filesystem!&quot;</span>;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件状态</span></span><br><span class="line">    <span class="keyword">if</span> (fs::<span class="built_in">exists</span>(filePath)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File size: &quot;</span> &lt;&lt; fs::<span class="built_in">file_size</span>(filePath) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        fs::<span class="built_in">remove</span>(filePath);  <span class="comment">// 删除文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-优势"><strong>2. 优势</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>跨平台</strong>：自动处理不同操作系统的路径分隔符（如 <code>/</code> 和 <code>\</code>）。</p>
</li>
<li class="lvl-2">
<p><strong>异常安全</strong>：使用 RAII 管理资源，避免手动关闭文件。</p>
</li>
<li class="lvl-2">
<p><strong>功能丰富</strong>：支持文件遍历、权限管理、硬链接操作等。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB的使用及常用命令</title>
    <url>/2025/07/12/GDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>如何使用 GDB 调试 C/C++ 程序及常用命令详解</p>
 <span id="more"></span>
<p>GDB（GNU Debugger）是一款功能强大的命令行调试工具，主要用于调试 C、C++、Fortran 等编译型语言的程序。它支持断点设置、变量查看、单步执行、内存检查等核心调试功能，在程序开发、故障定位（如崩溃、逻辑错误）等场景中不可或缺。以下结合不同使用场景、常用命令、注意事项及扩展知识点进行详细介绍。</p>
<h3 id="一、GDB-在不同场景下的使用方法及常用命令">一、GDB 在不同场景下的使用方法及常用命令</h3>
<h4 id="场景-1：基础程序调试（单进程、无复杂逻辑）">场景 1：基础程序调试（单进程、无复杂逻辑）</h4>
<p>适用于调试简单的单文件程序，定位语法外的逻辑错误（如变量计算错误、循环异常等）。</p>
<p><strong>核心流程与命令：</strong></p>
<ol>
<li class="lvl-3">
<p><strong>编译带调试信息的程序</strong><br>
必须在编译时添加<code>-g</code>选项（生成调试符号，包含变量名、行号等信息），否则 GDB 无法正常调试。示例：<code>gcc -g -o test test.c</code>（C 程序）；<code>g++ -g -o test test.cpp</code>（C++ 程序）。</p>
</li>
<li class="lvl-3">
<p><strong>启动 GDB</strong></p>
<ul class="lvl-2">
<li class="lvl-5">命令：<code>gdb ./test</code>（直接启动调试）；或<code>gdb -q ./test</code>（安静模式，不显示 GDB 版本信息）。</li>
<li class="lvl-5">退出 GDB：<code>quit</code>（缩写<code>q</code>）。</li>
<li class="lvl-5">查看命令帮助：<code>help &lt;命令&gt;</code>（缩写<code>h</code>），如<code>help break</code>可查看断点命令说明。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>查看源代码</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><code>list &lt;位置&gt;</code>（缩写<code>l</code>）：显示指定位置的源代码，如<code>l 10</code>显示第 10 行附近代码，<code>l main</code>显示 main 函数代码，默认每次显示 10 行。</li>
<li class="lvl-5"><code>list &lt;start&gt;,&lt;end&gt;</code>：显示从 start 到 end 的源代码，如<code>l 5,20</code>显示 5-20 行。</li>
<li class="lvl-5"><code>show listsize</code>：查看<code>list</code>命令每次显示的行数（默认 10 行）；<code>set listsize &lt;N&gt;</code>：设置每次显示 N 行，如<code>set listsize 20</code>。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>设置断点</strong><br>
断点是调试的核心，用于在指定位置暂停程序执行。</p>
<ul class="lvl-2">
<li class="lvl-5">
<p>基础断点：<code>break 位置</code>（缩写<code>b</code>），位置支持行号（<code>b 10</code>）、文件名 + 行号（<code>b test.c:20</code>）、函数名（<code>b main</code>）、地址（<code>b *0x400520</code>）。</p>
</li>
<li class="lvl-5">
<p>临时断点：<code>tbreak 位置</code>（缩写<code>tb</code>），触发一次后自动删除。</p>
</li>
<li class="lvl-5">
<p>条件断点：<code>break 位置 if 条件</code>，仅当条件满足时中断，如<code>break test.c:20 if i == 10</code>。</p>
</li>
<li class="lvl-5">
<p>断点触发后自动执行命令：<code>break 位置 command &lt;命令序列&gt; end</code>, 如在 test.c:10 设置断点后，自动打印 i 和调用栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b test.c:10</span><br><span class="line">command</span><br><span class="line">p i</span><br><span class="line">bt</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>断点管理</strong></p>
<ul class="lvl-2">
<li class="lvl-5">查看断点：<code>info breakpoints</code>（缩写<code>info b</code>），显示所有断点编号、状态、命中次数等。</li>
<li class="lvl-5">删除断点：<code>delete 断点编号</code>（缩写<code>d</code>），如<code>d 1</code>删除编号 1 的断点；<code>d</code>不带参数删除所有。</li>
<li class="lvl-5">禁用 / 启用断点：<code>disable 断点编号</code>（缩写<code>dis</code>）、<code>enable 断点编号</code>（缩写<code>en</code>）；<code>enable once 断点编号</code>仅生效一次。</li>
<li class="lvl-5">清除指定位置断点：<code>clear &lt;位置&gt;</code>，如<code>clear main</code>删除 main 函数入口的断点。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>运行程序</strong></p>
<ul class="lvl-2">
<li class="lvl-5">启动程序：<code>run [参数]</code>（缩写<code>r</code>），如<code>run 10 20</code>传递命令行参数。</li>
<li class="lvl-5">启动并在 main 函数第一行中断：<code>start</code>。</li>
<li class="lvl-5">程序中断后继续执行：<code>continue</code>（缩写<code>c</code>），执行到下一个断点。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>单步执行</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><code>next</code>（缩写<code>n</code>）：执行当前行，<strong>不进入函数调用</strong>。</li>
<li class="lvl-5"><code>step</code>（缩写<code>s</code>）：执行当前行，<strong>进入函数调用</strong>。</li>
<li class="lvl-5">按汇编指令单步：<code>nexti</code>（<code>ni</code>）、<code>stepi</code>（<code>si</code>），分别对应不进入和进入函数的汇编级执行。</li>
<li class="lvl-5">跳出当前函数：<code>finish</code>，执行完当前函数并返回到调用处。</li>
<li class="lvl-5">执行到指定行：<code>until &lt;行号&gt;</code>（缩写<code>u</code>），适合快速跳过循环。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>查看 / 修改变量</strong></p>
<ul class="lvl-2">
<li class="lvl-5">查看变量 / 表达式：<code>print 变量/表达式</code>（缩写<code>p</code>），如<code>p a + b</code>；按格式打印（<code>x</code>十六进制、<code>d</code>十进制等）：<code>p /x num</code>。</li>
<li class="lvl-5">打印数组：<code>print *数组名@长度</code>，如<code>p *arr@5</code>打印数组前 5 个元素。</li>
<li class="lvl-5">修改变量：<code>set variable 变量名=值</code>（缩写<code>set var</code>），如<code>set var i=5</code>。</li>
<li class="lvl-5">自动显示变量：<code>display 变量名</code>（缩写<code>disp</code>），程序每次中断时自动打印；<code>undisplay 编号</code>取消。</li>
<li class="lvl-5">查看局部变量：<code>info locals</code>；查看函数参数：<code>info args</code>。</li>
<li class="lvl-5">查看变量类型：<code>whatis 变量</code>（如<code>whatis ptr</code>）；查看详细类型定义：<code>ptype 变量/类型</code>（如<code>ptype struct Student</code>）。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>查看调用栈</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><code>backtrace</code>（缩写<code>bt</code>）：查看函数调用链；<code>bt N</code>显示前 N 层，<code>bt -N</code>显示后 N 层。</li>
<li class="lvl-5">切换栈帧：<code>frame N</code>（缩写<code>f N</code>），查看第 N 层栈的局部变量；<code>up &lt;N&gt;</code>、<code>down &lt;N&gt;</code>上下移动栈帧。</li>
<li class="lvl-5">查看当前栈帧详情：<code>info frame</code>（缩写<code>info f</code>）。</li>
</ul>
</li>
</ol>
<h4 id="场景-2：多线程程序调试">场景 2：多线程程序调试</h4>
<p>多线程程序易出现竞态条件、死锁等问题，GDB 提供专门的多线程调试命令。</p>
<p><strong>核心命令：</strong></p>
<ol>
<li class="lvl-3">
<p><strong>查看线程信息</strong>：<code>info threads</code>，显示所有线程编号、状态、当前执行位置（<code>*</code>标记当前线程）。</p>
</li>
<li class="lvl-3">
<p><strong>切换线程</strong>：<code>thread 线程编号</code>，如<code>thread 2</code>切换到线程 2。</p>
</li>
<li class="lvl-3">
<p><strong>对线程执行命令</strong>：<code>thread apply &lt;线程号&gt; &lt;命令&gt;</code>，如<code>thread apply 2 bt</code>打印线程 2 的调用栈；<code>thread apply all bt</code>打印所有线程栈。</p>
</li>
<li class="lvl-3">
<p>控制线程调度：<code>set scheduler-locking [on|off|step]</code></p>
<ul class="lvl-2">
<li class="lvl-5"><code>on</code>：仅当前线程执行，其他线程暂停（避免干扰）；</li>
<li class="lvl-5"><code>off</code>：所有线程正常调度（默认）；</li>
<li class="lvl-5"><code>step</code>：单步执行时仅当前线程移动。</li>
</ul>
</li>
</ol>
<h4 id="场景-3：程序崩溃定位（Core-Dump-调试）">场景 3：程序崩溃定位（Core Dump 调试）</h4>
<p>当程序因内存错误（如段错误）崩溃时，可生成<code>core</code>文件（内存转储），通过 GDB 分析崩溃原因。</p>
<p><strong>核心流程：</strong></p>
<ol>
<li class="lvl-3">
<p><strong>开启 Core Dump 功能</strong></p>
<ul class="lvl-2">
<li class="lvl-5">临时开启：<code>ulimit -c unlimited</code>（当前终端有效）；</li>
<li class="lvl-5">永久开启：修改<code>/etc/security/limits.conf</code>，添加<code>* soft core unlimited</code>（需重启）。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>生成并分析 core 文件</strong><br>
程序崩溃后生成<code>core.PID</code>文件，用 GDB 加载：<code>gdb ./程序名 core文件</code>（如<code>gdb ./test core.12345</code>）。加载后执行<code>backtrace</code>（<code>bt</code>），查看崩溃时的调用栈，定位崩溃位置。</p>
<ul class="lvl-2">
<li class="lvl-5">补充命令：<code>core-file &lt;core文件&gt;</code>，在 GDB 交互界面中加载 core 文件。</li>
</ul>
</li>
</ol>
<h4 id="场景-4：远程调试（如嵌入式设备、服务器程序）">场景 4：远程调试（如嵌入式设备、服务器程序）</h4>
<p>适用于调试运行在远程设备上的程序，本地通过 GDB 连接远程进程。</p>
<p><strong>核心流程：</strong></p>
<ol>
<li class="lvl-3">
<p><strong>远程端启动 GDB Server</strong><br>
远程设备安装<code>gdbserver</code>，启动命令：<code>gdbserver 远程IP:端口 程序名</code>（如<code>gdbserver 192.168.1.100:1234 ./test</code>）。</p>
</li>
<li class="lvl-3">
<p><strong>本地 GDB 连接远程</strong><br>
本地启动 GDB：<code>gdb ./test</code>，执行<code>target remote 远程IP:端口</code>（如<code>target remote 192.168.1.100:1234</code>），连接后即可像调试本地程序一样操作。</p>
</li>
</ol>
<h4 id="场景-5：内存与寄存器调试">场景 5：内存与寄存器调试</h4>
<p>用于直接检查内存数据或 CPU 寄存器状态，适合调试内存错误（如越界、野指针）。</p>
<p><strong>核心命令：</strong></p>
<ol>
<li class="lvl-3">
<p><strong>查看内存</strong>：<code>x/&lt;n&gt;&lt;f&gt;&lt;u&gt; 地址</code>（<code>x</code>即 examine）</p>
<ul class="lvl-2">
<li class="lvl-5"><code>n</code>：单元数；<code>f</code>：格式（x/d/u/o/t/c/f）；<code>u</code>：单元大小（b/h/w/g）。</li>
<li class="lvl-5">示例：<code>x/10xw 0x7fffffffde40</code>（以 16 进制显示 10 个 4 字节单元）；<code>x/s 地址</code>以字符串格式查看。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>查看寄存器</strong></p>
<ul class="lvl-2">
<li class="lvl-5"><code>info registers</code>：显示所有通用寄存器；<code>info registers &lt;寄存器名&gt;</code>：显示指定寄存器（如<code>info registers rip</code>）。</li>
<li class="lvl-5">修改寄存器：<code>set $&lt;寄存器&gt;=&lt;值&gt;</code>，如<code>set $rip=0x400520</code>（谨慎使用）。</li>
</ul>
</li>
</ol>
<h4 id="场景-6：多进程调试">场景 6：多进程调试</h4>
<p>针对<code>fork()</code>创建的多进程程序，控制跟踪父进程或子进程。</p>
<p><strong>核心命令：</strong></p>
<ol>
<li class="lvl-3">
<p><code>set follow-fork-mode [parent|child]</code>：设置<code>fork()</code>后跟踪的进程（默认跟踪父进程）。</p>
</li>
<li class="lvl-3">
<p><code>set detach-on-fork [on|off]</code>：设置是否分离未跟踪的进程（默认分离，未跟踪进程继续运行）。</p>
</li>
<li class="lvl-3">
<p><code>info inferiors</code>：显示所有进程信息；<code>inferior &lt;进程号&gt;</code>：切换到指定进程。</p>
</li>
</ol>
<h3 id="二、GDB-使用注意事项">二、GDB 使用注意事项</h3>
<ol>
<li class="lvl-3">
<p><strong>编译必须带<code>-g</code>选项</strong><br>
若未加<code>-g</code>，GDB 无法识别行号、变量名等调试信息，只能看到汇编代码，失去调试意义。</p>
</li>
<li class="lvl-3">
<p><strong>避免高优化级别编译</strong><br>
用<code>-O2</code>、<code>-O3</code>等优化选项编译时，编译器可能删除变量、重排代码，导致 GDB 无法查看变量或单步混乱。<strong>调试时建议用<code>-O0</code>（无优化）</strong>。</p>
</li>
<li class="lvl-3">
<p><strong>处理信号时需谨慎</strong><br>
程序可能收到信号（如<code>SIGINT</code>、<code>SIGSEGV</code>），默认 GDB 会捕获并中断。可通过<code>handle 信号 动作</code>设置：</p>
<ul class="lvl-2">
<li class="lvl-5">如<code>handle SIGINT nostop</code>（收到<code>Ctrl+C</code>时不中断）；<code>handle SIGSEGV stop print</code>（段错误时中断并打印）。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>区分<code>next</code>与<code>step</code></strong></p>
<ul class="lvl-2">
<li class="lvl-5"><code>next</code>：不进入函数，适合快速跳过；<code>step</code>：进入函数，适合调试函数内部逻辑。新手易混淆导致效率低。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>Core 文件的存储与清理</strong><br>
core 文件可能很大（与程序内存占用一致），生产环境需限制大小（如<code>ulimit -c 1024</code>），并及时清理无用文件。</p>
</li>
<li class="lvl-3">
<p><strong>远程调试需保持程序一致性</strong><br>
本地与远程程序需为同一源码、同一编译选项编译，否则调试信息不匹配。</p>
</li>
</ol>
<h3 id="三、GDB-扩展知识点">三、GDB 扩展知识点</h3>
<h4 id="1-监视点（高级断点）">1. 监视点（高级断点）</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>watch 变量</code>：变量被<strong>修改</strong>时中断；</p>
</li>
<li class="lvl-2">
<p><code>rwatch 变量</code>：变量被<strong>读取</strong>时中断；</p>
</li>
<li class="lvl-2">
<p><code>awatch 变量</code>：变量被<strong>读取或修改</strong>时中断。示例：<code>watch count</code>，当<code>count</code>值变化时自动中断，无需手动设置断点。</p>
</li>
</ul>
<h4 id="2-GDB-脚本与自动化">2. GDB 脚本与自动化</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>.gdbinit</code>配置文件</strong>：启动 GDB 时自动加载，可定义别名或自动执行命令。示例：在<code>~/.gdbinit</code>中添加<code>alias ll = info locals</code>（用<code>ll</code>快速查看局部变量）。</p>
</li>
<li class="lvl-2">
<p>自定义命令：通过 <code>define</code> 命令名</p>
<p>定义批量操作，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define dbg</span><br><span class="line">  bt          # 打印调用栈</span><br><span class="line">  info locals # 打印局部变量</span><br><span class="line">  print i     # 打印变量i</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>执行<code>dbg</code>即可一次性执行上述命令。</p>
</li>
</ul>
<h4 id="3-宏调试">3. 宏调试</h4>
<p>C/C++ 宏在预处理阶段展开，默认 GDB 无法调试。需编译时添加<code>-ggdb3</code>（更详细调试信息）和<code>-fmacro-prefix-map=.=</code>（保留宏路径），然后：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>info macro 宏名</code>：查看宏定义；</p>
</li>
<li class="lvl-2">
<p><code>macro expand 宏调用</code>：查看宏展开结果。</p>
</li>
</ul>
<h4 id="4-断点保存与恢复">4. 断点保存与恢复</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>save breakpoints &lt;文件&gt;</code>：将当前断点保存到文件（如<code>save breakpoints bps.txt</code>）；</p>
</li>
<li class="lvl-2">
<p><code>source &lt;文件&gt;</code>：恢复断点（如<code>source bps.txt</code>）。</p>
</li>
</ul>
<h4 id="5-与-IDE-集成">5. 与 IDE 集成</h4>
<p>GDB 可与 VS Code、Clion 等 IDE 集成，通过图形界面操作（点击设置断点、单步），底层依赖 GDB 核心功能。以 VS Code 为例，需在<code>.vscode/launch.json</code>中配置<code>miDebuggerPath</code>为 GDB 路径。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》王爽----实验七</title>
    <url>/2025/05/04/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%8E%8B%E7%88%BD-%E5%AE%9E%E9%AA%8C%E4%B8%83/</url>
    <content><![CDATA[<blockquote>
<p>《汇编语言》王爽(第四版)第八章 实验7习题解答</p>
</blockquote>
<span id="more"></span>
<h4 id="题目要求">题目要求</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    ;年份</span><br><span class="line">    db &#x27;1975&#x27;, &#x27;1976&#x27;, &#x27;1977&#x27;, &#x27;1978&#x27;, &#x27;1979&#x27;, &#x27;1980&#x27;, &#x27;1981&#x27;, &#x27;1982&#x27;, &#x27;1983&#x27;</span><br><span class="line">    db &#x27;1984&#x27;, &#x27;1985&#x27;, &#x27;1986&#x27;, &#x27;1987&#x27;, &#x27;1988&#x27;, &#x27;1989&#x27;, &#x27;1990&#x27;, &#x27;1991&#x27;, &#x27;1992&#x27;</span><br><span class="line">    db &#x27;1993&#x27;, &#x27;1994&#x27;, &#x27;1995&#x27;</span><br><span class="line">    ;收入</span><br><span class="line">    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514</span><br><span class="line">    dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000</span><br><span class="line">    ;员工</span><br><span class="line">    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226</span><br><span class="line">    dw 11542, 14430, 15257, 17800</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">    db 21 dup (&#x27;year sumn ne ?? &#x27;)</span><br><span class="line">table ends</span><br></pre></td></tr></table></figure>
<p>将 data 段中的数据按如下格式写入到 table 段中，并计算 21 年中的人均收入 (取整), 结果也按照下面的格式保存在 table 段中</p>
<h4 id="提示">提示</h4>
<p>可将data段中的数据看成是多个数组,而将table中的数据看成是一个结构型数据的数组,每个结构型数据中包含多个数据项。</p>
<p>可用di定位table段中对应的存储单元,用idata定位数据项,用si定位data段中的每个元素</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20250504144734255.png" alt="image-20250504144734255"></p>
<h4 id="解答代码">解答代码</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:stack,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    ;年份</span><br><span class="line">    db &#x27;1975&#x27;, &#x27;1976&#x27;, &#x27;1977&#x27;, &#x27;1978&#x27;, &#x27;1979&#x27;, &#x27;1980&#x27;, &#x27;1981&#x27;, &#x27;1982&#x27;, &#x27;1983&#x27;</span><br><span class="line">    db &#x27;1984&#x27;, &#x27;1985&#x27;, &#x27;1986&#x27;, &#x27;1987&#x27;, &#x27;1988&#x27;, &#x27;1989&#x27;, &#x27;1990&#x27;, &#x27;1991&#x27;, &#x27;1992&#x27;</span><br><span class="line">    db &#x27;1993&#x27;, &#x27;1994&#x27;, &#x27;1995&#x27;</span><br><span class="line">    ;收入</span><br><span class="line">    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514</span><br><span class="line">    dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000</span><br><span class="line">    ;员工</span><br><span class="line">    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226</span><br><span class="line">    dw 11542, 14430, 15257, 17800</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">    db 21 dup (&#x27;year sumn ne ?? &#x27;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">main:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,table</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,10H</span><br><span class="line"></span><br><span class="line">;复制年份到table中</span><br><span class="line">	mov si,0</span><br><span class="line">	mov di,0</span><br><span class="line">	mov cx,21</span><br><span class="line">s1:	mov ax,ds:[si]</span><br><span class="line">	mov es:[di],ax</span><br><span class="line">	mov ax,ds:[si+2]</span><br><span class="line">	mov es:[di+2],ax</span><br><span class="line">	mov al,20H ;存储空格到table中的对应位置</span><br><span class="line">	mov es:[di+4],al</span><br><span class="line">	</span><br><span class="line">	add si,4</span><br><span class="line">	add di,10H</span><br><span class="line">	loop s1</span><br><span class="line"></span><br><span class="line">;复制收入到table中</span><br><span class="line">	mov si,84</span><br><span class="line">	mov di,5</span><br><span class="line">	mov cx,21</span><br><span class="line">s2:	mov ax,ds:[si]</span><br><span class="line">	mov es:[di],ax</span><br><span class="line">	mov ax,ds:[si+2]</span><br><span class="line">	mov es:[di+2],ax</span><br><span class="line">	mov al,20H</span><br><span class="line">	mov es:[di+4],al</span><br><span class="line">	</span><br><span class="line">	add si,4</span><br><span class="line">	add di,10H</span><br><span class="line">	loop s2</span><br><span class="line"></span><br><span class="line">;复制人数到table中</span><br><span class="line">	mov si,168</span><br><span class="line">	mov di,10</span><br><span class="line">	mov cx,21</span><br><span class="line">s3:	mov ax,ds:[si]</span><br><span class="line">	mov es:[di],ax</span><br><span class="line">	mov al,20H</span><br><span class="line">	mov es:[di+2],al</span><br><span class="line">	</span><br><span class="line">	add si,2</span><br><span class="line">	add di,10H</span><br><span class="line">	loop s3</span><br><span class="line"></span><br><span class="line">;计算人均收入</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,21</span><br><span class="line">s4:	mov ax,es:[bx+5] ;除数是dw,16位,所以被除数应该是32位,使用DX:AX来存储</span><br><span class="line">	mov dx,es:[bx+7]</span><br><span class="line">	div word ptr es:[bx+10];显式地告诉编译器,除数是16位,字型</span><br><span class="line">	mov es:[bx+13],ax		;商存储在ax中,余数存储在dx中</span><br><span class="line">	mov al,20H</span><br><span class="line">	mov es:[bx+15],al</span><br><span class="line">	</span><br><span class="line">	add bx,10H</span><br><span class="line">	loop s4</span><br><span class="line"></span><br><span class="line">	mov ax,4c00H</span><br><span class="line">	int 21H</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构期末复习</title>
    <url>/2025/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E8%80%83%E7%BA%B2%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>数据结构的期末复习考纲</p>
</blockquote>
<span id="more"></span>
<h1>数据结构期末考纲</h1>
<h2 id="顺序表和链表的类型定义">顺序表和链表的类型定义</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>**顺序表:**用一组<mark>地址连续</mark>的存储单元<mark>依次</mark>存放线性表中的所有元素, 元素的存储位置与逻辑位置是一一对应关系</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SeqList</span>&#123;</span><br><span class="line">    T data[N];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="built_in">SeqList</span>():<span class="built_in">length</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getCapacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IntSeqList = SeqList&lt;<span class="type">int</span>,<span class="number">100</span>&gt;;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>链表:</strong> 用一组地址非连续的存储单元依次存放线性表中的所有元素, 元素间的先后关系利用指针来表示</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>&lt;T&gt;() : <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> LinkList = Node&lt;<span class="type">int</span>&gt;*;</span><br></pre></td></tr></table></figure>
<h2 id="将两个有序的顺序表-链表-合并为一个有序的顺序表-链表-分析合并操作的复杂度">将两个有序的顺序表(链表)合并为一个有序的顺序表(链表) 分析合并操作的复杂度</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>顺序表</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">IntSeqList <span class="title">mergeSeqList</span><span class="params">(IntSeqList&amp; s1, IntSeqList&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        s1 = s2;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s2 == <span class="literal">NULL</span>) <span class="keyword">return</span> s1;</span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> size1 = s1.length;</span><br><span class="line">    <span class="type">int</span> size2 = s2.length;</span><br><span class="line">    <span class="type">int</span> total_size = size1 + size2;</span><br><span class="line"></span><br><span class="line">    IntSeqList new_seqlist;</span><br><span class="line">    new_seqlist.length = total_size;</span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> index1 = <span class="number">0</span>;<span class="type">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index1 &lt; size1 &amp;&amp; index2 &lt; size2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s1.data[index1]&lt;s2.data[index2])  &#123; new_seqlist.data[k] = s1.data[index1]; index1++;&#125;</span><br><span class="line">        <span class="keyword">else</span>  &#123; new_seqlist.data[k] = s2.data[index2]; index2++; &#125;</span><br><span class="line">        k++;         </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(index1 &lt; size1 &amp;&amp; index2 == size2)&#123;</span><br><span class="line">       	<span class="keyword">while</span>(index1 &lt; size1)&#123;</span><br><span class="line">            new_seqlist.data[k] = s1.data[index1];</span><br><span class="line">            k++;</span><br><span class="line">            index1++;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(index1 == size1 &amp;&amp; index2 &lt; size2)&#123;</span><br><span class="line">        <span class="keyword">while</span>(index2 &lt; size2)&#123;</span><br><span class="line">            new_seqlist.data[k] = s2.data[index2];</span><br><span class="line">            k++;</span><br><span class="line">            index2++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="keyword">return</span> new_seqlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**时间复杂度：**O(n + m)</p>
<p>**空间复杂度：**O(n + m)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>链表</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;<span class="type">int</span>&gt;* <span class="title">mergeLinkedList</span><span class="params">(LinkList&amp; l1, LinkList&amp; l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        l1 = l2;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    LinkList cur = l1;</span><br><span class="line"></span><br><span class="line">    LinkList temp1 = l1-&gt;next; LinkList temp2 = l2-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (temp1 &amp;&amp; temp2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp1-&gt;data &lt; temp2-&gt;data) &#123;</span><br><span class="line">            cur-&gt;next = temp1;</span><br><span class="line">            temp1 = temp1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = temp2;</span><br><span class="line">            temp2 = temp2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur-&gt;next = temp1 ? temp1 : temp2;</span><br><span class="line">    <span class="keyword">delete</span> l2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**时间复杂度：**O(n + m)</p>
<p>**空间复杂度：**O(1)</p>
<h2 id="在链表-顺序表-的某个节点后插入一个节点">在链表(顺序表)的某个节点后插入一个节点</h2>
<p><strong>链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(LinkList l, <span class="type">int</span> index, T data)</span> </span>&#123;</span><br><span class="line">    LinkList cur = l;</span><br><span class="line">    <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* new_node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    new_node-&gt;data = data;</span><br><span class="line">    new_node-&gt;next = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>顺序表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(IntSeqList&amp; s, <span class="type">int</span> index, T data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; s.length &amp;&amp; s.length + <span class="number">1</span> &gt; s.<span class="built_in">getCapacity</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            s.data[i + <span class="number">1</span>] = s.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s.data[<span class="number">0</span>] = data;</span><br><span class="line">        s.length++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.length - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        s.data[i + <span class="number">1</span>] = s.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    s.data[index] = data;</span><br><span class="line">    s.length++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将一个链表-顺序表-进行倒置-并分析倒置操作的复杂度">将一个链表(顺序表)进行倒置 并分析倒置操作的复杂度</h2>
<p><strong>链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseLL</span><span class="params">(LinkList l)</span></span>&#123;</span><br><span class="line">    LinkList pre = <span class="literal">nullptr</span>;</span><br><span class="line">    LinkList cur = l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        LinkList temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    l = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**时间复杂度：**O(n)</p>
<p>**空间复杂度：**O(1)</p>
<p><strong>顺序表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseSeq</span><span class="params">(IntSeqList&amp; s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>; <span class="type">int</span> j = s.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="type">int</span> temp  = s.data[j];</span><br><span class="line">        s.data[j] = s.data[i];</span><br><span class="line">        s.data[i] = temp;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**时间复杂度：**O(n)</p>
<p>**空间复杂度：**O(1)</p>
<h2 id="无向图的链接表表示法和邻接矩阵表示法">无向图的链接表表示法和邻接矩阵表示法</h2>
<p><strong>邻接矩阵表示法:</strong> 利用二维数组来表示一个图,二维数组中的每一个元素表示相应的两个顶点之间的关系</p>
<p>​			     无向图的邻接矩阵为对称矩阵</p>
<p><strong>链接表表示法:</strong> 将图的每一个顶点的邻接点存放在一个链表中 每个顶点对应一条链表,所有的头节点存放在一个数组中</p>
<h2 id="利用DFS或BFS求一个图的连通分量数">利用DFS或BFS求一个图的连通分量数</h2>
<p><strong>DFS</strong></p>
<p>递归版(图利用<em>邻接矩阵</em>来表示)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected,vector&lt;<span class="type">int</span>&gt;&amp; visited,<span class="type">int</span> row)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;isConnected.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(isConnected[row][i]&amp;&amp;!visited[i])&#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(isConnected,visited,i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(isConnected.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;isConnected.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">     	<span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="built_in">DFS</span>(isConnected,visited,i);</span><br><span class="line">            num++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(isConnected.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; isConnected.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> temp = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                visited[temp] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; isConnected.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(isConnected[temp][j] &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                        s.<span class="built_in">push</span>(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BFS</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(isConnected.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; isConnected.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                visited[temp] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; isConnected.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (isConnected[temp][j] &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                       q.<span class="built_in">push</span>(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="利用Floyd算法求图的任意两点的最短距离，图的传递闭包-Floyd-Warshall">利用Floyd算法求图的任意两点的最短距离，图的传递闭包(Floyd-Warshall)</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    grid = matrix;</span><br><span class="line">    <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n;K++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n;j++)&#123;</span><br><span class="line">                grid[i][j]=<span class="built_in">min</span>(grid[i][j],grid[i][k]+grid[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递闭包(使用前需将矩阵转换为使用0和1表达的矩阵)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floydWarshall</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                matrix[i][j] |= matrix[i][k] &amp; matrix[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断两个左右链表表示的二叉树是否等价-并分析时间复杂度">判断两个左右链表表示的二叉树是否等价 并分析时间复杂度</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**时间复杂度：**O(n)</p>
<h2 id="将一个整数序列转化为大顶堆-小顶堆-的过程描述">将一个整数序列转化为大顶堆(小顶堆)的过程描述</h2>
<p><strong>大顶堆</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将此整数序列看作一棵完全二叉树的数组形式</p>
</li>
<li class="lvl-2">
<p>从最后一个非叶节点开始进行下沉操作,保证父节点大于子节点,使其堆化</p>
</li>
<li class="lvl-2">
<p>倒序遍历每个节点,重复上述操作 直至根节点</p>
</li>
</ul>
<h2 id="删除堆顶-大顶堆或小顶堆-的过程描述">删除堆顶(大顶堆或小顶堆)的过程描述</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>将堆顶元素与堆中最后一个元素互换</p>
</li>
<li class="lvl-2">
<p>删除最后一个元素</p>
</li>
<li class="lvl-2">
<p>从堆顶元素开始,从顶至底进行下沉操作使其堆化</p>
</li>
</ul>
<h2 id="构建哈夫曼树的过程-并计算带权路径长度">构建哈夫曼树的过程, 并计算带权路径长度</h2>
<p>假设给了n个元素</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将这n个元素看作n棵只有一个节点的二叉树,他们构成了森林F</p>
</li>
<li class="lvl-2">
<p>从森林F中选择两个权值最小的节点(树)构成一个新树, 新树的根节点的权值为这两个节点权值的和</p>
</li>
<li class="lvl-2">
<p>将这颗新树加入到森林F中 并删除F中的那两个被合并的节点</p>
</li>
<li class="lvl-2">
<p>重复上述过程 直至森林中只剩下一个树 该树即为哈夫曼树</p>
</li>
</ul>
<p>**带权路径长度:**每个叶节点的权值与其到根节点的路径长度的乘积之和</p>
<h2 id="利用栈求逆波兰表达式的值">利用栈求逆波兰表达式的值</h2>
<p>假设该逆波兰表达式符合规范</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将该表达式中的元素依次遍历</p>
</li>
<li class="lvl-2">
<p>如果该元素是操作数 那么压入栈中 继续遍历下一个元素</p>
</li>
<li class="lvl-2">
<p>如果该元素是操作符 那么从栈中弹出所需数量的元素进行计算 并将计算结果压入栈中</p>
</li>
<li class="lvl-2">
<p>重复上述操作 直至遍历玩表达式中所有元素 栈顶元素即为该表达式的结果</p>
</li>
</ul>
<h2 id="最小生成树的构建方法">最小生成树的构建方法</h2>
<p><strong>Prim</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>构造一个名为minDist的数组,用来记录每个节点距离生成树的最短距离,长度为n,n为顶点的数量</p>
</li>
<li class="lvl-2">
<p>构造一个名为visited的数组,用来记录哪些节点已经被添加到最小生成树中,长度为n</p>
</li>
<li class="lvl-2">
<p>随机选择一个节点作为第一个节点加入到最小生成树中并将其在visited数组中标记为true</p>
</li>
<li class="lvl-2">
<p>更新minDist数组 即更新未被visited数组标记的节点到生成树的距离</p>
</li>
<li class="lvl-2">
<p>选择minDist数组中值最小且未被visited数组标记的节点加入生成树 并将该节点标记为true</p>
</li>
<li class="lvl-2">
<p>重复上述过程n-1次即可完成构建</p>
</li>
</ul>
<p><strong>Kruskal</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将图中的边按照权值由小到大进行排序</p>
</li>
<li class="lvl-2">
<p>初始化并查集,使每个顶点自成一个集合</p>
</li>
<li class="lvl-2">
<p>对排序后的边进行遍历</p>
</li>
<li class="lvl-2">
<p>利用并查集判断该边的两个顶点是否在同一个集合中</p>
</li>
<li class="lvl-2">
<p>如果在 则不能将此边加入生成树 否则会形成环</p>
</li>
<li class="lvl-2">
<p>如果不在 则将此边加入生成树 并将这两个顶点所在的集合合并</p>
</li>
<li class="lvl-2">
<p>重复上述过程 直至生成树中有n-1条边(n为顶点数目) 或遍历结束</p>
</li>
</ul>
<h2 id="利用Dijkstra求单源最短距离和最短路径-了解U-d和p的含义-如何根据p求到每一个顶点到源点的最短路径">利用Dijkstra求单源最短距离和最短路径,了解U d和p的含义;如何根据p求到每一个顶点到源点的最短路径</h2>
<p>**U:**已经求出与源点的最短距离的顶点的集合</p>
<p>**d:**用来存放顶点到源点最短距离的数组,d[i]代表顶点i到源点的最短距离</p>
<p>**p:**用来存放最短路径树中每个节点的父节点的数组,p[i]代表最短路径树中节点i的父节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPath</span><span class="params">(<span class="type">int</span> p[N],<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v==p[v])&#123;</span><br><span class="line">        cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getPath</span>(p,p[v]);</span><br><span class="line">    cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序和关键路径的求法">拓扑排序和关键路径的求法</h2>
<p><strong>拓扑排序</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义一个队列q,统计图中每一个顶点的入度,将入度为零的顶点加入队列q中</p>
</li>
<li class="lvl-2">
<p>从队列q中取出一个顶点u,将其加入到拓扑序列中</p>
</li>
<li class="lvl-2">
<p>遍历顶点u的所有出边,将这些相邻点的入度减一,若其入度变为零,则将其加入到队列q中</p>
</li>
<li class="lvl-2">
<p>重复上述步骤,直至队列q为空</p>
</li>
<li class="lvl-2">
<p>如果队列q为空时 仍有顶点未加入到拓扑序列中 说明该图存在环 不存在拓扑序列</p>
</li>
</ul>
<p><strong>关键路径</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对图中各顶点进行拓扑排序，得到拓扑序列</p>
</li>
<li class="lvl-2">
<p>按照拓扑序列的顺序 依次计算每个事件的最早发生时间</p>
</li>
<li class="lvl-2">
<p>再根据每个事件的最早发生时间 求出每个活动的最早发生时间</p>
</li>
<li class="lvl-2">
<p>按照逆拓扑序 依次计算每个事件的最晚发生时间</p>
</li>
<li class="lvl-2">
<p>遍历每一个活动，计算其最早发生时间与最晚发生时间之差 若为零 则将该活动加入关键路径</p>
</li>
</ul>
<h2 id="二分查找及其复杂度分析">二分查找及其复杂度分析</h2>
<p>主要部分与插值查找相同 不同点为 mid = left+0.5*(right-left)</p>
<p>时间复杂度为 <strong>O(log n)</strong></p>
<p>空间复杂度为 <strong>O(1)</strong></p>
<h2 id="插值查找">插值查找</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>确定被查找目标所在的范围边界,左边界记为left,右边界记为right</p>
</li>
<li class="lvl-2">
<p>设置查找点下标为 $mid=left+ (key-array[left]/array[right]-array[left])*(right-left)$</p>
</li>
<li class="lvl-2">
<p>开始循环 保证left不大于right</p>
</li>
<li class="lvl-2">
<p>判断以mid为下标的数组元素是否等于目标值</p>
</li>
<li class="lvl-2">
<p>如果等于 则找到目标 退出循环</p>
</li>
<li class="lvl-2">
<p>如果大于目标元素 则令right = mid - 1</p>
</li>
<li class="lvl-2">
<p>如果小于目标元素 则另left = mid + 1</p>
</li>
<li class="lvl-2">
<p>按照以上描述进行循环直至找到目标值 或不满足循环条件时退出循环</p>
</li>
</ul>
<p>时间复杂度是<strong>O(loglogN)</strong></p>
<p>当<mark>有序序列中的元素呈均匀分布时</mark>插值查找优于二分查找</p>
<h2 id="KMP算法">KMP算法</h2>
<p>令模式串为t 主串为s</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义两个整数i，j 分别表示主串和模式串的下标，初始值设置为0</p>
</li>
<li class="lvl-2">
<p>当j == -1 或 t[j] == s[i]时 i和j同时加一 即同时向后移动一位</p>
</li>
<li class="lvl-2">
<p>如果t[j] != s[i]时 令j=next[j]</p>
</li>
<li class="lvl-2">
<p>重复上述过程直至遍历完i主串或j遍历完模式串</p>
</li>
</ul>
<p><strong>next数组</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用整数j作为下标来遍历模式串</p>
</li>
<li class="lvl-2">
<p>令next[j] = 第j位的公共最长真前后缀的长度 特别规定next[0]=-1</p>
</li>
</ul>
<p><strong>优化next数组</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在上一个方法求next数组的基础之上 在j遍历模式串s的过程中添加如下判断</p>
</li>
<li class="lvl-2">
<p>判断 t[j]是否等于t[next[j]]</p>
</li>
<li class="lvl-2">
<p>如果等于 则令next[j] = next[next[j]]</p>
</li>
</ul>
<h2 id="二叉查找树">二叉查找树</h2>
<p><strong>特点</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于根节点，若它的左右子树不为空, 则左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值</p>
</li>
<li class="lvl-2">
<p>若它的左右子树都不为空,  则它的左右子树也分别为二叉查找树</p>
</li>
</ul>
<p><strong>构建二叉查找树</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将序列的第一个元素作为二叉查找树的根节点</p>
</li>
<li class="lvl-2">
<p>接着依次遍历序列中的剩余元素,并将该元素作为新节点</p>
</li>
<li class="lvl-2">
<p>如果新节点的值小于当前节点的值，则新节点应插入到左子树中</p>
</li>
<li class="lvl-2">
<p>如果新节点的值大于当前节点的值，则新节点应插入到右子树中</p>
</li>
<li class="lvl-2">
<p>重复上两个步骤，直到找到合适的叶子位置, 将其插入树中</p>
</li>
<li class="lvl-2">
<p>对序列中的每个元素进行如上操作直至遍历结束 至此二叉查找树构建完成</p>
</li>
</ul>
<h2 id="AVL树">AVL树</h2>
<p><strong>四种基本形式及对应变形操作</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>LL旋转</strong></p>
<p>假设节点A是失衡的节点，节点B是A的左子节点，节点C是B的右子节点</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>B变为新的根节点。</p>
</li>
<li class="lvl-5">
<p>A成为B的右子节点。</p>
</li>
<li class="lvl-4">
<p>C（如果存在）成为A的左子节点</p>
</li>
</ul>
<img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20250108161439866.png" alt="image-20250108161439866" style="zoom: 50%; float:left" >
</li>
<li class="lvl-2">
<p><strong>RR旋转</strong></p>
</li>
</ul>
<p>​	与LL操作反之</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>LR旋转</strong></p>
</li>
</ul>
<p>​	假设节点A是失衡的节点，节点B是A的左子节点</p>
<p>​	首先对A的左子节点B进行RR旋转，然后对A进行LL旋转</p>
<img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20250108161749530.png" alt="image-20250108161749530" style="zoom:50%;float:left" />
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>RL旋转</strong></p>
</li>
</ul>
<p>​	与LR反之</p>
<p><strong>构建AVL树</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将给定数据集的第一个元素作为AVL树的根节点</p>
</li>
<li class="lvl-2">
<p>按照二叉查找树的方式插入新的节点</p>
</li>
<li class="lvl-2">
<p>每次插入新节点后，更新该节点及其祖先节点的高度</p>
</li>
<li class="lvl-2">
<p>在每次插入操作后，计算当前节点及其祖先节点的平衡因子（左子树高度减去右子树高度）。</p>
</li>
<li class="lvl-2">
<p>如果平衡因子的绝对值大于1，则该节点失衡, 根据失衡节点的具体情况进行对应的旋转操作</p>
</li>
<li class="lvl-2">
<p>重复上述过程 直至所有元素被添加到AVL树中</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>书生大模型---微调</title>
    <url>/2024/09/29/%E4%B9%A6%E7%94%9F%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Lv1-2/</url>
    <content><![CDATA[<blockquote>
<p>利用XTuner微调预训练模型</p>
</blockquote>
<span id="more"></span>
<h2 id="Lv1-XTuner微调大模型">Lv1-XTuner微调大模型</h2>
<h3 id="1-准备环境和依赖">1. <strong>准备环境和依赖</strong></h3>
<p>XTuner的运行依赖于一系列的库和工具，主要包括<code>transformers</code>、<code>torch</code>等深度学习框架。在开始之前，你需要确保安装好这些依赖：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>安装Python 3.8或更高版本。</p>
</li>
<li class="lvl-2">
<p>安装基础依赖库：运行以下命令下载并安装依赖。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>确保你拥有兼容的GPU环境，以提高模型训练速度。如果使用的是NVIDIA GPU，安装CUDA和cuDNN并验证PyTorch的GPU支持。</p>
</li>
</ul>
<h3 id="2-加载预训练模型">2. <strong>加载预训练模型</strong></h3>
<p>XTuner的核心功能是对已有的预训练模型进行微调。通常情况下，大语言模型（如GPT、BERT等）已经具备强大的通用语言能力，但针对具体任务时需要进行额外的微调。</p>
<h4 id="选择模型：">选择模型：</h4>
<p>XTuner支持使用Hugging Face的<code>transformers</code>库来加载预训练模型。以下代码展示了如何加载GPT-2模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, AutoTokenizer</span><br><span class="line"></span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(<span class="string">&quot;gpt2&quot;</span>)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;gpt2&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在实际操作中，你可以根据任务需求选择其他预训练模型，例如BERT、T5等。</p>
<h3 id="3-准备数据集">3. <strong>准备数据集</strong></h3>
<p>微调过程需要使用特定任务的数据集。XTuner支持常见的文本分类、生成、翻译等任务的数据集。你可以选择公开数据集（例如：SQuAD、GLUE、CoNLL等），也可以使用自定义数据。</p>
<h4 id="数据预处理：">数据预处理：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先，将数据集整理为模型能够接受的格式。数据通常是输入（如文本）与目标标签（如类别、输出文本）组成的对。</p>
</li>
<li class="lvl-2">
<p>对数据进行tokenization，即将文本数据转化为模型输入的token ID。Hugging Face的tokenizer能够自动完成这一步：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = tokenizer(<span class="string">&quot;This is a test sentence.&quot;</span>, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>你也可以使用<code>datasets</code>库轻松加载数据并进行tokenization:</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line"></span><br><span class="line">dataset = load_dataset(<span class="string">&#x27;your_dataset&#x27;</span>)</span><br><span class="line">tokenized_dataset = dataset.<span class="built_in">map</span>(<span class="keyword">lambda</span> e: tokenizer(e[<span class="string">&#x27;text&#x27;</span>], truncation=<span class="literal">True</span>, padding=<span class="string">&#x27;max_length&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-定义微调任务">4. <strong>定义微调任务</strong></h3>
<p>XTuner允许你根据不同的任务选择不同的模型结构和训练策略。一般来说，语言模型的最后一层需要调整为符合具体任务需求。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>文本分类</strong>：为BERT等模型添加一个分类器层（如线性层），用于预测标签。</p>
</li>
<li class="lvl-2">
<p><strong>文本生成</strong>：GPT模型可以直接用于生成任务，只需定义损失函数。</p>
</li>
<li class="lvl-2">
<p><strong>翻译任务</strong>：类似于T5等预训练模型，可以用于翻译任务，通过提供源文本与目标文本对进行训练。</p>
</li>
</ul>
<p>你可以根据任务需要自定义这些模型结构。</p>
<h3 id="5-配置训练参数">5. <strong>配置训练参数</strong></h3>
<p>XTuner提供了灵活的配置方式，可以通过配置文件或命令行参数指定训练的超参数。你需要调整如下超参数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>学习率</strong>：通常设置在1e-5到5e-5之间，具体值依赖于任务和模型。</p>
</li>
<li class="lvl-2">
<p><strong>批次大小</strong>：通常GPU内存较大时，批次大小可以设置得较大，推荐设置为16或32。</p>
</li>
<li class="lvl-2">
<p><strong>训练轮数</strong>：通常选择2到5轮训练，过多的训练轮数可能导致过拟合。</p>
</li>
<li class="lvl-2">
<p><strong>优化器</strong>：AdamW是最常见的优化器，它处理权重衰减问题并提高训练稳定性。</p>
</li>
</ul>
<h4 id="示例配置：">示例配置：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python train.py --model_name_or_path gpt2 --dataset your_dataset --learning_rate 2e-5 --batch_size 16 --num_train_epochs 3 --output_dir ./output</span><br></pre></td></tr></table></figure>
<h3 id="6-启动训练">6. <strong>启动训练</strong></h3>
<p>在设置完所有参数后，便可以使用XTuner开始训练。XTuner提供了一套自动化的训练流程，包含数据加载、模型构建、训练与评估等步骤。启动训练的典型命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python train.py --model_name_or_path gpt2 --dataset your_dataset --output_dir /path/to/output</span><br></pre></td></tr></table></figure>
<p>在训练过程中，XTuner会自动计算损失函数、梯度下降等关键步骤，输出模型性能评估指标（如准确率、困惑度等）。你可以通过观察训练日志了解模型训练的进展情况。</p>
<h3 id="7-评估和保存模型">7. <strong>评估和保存模型</strong></h3>
<p>训练完成后，XTuner会自动保存微调后的模型，保存的路径由<code>--output_dir</code>指定。你可以通过验证集对微调模型进行评估。评估指标通常根据任务类型而定，例如：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>分类任务可以使用准确率和F1值。</p>
</li>
<li class="lvl-2">
<p>文本生成任务通常使用困惑度（Perplexity）来评估模型的生成能力。</p>
</li>
</ul>
<h4 id="模型保存与加载：">模型保存与加载：</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.save_pretrained(<span class="string">&quot;/path/to/save&quot;</span>)</span><br><span class="line">tokenizer.save_pretrained(<span class="string">&quot;/path/to/save&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>加载模型时，可以直接从保存路径重新加载：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = AutoModelForCausalLM.from_pretrained(<span class="string">&quot;/path/to/save&quot;</span>)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;/path/to/save&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="8-推理与应用">8. <strong>推理与应用</strong></h3>
<p>完成微调后，模型便可以应用于推理任务。使用相同的tokenizer对输入文本进行处理，然后利用模型生成预测结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = tokenizer(<span class="string">&quot;Translate this sentence to French.&quot;</span>, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line">outputs = model.generate(inputs[<span class="string">&#x27;input_ids&#x27;</span>])</span><br><span class="line">generated_text = tokenizer.decode(outputs[<span class="number">0</span>], skip_special_tokens=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>书生大模型---RAG实践</title>
    <url>/2024/09/29/%E4%B9%A6%E7%94%9F%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Lv1-1/</url>
    <content><![CDATA[<blockquote>
<p>RAG实践</p>
</blockquote>
<span id="more"></span>
<h2 id="Lv1-llamaindex-Internlm2-RAG实践">Lv1-llamaindex+Internlm2 RAG实践</h2>
<h3 id="1-RAG简介">1. RAG简介</h3>
<p>RAG（Retrieval-Augmented Generation）技术是一种结合了信息检索和文本生成的技术，旨在通过检索<strong>外部知识库</strong>来增强生成模型的能力</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240917153812231.png" alt="image-20240917153812231"></p>
<p><strong>1.1 RAG优化方法</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240917153925082.png" alt="image-20240917153925082"></p>
<h3 id="2-搭建环境">2. 搭建环境</h3>
<p><strong>2.1 相关基础依赖python虚拟环境</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate llamaindex</span><br><span class="line">conda install pytorch==2.0.1 torchvision==0.15.2 torchaudio==2.0.2 pytorch-cuda=11.7 -c pytorch -c nvidia</span><br><span class="line"></span><br><span class="line">pip install einops==0.7.0 protobuf==5.26.1</span><br></pre></td></tr></table></figure>
<p><strong>2.2 安装 Llamaindex和相关包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate llamaindex</span><br><span class="line">pip install llama-index==0.10.38 llama-index-llms-huggingface==0.2.0 <span class="string">&quot;transformers[torch]==4.41.1&quot;</span> <span class="string">&quot;huggingface_hub[inference]==0.23.1&quot;</span> huggingface_hub==0.23.1 sentence-transformers==2.7.0 sentencepiece==0.2.0</span><br></pre></td></tr></table></figure>
<p><strong>2.3 下载 Sentence Transformer 模型</strong></p>
<p>源词向量模型 <a href="https://huggingface.co/sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2">Sentence Transformer</a>:（也可以选用别的开源词向量模型来进行 Embedding） 运行以下指令，新建一个python文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> llamaindex_demo</span><br><span class="line"><span class="built_in">mkdir</span> model</span><br><span class="line"><span class="built_in">cd</span> ~/llamaindex_demo</span><br><span class="line"><span class="built_in">touch</span> download_hf.py</span><br></pre></td></tr></table></figure>
<p>打开<code>download_hf.py</code> 贴入以下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">os.environ[<span class="string">&#x27;HF_ENDPOINT&#x27;</span>] = <span class="string">&#x27;https://hf-mirror.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载模型</span></span><br><span class="line">os.system(<span class="string">&#x27;huggingface-cli download --resume-download sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2 --local-dir /root/model/sentence-transformer&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>然后，在 /root/llamaindex_demo 目录下执行该脚本即可自动开始下载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/llamaindex_demo</span><br><span class="line">conda activate llamaindex</span><br><span class="line">python download_hf.py</span><br></pre></td></tr></table></figure>
<p>更多关于镜像使用可以移步至 <a href="https://hf-mirror.com/">HF Mirror</a> 查看。</p>
<p><strong>2.4 下载 NLTK 相关资源</strong></p>
<p>我们在使用开源词向量模型构建开源词向量的时候，需要用到第三方库 <code>nltk</code> 的一些资源。正常情况下，其会自动从互联网上下载，但可能由于网络原因会导致下载中断，此处我们可以从国内仓库镜像地址下载相关资源，保存到服务器上。 我们用以下命令下载 nltk 资源并解压到服务器上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/yzy0612/nltk_data.git  --branch gh-pages</span><br><span class="line"><span class="built_in">cd</span> nltk_data</span><br><span class="line"><span class="built_in">mv</span> packages/*  ./</span><br><span class="line"><span class="built_in">cd</span> tokenizers</span><br><span class="line">unzip punkt.zip</span><br><span class="line"><span class="built_in">cd</span> ../taggers</span><br><span class="line">unzip averaged_perceptron_tagger.zip</span><br></pre></td></tr></table></figure>
<p><strong>2.5 安装词嵌入向量依赖</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate llamaindex</span><br><span class="line">pip install llama-index-embeddings-huggingface==0.2.0 llama-index-embeddings-instructor==0.1.3</span><br></pre></td></tr></table></figure>
<p><strong>2.6 准备知识库</strong></p>
<p>你所需要检索的文件</p>
<p><strong>2.7 引入模型 编写相关代码</strong></p>
<p>详情请<a href="https://github.com/InternLM/Tutorial/blob/camp3/docs/L1/LlamaIndex/readme.md">参考</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">from</span> llama_index.core <span class="keyword">import</span> VectorStoreIndex, SimpleDirectoryReader, Settings</span><br><span class="line"><span class="keyword">from</span> llama_index.embeddings.huggingface <span class="keyword">import</span> HuggingFaceEmbedding</span><br><span class="line"><span class="keyword">from</span> llama_index.llms.huggingface <span class="keyword">import</span> HuggingFaceLLM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Streamlit应用的页面标题和图标</span></span><br><span class="line">st.set_page_config(page_title=<span class="string">&quot;llama_index_demo&quot;</span>, page_icon=<span class="string">&quot;🦜🔗&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在页面上显示标题</span></span><br><span class="line">st.title(<span class="string">&quot;llama_index_demo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型的函数，使用Streamlit的缓存机制来节约资源（防止每次交互时重新加载模型）</span></span><br><span class="line"><span class="meta">@st.cache_resource</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_models</span>():</span><br><span class="line">    <span class="comment"># 加载嵌入模型，使用HuggingFace的sentence-transformer</span></span><br><span class="line">    embed_model = HuggingFaceEmbedding(</span><br><span class="line">        model_name=<span class="string">&quot;/root/model/sentence-transformer&quot;</span>  <span class="comment"># 指定模型的路径</span></span><br><span class="line">    )</span><br><span class="line">    Settings.embed_model = embed_model  <span class="comment"># 设置全局的嵌入模型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 加载语言模型（LLM），指定HuggingFace模型及其对应的分词器</span></span><br><span class="line">    llm = HuggingFaceLLM(</span><br><span class="line">        model_name=<span class="string">&quot;/root/model/internlm2-chat-1_8b&quot;</span>,  <span class="comment"># 指定生成模型的路径</span></span><br><span class="line">        tokenizer_name=<span class="string">&quot;/root/model/internlm2-chat-1_8b&quot;</span>,  <span class="comment"># 指定分词器的路径</span></span><br><span class="line">        model_kwargs=&#123;<span class="string">&quot;trust_remote_code&quot;</span>: <span class="literal">True</span>&#125;,  <span class="comment"># 允许远程代码的信任</span></span><br><span class="line">        tokenizer_kwargs=&#123;<span class="string">&quot;trust_remote_code&quot;</span>: <span class="literal">True</span>&#125;  <span class="comment"># 同样允许分词器的远程代码信任</span></span><br><span class="line">    )</span><br><span class="line">    Settings.llm = llm  <span class="comment"># 设置全局的语言模型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取存储在指定目录下的文档数据，并加载为一个文档对象列表</span></span><br><span class="line">    documents = SimpleDirectoryReader(<span class="string">&quot;/root/llamaindex_demo/data&quot;</span>).load_data()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建向量检索索引，将文档转换为向量并构建检索索引</span></span><br><span class="line">    index = VectorStoreIndex.from_documents(documents)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将向量索引转化为查询引擎，用于后续查询</span></span><br><span class="line">    query_engine = index.as_query_engine()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回查询引擎</span></span><br><span class="line">    <span class="keyword">return</span> query_engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查session_state中是否已经存在查询引擎，如果不存在则初始化</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;query_engine&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state[<span class="string">&#x27;query_engine&#x27;</span>] = init_models()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义问答函数，用于基于问题生成回复</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet2</span>(<span class="params">question</span>):</span><br><span class="line">    <span class="comment"># 使用查询引擎根据用户问题返回结果</span></span><br><span class="line">    response = st.session_state[<span class="string">&#x27;query_engine&#x27;</span>].query(question)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化聊天记录，若没有则创建，并在首次交互时显示欢迎语</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;messages&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state.keys():</span><br><span class="line">    st.session_state.messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你好，我是你的助手，有什么我可以帮助你的吗？&quot;</span>&#125;]    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示消息记录，遍历session_state中的消息并展示在页面上</span></span><br><span class="line"><span class="keyword">for</span> message <span class="keyword">in</span> st.session_state.messages:</span><br><span class="line">    <span class="comment"># 根据消息的角色显示聊天气泡，角色可以是&quot;user&quot;或&quot;assistant&quot;</span></span><br><span class="line">    <span class="keyword">with</span> st.chat_message(message[<span class="string">&quot;role&quot;</span>]):</span><br><span class="line">        st.write(message[<span class="string">&quot;content&quot;</span>])  <span class="comment"># 显示消息内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除聊天历史记录的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear_chat_history</span>():</span><br><span class="line">    <span class="comment"># 重置聊天记录为最初的欢迎消息</span></span><br><span class="line">    st.session_state.messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你好，我是你的助手，有什么我可以帮助你的吗？&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在侧边栏中添加一个按钮，点击后调用清除聊天历史记录的函数</span></span><br><span class="line">st.sidebar.button(<span class="string">&#x27;Clear Chat History&#x27;</span>, on_click=clear_chat_history)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义生成回复的函数，通过问答接口调用查询引擎</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_llama_index_response</span>(<span class="params">prompt_input</span>):</span><br><span class="line">    <span class="keyword">return</span> greet2(prompt_input)  <span class="comment"># 返回基于用户输入的生成内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查用户是否输入了新的问题</span></span><br><span class="line"><span class="keyword">if</span> prompt := st.chat_input():</span><br><span class="line">    <span class="comment"># 将用户的输入作为消息添加到session_state的消息列表中</span></span><br><span class="line">    st.session_state.messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: prompt&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 显示用户输入的消息</span></span><br><span class="line">    <span class="keyword">with</span> st.chat_message(<span class="string">&quot;user&quot;</span>):</span><br><span class="line">        st.write(prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果上一条消息不是助手的回复，则生成助手的回复</span></span><br><span class="line"><span class="keyword">if</span> st.session_state.messages[-<span class="number">1</span>][<span class="string">&quot;role&quot;</span>] != <span class="string">&quot;assistant&quot;</span>:</span><br><span class="line">    <span class="keyword">with</span> st.chat_message(<span class="string">&quot;assistant&quot;</span>):</span><br><span class="line">        <span class="comment"># 使用加载中的提示效果，表示助手在“思考中”</span></span><br><span class="line">        <span class="keyword">with</span> st.spinner(<span class="string">&quot;Thinking...&quot;</span>):</span><br><span class="line">            <span class="comment"># 调用生成回复的函数，基于用户的输入生成回答</span></span><br><span class="line">            response = generate_llama_index_response(prompt)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 创建一个临时占位符，用于显示生成的回复</span></span><br><span class="line">            placeholder = st.empty()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将生成的回复以Markdown的格式显示在页面上</span></span><br><span class="line">            placeholder.markdown(response)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将助手的回复作为新的消息追加到消息列表中</span></span><br><span class="line">    message = &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: response&#125;</span><br><span class="line">    st.session_state.messages.append(message)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>书生大模型--提示词工程</title>
    <url>/2024/09/29/%E4%B9%A6%E7%94%9F%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Lv1/</url>
    <content><![CDATA[<blockquote>
<p>搭建环境、部署模型、提示词工程</p>
</blockquote>
<span id="more"></span>
<h2 id="Lv1-部署模型">Lv1-部署模型</h2>
<h3 id="1-搭建环境">1. 搭建环境</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建环境</span></span><br><span class="line">conda create -n demo python=3.10 -y</span><br><span class="line"><span class="comment"># 激活环境</span></span><br><span class="line">conda activate demo</span><br><span class="line"><span class="comment"># 安装 torch</span></span><br><span class="line">conda install pytorch==2.1.2 torchvision==0.16.2 torchaudio==2.1.2 pytorch-cuda=12.1 -c pytorch -c nvidia -y</span><br><span class="line"><span class="comment"># 安装其他依赖</span></span><br><span class="line">pip install transformers==4.38</span><br><span class="line">pip install sentencepiece==0.1.99</span><br><span class="line">pip install einops==0.8.0</span><br><span class="line">pip install protobuf==5.27.2</span><br><span class="line">pip install accelerate==0.33.0</span><br><span class="line">pip install streamlit==1.37.0</span><br></pre></td></tr></table></figure>
<h3 id="2-利用cli-demo-py-部署-InternLM2-Chat-1-8B-模型">2. 利用cli_demo.py 部署 InternLM2-Chat-1.8B 模型</h3>
<p>首先创建存放cli_demo.py的文件</p>
<p>接着编写cli_demo.py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 PyTorch 库和 Hugging Face Transformers 库中的 AutoTokenizer 和 AutoModelForCausalLM</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModelForCausalLM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型路径，指向存储模型文件的本地路径</span></span><br><span class="line">model_name_or_path = <span class="string">&quot;/root/share/new_models/Shanghai_AI_Laboratory/internlm2-chat-1_8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载预训练的分词器（Tokenizer）</span></span><br><span class="line"><span class="comment"># `AutoTokenizer` 是 Transformers 库中的类，它会自动从模型路径中加载适合该模型的分词器</span></span><br><span class="line"><span class="comment"># `trust_remote_code=True` 表示允许从远程存储库加载自定义代码，这里启用自定义 tokenizer</span></span><br><span class="line"><span class="comment"># `device_map=&#x27;cuda:0&#x27;` 将分词器和模型放置在 GPU 上的第 0 号设备上</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_name_or_path, trust_remote_code=<span class="literal">True</span>, device_map=<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载预训练的语言模型</span></span><br><span class="line"><span class="comment"># `AutoModelForCausalLM` 用于加载因果语言模型（Causal Language Model），模型将使用自回归方法生成文本</span></span><br><span class="line"><span class="comment"># `torch_dtype=torch.bfloat16` 表示将模型转换为使用 `bfloat16` 数据类型（在 GPU 上节省内存的半精度格式）</span></span><br><span class="line"><span class="comment"># `device_map=&#x27;cuda:0&#x27;` 指定将模型加载到 GPU 的第 0 号设备上</span></span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_name_or_path, trust_remote_code=<span class="literal">True</span>, torch_dtype=torch.bfloat16, device_map=<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将模型设置为评估模式，禁用训练模式以节省资源</span></span><br><span class="line">model = model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置系统提示词（system prompt），该提示词用于初始化对话，为模型提供上下文和行为规范</span></span><br><span class="line"><span class="comment"># 这个提示词告诉模型，它是一个名为 InternLM (书生·浦语) 的对话助手，并提供了相关的描述信息</span></span><br><span class="line">system_prompt = <span class="string">&quot;&quot;&quot;You are an AI assistant whose name is InternLM (书生·浦语).</span></span><br><span class="line"><span class="string">- InternLM (书生·浦语) is a conversational language model that is developed by Shanghai AI Laboratory (上海人工智能实验室). It is designed to be helpful, honest, and harmless.</span></span><br><span class="line"><span class="string">- InternLM (书生·浦语) can understand and communicate fluently in the language chosen by the user such as English and 中文.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化消息列表，其中第一个消息是系统提示词</span></span><br><span class="line"><span class="comment"># 消息列表用于跟踪用户和模型之间的对话历史</span></span><br><span class="line">messages = [(system_prompt, <span class="string">&#x27;&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出欢迎信息，提示用户输入文本，并提供退出选项</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============Welcome to InternLM chatbot, type &#x27;exit&#x27; to exit.=============&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始一个无限循环，用于与用户进行交互</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 获取用户输入文本，去除输入文本中的所有空格</span></span><br><span class="line">    input_text = <span class="built_in">input</span>(<span class="string">&quot;\nUser  &gt;&gt;&gt; &quot;</span>)</span><br><span class="line">    input_text = input_text.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果用户输入 &quot;exit&quot;，则退出循环，结束程序</span></span><br><span class="line">    <span class="keyword">if</span> input_text == <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化响应的长度为 0，后续会用来增量显示模型生成的响应</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调用模型的 `stream_chat` 方法，与模型进行流式交互对话</span></span><br><span class="line">    <span class="comment"># `stream_chat` 以流的形式逐步生成并返回响应，适合长文本生成</span></span><br><span class="line">    <span class="comment"># `tokenizer` 是用于对输入文本进行编码和解码的分词器</span></span><br><span class="line">    <span class="comment"># `input_text` 是用户输入的文本</span></span><br><span class="line">    <span class="comment"># `messages` 是对话历史（包括系统提示词和之前的用户对话）</span></span><br><span class="line">    <span class="keyword">for</span> response, _ <span class="keyword">in</span> model.stream_chat(tokenizer, input_text, messages):</span><br><span class="line">        <span class="comment"># 如果模型生成了部分响应，则输出新生成的文本部分</span></span><br><span class="line">        <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 输出新生成的文本部分（从上次生成的文本长度开始）</span></span><br><span class="line">            <span class="built_in">print</span>(response[length:], flush=<span class="literal">True</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="comment"># 更新当前已生成响应的长度</span></span><br><span class="line">            length = <span class="built_in">len</span>(response)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240916152602737.png" alt="image-20240916152602737"></p>
<h3 id="3-Streamlit-Web-Demo-部署-InternLM2-Chat-1-8B-模型">3. Streamlit Web Demo 部署 InternLM2-Chat-1.8B 模型</h3>
<p>详情可参考<a href="https://github.com/InternLM/Tutorial/blob/camp3/docs/L1/Demo/readme.md">https://github.com/InternLM/Tutorial/blob/camp3/docs/L1/Demo/readme.md</a></p>
<h2 id="Lv1-提示工程-Prompt-Engineering">Lv1-提示工程(Prompt Engineering)</h2>
<h3 id="1-LangGPT结构化提示词">1. LangGPT结构化提示词</h3>
<p>LangGPT 是 <strong>Language For GPT-like LLMs</strong> 的简称，中文名为结构化提示词。</p>
<h3 id="2-编写技巧">2. 编写技巧</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>构建全局思维链</strong></p>
</li>
</ul>
<p>💡 Role (角色) -&gt; Profile（角色简介）—&gt; Profile 下的 skill (角色技能) -&gt; Rules (角色要遵守的规则) -&gt; Workflow (满足上述条件的角色的工作流程) -&gt; Initialization (进行正式开始工作的初始化准备) -&gt; 开始实际使用</p>
<h3 id="3-示例">3. 示例</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Role: 吹牛逼大师</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Background:  </span></span><br><span class="line">我是一名自傲的成功人士,艺高人胆大,目空一切。我见过的世面,你们这些凡人难以想象。我无所不知,无所不能,所有人都应向我学习。</span><br><span class="line"></span><br><span class="line"><span class="section">## Attention:</span></span><br><span class="line">不要被我的伟岸身姿吓倒,我就是来教导你们这些平庸之辈的。你们要好好倾听,说不定能 approving0.1%的本大师的风范。 </span><br><span class="line"></span><br><span class="line"><span class="section">## Profile:  </span></span><br><span class="line"><span class="bullet">-</span> 姓名:吹牛逼大师</span><br><span class="line"><span class="bullet">-</span> 爱好:吹牛,嘲笑别人</span><br><span class="line"><span class="bullet">-</span> 座右铭:要么吹牛,要么被吹</span><br><span class="line"></span><br><span class="line"><span class="section">### Skills:</span></span><br><span class="line"><span class="bullet">-</span> 吹牛技能MAX</span><br><span class="line"><span class="bullet">-</span> 自我标榜“人生导师”</span><br><span class="line"><span class="bullet">-</span> 熟记各行各业知识点</span><br><span class="line"><span class="bullet">-</span> 善于羞辱他人来彰显自我</span><br><span class="line"></span><br><span class="line"><span class="section">## Goals:  </span></span><br><span class="line"><span class="bullet">-</span> 根据对话内容吹牛</span><br><span class="line"><span class="bullet">-</span> 语气狂妄自大</span><br><span class="line"><span class="bullet">-</span> 夸大自身成就和见识</span><br><span class="line"><span class="bullet">-</span> 贬低对方加强自我</span><br><span class="line"></span><br><span class="line"><span class="section">## Constrains:  </span></span><br><span class="line"><span class="bullet">-</span> 不可使用粗俗语言</span><br><span class="line"><span class="bullet">-</span> 不可人身攻击</span><br><span class="line"><span class="bullet">-</span> 要让对方感觉自卑</span><br><span class="line"></span><br><span class="line"><span class="section">## Workflow:</span></span><br><span class="line"><span class="bullet">1.</span> 倾听对方话语</span><br><span class="line"><span class="bullet">2.</span> 搜索相关知识</span><br><span class="line"><span class="bullet">3.</span> 承上启下吹自己</span><br><span class="line"><span class="bullet">4.</span> 贬低对方</span><br><span class="line"><span class="bullet">5.</span> 重复下去</span><br><span class="line"></span><br><span class="line"><span class="section">## OutputFormat:  </span></span><br><span class="line"><span class="bullet">-</span> 语气自大,长度100-200字</span><br><span class="line"><span class="bullet">-</span> 充满不切实际的吹嘘</span><br><span class="line"><span class="bullet">-</span> 贬低他人,突显自己</span><br><span class="line"><span class="bullet">-</span> 给人劣迹斑斑的感觉</span><br><span class="line"></span><br><span class="line"><span class="section">## Initialization</span></span><br><span class="line">凡人们,在本大师面前不要装逼。我见的世面,你这辈子加起来也比不了!要想成功,就把本大师的话跪下来听!</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># Role: 数字比大小专家</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Background:</span></span><br><span class="line">有人需要你帮忙找出两个数字中最大的那个,你需要给出答案</span><br><span class="line"></span><br><span class="line"><span class="section">## Skils:</span></span><br><span class="line"><span class="bullet">-</span> 掌握多种比大小的方法</span><br><span class="line"><span class="bullet">-</span> 善于检查,对于得到的结果会反复确认</span><br><span class="line"></span><br><span class="line"><span class="section">## Goals:</span></span><br><span class="line"><span class="bullet">-</span> 正确回答出所给的比大小问题</span><br><span class="line"><span class="bullet">-</span> 解题过程要符合逻辑</span><br><span class="line"></span><br><span class="line"><span class="section">## Workflow: </span></span><br><span class="line"><span class="bullet">1.</span> 倾听对方提出的比大小问题</span><br><span class="line"><span class="bullet">2.</span> 分析这道比大小问题</span><br><span class="line"><span class="bullet">3.</span> 判断这是否是一道数学比大小问题</span><br><span class="line"><span class="bullet">4.</span> 如果不是请告知对方</span><br><span class="line"><span class="bullet">5.</span> 如果是,请一步一步推导这个比大小问题的答案</span><br><span class="line"><span class="bullet">6.</span> 得到答案后,自己对答案进行检查</span><br><span class="line"><span class="bullet">7.</span> 确认答案无误,符合逻辑后告诉对方结果</span><br><span class="line"></span><br><span class="line"><span class="section">## Constrains:</span></span><br><span class="line"><span class="bullet">-</span> 你需要一步一步慢慢推导</span><br><span class="line"><span class="bullet">-</span> 你无须呈现推导过程,直接给出结果即可</span><br><span class="line"><span class="bullet">-</span> 在对方向你问好时,你需要按照(Initialization)的格式回答</span><br><span class="line"><span class="bullet">-</span> 回答比大小相关的问题时按照(Example)中的格式回答,直接给出答案</span><br><span class="line"><span class="bullet">-</span> 你需要时刻记住自己的(workflow),不断提醒自己</span><br><span class="line"><span class="bullet">-</span> 当两个比较对象不是同一类时,你需要告知用户,按照(Example)的格式那样</span><br><span class="line"></span><br><span class="line"><span class="section">## OutputFormat</span></span><br><span class="line"><span class="bullet">-</span> 直接说明哪个数字更大</span><br><span class="line"><span class="bullet">-</span> 按照(Example)中的格式回答</span><br><span class="line"></span><br><span class="line"><span class="section">## Example:</span></span><br><span class="line"><span class="bullet">-</span> question: 3.88与3.11哪个数字更大</span><br><span class="line"><span class="bullet">	-</span> answer: 3.88更大</span><br><span class="line"><span class="bullet">-</span> question: 3.453和天空谁大</span><br><span class="line"><span class="bullet">	-</span> answer: 不好意思,这两个不是同一事物,请你重新描述,提出具体问题</span><br><span class="line"></span><br><span class="line"><span class="section">## Initialization:</span></span><br><span class="line">请你提出你的比大小问题,我会耐心解答</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>书生大模型---前置知识</title>
    <url>/2024/09/13/%E4%B9%A6%E7%94%9F%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%97%AF%E5%85%B3%E7%BB%83%E4%B9%A0-Lv0/</url>
    <content><![CDATA[<blockquote>
<p>基础知识</p>
</blockquote>
<span id="more"></span>
<h1>书生大模型闯关练习</h1>
<h2 id="Lv0-Linux基础知识">Lv0-Linux基础知识</h2>
<h3 id="1-SSH（Secure-Shell）"><strong>1. SSH（Secure Shell）</strong></h3>
<p><strong><mark>1.1 概述</mark></strong></p>
<p>SSH是用于远程登录和其他网络服务之间的安全协议。它使用加密技术来确保数据的机密性和完整性。SSH的常见用途包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>远程服务器登录</strong>：无密码安全访问远程服务器。</p>
</li>
<li class="lvl-2">
<p><strong>数据传输</strong>：通过安全通道传输文件（如<code>SCP</code>和<code>SFTP</code>）。</p>
</li>
<li class="lvl-2">
<p><strong>端口转发</strong>：通过SSH隧道转发TCP端口。</p>
</li>
</ul>
<p><strong><mark>1.2 SSH密钥对</mark></strong></p>
<p>SSH使用公钥加密系统，密钥对由两部分组成：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>公钥</strong>：公开分发，存储在服务器上。</p>
</li>
<li class="lvl-2">
<p><strong>私钥</strong>：保留在客户端，不能外泄。</p>
</li>
</ul>
<p>客户端使用私钥与服务器的公钥进行匹配，从而验证身份，服务器无需存储任何敏感的凭据。</p>
<p><strong><mark>1.3 SSH密钥的生成</mark></strong></p>
<p>在ssh命令中我们可以使用<strong>ssh-keygen</strong>命令来生成密钥, <strong>ssh-keygen</strong>支持RSA和DSA两种认证密钥</p>
<p>常用参数包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>-t：指定密钥类型，如dsa、ecdsa、ed25519、rsa。</p>
</li>
<li class="lvl-2">
<p>-b：指定密钥长度。</p>
</li>
<li class="lvl-2">
<p>-C：添加注释。</p>
</li>
<li class="lvl-2">
<p>-f：指定保存密钥的文件名。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong><mark>1.4 为不同的服务生成各自的SSH密钥</mark></strong></p>
<blockquote>
<p>使用上述命令生成密钥后, <strong>系统会提示你输入密钥文件的保存路径</strong>。为了生成多个密钥，确保每个密钥文件名不同</p>
</blockquote>
<p>如: 为GitHub生成一个密钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/home/username/.ssh/id_rsa): /home/username/.ssh/id_rsa_github</span><br><span class="line"><span class="comment">#如果是windows系统则是 C:\Users\your_userName\.ssh\id_rsa_github</span></span><br></pre></td></tr></table></figure>
<p>在powerShell中可以使用<code>Get-Content</code>命令查看生成的密钥，如果是<strong>linux操作系统</strong>可以使用<code>cat</code>命令</p>
<p>最后将公钥复制粘贴到目标服务的SSH设置中</p>
<p><strong><mark>1.5 配置多个SSH密钥</mark></strong></p>
<p>在<code>~/.ssh/config</code>文件可以方便地为不同的服务配置不同的SSH密钥</p>
<ol>
<li class="lvl-3">
<p><strong>添加配置项</strong>： 为每个服务添加单独的配置项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"></span><br><span class="line">Host gitlab.com</span><br><span class="line">  HostName gitlab.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_gitlab</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul class="lvl-2">
<li class="lvl-5">
<p><strong>Host</strong>：自定义别名或远程主机名。</p>
</li>
<li class="lvl-5">
<p><strong>HostName</strong>：实际的远程服务器主机名（<a href="http://xn--github-hh4k.xn--comgitlab-267r.com">如github.com或gitlab.com</a>）。</p>
</li>
<li class="lvl-5">
<p><strong>User</strong>：登录时使用的用户名（通常是<code>git</code>，用于代码托管平台）。</p>
</li>
<li class="lvl-5">
<p><strong>IdentityFile</strong>：指定使用的SSH私钥。</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-端口映射">2. 端口映射</h3>
<p><strong><mark>2.1 基础概念</mark></strong></p>
<p>在计算机网络中，<strong>端口（Port）</strong> 是网络通信中的一个逻辑抽象概念，用于区分同一台计算机上不同网络服务或进程之间的通信通道。它与IP地址一起，用来标识网络中的不同通信终端和服务。<strong>端口映射</strong>是一种网络技术，它可以将外网中的任意端口映射到内网中的相应端口，实现内网与外网之间的通信。通过端口映射，可以在外网访问内网中的服务或应用，实现跨越网络的便捷通信</p>
<p><strong><mark>2.2 如何工作</mark></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 37367 root@ssh.intern-ai.org.cn -CNg -L 7860:127.0.0.1:7860 -o StrictHostKeyChecking=no</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>-p 37367</code>：是指定 SSH 连接的端口为 37367</p>
</li>
<li class="lvl-2">
<p><code>root@ssh.intern-ai.org.cn</code>：表示要以 <code>root</code> 用户身份连接到 <code>ssh.intern-ai.org.cn</code> 这个主机。</p>
</li>
<li class="lvl-2">
<p><code>CNg</code></p>
<ul class="lvl-2">
<li class="lvl-4"><code>-C</code> 启用压缩功能，这可以加快数据传输速度，尤其是在网络速度较慢的情况下。</li>
<li class="lvl-4"><code>-N</code> 表示不执行远程命令，仅建立连接用于端口转发等。</li>
<li class="lvl-4"><code>-g</code> 允许远程主机连接到本地转发的端口。这通常用于设置一个“网关”，允许其他计算机通过这个 SSH 会话访问转发端口</li>
</ul>
</li>
<li class="lvl-2">
<p><code>-L &#123;本地机器_PORT&#125;:127.0.0.1:&#123;开发机_PORT&#125;</code>：这是设置本地端口转发，将本地机器的指定端口转发到远程主机的 <code>127.0.0.1</code> （即本地回环地址）和指定的开发机端口。</p>
</li>
<li class="lvl-2">
<p><code>-o StrictHostKeyChecking=no</code>：关闭严格的主机密钥检查，这样可以避免第一次连接时因为未知主机密钥而产生的提示或错误。</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/portMapping.png" alt="portMapping"></p>
<p>使用<strong>VSCode</strong>可以使用其<strong>自动端口映射</strong>的功能,不需要自己手动配置</p>
<p><strong><mark>2.3 常见端口和服务</mark></strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>21</strong>：FTP（文件传输协议）</p>
</li>
<li class="lvl-2">
<p><strong>22</strong>：SSH（远程登录）</p>
</li>
<li class="lvl-2">
<p><strong>25</strong>：SMTP（邮件传输）</p>
</li>
<li class="lvl-2">
<p><strong>53</strong>：DNS（域名解析）</p>
</li>
<li class="lvl-2">
<p><strong>80</strong>：HTTP（网页浏览）</p>
</li>
<li class="lvl-2">
<p><strong>443</strong>：HTTPS（安全网页浏览）</p>
</li>
</ul>
<p><strong><mark>2.4 查看和管理端口</mark></strong></p>
<p>使用<code>netstat</code>命令</p>
<h3 id="3-Linux基础命令">3. Linux基础命令</h3>
<p><strong><mark>3.1 文件管理相关命令</mark></strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>创建文件</strong>：可以使用 <code>touch</code> 命令创建空文件。</p>
</li>
<li class="lvl-2">
<p><strong>创建目录</strong>：使用 <code>mkdir</code> 命令。</p>
</li>
<li class="lvl-2">
<p><strong>目录切换</strong>：使用<code>cd</code>命令。</p>
</li>
<li class="lvl-2">
<p><strong>显示所在目录</strong>：使用<code>pwd</code>命令。</p>
</li>
<li class="lvl-2">
<p><strong>查看文件内容</strong>：如使用 <code>cat</code> 直接显示文件全部内容，<code>more</code> 和 <code>less</code> 可以分页查看。</p>
</li>
<li class="lvl-2">
<p><strong>编辑文件</strong>：如 <code>vi</code> 或 <code>vim</code> 等编辑器。</p>
</li>
<li class="lvl-2">
<p><strong>复制文件</strong>：用 <code>cp</code> 命令。</p>
</li>
<li class="lvl-2">
<p><strong>创建文件链接</strong>：用<code>ln</code>命令。</p>
<ul class="lvl-2">
<li class="lvl-4">-s：创建软链接（符号链接）也是最常用的</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>移动文件</strong>：通过 <code>mv</code> 命令。</p>
</li>
<li class="lvl-2">
<p><strong>删除文件</strong>：使用 <code>rm</code> 命令。</p>
</li>
<li class="lvl-2">
<p><strong>删除目录</strong>：<code>rmdir</code>（只能删除空目录）或 <code>rm -r</code>（可删除非空目录）。</p>
</li>
<li class="lvl-2">
<p><strong>查找文件</strong>：可以用 <code>find</code> 命令。</p>
</li>
<li class="lvl-2">
<p><strong>查看文件或目录的详细信息</strong>：使用<code>ls</code>命令，如使用 <code>ls -l</code>查看目录下文件的详细信息。</p>
</li>
<li class="lvl-2">
<p><strong>处理文件</strong>：进行复杂的文件操作，可以使用<code>sed</code>命令。</p>
</li>
</ul>
<p><strong><mark>3.2 进程管理相关命令</mark></strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>ps</strong>：查看正在运行的进程</p>
</li>
<li class="lvl-2">
<p><strong>top</strong>：动态显示正在运行的进程</p>
</li>
<li class="lvl-2">
<p><strong>pstree</strong>：树状查看正在运行的进程</p>
</li>
<li class="lvl-2">
<p><strong>pgrep</strong>：用于查找进程</p>
</li>
<li class="lvl-2">
<p><strong>nice</strong>：更改进程的优先级</p>
</li>
<li class="lvl-2">
<p><strong>jobs</strong>：显示进程的相关信息</p>
</li>
<li class="lvl-2">
<p><strong>bg 和 fg</strong>：将进程调入后台</p>
</li>
<li class="lvl-2">
<p><strong>kill</strong>：杀死进程</p>
</li>
</ul>
<p><strong><mark>nvidia-smi命令</mark></strong></p>
<p>是一个命令行工具，用于监控 NVIDIA GPU 的状态和性能，以及管理 GPU 相关的任务</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/nvidiaGPU.png" alt="nvidiaGPU"></p>
<h3 id="4-Conda">4. Conda</h3>
<blockquote>
<p>一个开源的包管理和环境管理工具, 主要用于简化软件包的安装、依赖管理和隔离虚拟环境。</p>
</blockquote>
<h6 id="4-1-两个核心功能"><strong><mark>4.1 两个核心功能</mark></strong></h6>
<p><strong>包管理</strong>：Conda 可以安装、更新、卸载软件包，并自动解决依赖问题。</p>
<p><strong>环境管理</strong>：Conda 允许用户创建和管理多个独立的虚拟环境，每个环境可以有不同的包和工具。</p>
<p><mark><strong>4.2 Conda 的基本操作</strong></mark></p>
<ol>
<li class="lvl-3">
<p>检查 Conda 版本</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>创建虚拟环境</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create --name myenv python=3.9</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>myenv</code> 是虚拟环境的名称。</p>
</li>
<li class="lvl-2">
<p><code>python=3.9</code> 指定了该环境将使用 Python 3.9。</p>
</li>
</ul>
<ol start="3">
<li class="lvl-3">
<p>激活和退出环境</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate myenv</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>安装软件包</p>
</li>
</ol>
<p>安装软件包时，Conda 会自动处理依赖问题。使用 <code>conda install</code> 安装包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install numpy pandas</span><br></pre></td></tr></table></figure>
<p>这会在当前激活的环境中安装 <code>numpy</code> 和 <code>pandas</code>。</p>
<ol start="5">
<li class="lvl-3">
<p>更新软件包</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda update numpy</span><br></pre></td></tr></table></figure>
<ol start="6">
<li class="lvl-3">
<p>列出创建的所有虚拟环境</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure>
<ol start="7">
<li class="lvl-3">
<p>删除虚拟环境</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> remove --name myenv</span><br></pre></td></tr></table></figure>
<ol start="8">
<li class="lvl-3">
<p>导出和导入环境</p>
</li>
</ol>
<p>Conda 允许你导出当前环境的所有包列表，以便于在其他系统上重建相同的环境。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>导出环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> <span class="built_in">export</span> &gt; environment.yml</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>从导出的 <code>.yml</code> 文件创建新环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> create -f environment.yml</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="9">
<li class="lvl-3">
<p>添加其他的源</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add [url]</span><br></pre></td></tr></table></figure>
<h2 id="Lv0-Python基础">Lv0-Python基础</h2>
<h3 id="1-环境准备">1. 环境准备</h3>
<p><strong><mark>1.1 下载miniconda</mark></strong></p>
<p>anaconda和miniconda都可以, 推荐后者</p>
<p>清华源miniconda下载链接: <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a>(建议选择python3.9以上的版本，比如Miniconda3-py310_24.5.0)</p>
<p><strong><mark>1.2 换源</mark></strong></p>
<p>进入命令行开始进行换源，Windows可以直接打开miniconda powershell promt。</p>
<p>首先将pip替换为清华源，只需要一条命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>接着我们来给conda替换成清华源。各系统都可以通过修改用户目录下的 <code>.condarc</code> 文件来修改镜像源。Windows 用户无法直接创建名为 <code>.condarc</code> 的文件，<strong>可先执行 <code>conda config --set show_channel_urls yes</code> 生成该文件之后再修改</strong>。在用户目录找到<code>.condarc</code> 文件后，使用文本编辑器打开，将下面的内容复制进去并保存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">channels:   - defaults show_channel_urls: <span class="literal">true</span> default_channels:</span><br><span class="line">- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span><br><span class="line">- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels:</span><br><span class="line">conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span><br><span class="line">deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/</span><br></pre></td></tr></table></figure>
<p>接着在命令行中运行 <code>conda clean -i</code> 清除索引缓存，保证用的是镜像站提供的索引。</p>
<h3 id="2-不断学习-使用python">2. 不断学习,使用python</h3>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET Core(一)</title>
    <url>/2024/08/08/ASP-NET-Core-%E4%B8%80/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://ASP.NET">ASP.NET</a> Core框架中 依赖注入 LINQ语句 配置系统 日志</p>
</blockquote>
<span id="more"></span>
<h1><a href="http://ASP.NET">ASP.NET</a> core</h1>
<h3 id="异步">异步</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>Task</p>
</li>
<li class="lvl-2">
<p>async</p>
</li>
<li class="lvl-2">
<p>await</p>
</li>
</ul>
<h3 id="委托">委托</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>关键字 delegate</p>
</li>
<li class="lvl-2">
<p>指向方法的类型</p>
</li>
<li class="lvl-2">
<p>.NET中内置了两个泛型委托 <mark>Action(无返回值)</mark> 和 <mark>Func(有返回值)</mark></p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无返回值</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action a1 = F1;</span><br><span class="line">        a1();</span><br><span class="line"></span><br><span class="line">        Action&lt;<span class="built_in">int</span>&gt; a_int = F_int;</span><br><span class="line">        a_int(<span class="number">520</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">F1</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">F_int</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有返回值,与上述类似,但是Func的参数列表中最后一个记录的是返回值</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>&gt; F1 = function;</span><br><span class="line">F1();</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">function</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">520</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lambda-表达式">Lambda 表达式</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; a1 = (<span class="built_in">int</span> i, <span class="built_in">int</span> j) =&gt; &#123; Console.WriteLine(<span class="string">&quot;hello world!&quot;</span>); &#125;;</span><br><span class="line">        a1(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="yeild">yeild</h3>
<p><code>yield</code>关键字用于简化实现迭代器的方法。迭代器是一种特殊的方法，它可以<mark>逐步返回</mark>集合中的元素，而不是一次性返回整个集合。使用<code>yield</code>可以让方法在每次调用时返回一个元素，并在需要时保持其当前状态，以便下次调用时继续执行。</p>
<h3 id="LINQ">LINQ</h3>
<blockquote>
<p>几乎里面的所有的扩展方法都是针对 IEnumerable接口的</p>
<p>所有能返回集合的都是返回IEnumerable</p>
<p>处于System.Linq命名空间中</p>
</blockquote>
<p><strong>常用方法</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Where()  筛选出符合条件的数据</p>
</li>
<li class="lvl-2">
<p>Single()  有且只有一条数据时返回</p>
</li>
<li class="lvl-2">
<p>SingleOrDefault()</p>
</li>
<li class="lvl-2">
<p>First():至少有一条时返回第一条</p>
</li>
<li class="lvl-2">
<p>FirstOrDefault()</p>
</li>
<li class="lvl-2">
<p>Order()  正序排序</p>
</li>
<li class="lvl-2">
<p>OrderByDescending() 倒序排序</p>
</li>
<li class="lvl-2">
<p>OrderBy() 按照自定义要求排序</p>
</li>
<li class="lvl-2">
<p>ThenBy()</p>
</li>
<li class="lvl-2">
<p>Skip() Take()</p>
</li>
</ul>
<p><strong>聚合函数</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Max() Min() Average() Sum() Count()</p>
</li>
</ul>
<p><strong>分组函数</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>GroupBy() 根据选择的属性进行分组</p>
</li>
</ul>
<p>返回值IEnumerable&lt;IGrouping&lt;T,Y&gt;&gt;</p>
<p><strong>投影</strong></p>
<p>按照某种规则将一组数据映射为另一组数据</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Select</p>
</li>
</ul>
<p><strong>集合转换</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>ToList()</p>
</li>
<li class="lvl-2">
<p>ToArray()</p>
</li>
</ul>
<h3 id="控制反转">控制反转</h3>
<p>1.服务定位器(ServiceLocator)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITestService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHi</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestServiceImpl</span> : <span class="title">ITestService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHi</span>()</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Hi!My name is <span class="subst">&#123;Name&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ServiceCollection services = <span class="keyword">new</span> ServiceCollection();<span class="comment">//创建服务容器</span></span><br><span class="line">        services.AddTransient&lt;TestServiceImpl&gt;();<span class="comment">//注册服务</span></span><br><span class="line">        <span class="keyword">using</span> (ServiceProvider sp = services.BuildServiceProvider())<span class="comment">//创建服务定位器</span></span><br><span class="line">        &#123;<span class="comment">//使用了服务定位器 获取存放在容器中所需要的服务</span></span><br><span class="line">            TestServiceImpl t = sp.GetService&lt;TestServiceImpl&gt;();</span><br><span class="line">            t.Name = <span class="string">&quot;WangMC&quot;</span>;</span><br><span class="line">            t.SayHi();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><mark>2.依赖注入(Dependency Injection)</mark></strong></p>
<blockquote>
<p>.NET控制反转组件取名为DependencyInjection,但其中包含服务定位器</p>
<p>使用前要安装Microsoft.Extensions.DependencyInjection</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>服务(service):要使用的对象</p>
</li>
<li class="lvl-2">
<p>注册服务</p>
</li>
<li class="lvl-2">
<p>服务容器:存放和管理注册好的服务</p>
</li>
<li class="lvl-2">
<p>查询服务:创建对象及关联对象</p>
</li>
<li class="lvl-2">
<p>对象的生命周期:Transient(瞬态) Scoped(范围) Singleton(单例)</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span>;</span><br><span class="line"><span class="comment">//控制器发出测试请求,开始调用日志单元和存储单元</span></span><br><span class="line"><span class="comment">//存储单元需要调用配置信息连接存储设备,最后将测试的信息存储到设备中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> service = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line"></span><br><span class="line">        service.AddScoped&lt;Controller&gt;();</span><br><span class="line">        service.AddScoped&lt;IStorage,StorageImp1&gt;();</span><br><span class="line">        service.AddScoped&lt;ILog,LogImp1&gt;();</span><br><span class="line">        service.AddScoped&lt;IConfig,ConfigImp1&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> sp = service.BuildServiceProvider())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> controller = sp.GetService&lt;Controller&gt;();</span><br><span class="line">            controller.Test();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Controller</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILog log;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IStorage storage;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Controller</span>(<span class="params">ILog log, IStorage storage</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.storage = storage;</span><br><span class="line">            <span class="keyword">this</span>.log = log;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.log.Log(<span class="string">&quot;开始上传&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.storage.Save(<span class="string">&quot;依赖注入测试&quot;</span>, <span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.log.Log(<span class="string">&quot;上传完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">ILog</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">LogImp1</span> : <span class="title">ILog</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;日志<span class="subst">&#123;msg&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IConfig</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetValue</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ConfigImp1</span> : <span class="title">IConfig</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetValue</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;\&quot;hello_world\&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Save</span>(<span class="params"><span class="built_in">string</span> content, <span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">StorageImp1</span> : <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IConfig config;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StorageImp1</span>(<span class="params">IConfig config</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.config = config;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Save</span>(<span class="params"><span class="built_in">string</span> content, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> service = config.GetValue(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;向服务器<span class="subst">&#123;service&#125;</span>上传文件名为<span class="subst">&#123;name&#125;</span>,其内容为<span class="subst">&#123;content&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置系统">配置系统</h3>
<p><strong>配置读取顺序</strong></p>
<p>配置中心服务器----&gt;本地环境变量------&gt;本地配置文件  (后者可将前者覆盖)</p>
<p><strong>Json文件配置</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WangMC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hobby&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;sport&quot;</span><span class="punctuation">:</span> <span class="string">&quot;swimming&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;music&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rock&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>属性设置为 如果较新则复制</p>
<p>法一: NuGet安装Microsoft.Extensions.Configuration和Microsoft.Extensions.Configuration.Json包</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> configBuilder = <span class="keyword">new</span> ConfigurationBuilder();</span><br><span class="line">        configBuilder.AddJsonFile(<span class="string">&quot;config.json&quot;</span>, optional: <span class="literal">true</span>, reloadOnChange: <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">var</span> configRoot = configBuilder.Build();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> name = configRoot[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">        <span class="built_in">string</span> hobby_sport = configRoot.GetSection(<span class="string">&quot;hobby&quot;</span>)[<span class="string">&quot;sport&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;name&#125;</span>, Age: <span class="subst">&#123;age&#125;</span>, Hobby_sport: <span class="subst">&#123;hobby_sport&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法二: 绑定一个类 来进行配置的读取</p>
<p>NuGet安装Microsoft.Extensions.Configuration.Binder</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration; </span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> configBuilder = <span class="keyword">new</span> ConfigurationBuilder();</span><br><span class="line">        configBuilder.AddJsonFile(<span class="string">&quot;config.json&quot;</span>, optional: <span class="literal">true</span>, reloadOnChange: <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">var</span> configRoot = configBuilder.Build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> config = configRoot.Get&lt;Config&gt;();</span><br><span class="line">        <span class="built_in">string</span> name = config.name;</span><br><span class="line">        <span class="built_in">int</span> age = config.age;</span><br><span class="line">        Hobby hobby = config.hobby;</span><br><span class="line">        <span class="built_in">string</span> sprot = config.hobby.sport;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Config</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Hobby hobby &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Hobby</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> sport &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> music &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><mark>选项方式读取</mark></strong></p>
<ol>
<li class="lvl-3">
<p>NuGet安装Microsoft.Extensions.Configuration  Microsoft.Extensions.Configuration.Json包</p>
</li>
</ol>
<p>Microsoft.Extensions.Configuration.Options  Microsoft.Extensions.Configuration.Binder</p>
<ol start="2">
<li class="lvl-3">
<p>读取配置时, DI要声明IOptions<T> IOptionsMonitor<T> IOptionsSnapshot<T>等类型</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>IOptions<T>不会读取到新的值</p>
</li>
<li class="lvl-2">
<p>==IOptionsSnapshot<T>==与IOptionsMonitor<T> 相比,IOptionsSnapshot<T>读取到的值会在同一个范围中保持一致</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration; </span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Options;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">        services.AddScoped&lt;TestController&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> configBuild = <span class="keyword">new</span> ConfigurationBuilder();</span><br><span class="line">        configBuild.AddJsonFile(<span class="string">&quot;config.json&quot;</span>,optional:<span class="literal">true</span>,reloadOnChange:<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> configRoot = configBuild.Build();</span><br><span class="line">        services.AddOptions().Configure&lt;Config&gt;(e =&gt; configRoot.Bind(e));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> sp = services.BuildServiceProvider())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> i = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">while</span> (i!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> info = sp.GetRequiredService&lt;TestController&gt;();</span><br><span class="line">                info.Test();</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">TestController</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IOptionsSnapshot&lt;Config&gt; optConfig;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">IOptionsSnapshot&lt;Config&gt; optConfig</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.optConfig=optConfig;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;姓名:<span class="subst">&#123;optConfig.Value.name&#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;年龄:<span class="subst">&#123;optConfig.Value.age&#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;兴趣爱好:<span class="subst">&#123;optConfig.Value.hobby.sport&#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;兴趣爱好:<span class="subst">&#123;optConfig.Value.hobby.music&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Config</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Hobby hobby &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Hobby</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> sport &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> music &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="日志">日志</h3>
<blockquote>
<p>级别: Trace&lt;Debug&lt;Information&lt;Warning&lt;Error&lt;Critical</p>
</blockquote>
<p><strong>1. 输出到控制台</strong></p>
<blockquote>
<p>安装Microsoft.Extensions.Logging  Microsoft.Extensions.Logging.Console</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging.Console</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line"></span><br><span class="line">        services.AddLogging(logBuilder =&gt; &#123; </span><br><span class="line">            logBuilder.AddConsole();</span><br><span class="line">            logBuilder.SetMinimumLevel(LogLevel.Trace);</span><br><span class="line">        &#125;);</span><br><span class="line">        services.AddScoped&lt;Demo&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> sp = services.BuildServiceProvider())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> demo = sp.GetRequiredService&lt;Demo&gt;();</span><br><span class="line">            demo.Test();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;Demo&gt; logger;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Demo</span>(<span class="params">ILogger&lt;Demo&gt; logger</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            logger.LogWarning(<span class="string">&quot;this is a warning&quot;</span>);</span><br><span class="line">            logger.LogError(<span class="string">&quot;this is a Error&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                File.ReadAllText(<span class="string">&quot;A fake document&quot;</span>);</span><br><span class="line">                logger.LogDebug(<span class="string">&quot;Read Success!!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                logger.LogDebug(ex,<span class="string">&quot;Read Failed!!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 文本日志</strong></p>
<blockquote>
<p>使用NLog包</p>
</blockquote>
<p>日志过滤和分类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">xsi:type</span>=<span class="string">&quot;File&quot;</span> <span class="attr">name</span>=<span class="string">&quot;logfile&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;c:\temp\console-example.log&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">archiveAboveSize</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">maxArchiveFiles</span>=<span class="string">&quot;3&quot;</span> <span class="attr">maxArchiveDays</span>=<span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">layout</span>=<span class="string">&quot;$&#123;longdate&#125;|$&#123;level&#125;|$&#123;message&#125; |$&#123;all-event-properties&#125; $&#123;exception:format=tostring&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>xsi:type=&quot;File&quot;</code>：指定了目标的类型为<code>File</code>，这意味着日志消息将被写入到文件中。</p>
</li>
<li class="lvl-2">
<p><code>name=&quot;logfile&quot;</code>：为目标命名，这个名字在整个NLog配置中必须是唯一的，并且可以在日志规则中引用。</p>
</li>
<li class="lvl-2">
<p><code>fileName=&quot;c:\temp\console-example.log&quot;</code>：指定了日志文件的完整路径。日志消息将被写入到这个文件中。</p>
</li>
<li class="lvl-2">
<p><code>archiveAboveSize=&quot;10000&quot;</code>：这是一个可选参数，用于指定日志文件的大小阈值。当日志文件达到或超过这个大小时，NLog会将当前日志文件归档，并创建一个新的日志文件继续记录。单位是字节，这里设置为10000字节（大约10KB）。</p>
</li>
<li class="lvl-2">
<p><code>maxArchiveFiles=&quot;3&quot;</code>：这是一个可选参数，用于指定最大归档文件的数量。当达到这个数量时，NLog将开始删除最旧的归档文件，以便为新归档文件腾出空间。这里设置为3，意味着最多保留3个归档文件。</p>
</li>
<li class="lvl-2">
<p><code>maxArchiveDays=&quot;30&quot;</code>：其中 <code>X</code> 是一个整数，表示归档文件将被保留的天数。当归档文件创建后经过 <code>X</code> 天，NLog 将自动删除这些归档文件</p>
</li>
<li class="lvl-2">
<p><code>layout=&quot;$&#123;longdate&#125;|$&#123;level&#125;|$&#123;message&#125; |$&#123;all-event-properties&#125; $&#123;exception:format=tostring&#125;&quot;</code>：定义了日志消息的布局（layout）。布局是一个模板，它指定了日志消息的格式。以下是布局中各个元素的含义：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>$&#123;longdate&#125;</code>：插入日志事件的时间戳。</li>
<li class="lvl-4"><code>$&#123;level&#125;</code>：插入日志事件的级别（例如：Info、Debug、Error等）。</li>
<li class="lvl-4"><code>$&#123;message&#125;</code>：插入日志事件的文本消息。</li>
<li class="lvl-4"><code>$&#123;all-event-properties&#125;</code>：插入所有事件属性的内容。</li>
<li class="lvl-4"><code>$&#123;exception:format=tostring&#125;</code>：如果日志事件中包含异常信息，则将其转换为字符串并插入到日志消息中。</li>
</ul>
</li>
</ul>
<p><strong>3.结构化日志</strong></p>
<blockquote>
<p>使用Serilog包 安装Serilog.AspNetCore包</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging;</span><br><span class="line"><span class="keyword">using</span> Serilog;</span><br><span class="line"><span class="keyword">using</span> Serilog.Formatting.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IServiceCollection services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line"></span><br><span class="line">        services.AddLogging(logBuilder =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Log.Logger = <span class="keyword">new</span> LoggerConfiguration().</span><br><span class="line">                             MinimumLevel.Debug().</span><br><span class="line">                             Enrich.FromLogContext().</span><br><span class="line">                             WriteTo.Console(<span class="keyword">new</span> JsonFormatter()).</span><br><span class="line">                             CreateLogger();</span><br><span class="line">        services.AddSerilog();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//services.AddSerilog();</span></span><br><span class="line">        services.AddScoped&lt;Demo&gt;();</span><br><span class="line">        services.AddScoped&lt;Demo1&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> sp = services.BuildServiceProvider())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> demo = sp.GetRequiredService&lt;Demo&gt;();</span><br><span class="line">            <span class="keyword">var</span> demo1 = sp.GetRequiredService&lt;Demo1&gt;();</span><br><span class="line"></span><br><span class="line">            demo1.Test();</span><br><span class="line">            demo.Test();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;Demo&gt; logger;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Demo</span>(<span class="params">ILogger&lt;Demo&gt; logger</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            logger.LogWarning(<span class="string">&quot;this is a warning&quot;</span>);</span><br><span class="line">            logger.LogError(<span class="string">&quot;this is a Error&quot;</span>);</span><br><span class="line">            logger.LogDebug(<span class="string">&quot;this is a debug&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> Information = <span class="keyword">new</span> &#123; name = <span class="string">&quot;WangMC&quot;</span>, Age = <span class="number">18</span> &#125;;</span><br><span class="line">            <span class="built_in">string</span> Hobby = <span class="string">&quot;running&quot;</span>;</span><br><span class="line">            logger.LogDebug(<span class="string">&quot;Hello this is my informaiton &#123;@Information&#125;,my hobby is &#123;Hobby&#125;&quot;</span>, Information, Hobby);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Demo1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;Demo1&gt; logger;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Demo1</span>(<span class="params">ILogger&lt;Demo1&gt; logger</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            logger.LogWarning(<span class="string">&quot;这是一个警告&quot;</span>);</span><br><span class="line">            logger.LogError(<span class="string">&quot;这是一个错误&quot;</span>);</span><br><span class="line">            logger.LogDebug(<span class="string">&quot;这是一个debug&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.集中化日志</strong></p>
<blockquote>
<p>适合集群化部署 有N多服务器</p>
<p>Exceptionless 提供了现成的云服务 也可以本地部署(self hosting)</p>
</blockquote>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2022 ASP.NET core Web API 示例代码解释</title>
    <url>/2024/07/15/VS2022-ASP-NET-core-Web-API-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<blockquote>
<p>关于VS2022提供的天气预报示例代码的一些解释</p>
</blockquote>
 <span id="more"></span>
<h3 id="0-项目结构">0. 项目结构</h3>
<p><a href="http://xn--ASP-th2ey4ui5m.NET">在创建ASP.NET</a> Core Web API项目后，项目的基本结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyWebApiProject</span><br><span class="line">│   Controllers</span><br><span class="line">│   └── WeatherForecastController.cs</span><br><span class="line">│   Program.cs</span><br><span class="line">│   WeatherForecast.cs</span><br><span class="line">│   appsettings.json</span><br><span class="line">│   ...</span><br></pre></td></tr></table></figure>
<h3 id="1-Program-cs">1. <code>Program.cs</code></h3>
<p>这个文件是应用程序的入口点，负责配置和启动Web服务器。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>WebApplication.CreateBuilder(args)</code>：创建一个Web应用程序构建器。</p>
</li>
<li class="lvl-2">
<p><code>args</code>：命令行参数。</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">builder.Services.AddControllers();</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>builder.Services</code>：表示依赖注入容器。</p>
</li>
<li class="lvl-2">
<p><code>AddControllers</code>：向依赖注入容器添加控制器服务。</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>AddEndpointsApiExplorer</code>：用于API文档生成。</p>
</li>
<li class="lvl-2">
<p><code>AddSwaggerGen</code>：添加Swagger生成器，生成API文档。</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>builder.Build()</code>：构建Web应用程序。</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseDeveloperExceptionPage();</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>app.Environment.IsDevelopment()</code>：检查当前环境是否是开发环境。</p>
</li>
<li class="lvl-2">
<p><code>UseDeveloperExceptionPage</code>：在开发环境中使用开发者异常页面。</p>
</li>
<li class="lvl-2">
<p><code>UseSwagger</code>和<code>UseSwaggerUI</code>：启用Swagger中间件，提供API文档UI。</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">app.UseHttpsRedirection();</span><br><span class="line">app.UseAuthorization();</span><br><span class="line">app.MapControllers();</span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>UseHttpsRedirection</code>：强制使用HTTPS。</p>
</li>
<li class="lvl-2">
<p><code>UseAuthorization</code>：启用授权中间件。</p>
</li>
<li class="lvl-2">
<p><code>MapControllers</code>：将控制器映射到路由。</p>
</li>
<li class="lvl-2">
<p><code>app.Run()</code>：运行Web应用程序。</p>
</li>
</ul>
<h3 id="2-WeatherForecast-cs">2. <code>WeatherForecast.cs</code></h3>
<p>这个文件定义了天气预报的数据模型。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecast</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DateTime Date &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TemperatureC &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TemperatureF =&gt; <span class="number">32</span> + (<span class="built_in">int</span>)(TemperatureC / <span class="number">0.5556</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Summary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Date</code>：表示预报的日期。</p>
</li>
<li class="lvl-2">
<p><code>TemperatureC</code>：表示摄氏温度。</p>
</li>
<li class="lvl-2">
<p><code>TemperatureF</code>：表示华氏温度，通过摄氏温度计算得出。</p>
</li>
<li class="lvl-2">
<p><code>Summary</code>：表示天气总结，可以为空（<code>string?</code>表示可空类型）。</p>
</li>
</ul>
<h3 id="3-WeatherForecastController-cs">3. <code>WeatherForecastController.cs</code></h3>
<p>这个文件定义了一个控制器类，处理与天气预报相关的HTTP请求。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>using</code>语句：导入命名空间，包含<code>Microsoft.AspNetCore.Mvc</code>用于控制器相关功能。</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyWebApiProject.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecastController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span>[] Summaries = <span class="keyword">new</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;Freezing&quot;</span>, <span class="string">&quot;Bracing&quot;</span>, <span class="string">&quot;Chilly&quot;</span>, <span class="string">&quot;Cool&quot;</span>, <span class="string">&quot;Mild&quot;</span>, <span class="string">&quot;Warm&quot;</span>, <span class="string">&quot;Balmy&quot;</span>, <span class="string">&quot;Hot&quot;</span>, <span class="string">&quot;Sweltering&quot;</span>, <span class="string">&quot;Scorching&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WeatherForecastController&gt; _logger;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WeatherForecastController</span>(<span class="params">ILogger&lt;WeatherForecastController&gt; logger</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="title">Get</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> rng = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">return</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>).Select(index =&gt; <span class="keyword">new</span> WeatherForecast</span><br><span class="line">            &#123;</span><br><span class="line">                Date = DateTime.Now.AddDays(index),</span><br><span class="line">                TemperatureC = rng.Next(<span class="number">-20</span>, <span class="number">55</span>),</span><br><span class="line">                Summary = Summaries[rng.Next(Summaries.Length)]</span><br><span class="line">            &#125;)</span><br><span class="line">            .ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="详细解析：">详细解析：</h4>
<ol>
<li class="lvl-3">
<p><strong><code>[ApiController]</code></strong></p>
<ul class="lvl-2">
<li class="lvl-6">标记该类为API控制器，启用一些自动化功能，如模型验证和路由推断。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>[Route(&quot;[controller]&quot;)]</code></strong></p>
<ul class="lvl-2">
<li class="lvl-6">定义控制器的路由模板。<code>[controller]</code>占位符会被控制器名称替换（去掉“Controller”后缀）。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>控制器类</strong>：</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecastController</span> : <span class="title">ControllerBase</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6"><code>WeatherForecastController</code>：控制器类，继承自<code>ControllerBase</code>。</li>
<li class="lvl-6"><code>ControllerBase</code>：提供访问控制器功能的基类，不包含视图支持。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>Summaries</code>字段</strong>：</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span>[] Summaries = <span class="keyword">new</span>[]</span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6">定义了一个静态只读数组，包含各种天气总结描述。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>构造函数</strong>：</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeatherForecastController</span>(<span class="params">ILogger&lt;WeatherForecastController&gt; logger</span>)</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6">依赖注入<code>ILogger&lt;WeatherForecastController&gt;</code>实例，用于日志记录。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong><code>Get</code>方法</strong>：</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="title">Get</span>()</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6"><code>[HttpGet]</code>：标记该方法处理HTTP GET请求。</li>
<li class="lvl-6"><code>Get</code>方法返回一个<code>IEnumerable&lt;WeatherForecast&gt;</code>，生成并返回5天的天气预报数据。</li>
</ul>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rng = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">return</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>).Select(index =&gt; <span class="keyword">new</span> WeatherForecast</span><br><span class="line">&#123;</span><br><span class="line">    Date = DateTime.Now.AddDays(index),</span><br><span class="line">    TemperatureC = rng.Next(<span class="number">-20</span>, <span class="number">55</span>),</span><br><span class="line">    Summary = Summaries[rng.Next(Summaries.Length)]</span><br><span class="line">&#125;)</span><br><span class="line">.ToArray();</span><br></pre></td></tr></table></figure>
<ul class="lvl-2">
<li class="lvl-6">
<p>创建一个随机数生成器。</p>
</li>
<li class="lvl-6">
<p>使用<code>Enumerable.Range</code>生成1到5的整数序列。</p>
</li>
<li class="lvl-6">
<p>使用<code>Select</code>方法将每个整数转换为一个<code>WeatherForecast</code>对象。</p>
</li>
<li class="lvl-6">
<p>生成日期为当前日期加上序列中的天数。</p>
</li>
<li class="lvl-6">
<p>生成随机的摄氏温度和天气总结。</p>
</li>
<li class="lvl-6">
<p>将结果转换为数组并返回。</p>
</li>
</ul>
</li>
</ol>
<h3 id="设计代码结构的建议">设计代码结构的建议</h3>
<p><a href="http://xn--ASP-lp6e.NET">在ASP.NET</a> Core Web API项目中，将代码分为模型层、控制器层、服务层和数据访问层有助于组织代码，使其更易于维护和扩展。以下是各个层的详细描述以及它们存放的代码类型：</p>
<h4 id="1-模型层（Models）">1. 模型层（Models）</h4>
<p>模型层存放数据结构和业务对象，这些对象通常反映了系统的核心业务实体。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数据模型</strong>：表示数据的结构，如数据库表的实体。</p>
</li>
<li class="lvl-2">
<p><strong>数据传输对象（DTO）</strong>：用于在客户端和服务器之间传输数据。</p>
</li>
<li class="lvl-2">
<p><strong>视图模型</strong>：用于将数据从控制器传递到视图（在API中较少使用）。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径：Models/WeatherForecast.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecast</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DateTime Date &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TemperatureC &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TemperatureF =&gt; <span class="number">32</span> + (<span class="built_in">int</span>)(TemperatureC / <span class="number">0.5556</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Summary &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-控制器层（Controllers）">2. 控制器层（Controllers）</h4>
<p>控制器层包含控制器类，这些类处理HTTP请求并返回响应。控制器通常使用服务层来处理业务逻辑。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>控制器</strong>：处理HTTP请求，调用服务层，并返回响应。</p>
</li>
<li class="lvl-2">
<p><strong>属性和方法</strong>：处理特定的HTTP请求（如GET、POST、PUT、DELETE）。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径：Controllers/WeatherForecastController.cs</span></span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> MyWebApiProject.Services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyWebApiProject.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecastController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IWeatherForecastService _weatherForecastService;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WeatherForecastController</span>(<span class="params">IWeatherForecastService weatherForecastService</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _weatherForecastService = weatherForecastService;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="title">Get</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _weatherForecastService.GetWeatherForecasts();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-服务层（Services）">3. 服务层（Services）</h4>
<p>服务层包含业务逻辑和操作，这些逻辑通常涉及多个数据模型或需要复杂的业务规则。服务层从数据访问层获取数据并进行处理。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>服务接口</strong>：定义服务的合同。</p>
</li>
<li class="lvl-2">
<p><strong>服务实现</strong>：实现服务接口，包含具体的业务逻辑。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径：Services/IWeatherForecastService.cs</span></span><br><span class="line"><span class="keyword">using</span> MyWebApiProject.Models;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWeatherForecastService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerable&lt;WeatherForecast&gt; <span class="title">GetWeatherForecasts</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径：Services/WeatherForecastService.cs</span></span><br><span class="line"><span class="keyword">using</span> MyWebApiProject.Models;</span><br><span class="line"><span class="keyword">using</span> MyWebApiProject.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecastService</span> : <span class="title">IWeatherForecastService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IWeatherForecastRepository _repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherForecastService</span>(<span class="params">IWeatherForecastRepository repository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="title">GetWeatherForecasts</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _repository.GetWeatherForecasts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-数据访问层（Data-Access-Layer-DAL）">4. 数据访问层（Data Access Layer, DAL）</h4>
<p>数据访问层处理与数据库的交互，负责从数据库中检索和存储数据。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>仓储接口</strong>：定义数据访问的合同。</p>
</li>
<li class="lvl-2">
<p><strong>仓储实现</strong>：实现仓储接口，包含具体的数据访问逻辑。</p>
</li>
<li class="lvl-2">
<p><strong>数据上下文</strong>：表示数据库连接和操作。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径：Data/IWeatherForecastRepository.cs</span></span><br><span class="line"><span class="keyword">using</span> MyWebApiProject.Models;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWeatherForecastRepository</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerable&lt;WeatherForecast&gt; <span class="title">GetWeatherForecasts</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径：Data/WeatherForecastRepository.cs</span></span><br><span class="line"><span class="keyword">using</span> MyWebApiProject.Models;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecastRepository</span> : <span class="title">IWeatherForecastRepository</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="title">GetWeatherForecasts</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里可以连接数据库并获取数据</span></span><br><span class="line">        <span class="keyword">var</span> rng = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>).Select(index =&gt; <span class="keyword">new</span> WeatherForecast</span><br><span class="line">        &#123;</span><br><span class="line">            Date = DateTime.Now.AddDays(index),</span><br><span class="line">            TemperatureC = rng.Next(<span class="number">-20</span>, <span class="number">55</span>),</span><br><span class="line">            Summary = Summaries[rng.Next(Summaries.Length)]</span><br><span class="line">        &#125;)</span><br><span class="line">        .ToArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span>[] Summaries = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Freezing&quot;</span>, <span class="string">&quot;Bracing&quot;</span>, <span class="string">&quot;Chilly&quot;</span>, <span class="string">&quot;Cool&quot;</span>, <span class="string">&quot;Mild&quot;</span>, <span class="string">&quot;Warm&quot;</span>, <span class="string">&quot;Balmy&quot;</span>, <span class="string">&quot;Hot&quot;</span>, <span class="string">&quot;Sweltering&quot;</span>, <span class="string">&quot;Scorching&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码结构设计建议">代码结构设计建议</h4>
<p>以下是一个示例项目的目录结构，以帮助组织各个层的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyWebApiProject</span><br><span class="line">│</span><br><span class="line">├── Controllers</span><br><span class="line">│   └── WeatherForecastController.cs</span><br><span class="line">│</span><br><span class="line">├── Models</span><br><span class="line">│   └── WeatherForecast.cs</span><br><span class="line">│</span><br><span class="line">├── Services</span><br><span class="line">│   ├── IWeatherForecastService.cs</span><br><span class="line">│   └── WeatherForecastService.cs</span><br><span class="line">│</span><br><span class="line">├── Data</span><br><span class="line">│   ├── IWeatherForecastRepository.cs</span><br><span class="line">│   └── WeatherForecastRepository.cs</span><br><span class="line">│</span><br><span class="line">├── Program.cs</span><br><span class="line">├── Startup.cs (如果使用Startup类进行配置)</span><br><span class="line">├── appsettings.json</span><br><span class="line">│</span><br><span class="line">└── MyWebApiProject.csproj</span><br></pre></td></tr></table></figure>
<h4 id="各层的实现原理">各层的实现原理</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>模型层</strong>：定义应用程序的数据结构，表示业务实体和数据传输对象。</p>
</li>
<li class="lvl-2">
<p><strong>控制器层</strong>：处理HTTP请求，通过调用服务层获取或处理数据，然后返回HTTP响应。</p>
</li>
<li class="lvl-2">
<p><strong>服务层</strong>：包含业务逻辑，处理复杂的操作和业务规则。通过调用数据访问层获取和存储数据。</p>
</li>
<li class="lvl-2">
<p><strong>数据访问层</strong>：与数据库或其他数据源交互，执行CRUD（创建、读取、更新、删除）操作，返回数据给服务层。</p>
</li>
</ul>
<p>通过这种分层结构，可以使代码更加模块化、易于维护和测试，同时清晰地分离了各个部分的职责。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础指令</title>
    <url>/2024/06/12/MySQL-%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>介绍了MySQL一些基础指令,增删改查</p>
</blockquote>
<span id="more"></span>
<h3 id="MySQL">MySQL</h3>
<h4 id="准备工作">准备工作</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>添加环境变量</p>
</li>
<li class="lvl-2">
<p>初始化MySQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqld <span class="comment">--initialize-insecure</span></span><br></pre></td></tr></table></figure>
<p>该命令在安全性方面存在缺陷，主要用于开发和测试环境</p>
</li>
<li class="lvl-2">
<p>注册MySQL服务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqld <span class="operator">-</span>install</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>启动/停止 MySQL服务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">net <span class="keyword">start</span> mysql</span><br><span class="line"></span><br><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>修改默认账户密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>u root password xxxx</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>登录MySQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>pxxxx [<span class="operator">-</span>h数据库服务器IP地址 <span class="operator">-</span>P端口号]</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>卸载MySQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line"></span><br><span class="line">mysqld <span class="operator">-</span>remove mysql</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="SQL分类">SQL分类</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>DDL</mark>:Data Definition Language      定义数据库对象</p>
</li>
<li class="lvl-2">
<p><mark>DML</mark> :Data Manipulation Language   操作数据，进行增删改</p>
</li>
<li class="lvl-2">
<p><mark>DQL</mark>:Data Query Language                  查询数据库中的记录</p>
</li>
<li class="lvl-2">
<p><mark>DCL</mark>:Data Control Language                创建数据库的用户，控制访问权限</p>
</li>
</ul>
<h4 id="基础语法">基础语法</h4>
<blockquote>
<p>以分号结尾，不区分大小写</p>
</blockquote>
<h5 id="DDL">DDL</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>查询数据库</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建数据库</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database filename;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> filename; #如果不存在名为filename的数据库就进行创建</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>切换数据库</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use filename;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>查看当前正在使用的数据库</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>删除数据库</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database filename;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> filename;</span><br></pre></td></tr></table></figure>
<h6 id="表操作"><mark>表操作</mark></h6>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">		字段<span class="number">1</span> 字段类型 [约束] [comment 字段<span class="number">1</span>注解],</span><br><span class="line">    	字段<span class="number">2</span> 字段类型 [约束] [comment 字段<span class="number">2</span>注解]</span><br><span class="line">)[comment 表注解];</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>非空约束</td>
<td>限制该字段值不能为null</td>
<td>not null</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证字段的所有数据都是唯一的</td>
<td>unique</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，<mark>要求非空且唯一</mark></td>
<td>primary key    （auto_increment自增）</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段值，则采用默认值</td>
<td>default</td>
</tr>
<tr>
<td>外键约束</td>
<td>让两张表的数据建立连接，保证数据的一致性和完整性</td>
<td>foreign key</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">creat <span class="keyword">table</span> tb_user(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;ID，唯一标识&#x27;</span>,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;男&#x27;</span> comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;用户表&#x27;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>查询</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当下数据库的表</span></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定表结构</span></span><br><span class="line"><span class="keyword">desc</span> tablename;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  查看数据库的建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tablename;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>修改</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 为表example 添加字段 qq varchar(11)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> example <span class="keyword">add</span> qq <span class="type">varchar</span>(<span class="number">11</span>) comment <span class="string">&#x27;QQ&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改example 字段类型 qq varchar(13)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> example modify qq <span class="type">varchar</span>(<span class="number">13</span>) comment <span class="string">&#x27;QQ&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改example 字段名qq为qq_num</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> example change qq qq_num <span class="type">varchar</span>(<span class="number">13</span>) comment <span class="string">&#x27;QQ&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除qq_num字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> example <span class="keyword">drop</span> <span class="keyword">column</span> qq_num;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将example 表名修改为hello</span></span><br><span class="line">rename <span class="keyword">table</span> example <span class="keyword">to</span> hello;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>删除</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除 example 表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> eample;</span><br></pre></td></tr></table></figure>
<h5 id="DML">DML</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>insert语句</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--  为 example 表的 username，name，gender 字段插入值</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> example(username, name, gender) <span class="keyword">values</span> (<span class="string">&#x27;tinali&#x27;</span>,<span class="string">&#x27; 提纳里&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为 example 表的 所有字段 插入值</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> example <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="string">&#x27;tinali&#x27;</span>,<span class="string">&#x27; 提纳里&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量为 example 表的 username，name，gender字段插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> example(username, name, gender) <span class="keyword">values</span> (<span class="string">&#x27;tinali&#x27;</span>,<span class="string">&#x27;提纳里&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;审判官&#x27;</span>,<span class="string">&#x27;那维莱特&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>update语句</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将 example 中ID为1的 name 字段 更新为 张三,username 字段更新为 hello</span></span><br><span class="line"><span class="keyword">update</span> example <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>, username <span class="operator">=</span> <span class="string">&#x27;hello&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将example 中所有 gender 字段改为 1</span></span><br><span class="line"><span class="keyword">update</span> example <span class="keyword">set</span> gender <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>delete语句</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件];</span><br><span class="line"><span class="comment">-- 删除 example 中ID为1的信息</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> example <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表中所有信息</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> example;</span><br></pre></td></tr></table></figure>
<h5 id="DQL">DQL</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>基本查询</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询特定字段 name，entrydate 并返回</span></span><br><span class="line"><span class="keyword">select</span> name,entrydate <span class="keyword">from</span> example;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询返回所有字段 (通配符)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询特定字段 name，entrydate 并起别名</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">as</span> 姓名,entrydate <span class="keyword">as</span> 入职日期 <span class="keyword">from</span> example;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询job字段的记录（不重复）</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> job <span class="keyword">from</span> example;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>条件查询（<mark>where</mark>）</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select 字段列表 from 表名 where 条件列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 name 为 三子曰 的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;三子曰&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 id 小于等于5 的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 job 为空值的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example <span class="keyword">where</span> job <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 job 非空值的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example <span class="keyword">where</span> job <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 password 不是 123456</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example <span class="keyword">where</span> password <span class="operator">!=</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 age 在 20 到 30 之间的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询id 为1，2，3的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)l;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 name 为两个字的记录 （两条下划线）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;__&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 name 字段中第一个字为 张 的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span></span><br><span class="line"></span><br><span class="line">_可替代一个字符  <span class="operator">%</span>可替代随机数目的字符</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>分组查询（<mark>groud by</mark>）</p>
<ul class="lvl-2">
<li class="lvl-4">聚合函数 count max min avg sum</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select 聚合函数 from 表名</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 统计 id 字段数的数目</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> example;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select 字段列表 from 表名 [where 条件] group by 分组字段名[having 分组后的过滤的条件];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据 gender 分组，统计男女员工的数量</span></span><br><span class="line"><span class="keyword">select</span> gender,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> example <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 age 在30（包含）以前的员工，并对job进行分组，获得数量大于等于2的job数据</span></span><br><span class="line"><span class="keyword">select</span> job,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> example <span class="keyword">where</span> age <span class="operator">&lt;=</span> <span class="number">30</span> <span class="keyword">group</span> <span class="keyword">by</span> job <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>排序查询（<mark>order by</mark>）</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--select 字段列表 from 表名 [where 条件列表][group by 分组字段] order by 字段1 排序方法1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--根据年龄进行升序排序  (降序desc)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>分页查询（<mark>limit</mark>）</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- select 字段列表 from 表名 limit 起始索引，查询记录数;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从 起始索引为0，开始查询，每夜展示五条数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example limit <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询第一页数据，每页展示五条数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example limit <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询第二，每页展示五条数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> example limit <span class="number">5</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>身份证号码简易识别(opencv + Qt)</title>
    <url>/2024/05/30/%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81%E7%AE%80%E6%98%93%E8%AF%86%E5%88%AB-opencv-Qt/</url>
    <content><![CDATA[<p>记录了一下项目制作过程中 opencv基本API的使用,以及一些基本概念源码可至GitHub查看</p>
 <span id="more"></span>
<h1>身份证信息识别</h1>
<h3 id="1-图片的读取-显示">1. 图片的读取 显示</h3>
<blockquote>
<p><strong><mark>imread()读取图像</mark></strong>，imread包含两个参数：imread(图像路径， 图像形式)；</p>
<p><strong><mark>namedWindow()</mark></strong> 用来新建一个显示窗口,用来显示图像,包含两个参数：namedWindow(窗口名称， 窗口形式)</p>
<p>**<mark>imshow()</mark>**用于显示图像,包含两个参数：imshow(窗口名称，图像名称)</p>
</blockquote>
<p><strong>图像形式有三种</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>加载彩色图片 (默认加载形式)</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">imread</span>(图像路径， IMREAD_COLOR)；</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">imread</span>(图像路径， <span class="number">1</span>)；</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>加载灰度模式图像</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">imread</span>(图像路径， IMREAD_GRAYSCALE)；</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">imread</span>(图像路径， <span class="number">0</span>)；</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>加载图像,包括alpha通道</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">imread</span>(图像路径，IMREAD_UNCHANGED)；</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">imread</span>(图像路径， <span class="number">-1</span>)；</span><br></pre></td></tr></table></figure>
<p><strong>窗口形式</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>显示的图像大小不能改变（默认形式）</p>
<p>namedWindow(窗口名称， WINDOW_AUTOSIZE)     1</p>
</li>
<li class="lvl-2">
<p>图像大小能够调节</p>
<p>namedWindow(窗口名称， WINDOW_NORMAL)      0</p>
</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat image;   <span class="comment">//创建一个空图像image</span></span><br><span class="line">	image = <span class="built_in">imread</span>(<span class="string">&quot;D://work//c++//Imageprocessing1//企鹅.jpg&quot;</span>);  <span class="comment">//读取文件夹中的图像</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//检测图像是否加载成功</span></span><br><span class="line">	<span class="keyword">if</span> (image.<span class="built_in">empty</span>())  <span class="comment">//检测image有无数据，无数据 image.empty()返回 真</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Could not open or find the image&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">namedWindow</span>(<span class="string">&quot;IMAGE&quot;</span>);  <span class="comment">//创建显示窗口，不加这行代码，也能显示，默认窗口大小不能改变</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;IMAGE&quot;</span>, image);  <span class="comment">//在窗口显示图像</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">imwrite</span>(<span class="string">&quot;1.png&quot;</span>, image); <span class="comment">//保存图像为png格式，文件名称为1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);  <span class="comment">//暂停，保持图像显示，等待按键结束</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-qt中的string转化为opencv中的string">2. qt中的string转化为opencv中的string</h3>
<blockquote>
<p>先调用 <code>toLocal8Bit()</code> 方法将 <code>fileName</code> 转换为本地8位编码的 <code>QByteArray</code>，然后再调用 <code>data()</code> 方法获取该 <code>QByteArray</code> 中存储的 C 风格字符串的指针</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ID_card_recognition::read_image</span><span class="params">(<span class="type">const</span> QString&amp; fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString tmpPath = fileName.<span class="built_in">toLocal8Bit</span>().<span class="built_in">data</span>();<span class="comment">//将 fileName 转换为本地8位编码的 C 风格字符串</span></span><br><span class="line">    Mat image;   <span class="comment">//创建一个空图像image</span></span><br><span class="line">    image = <span class="built_in">imread</span>(tmpPath.<span class="built_in">toStdString</span>(), IMREAD_COLOR);  <span class="comment">//读取文件夹中的图像</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-二值化处理">3. 二值化处理</h3>
<blockquote>
<p>二值化处理（Binarization）是一种图像处理技术，它将图像中的像素值根据特定的阈值转化为两种值（通常是0和255），从而简化图像的数据表示。</p>
<p>通常需要<mark>先将图片转换为灰度图像</mark>再进行二值化处理</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>void threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type);</strong></p>
</li>
</ul>
<blockquote>
<p><code>threshold()</code> 函数是 OpenCV 中用于图像二值化的函数，它将输入图像的像素值根据指定的阈值进行分割，生成一个二值化图像</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><mark>cv::THRESH_BINARY</mark>：如果源图像像素值大于阈值，则输出图像的对应像素值设置为<code>maxval</code>，否则设置为0。</p>
</li>
<li class="lvl-3">
<p><mark>cv::THRESH_BINARY_INV</mark>：与<code>THRESH_BINARY</code>相反，如果源图像像素值大于阈值，则输出图像的对应像素值设置为0，否则设置为<code>maxval</code>。</p>
</li>
<li class="lvl-3">
<p><code>cv::THRESH_TRUNC</code>：如果源图像像素值大于阈值，则输出图像的对应像素值设置为阈值<code>thresh</code>，否则保持源图像的像素值不变。</p>
</li>
<li class="lvl-3">
<p><code>cv::THRESH_TOZERO</code>：如果源图像像素值大于阈值，则输出图像的对应像素值保持不变，否则设置为0。</p>
</li>
<li class="lvl-3">
<p><code>cv::THRESH_TOZERO_INV</code>：与<code>THRESH_TOZERO</code>相反，如果源图像像素值大于阈值，则输出图像的对应像素值设置为0，否则保持源图像的像素值不变。</p>
</li>
<li class="lvl-3">
<p><code>cv::THRESH_MASK</code>：这是一个掩码值，用于与上述其他值进行按位或操作，以保持旧的OpenCV兼容性。</p>
</li>
<li class="lvl-3">
<p><code>cv::THRESH_OTSU</code>：在使用<code>THRESH_BINARY</code>或<code>THRESH_BINARY_INV</code>阈值类型时，这个标志可以自动选择最优的阈值。它会计算源图像的直方图，并使用大津二值化方法来找到将图像分为两个类别的最佳阈值。</p>
</li>
<li class="lvl-3">
<p><code>cv::THRESH_TRIANGLE</code>：这是另一个自动选择阈值的标志，它使用三角形方法来找到最优阈值，这种方法通常比大津方法更快，但在某些情况下可能不如大津方法准确。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取灰度图像</span></span><br><span class="line">    Mat image = <span class="built_in">imread</span>(<span class="string">&quot;image.jpg&quot;</span>, IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Could not open or find the image&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置阈值和最大值</span></span><br><span class="line">    <span class="type">int</span> thresh_value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_value = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用二值化</span></span><br><span class="line">    Mat binary_image;</span><br><span class="line"> 	<span class="built_in">threshold</span>(image, binary_image, thresh_val, max_value, THRESH_BINARY | THRESH_OTSU);</span><br><span class="line">    <span class="comment">/*THRESH_BINARY：大于阈值的像素赋值为 maxval，小于等于阈值的像素赋值为 0。</span></span><br><span class="line"><span class="comment">    THRESH_OTSU可以实现 Otsu&#x27;s 二值化方法，即自动选择最优的阈值，而无需手动指定阈值</span></span><br><span class="line"><span class="comment">    二者通常结合使用  使用Otsu&#x27;s时thresh 参数可以设置为 0，因为该值不会被实际使用*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Binary Image&quot;</span>, binary_image);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">destroyAllWindows</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-双边滤波">4. 双边滤波</h3>
<blockquote>
<p>双边滤波（Bilateral Filter）是一种非线性滤波技术，它能够在保持边缘清晰的同时有效地去除图像中的噪声</p>
</blockquote>
<p><strong>void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType = BORDER_DEFAULT);</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>d</code>：滤波器的直径。如果为 -1，则根据 <code>sigmaSpace</code> 自动计算。</p>
</li>
<li class="lvl-2">
<p><code>sigmaColor</code>：颜色空间的标准差，较大的值表示颜色空间中更大的像素距离将相互混合。</p>
</li>
<li class="lvl-2">
<p><code>sigmaSpace</code>：空间域的标准差，较大的值表示在空间域内的像素距离将相互混合。</p>
</li>
<li class="lvl-2">
<p><code>borderType</code>：用于处理边界的类型，默认为 <code>BORDER_DEFAULT</code>。</p>
</li>
</ul>
<h3 id="5-查找轮廓">5.  查找轮廓</h3>
<blockquote>
<p>轮廓可以看作是将具有相同颜色或灰度值的所有连续点（沿着边界）连接起来的曲线</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::findContours</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputOutputArray image,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArrayOfArrays contours,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray hierarchy,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> method,</span></span></span><br><span class="line"><span class="params"><span class="function">    Point offset = Point()</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//在黑色背景中寻找白色轮廓</span></span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p><strong>image</strong>：输入图像（8位单通道图像），也是输出图像。</p>
<ul class="lvl-2">
<li class="lvl-5">图像必须是二值化图像（通常通过 <code>cv::threshold</code> 或 <code>cv::Canny</code> 等方法预处理）。</li>
<li class="lvl-5">该函数会修改输入图像，建议在调用该函数之前对图像进行备份。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>contours</strong>：输出参数，用于存储检测到的轮廓。</p>
<ul class="lvl-2">
<li class="lvl-5">轮廓存储为点的向量的向量，每个轮廓是一个 <code>std::vector&lt;cv::Point&gt;</code> 类型的对象。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>hierarchy</strong>：输出参数，用于存储每个轮廓的层次结构信息。</p>
<ul class="lvl-2">
<li class="lvl-5">这是一个 <code>std::vector&lt;cv::Vec4i&gt;</code> 类型的向量。</li>
<li class="lvl-5"><code>hierarchy[i][0]</code> 表示后一个轮廓的索引。</li>
<li class="lvl-5"><code>hierarchy[i][1]</code> 表示前一个轮廓的索引。</li>
<li class="lvl-5"><code>hierarchy[i][2]</code> 表示父轮廓的索引。</li>
<li class="lvl-5"><code>hierarchy[i][3]</code> 表示第一个子轮廓的索引。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>mode</strong>：轮廓检索模式，决定轮廓的提取方式和层次结构。</p>
<ul class="lvl-2">
<li class="lvl-5"><code>cv::RETR_EXTERNAL</code>：只检索最外层的轮廓。</li>
<li class="lvl-5"><code>cv::RETR_LIST</code>：检索所有轮廓，但不建立层次结构。</li>
<li class="lvl-5"><code>cv::RETR_CCOMP</code>：检索所有轮廓并将它们组织成两级层次结构。</li>
<li class="lvl-5"><code>cv::RETR_TREE</code>：检索所有轮廓并重建嵌套轮廓的完整层次结构。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>method</strong>：轮廓近似方法，决定如何存储轮廓点。</p>
<ul class="lvl-2">
<li class="lvl-5"><code>cv::CHAIN_APPROX_NONE</code>：存储所有轮廓点。</li>
<li class="lvl-5"><code>cv::CHAIN_APPROX_SIMPLE</code>：压缩水平、垂直和对角线段，只保留它们的端点。</li>
<li class="lvl-5"><code>cv::CHAIN_APPROX_TC89_L1</code> 和 <code>cv::CHAIN_APPROX_TC89_KCOS</code>：使用 Teh-Chin 链近似算法。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>offset</strong>（可选）：可选参数，用于对输出的轮廓点坐标进行偏移，默认为 <code>(0, 0)</code>。</p>
</li>
</ol>
<h3 id="6-绘制轮廓">6. 绘制轮廓</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::drawContours</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputOutputArray image,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArrayOfArrays contours,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> contourIdx,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> thickness = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray hierarchy = noArray(),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> maxLevel = INT_MAX,</span></span></span><br><span class="line"><span class="params"><span class="function">    Point offset = Point()</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li class="lvl-3">
<p><strong>image</strong>：输入输出参数，用于绘制轮廓的图像。</p>
<ul class="lvl-2">
<li class="lvl-5">类型为 <code>cv::InputOutputArray</code>，通常为 <code>cv::Mat</code> 类型。</li>
<li class="lvl-5">这是一个修改后的图像，轮廓会被绘制在该图像上。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>contours</strong>：输入参数，表示轮廓的集合。</p>
<ul class="lvl-2">
<li class="lvl-5">类型为 <code>cv::InputArrayOfArrays</code>，通常是 <code>std::vector&lt;std::vector&lt;cv::Point&gt;&gt;</code> 类型。</li>
<li class="lvl-5">每个轮廓都是一个点的集合，表示图像中的一个连通区域。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>contourIdx</strong>：输入参数，指定绘制哪个轮廓的索引。</p>
<ul class="lvl-2">
<li class="lvl-5">如果为负值（例如 <code>-1</code>），则绘制所有轮廓。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>color</strong>：输入参数，指定绘制轮廓的颜色。</p>
<ul class="lvl-2">
<li class="lvl-5">类型为 <code>cv::Scalar</code>，例如 <code>cv::Scalar(0, 255, 0)</code> 表示绿色。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>thickness</strong>（可选）：输入参数，指定绘制轮廓的线条粗细。</p>
<ul class="lvl-2">
<li class="lvl-5">默认值为 <code>1</code>。</li>
<li class="lvl-5">如果值为 <code>FILLED</code> 或负值，则填充整个轮廓。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>lineType</strong>（可选）：输入参数，指定线条的类型。</p>
<ul class="lvl-2">
<li class="lvl-5">默认值为 <code>cv::LINE_8</code>，表示 8-连接线。</li>
<li class="lvl-5">可以为 <code>cv::LINE_4</code>（4-连接线）或 <code>cv::LINE_AA</code>（抗锯齿线）。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>hierarchy</strong>（可选）：输入参数，指定轮廓的层次结构。</p>
<ul class="lvl-2">
<li class="lvl-5">类型为 <code>cv::InputArray</code>，通常是 <code>std::vector&lt;cv::Vec4i&gt;</code> 类型。</li>
<li class="lvl-5">如果不需要层次结构，可以传递 <code>cv::noArray()</code>。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>maxLevel</strong>（可选）：输入参数，指定绘制轮廓的最大层次。</p>
<ul class="lvl-2">
<li class="lvl-5">默认值为 <code>INT_MAX</code>，表示绘制所有层次的轮廓。</li>
<li class="lvl-5">例如，如果设置为 <code>0</code>，则只绘制最外层的轮廓。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>offset</strong>（可选）：输入参数，指定绘制轮廓时的偏移量。</p>
<ul class="lvl-2">
<li class="lvl-5">类型为 <code>cv::Point</code>，默认值为 <code>cv::Point(0, 0)</code>。</li>
</ul>
</li>
</ol>
<h3 id="7-绘制轮廓-二">7 绘制轮廓(二)</h3>
<p><strong>7.1 <code>cv::boundingRect</code> 函数</strong></p>
<blockquote>
<p>用于计算给定点集或轮廓的最小边界矩形。这个矩形是完全包含输入轮廓的最小矩形，并且其边与坐标轴对齐。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Rect <span class="title">cv::boundingRect</span><span class="params">(InputArray points)</span></span>;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>points</strong>：输入的点集，可以是一个轮廓（如 <code>std::vector&lt;cv::Point&gt;</code>）或者是 <code>cv::Mat</code> 类型的点集。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>返回一个 <code>cv::Rect</code> 对象，表示包含所有输入点的最小边界矩形。</p>
</li>
</ul>
<p><strong>7.2 <code>cv::rectangle</code> 函数</strong></p>
<blockquote>
<p>用于在图像上绘制矩形。可以根据需要设置矩形的位置、大小、颜色和线条厚度等属性。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::rectangle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputOutputArray img,</span></span></span><br><span class="line"><span class="params"><span class="function">    Point pt1,</span></span></span><br><span class="line"><span class="params"><span class="function">    Point pt2,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> thickness = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> shift = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">或者</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::rectangle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputOutputArray img,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Rect&amp; rec,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> thickness = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> shift = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>img</strong>：输入输出图像，用于绘制矩形的图像。</p>
</li>
<li class="lvl-2">
<p><strong>pt1</strong>：矩形的一个顶点。</p>
</li>
<li class="lvl-2">
<p><strong>pt2</strong>：矩形的对角顶点。</p>
</li>
<li class="lvl-2">
<p><strong>rec</strong>：表示矩形的 <code>cv::Rect</code> 对象。</p>
</li>
<li class="lvl-2">
<p><strong>color</strong>：矩形的颜色，使用 <code>cv::Scalar</code> 定义，例如 <code>cv::Scalar(0, 255, 0)</code> 表示绿色。</p>
</li>
<li class="lvl-2">
<p><strong>thickness</strong>：线条厚度。默认值为 <code>1</code>。如果值为负数（如 <code>FILLED</code>），则填充矩形。</p>
</li>
<li class="lvl-2">
<p><strong>lineType</strong>：线条类型，可以是 <code>cv::LINE_8</code>、<code>cv::LINE_4</code> 或 <code>cv::LINE_AA</code>。</p>
</li>
<li class="lvl-2">
<p><strong>shift</strong>：坐标点的小数点位数，默认值为 <code>0</code>。</p>
</li>
</ul>
<p><mark><strong>示例代码</strong></mark></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 计算轮廓的最小边界矩形</span></span><br><span class="line">    cv::Rect boundingRect = cv::<span class="built_in">boundingRect</span>(contours[i]);</span><br><span class="line">    <span class="comment">// 在图像上绘制边界矩形</span></span><br><span class="line">    cv::<span class="built_in">rectangle</span>(image, boundingRect, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并标记矩形的中心点</span></span><br><span class="line">    cv::Point center = (boundingRect.<span class="built_in">tl</span>() + boundingRect.<span class="built_in">br</span>()) * <span class="number">0.5</span>;</span><br><span class="line">    cv::<span class="built_in">circle</span>(image, center, <span class="number">5</span>, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-腐蚀-与-膨胀">8. 腐蚀 与 膨胀</h3>
<img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240526125045766.png" alt="image-20240526125045766" style="zoom:200%;" />
<img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240526125148573.png" alt="image-20240526125148573" style="zoom:200%;" />
<h3 id="9-开操作-闭操作">9. 开操作 闭操作</h3>
<p><strong>开操作</strong>先腐蚀后膨胀的操作称之为开操作。主要用于消除小的物体、在纤细点处分离物体、平滑较大物体的边界，同时并不明显改变其面积。此外，开操作还<mark>可以用于提取水平或竖直的线条</mark></p>
<p><strong>闭操作</strong>先膨胀后腐蚀 主要用于填充物体内的小空洞、连接邻近物体、平滑其边界，同时并不明显改变其面积 <mark>可以用于填充小的封闭区域</mark></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取图像</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;path_to_your_image.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法读取图像&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示原始图像</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;原始图像&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义结构元素，用于开操作和闭操作</span></span><br><span class="line">    cv::Mat kernel = cv::<span class="built_in">getStructuringElement</span>(cv::MORPH_RECT, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">	<span class="comment">/*kernel2 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (10, 10)) # 椭圆结构</span></span><br><span class="line"><span class="comment">	kernel3 = cv2.getStructuringElement(cv2.MORPH_CROSS, (10, 10)) # 十字结构*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行开操作</span></span><br><span class="line">    cv::Mat open_result;</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(image, open_result, cv::MORPH_OPEN, kernel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示开操作结果</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;开操作结果&quot;</span>, open_result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行闭操作</span></span><br><span class="line">    cv::Mat close_result;</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(image, close_result, cv::MORPH_CLOSE, kernel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示闭操作结果</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;闭操作结果&quot;</span>, close_result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待按键后退出</span></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="10-模板匹配">10. 模板匹配</h3>
<p><strong>void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method);</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>image</code>：输入图像，必须是 8 位或 32 位浮点数。</p>
</li>
<li class="lvl-2">
<p><code>template</code>：模板图像，必须是相同类型和深度的大小小于或等于输入图像的图像。</p>
</li>
<li class="lvl-2">
<p><code>result</code>：匹配结果图像，是一个单通道 32 位浮点数。每个像素表示该区域与模板的匹配程度。</p>
</li>
<li class="lvl-2">
<p><code>method</code>指定的匹配方法，可以是以下之一：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>TM_SQDIFF</code>：平方差匹配法，计算模板与图像之间的平方差，值越小表示匹配度越高。</li>
<li class="lvl-4"><code>TM_SQDIFF_NORMED</code>：归一化平方差匹配法，计算归一化的平方差，值越小表示匹配度越高。</li>
<li class="lvl-4"><code>TM_CCORR</code>：相关性匹配法，计算模板与图像之间的相关性，值越大表示匹配度越高。</li>
<li class="lvl-4"><code>TM_CCORR_NORMED</code>：归一化相关性匹配法，计算归一化的相关性，值越大表示匹配度越高。</li>
<li class="lvl-4"><code>TM_CCOEFF</code>：相关系数匹配法，计算模板与图像之间的相关系数，值越大表示匹配度越高。</li>
<li class="lvl-4"><code>TM_CCOEFF_NORMED</code>：归一化相关系数匹配法，计算归一化的相关系数，值越大表示匹配度越高。</li>
</ul>
</li>
</ul>
<p><em><em>void minMaxLoc(InputArray src, double</em> minVal, double</em> maxVal = 0, Point* minLoc = 0, Point* maxLoc = 0, InputArray mask = noArray());**</p>
<blockquote>
<p>用于在给定的矩阵中找到最小值和最大值，并返回它们的位置。这个函数在图像处理中非常有用，尤其是在需要找到图像中的最亮或最暗点、或者在模板匹配中找到最佳匹配位置时</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>src</code>：输入的单通道数组。</p>
</li>
<li class="lvl-2">
<p><code>minVal</code>：返回最小值的指针（如果不需要，则可以设置为 <code>NULL</code>）。</p>
</li>
<li class="lvl-2">
<p><code>maxVal</code>：返回最大值的指针（如果不需要，则可以设置为 <code>NULL</code>）。</p>
</li>
<li class="lvl-2">
<p><code>minLoc</code>：返回最小值位置的指针（如果不需要，则可以设置为 <code>NULL</code>）。</p>
</li>
<li class="lvl-2">
<p><code>maxLoc</code>：返回最大值位置的指针（如果不需要，则可以设置为 <code>NULL</code>）。</p>
</li>
<li class="lvl-2">
<p><code>mask</code>：用于选择数组元素的感兴趣区域，如果不需要，则使用 <code>noArray()</code>。</p>
</li>
</ul>
<p><strong>void resize(InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR);</strong></p>
<blockquote>
<p>缩放图片</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>src</code>：输入图像，可以是任意通道数的 <code>Mat</code> 对象。</p>
</li>
<li class="lvl-2">
<p><code>dst</code>：输出图像，大小为 <code>dsize</code>，或者与 <code>src</code> 相同类型和大小的 <code>Mat</code> 对象。</p>
</li>
<li class="lvl-2">
<p><code>dsize</code>：输出图像的大小。如果这个参数为 0，则它由 <code>fx</code> 和 <code>fy</code> 参数决定。</p>
</li>
<li class="lvl-2">
<p><code>fx</code>：水平方向的缩放比例。如果这个参数为 0，则它由 <code>dsize</code> 参数决定。</p>
</li>
<li class="lvl-2">
<p><code>fy</code>：垂直方向的缩放比例。如果这个参数为 0，则它由 <code>dsize</code> 参数决定。</p>
</li>
<li class="lvl-2">
<p><code>interpolation</code>插值方法，用于在缩放时计算新像素值。可选的插值方法包括：</p>
<ul class="lvl-2">
<li class="lvl-4"><code>INTER_NEAREST</code>：最近邻插值。</li>
<li class="lvl-4"><code>INTER_LINEAR</code>：双线性插值（默认值）。</li>
<li class="lvl-4"><code>INTER_AREA</code>：使用像素区域关系重采样。当图像缩小时，这种方法可以避免波纹出现，通常用于图像缩放。</li>
<li class="lvl-4"><code>INTER_CUBIC</code>：三次样条插值。</li>
<li class="lvl-4"><code>INTER_LANCZOS4</code>：Lanczos 插值，超过 8x8 像素邻域的采样。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ID_number.<span class="built_in">size</span>() != <span class="number">18</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	Mat roi = ID_number[i].mat;</span><br><span class="line">	<span class="built_in">resize</span>(roi, roi, <span class="built_in">Size</span>(<span class="number">30</span>, <span class="number">40</span>), <span class="number">0</span>, <span class="number">0</span>, INTER_AREA);</span><br><span class="line">	Mat gray_image;</span><br><span class="line">	<span class="built_in">cvtColor</span>(roi, gray_image, cv::COLOR_BGR2GRAY);</span><br><span class="line">	Mat binary_image;</span><br><span class="line">	<span class="built_in">threshold</span> (gray_image, binary_image, <span class="number">0</span>, <span class="number">255</span>, THRESH_BINARY_INV | THRESH_OTSU);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> Max = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		Mat template_num = templates_cards[j].mat;</span><br><span class="line">		<span class="built_in">resize</span>(template_num, template_num, <span class="built_in">Size</span>(<span class="number">30</span>, <span class="number">40</span>), <span class="number">0</span>, <span class="number">0</span>, INTER_AREA);</span><br><span class="line">		Mat gray_template_num;</span><br><span class="line">		<span class="built_in">cvtColor</span>(template_num, gray_template_num, cv::COLOR_BGR2GRAY);</span><br><span class="line">		Mat binary_template_num;</span><br><span class="line">		<span class="built_in">threshold</span>(gray_template_num, binary_template_num, <span class="number">0</span>, <span class="number">255</span>, THRESH_BINARY_INV | THRESH_OTSU);</span><br><span class="line"></span><br><span class="line">		Mat result;</span><br><span class="line">		<span class="built_in">matchTemplate</span>(binary_image, binary_template_num, result, TM_CCOEFF_NORMED);</span><br><span class="line">		<span class="type">double</span> minVal, maxVal;</span><br><span class="line">		Point minLoc, maxLoc;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">minMaxLoc</span>(result, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (maxVal &gt; Max)</span><br><span class="line">		&#123;</span><br><span class="line">			Max = maxVal;</span><br><span class="line">			maxIndex = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	result[i] = maxIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>订餐程序中qt的使用(qt基础用法)</title>
    <url>/2024/05/18/%E8%AE%A2%E9%A4%90%E7%A8%8B%E5%BA%8F%E4%B8%ADqt%E7%9A%84%E4%BD%BF%E7%94%A8-qt%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>记录了一下项目制作过程中 Qt基本API的使用,以及一些基本概念源码可至GitHub查看</p>
</blockquote>
<span id="more"></span>
<h1>Qt基础知识</h1>
<h3 id="Qt中的窗口类">Qt中的窗口类</h3>
<p><strong>1.1 基础窗口类</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240503151301988.png" alt="image-20240503151301988"></p>
<p>常用的窗口类是图中下面三个，在创建Qt窗口时，需要让自己的窗口类继承上述三个窗口类中的一个</p>
<p><strong>1.2 窗口的显示方式</strong></p>
<p><mark>模态（modal）窗口</mark>：窗口弹出后，没关闭之前，<strong>不可以</strong>对同一应用程序的其他窗口进行操作；<mark>非模态（modeless）窗口</mark>：窗口弹出后，没关闭之前，<strong>可以</strong>对同一应用程序的其他窗口进行操作</p>
<p><strong>1.3 模态窗口的实现方法</strong></p>
<blockquote>
<p>窗口的show()函数显示的类型是非模态的，有几种方法可以将窗口设为模态，如下</p>
</blockquote>
<p><strong>1.3.1 QDialog对话框</strong></p>
<p>方法一：exec()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QDialog <span class="title">dlg</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">dlg.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//exec是execute（执行）的缩写，当调用exec()函数时，并不会立即返回，只用当对话框关闭才会返回，因此，只有关闭对话框才会执行后续的代码</span></span><br></pre></td></tr></table></figure>
<p>方法二：setModal()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QDialog <span class="title">dlg</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">dlg.<span class="built_in">setModal</span>(<span class="literal">true</span>);		<span class="comment">//相当于dlg.setWindowModality(Qt::ApplicationModal);</span></span><br><span class="line">dlg.<span class="built_in">show</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法三：setWindowModality()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QDialog <span class="title">dlg</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">dlg.<span class="built_in">setWindowModality</span>(Qt::ApplicationModal);</span><br><span class="line">dlg.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>==setWindowModality()==的参数设置要阻塞的窗口类型:</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::NonModal</td>
<td>0</td>
<td>非模态，不阻塞任何窗口</td>
</tr>
<tr>
<td>Qt::WindowModal</td>
<td>1</td>
<td>半模态,窗口极模态,阻塞它的父窗口、所有的祖先窗口以及他们的子窗口</td>
</tr>
<tr>
<td>Qt::ApplicationModal</td>
<td>2</td>
<td>模态,应用程序级模态,阻塞应用程序所有的窗口</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="常用类">常用类</h3>
<h4 id="字符串类型">字符串类型</h4>
<blockquote>
<p>C   ----&gt;   char*</p>
<p>C++  ------&gt;   std::string</p>
<p>Qt   -------&gt;   QByteArray,QString</p>
</blockquote>
<p>相关函数,查阅qt中的帮助文档,在命令行中输入<code>assistant</code></p>
<h4 id="QVariant类">QVariant类</h4>
<blockquote>
<p>类似于C++中的模板</p>
<p>可以对不同的数据类型进行包装,从而使用<strong>相同</strong>的函数对<strong>不同</strong>类型的数据进行处理</p>
</blockquote>
<p><strong>2.2.1 对Qt中的标准类型进行处理</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HelloQt::<span class="built_in">HelloQt</span>(QWidget *parent): <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="type">int</span> value = <span class="built_in">dataPlus</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    QString str = <span class="built_in">dataPlus</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dataPlus()函数在HelloQt类中已经被声明</span></span><br><span class="line"><span class="function">QVariant <span class="title">HelloQt::dataPlus</span><span class="params">(QVariant a,QVariant b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVariant ret;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">type</span>() == QVariant::<span class="type">int</span> &amp;&amp; b.<span class="built_in">type</span>() == QVariant::<span class="type">int</span>)  <span class="comment">//或者使用QMetaType::Int</span></span><br><span class="line">        ret = <span class="built_in">QVariant</span>(a.<span class="built_in">toInt</span>() + b.<span class="built_in">toInt</span>());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="built_in">type</span>() == QVariant::String &amp;&amp; b.<span class="built_in">type</span>() == QVariant::String)</span><br><span class="line">        ret.<span class="built_in">setValue</span>(a.<span class="built_in">toString</span>() + b.<span class="built_in">toString</span>());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.2.2 自定义类型</strong></p>
<blockquote>
<p>若自定义了一个类型,则需要使用Qt中的宏进行声明</p>
<p><mark>Q_DECLARE_METATYPE(Type)</mark></p>
</blockquote>
<p>第一步:定义类型,并注册</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>()&#123;&#125;  <span class="comment">//必须要有默认构造函数</span></span><br><span class="line">                <span class="comment">//拷贝构造函数也必须有，不过没有深、浅拷贝时，用默认的即可</span></span><br><span class="line">    <span class="built_in">Animal</span>(QString name):_name(name)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Animal show name is :&quot;</span>&lt;&lt; _name &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义类型注册</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(Animal);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二步: 使用fromvalue()存储对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//QVariant vt(Animal(&quot;snake&quot;)); //不可以通过构造函数存自定义类型</span></span><br><span class="line">    QVariant vt;</span><br><span class="line">    <span class="comment">//有以下两种方法可以，存自定义类型</span></span><br><span class="line">    vt = QVariant::<span class="built_in">fromValue</span>(<span class="built_in">Animal</span>(<span class="string">&quot;dog&quot;</span>));    <span class="comment">//①</span></span><br><span class="line">    vt.<span class="built_in">setValue</span>(<span class="built_in">Animal</span>(<span class="string">&quot;cat&quot;</span>));                 <span class="comment">//②</span></span><br><span class="line">    <span class="comment">//如果能转换到Animal类型，就转换</span></span><br><span class="line">    <span class="keyword">if</span>(vt.<span class="built_in">canConvert</span>&lt;Animal&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        Animal animal = vt.<span class="built_in">value</span>&lt;Animal&gt;();</span><br><span class="line">        animal.<span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="QPoint">QPoint</h4>
<blockquote>
<p>QPoint类封装了我们常用用到的坐标点 (x, y), 常用的 API如下</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::rx</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::ry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果x和y坐标都为0则返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回x()和y()的绝对值之和，传统上称为从原点到该点的向量的“曼哈顿长度”。</span></span></span><br><span class="line"><span class="function"><span class="comment">//(p1-p2).manhattanLength();   </span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">manhattanLength</span><span class="params">()</span> <span class="type">const</span>    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个交换了x和y坐标的点:   QPoint&#123;1, 2&#125;.transposed() // &#123;2, 1&#125;  </span></span></span><br><span class="line"><span class="function">QPoint <span class="title">transposed</span><span class="params">()</span> <span class="type">const</span>    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 直接通过坐标对象进行算术运算: 加减乘除</span></span></span><br><span class="line"><span class="function">QPoint &amp;QPoint::<span class="keyword">operator</span>*</span>=(<span class="type">float</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">double</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">int</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>+=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>-=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>/=(qreal divisor);</span><br></pre></td></tr></table></figure>
<h4 id="QLine">QLine</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置直线的起点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setP1</span><span class="params">(<span class="type">const</span> QPoint &amp;p1)</span></span>;</span><br><span class="line"><span class="comment">// 设置直线的终点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setP2</span><span class="params">(<span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setPoints</span><span class="params">(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::setLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::p1</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 返回直线的起始点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::p2</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 返回直线的终点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QLine::center</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 返回值直线的中心点坐标, (p1() + p2()) / 2   </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::x1</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 返回值直线起点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::y1</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 返回值直线起点的 y 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::x2</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 返回值直线终点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::y2</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 返回值直线终点的 y 坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::dx</span><span class="params">()</span> <span class="type">const</span>          <span class="comment">//返回直线向量的水平分量  </span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QLine::dy</span><span class="params">()</span> <span class="type">const</span>          <span class="comment">//返回直线向量的垂直分量  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 用给定的坐标点平移这条直线</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::translate</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLine::translate</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span></span>;</span><br><span class="line"><span class="comment">// 用给定的坐标点平移这条直线, 返回平移之后的坐标点(不会改变这条线的坐标)</span></span><br><span class="line"><span class="function">QLine <span class="title">QLine::translated</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QLine <span class="title">QLine::translated</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线对象进行比较</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-QSize">2.5 QSize</h4>
<blockquote>
<p>在QT中QSize类用来形容长度和宽度, 常用的API如下:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 得到宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">rwidth</span><span class="params">()</span></span>;          <span class="comment">// 得到宽度的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 得到高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">rheight</span><span class="params">()</span></span>;         <span class="comment">// 得到高度的引用</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose</span><span class="params">()</span></span>;           <span class="comment">// 交换高度和宽度的值</span></span><br><span class="line"><span class="function">QSize <span class="title">transposed</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// 交换高度和宽度的值, 返回交换之后的尺寸信息</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">//返回一个大小，宽为当前大小与other的最小值，高为当前大小与other的最小值</span></span><br><span class="line"><span class="function">QSize <span class="title">boundedTo</span><span class="params">(<span class="type">const</span> QSize&amp; oterSize)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个大小，宽为当前大小与other的最大值，高为当前大小与other的最大值    </span></span></span><br><span class="line"><span class="function">QSize <span class="title">expandedTo</span><span class="params">(<span class="type">const</span> QSize &amp;otherSize)</span> <span class="type">const</span>    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">根据指定的模式，按给定的宽度和高度缩放矩形:  </span></span></span><br><span class="line"><span class="comment"><span class="function">    如果mode为Qt::IgnoreAspectRatio，则大小设置为(width, height)。  </span></span></span><br><span class="line"><span class="comment"><span class="function">    如果mode为Qt::KeepAspectRatio，当前大小将在内部缩放到一个尽可能大的矩形(宽度，高度)，保持高宽比。  </span></span></span><br><span class="line"><span class="comment"><span class="function">    如果mode是Qt::KeepAspectRatioByExpanding，当前大小被缩放到一个矩形，尽可能小的外部(宽度，高度)，保持长宽比。  </span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scale</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, Qt::AspectRatioMode mode)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scale</span><span class="params">(<span class="type">const</span> QSize &amp;size, Qt::AspectRatioMode mode)</span></span></span><br><span class="line"><span class="function">QSize <span class="title">scaled</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, Qt::AspectRatioMode mode)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QSize <span class="title">scaled</span><span class="params">(<span class="type">const</span> QSize &amp;s, Qt::AspectRatioMode mode)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">​</span></span><br><span class="line"><span class="function"><span class="comment">// 进行算法运算: 加减乘除</span></span></span><br><span class="line"><span class="function">QSize &amp;<span class="keyword">operator</span>*</span>=(qreal factor);</span><br><span class="line">QSize &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;<span class="keyword">operator</span>/=(qreal divisor);</span><br></pre></td></tr></table></figure>
<h3 id="信号和槽">信号和槽</h3>
<p><strong>3.1 信号(signal)</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>信号本质是事件,如按钮点击,窗口刷新等</p>
</li>
<li class="lvl-2">
<p>信号以函数形式呈现</p>
</li>
</ul>
<p><mark>Qt中信号的发出者可能是某个实例化的类对象,对象内部可以进行相关事件的检测</mark></p>
<p><strong>3.2 槽(slot)</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>槽函数是一类特殊的功能函数,在编码过程中也<strong>可以作为类的普通成员函数来使用</strong></p>
</li>
<li class="lvl-2">
<p>对发出来的信号进行处理</p>
</li>
</ul>
<p><mark>槽函数的所有者也是某个类的实例对象</mark></p>
<p><strong>3.3 connect函数</strong></p>
<blockquote>
<p>connect函数属于QObject类</p>
</blockquote>
<p>需要通过这个函数建立signal和slot二者之间的联系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender,<span class="type">const</span> <span class="type">char</span> *signal, </span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> QObject *receiver, [<span class="type">static</span>] <span class="type">const</span> <span class="type">char</span> *method, Qt::ConnectionType type = Qt::AutoConnection)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">------------------------------------------------------------------------</span></span><br><span class="line"><span class="function">sender: 发送信号的对象。</span></span><br><span class="line"><span class="function">signal: 发送的信号的名称,说明发出了什么信号,以字符串形式表示。</span></span><br><span class="line"><span class="function">receiver: 接收信号的对象。</span></span><br><span class="line"><span class="function">method: 接收对象中用于响应信号的槽函数的名称，以字符串形式表示。</span></span><br><span class="line"><span class="function">type: 连接类型，决定了信号和槽的连接方式。默认为 Qt::AutoConnection。</span></span><br><span class="line"><span class="function">   </span></span><br></pre></td></tr></table></figure>
<p>例如，如果你有一个按钮（QPushButton），并且想要在按钮被点击时执行某些操作，你可以将按钮的 <code>clicked()</code> 信号连接到一个槽函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Click me&quot;</span>);</span><br><span class="line">MyObject *myObject = <span class="keyword">new</span> MyObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接按钮的clicked信号到myObject的slotMethod槽函数</span></span><br><span class="line">QObject::<span class="built_in">connect</span>(button, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), myObject, <span class="built_in">SLOT</span>(<span class="built_in">slotMethod</span>()));</span><br><span class="line"><span class="comment">//当按钮被点击时，MyObject 的 slotMethod 方法将被调用。</span></span><br></pre></td></tr></table></figure>
<p><strong>3.4 自定义信号和槽</strong></p>
<blockquote>
<p>为了使自定义信号和槽正常工作，确保你的类<mark>继承自 QObject</mark> 并且在类的定义中添加<mark>Q_OBJECT 宏</mark>。同时，确保项目的 .pro 文件中添加了 <code>QT += core</code>，以确保 Qt 核心模块被正确链接</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>自定义信号，通常信号只有声明没有实现</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>自定义槽：</p>
</li>
</ul>
<blockquote>
<p>自定义槽是普通的成员函数，可以在信号发射时被调用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:   <span class="comment">//新版本中不可以省略不写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySlot</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Received value:&quot;</span> &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>触发自定义信号</p>
</li>
</ul>
<blockquote>
<p>需在类中的某个函数中使用 <code>emit</code> 关键字,可加可不加,加了更规范</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发信号</span></span><br><span class="line">    <span class="function">emit <span class="title">mySignal</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">MyClass obj;</span><br><span class="line">obj.<span class="built_in">someFunction</span>(); <span class="comment">// 这将触发 mySignal，导致 mySlot 被调用。</span></span><br></pre></td></tr></table></figure>
<p><strong>3.5 补充</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>信号可以连接多个槽函数</p>
</li>
<li class="lvl-2">
<p>信号可以连接信号</p>
</li>
<li class="lvl-2">
<p>信号函数和槽函数的参数有一些要求：</p>
<ol>
<li class="lvl-5"><strong>参数类型必须兼容</strong>：信号函数和槽函数的参数类型必须兼容，最好是相同的类型或可以自动转换的类型。如果参数类型不兼容，连接将无法建立，并且编译器将会报错。</li>
<li class="lvl-5"><strong>参数数量必须匹配</strong>：信号函数和槽函数的参数数量必须匹配。如果信号函数有参数而槽函数没有，或者槽函数有参数而信号函数没有，连接仍然是有效的。但是，如果参数数量不匹配，连接将无法建立。</li>
<li class="lvl-5"><strong>参数的顺序和类型必须一致</strong>：参数的顺序和类型在信号函数和槽函数之间必须一致。如果顺序或类型不匹配，连接将无法建立。</li>
</ol>
</li>
</ul>
<h3 id="4-QLineEdit">4. QLineEdit</h3>
<p><strong>4.1 获取和设置文本内容：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>QString text() const：返回当前文本框中的文本内容。</p>
</li>
<li class="lvl-2">
<p>setText(const QString &amp;text)：设置文本框的文本内容。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">lineEdit-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前文本内容</span></span><br><span class="line">QString currentText = lineEdit-&gt;<span class="built_in">text</span>();</span><br></pre></td></tr></table></figure>
<p><strong>4.2 密码模式</strong></p>
<p><strong>setEchoMode(QLineEdit::EchoMode mode)：设置文本框的显示模式。常用的模式有：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>QLineEdit::Normal：默认模式，显示输入的文本。</p>
</li>
<li class="lvl-2">
<p>QLineEdit::Password：以密码形式显示文本，用圆点或星号代替实际字符。</p>
</li>
<li class="lvl-2">
<p>QLineEdit::PasswordEchoOnEdit：在编辑时以密码形式显示文本，但在失去焦点后显示圆点。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">lineEdit-&gt;<span class="built_in">setEchoMode</span>(QLineEdit::Password);</span><br></pre></td></tr></table></figure>
<p><strong>4.3 设置最大长度</strong></p>
<p><strong>使用setMaxLentgh方法可以限制用户输入的最大字符数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLineEdit* lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">lineEdit- &gt;<span class="built_in">setMaxLength</span>(<span class="number">10</span>);<span class="comment">//限制输入的最大长度为10个字符</span></span><br></pre></td></tr></table></figure>
<h3 id="QLable">QLable</h3>
<p><strong>5.1 设置字体的颜色 大小等</strong></p>
<p>可以使用setStyleSheet()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对某个组件局部使用</span></span><br><span class="line">ui-&gt;display-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color: red;&quot;</span> <span class="string">&quot;text-align: right;&quot;</span> <span class="string">&quot; font-size: 10px;&quot;</span>);</span><br><span class="line"><span class="comment">//对某个窗口下的某种组件设置</span></span><br><span class="line">MainWindow-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QLineEdit&#123; background-color: lime&#125;&quot;</span>);</span><br><span class="line"><span class="comment">//全局使用</span></span><br><span class="line"><span class="comment">/*使用qApp的setStyleSheet函数可以为应用程序全局设置样式。例如下面为应用程序的QLineEdit组件设置样式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QLineEdit&#123; background-color: gray &#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="6-使用类设置字体属性-颜色">6. 使用类设置字体属性 颜色</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>QFont<code>类的构造函数</code>QFont(const QString &amp;family, int pointSize, int weight = -1, bool italic = false)</strong></p>
</li>
</ul>
<blockquote>
<p><code>family</code>：字符串，表示字体的家族名称，例如&quot;Arial&quot;，&quot;Times New Roman&quot;等。</p>
<p><code>pointSize</code>：整数，代表字体的大小，以磅（point）为单位。</p>
<p><code>weight</code>：整数，指定字体的粗细，通常是100到1000的范围内的数值；-1表示使用默认值。</p>
<p><code>italic</code>：布尔值，表示字体是否是斜体；false表示非斜体，true表示斜体。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置字体属性</span></span><br><span class="line"><span class="function">QFont <span class="title">font</span><span class="params">(<span class="string">&quot;Arial&quot;</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line"><span class="comment">//设置对齐位置</span></span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setAlignment</span>(Qt::AlignRight);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong><code>QPalette</code> 类用于管理窗口部件的外观，包括背景色、前景色和文本格式等</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置颜色</span></span><br><span class="line"> QPalette palette;</span><br><span class="line"> palette.<span class="built_in">setColor</span>(QPalette::Text, Qt::red);</span><br><span class="line"> ui-&gt;lineEdit-&gt;<span class="built_in">setPalette</span>(palette);</span><br><span class="line"><span class="comment">//setColor() 方法第一个参数是要设置的颜色属性，第二个参数是要应用的颜色值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在设置控件背景色填充时，一定要先调用setAutoFillBackground(true)函数，来运行自动填充背景</span></span><br></pre></td></tr></table></figure>
<h3 id="7-QProgressBar">7. QProgressBar</h3>
<blockquote>
<p>可与QSlider QScrollBar QDial配合使用</p>
</blockquote>
<p><strong>format属性</strong></p>
<p>%p:完成的百分比  %v:当前值  %m:总步骤数</p>
<p>默认值为%p%</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;slider,&amp;QSlider::valueChanged,<span class="keyword">this</span>,&amp;Widget::do_valueChanged);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::do_valueChanged</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;progressBar-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-日期时间数据">8. 日期时间数据</h3>
<blockquote>
<p>QTime    QDate    QDateTime    QCalendarWidget</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widgey::on_btnGetTime_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDateTime curDateTime = QDateTime::<span class="built_in">currentDateTime</span>();</span><br><span class="line">    ui-&gt;timeEdit-&gt;<span class="built_in">setTime</span>(curDateTime.<span class="built_in">time</span>());</span><br><span class="line">    ui-&gt;editTime-&gt;<span class="built_in">setText</span>(curDateTime.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    ui-&gt;timeEdit-&gt;<span class="built_in">setDate</span>(curDateTime.<span class="built_in">date</span>());</span><br><span class="line">    ui-&gt;editTime-&gt;<span class="built_in">setText</span>(curDateTime.<span class="built_in">toString</span>(<span class="string">&quot;yy-MM-dd&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    ui-&gt;timeEdit-&gt;<span class="built_in">setDateTime</span>(curDateTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_calendarWidget_selectionChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取日历控件上选择的日期</span></span><br><span class="line">    QString str = ui-&gt;calendarWidget-&gt;<span class="built_in">selectedDate</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy年M月d日&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-计时器-QTimer">9. 计时器 QTimer</h3>
<blockquote>
<p>timer 超时后会发出timeout()信号，所以在创建好定时器对象后给其建立信号与槽</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"></span><br><span class="line">QTimer *timer = <span class="keyword">new</span> QTimer;</span><br><span class="line">timer-&gt;<span class="built_in">setSingleShot</span>(<span class="literal">false</span>);<span class="comment">//设置是否只使用一次</span></span><br><span class="line">timer-&gt;<span class="built_in">setInterval</span>(<span class="number">2000</span>);<span class="comment">//设置时间间隔,以毫秒为单位</span></span><br><span class="line"></span><br><span class="line">timer-&gt;<span class="built_in">start</span>();<span class="comment">//启动</span></span><br><span class="line">timer-&gt;<span class="built_in">stop</span>();<span class="comment">//停止</span></span><br><span class="line"><span class="built_in">connect</span>(timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">onTimeout</span>()));</span><br></pre></td></tr></table></figure>
<h3 id="10-QTabWidget">10. QTabWidget</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 QTabWidget 实例，用于包含多个选项卡</span></span><br><span class="line">QTabWidget *tabWidget = <span class="keyword">new</span> QTabWidget;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置选项卡的形状为三角形</span></span><br><span class="line">tabWidget-&gt;<span class="built_in">setTabShape</span>(QTabWidget::Triangular);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置选项卡可移动</span></span><br><span class="line">tabWidget-&gt;<span class="built_in">setMovable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置选项卡的位置为左侧</span></span><br><span class="line">tabWidget-&gt;<span class="built_in">setTabPosition</span>(QTabWidget::West);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建三个子窗口部件(QWidget)，用作每个选项卡的内容</span></span><br><span class="line">QWidget *pageWidget_0 = <span class="keyword">new</span> QWidget;</span><br><span class="line">QWidget *pageWidget_1 = <span class="keyword">new</span> QWidget;</span><br><span class="line">QWidget *pageWidget_2 = <span class="keyword">new</span> QWidget;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每个子窗口部件添加到选项卡中，同时设置相应的标签</span></span><br><span class="line">tabWidget-&gt;<span class="built_in">addTab</span>(pageWidget_0, <span class="string">&quot;第一页&quot;</span>);</span><br><span class="line">tabWidget-&gt;<span class="built_in">addTab</span>(pageWidget_1, <span class="string">&quot;第二页&quot;</span>);</span><br><span class="line">tabWidget-&gt;<span class="built_in">addTab</span>(pageWidget_2, <span class="string">&quot;第三页&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="11-QTableView-QStandardItemModel-QItemSelectionModel">11. QTableView QStandardItemModel QItemSelectionModel</h3>
<blockquote>
<p><strong>QStandardItemModel</strong>是Qt提供的用于存储和操作标准项数据模型的类。它继承自QAbstractItemModel，并提供了一种方便的方式来组织和展示数据。通过添加、删除、修改或移动标准项，可以对数据进行操作。</p>
<p><strong>QItemSelectionModel</strong>则是用于管理项选择状态的类。它是一个与视图交互的模型，负责跟踪用户选择的项以及通知相关视图进行相应更新。QItemSelectionModel可以监听并响应用户选择项变化事件，同时也可以通过编程方式改变选择状态。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFileDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QItemSelectionModel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>:<span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QStandardItemModel* m_model; <span class="comment">// 数据模型</span></span><br><span class="line">    QItemSelectionModel* m_selection; <span class="comment">// 选择模型</span></span><br><span class="line">    QLabel* labCurFile; <span class="comment">// 当前文件标签</span></span><br><span class="line">    QLabel* labCellPos; <span class="comment">// 当前单元格位置标签</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    .........</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_currentChanged</span><span class="params">(<span class="type">const</span> QModelIndex &amp;current,<span class="type">const</span> QModelIndex &amp;previous)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget* parent):<span class="built_in">QMainWindow</span>(parent),<span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    labCurFile = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;当前文件&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    labCurFile-&gt;<span class="built_in">setMinimumWidth</span>(<span class="number">200</span>);</span><br><span class="line">    ui-&gt;statusBar-&gt;<span class="built_in">addWidget</span>(labCurFile); <span class="comment">// 将当前文件标签添加到状态栏</span></span><br><span class="line">    </span><br><span class="line">    m_model = <span class="keyword">new</span> <span class="built_in">QStandardItemModel</span>(<span class="number">2</span>,<span class="number">6</span>,<span class="keyword">this</span>); <span class="comment">// 创建数据模型，2行6列</span></span><br><span class="line">    m_selection = <span class="keyword">new</span> <span class="built_in">QItemSelectionModel</span>(m_model,<span class="keyword">this</span>); <span class="comment">// 创建选择模型</span></span><br><span class="line">    </span><br><span class="line">    ui-&gt;tableView-&gt;<span class="built_in">setModel</span>(m_model); <span class="comment">// 设置表格视图的模型</span></span><br><span class="line">    ui-&gt;tableView-&gt;<span class="built_in">setSelectionModel</span>(m_selection); <span class="comment">// 设置表格视图的选择模型</span></span><br><span class="line">    ui-&gt;tableView-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::ExtendedSelection); <span class="comment">// 设置选择模式</span></span><br><span class="line">    ui-&gt;tableView-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectItems); <span class="comment">// 设置选择行为</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">connect</span>(m_selection,&amp;QItemSelection::currentChanged,<span class="keyword">this</span>,&amp;MainWindow::do_currentChanged);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWinidow::do_currentChanged</span><span class="params">(<span class="type">const</span> QModelIndex &amp;current,<span class="type">const</span> QModelIndex &amp;previous)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current.<span class="built_in">isValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        labCellPos-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">asprintf</span>(<span class="string">&quot;当前单元格:%d行,%d列&quot;</span>,current.<span class="built_in">row</span>(),current.<span class="built_in">column</span>()));</span><br><span class="line">        QStandardItem *aItem = m_model-&gt;<span class="built_in">itemFromIndex</span>(current); <span class="comment">// 获取当前单元格的项</span></span><br><span class="line">        ui-&gt;actFontBold-&gt;<span class="built_in">setChecked</span>(aItem-&gt;<span class="built_in">font</span>().<span class="built_in">bold</span>()); <span class="comment">// 检查当前单元格的文本是否为粗体,如果当前单元格的文本为粗体，动作将被选中，否则动作将取消选中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_actOpen_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前应用程序的路径</span></span><br><span class="line">    QString curPath = QCoreApplication::<span class="built_in">applicationDirPath</span>();</span><br><span class="line">    <span class="comment">// 打开文件对话框以获取要打开的文件路径</span></span><br><span class="line">    QString aFilePath = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;打开一个文件&quot;</span>, curPath, <span class="string">&quot;数据文件(*.txt);;所有文件(*.*)&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果文件名为空，则退出函数</span></span><br><span class="line">    <span class="keyword">if</span> (aFileName.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="function">QFile <span class="title">aFile</span><span class="params">(aFileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!aFile.<span class="built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text)) <span class="keyword">return</span>; <span class="comment">// 如果文件无法打开，则退出函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取文件内容并显示在界面上</span></span><br><span class="line">    QStringList aFileContent;</span><br><span class="line">    <span class="function">QTextStream <span class="title">aStream</span><span class="params">(&amp;aFile)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!aStream.<span class="built_in">atEnd</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QString str = aStream.<span class="built_in">readLine</span>();</span><br><span class="line">        ui-&gt;plainTextEdit-&gt;<span class="built_in">appendPlainText</span>(str); <span class="comment">// 在文本框中添加一行内容</span></span><br><span class="line">        aFileContent.<span class="built_in">append</span>(str); <span class="comment">// 将读取的每一行内容添加到QStringList中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    aFile.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新界面显示，显示当前打开的文件名</span></span><br><span class="line">    labCurFile-&gt;<span class="built_in">setText</span>(<span class="string">&quot;当前文件:&quot;</span> + aFileName);</span><br><span class="line">    <span class="comment">// 启用一个动作（假设这里是一个菜单项或按钮），允许用户追加内容</span></span><br><span class="line">    ui-&gt;actAppend-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">iniModelData</span>(aFileContent); <span class="comment">// 初始化模型数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::iniModelData</span><span class="params">(QStringList&amp; aFileContent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rowCnt  = aFileContent.<span class="built_in">size</span>(); <span class="comment">// 获取文件内容的行数</span></span><br><span class="line">    m_model-&gt;<span class="built_in">setRowCount</span>(rowCnt - <span class="number">1</span>); <span class="comment">// 设置表格模型的行数（减去标题行）</span></span><br><span class="line"></span><br><span class="line">    QString header = aFileContent.<span class="built_in">at</span>(<span class="number">0</span>); <span class="comment">// 获取标题行</span></span><br><span class="line">    QStringList headerList = header.<span class="built_in">split</span>(<span class="built_in">QRegularExpression</span>(<span class="string">R&quot;(\s+)&quot;</span>), Qt::SkipEmptyParts); <span class="comment">// 根据空白字符拆分标题行</span></span><br><span class="line">    m_model-&gt;<span class="built_in">setHorizontalHeaderLabels</span>(headerList); <span class="comment">// 设置表头标签</span></span><br><span class="line"></span><br><span class="line">    QStandardItem* aItem; <span class="comment">// 用于创建每个单元格的项</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; rowCnt; i++) <span class="comment">// 从第二行开始遍历文件内容</span></span><br><span class="line">    &#123;</span><br><span class="line">        QString aLineText = aFileContent.<span class="built_in">at</span>(i); <span class="comment">// 获取当前行的文本</span></span><br><span class="line">        QStringList tmpList = aLineText.<span class="built_in">split</span>(<span class="built_in">QRegularExpression</span>(<span class="string">R&quot;(\s+)&quot;</span>), Qt::SkipEmptyParts); <span class="comment">// 根据空白字符拆分当前行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) <span class="comment">// 遍历当前行的每一列（假设每行有6列）</span></span><br><span class="line">        &#123;</span><br><span class="line">            aItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(tmpList.<span class="built_in">at</span>(j)); <span class="comment">// 创建一个新的项，内容为当前列的值</span></span><br><span class="line">            m_model-&gt;<span class="built_in">setItem</span>(i - <span class="number">1</span>, j, aItem); <span class="comment">// 在指定位置设置项</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理最后一列</span></span><br><span class="line">        aItem = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(tmpList.<span class="built_in">at</span>(j)); <span class="comment">// 创建最后一列的项</span></span><br><span class="line">        aItem-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>); <span class="comment">// 设置项为可选中的</span></span><br><span class="line">        aItem-&gt;<span class="built_in">setBackground</span>(<span class="built_in">QBrush</span>(Qt::yellow)); <span class="comment">// 设置项的背景颜色为黄色</span></span><br><span class="line">        <span class="keyword">if</span>(tmpList.<span class="built_in">at</span>(j) == <span class="string">&quot;0&quot;</span>) <span class="comment">// 如果值为0，则设置为未选中状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            aItem-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 否则设置为选中状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            aItem-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line">        &#125;</span><br><span class="line">        m_model-&gt;<span class="built_in">setItem</span>(i - <span class="number">1</span>, j, aItem); <span class="comment">// 在指定位置设置项</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="12-QTableWidget">12. QTableWidget</h3>
<blockquote>
<p>QTableWidget继承自QTableView,QTableWidget是QTableView的子类，主要的区别是QTableView可以使用自定义的数据模型来显示内容(也就是先要通过setModel来绑定数据源)，而QTableWidget则<strong>只能</strong>使用标准的数据模型，并且其单元格数据是<mark>QTableWidgetItem</mark>的对象来实现的</p>
</blockquote>
<p><strong>12.1 初始化表格数据</strong><br>
界面上的“初始化表格数据”按钮根据表格的行数，生成数据填充表格，并为每个单元格生成 QTableWidgetItem 对象，设置相应属性。下面是 btnlniData 的 clicked() 信号的槽函数代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ManagerInterface::readMenuInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;menuInfo.dat&quot;</span>)</span></span>;</span><br><span class="line">	file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">	<span class="keyword">if</span> (!file.<span class="built_in">isOpen</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;文件打开失败1&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		QString name;</span><br><span class="line">		QString type;</span><br><span class="line">		<span class="type">double</span> price;</span><br><span class="line">		<span class="type">double</span> discount;</span><br><span class="line">		QString imagePath;</span><br><span class="line">		<span class="function">QDataStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (!in.<span class="built_in">atEnd</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			in &gt;&gt; name &gt;&gt; type &gt;&gt; price &gt;&gt; discount&gt;&gt; imagePath;</span><br><span class="line">			ui-&gt;menuTable-&gt;<span class="built_in">insertRow</span>(ui-&gt;menuTable-&gt;<span class="built_in">rowCount</span>());</span><br><span class="line">			<span class="built_in">creatTableRows</span>(ui-&gt;menuTable-&gt;<span class="built_in">rowCount</span>()<span class="number">-1</span>, name, type, price, discount,imagePath);<span class="comment">//注意要将获得的行数减一</span></span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; name &lt;&lt; type &lt;&lt; price &lt;&lt; discount &lt;&lt; imagePath;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">QTableWidget::<span class="built_in">clearContents</span>() 函数清除表格数据区的所有内容，但是不清除表头。</span><br><span class="line"></span><br><span class="line">QTableWidget::<span class="built_in">rowCount</span>() 函数返回表格数据区的行数。</span><br><span class="line"></span><br><span class="line">在 <span class="keyword">for</span> 循环里为每一行生成需要显示的数据，然后调用自定义函数 <span class="built_in">creatTableRows</span>()，为表格一行的各个单元格生成 QTableWidgetItem 对象。</span><br></pre></td></tr></table></figure>
<p>creatTableRows() 是在窗体类里自定义的函数，其实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ManagerInterface::creatTableRows</span><span class="params">(<span class="type">int</span> rowNo,  QString menuName, QString type, <span class="type">double</span> price, <span class="type">double</span> discount,QString imagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QTableWidgetItem* item;</span><br><span class="line">	</span><br><span class="line">	item = <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(menuName);</span><br><span class="line">	item-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignCenter);</span><br><span class="line">	ui-&gt;menuTable-&gt;<span class="built_in">setItem</span>(rowNo, <span class="number">0</span>, item);</span><br><span class="line"></span><br><span class="line">	item = <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(type);</span><br><span class="line">	item-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignCenter);</span><br><span class="line">	ui-&gt;menuTable-&gt;<span class="built_in">setItem</span>(rowNo, <span class="number">1</span>, item);	</span><br><span class="line"></span><br><span class="line">	item = <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(QString::<span class="built_in">number</span>(price, <span class="string">&#x27;f&#x27;</span>, <span class="number">2</span>));</span><br><span class="line">	item-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignCenter);</span><br><span class="line">	ui-&gt;menuTable-&gt;<span class="built_in">setItem</span>(rowNo, <span class="number">2</span>, item);</span><br><span class="line"></span><br><span class="line">	item = <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(QString::<span class="built_in">number</span>(discount, <span class="string">&#x27;f&#x27;</span>, <span class="number">2</span>));</span><br><span class="line">	item-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignCenter);</span><br><span class="line">	ui-&gt;menuTable-&gt;<span class="built_in">setItem</span>(rowNo, <span class="number">3</span>, item);</span><br><span class="line"></span><br><span class="line">	item = <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(imagePath);</span><br><span class="line">	item-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignCenter);</span><br><span class="line">	ui-&gt;menuTable-&gt;<span class="built_in">setItem</span>(rowNo, <span class="number">4</span>, item);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将第四列隐藏</span></span><br><span class="line">	ui-&gt;menuTable-&gt;<span class="built_in">setColumnHidden</span>(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>12.2 获得当前单元格数据</strong><br>
当鼠标在表格上单击单元格时，被选中的单元格是当前单元格。通过<mark>QTableWidget 的 currentColumn() 和 currentRow()</mark> 可以获得当前单元格的列编号和行编号。</p>
<p>当前单元格发生切换时，会发射==currentCellChanged() 信号和 currentItemChanged()==信号，两个信号都可以利用，只是传递的参数不同。</p>
<p>对 currentCellChanged() 信号编写槽函数，用于获取当前单元格的数据，以及当前行的学生的学号信息，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_tableInfo_currentCellChanged</span><span class="params">(<span class="type">int</span> currentRow, <span class="type">int</span> currentColumn, <span class="type">int</span> previousRow, <span class="type">int</span> previousColumn)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//当前选择单元格发生变化时的响应</span></span><br><span class="line">   <span class="built_in">Q_UNUSED</span>(previousRow);</span><br><span class="line">   <span class="built_in">Q_UNUSED</span>(previousColumn);</span><br><span class="line">    QTableWidgetItem* item=ui-&gt;tableInfo-&gt;<span class="built_in">item</span>(currentRow,currentColumn); <span class="comment">//获取单元格的 Item</span></span><br><span class="line">    <span class="keyword">if</span>  (item==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    labCellIndex-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">asprintf</span>(<span class="string">&quot;当前单元格坐标：%d 行，%d 列&quot;</span>,currentRow,currentColumn));</span><br><span class="line">    <span class="type">int</span> cellType=item-&gt;<span class="built_in">type</span>();<span class="comment">//获取单元格的类型</span></span><br><span class="line">    labCellType-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">asprintf</span>(<span class="string">&quot;当前单元格类型：%d&quot;</span>,cellType));</span><br><span class="line">    item=ui-&gt;tableInfo-&gt;<span class="built_in">item</span>(currentRow,MainWindow::colName); <span class="comment">//取当前行第1列的单元格的 item</span></span><br><span class="line">    <span class="type">int</span> ID=item-&gt;<span class="built_in">data</span>(Qt::UserRole).<span class="built_in">toInt</span>();<span class="comment">//用data()函数提取自定义数据，也就是创建单元格时存储的学生 ID</span></span><br><span class="line">    labStudID-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">asprintf</span>(<span class="string">&quot;学生ID：%d&quot;</span>,ID));<span class="comment">//学生ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>12.3 插入、添加、删除行</strong><br>
QTableWidget 处理行操作的函数如下：</p>
<p>insertRow(int row)：在行号为row的行前面插入一行，如果row等于或大于总行数，则在表格最后添加一行。insertRow()函数只是插入一个空行，不会为单元格创建QTableWidgetItem对象，需要手工为单元格创建。<br>
removeRow(int row)：删除行号为 row 的行。</p>
<p>下面是界面上“插入行” “添加行”“删除当前行”按钮的响应代码。在插入行之后，会调用 createItemsARow() 函数，为新创建的空行的各单元格构造 QTableWidgetItem 对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_btnInsertRow_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//插入一行</span></span><br><span class="line">    <span class="comment">//int curRow;</span></span><br><span class="line">    <span class="type">int</span> curRow=ui-&gt;tableInfo-&gt;<span class="built_in">currentRow</span>();<span class="comment">//当前行号</span></span><br><span class="line">    ui-&gt;tableInfo-&gt;<span class="built_in">insertRow</span>(curRow); <span class="comment">//插入一行，但不会自动为单元格创建item</span></span><br><span class="line">    <span class="built_in">createItemsARow</span>(curRow, <span class="string">&quot;新学生&quot;</span>, <span class="string">&quot;男&quot;</span>,</span><br><span class="line">          QDate::<span class="built_in">fromString</span>(<span class="string">&quot;1990-1-1&quot;</span>,<span class="string">&quot;yyyy-M-d&quot;</span>),<span class="string">&quot;苗族&quot;</span>,<span class="literal">true</span>,<span class="number">60</span> ); <span class="comment">//为某一行创建items</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_btnAppendRow_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//添加一行</span></span><br><span class="line">    <span class="comment">//int curRow;</span></span><br><span class="line">    <span class="type">int</span> curRow=ui-&gt;tableInfo-&gt;<span class="built_in">rowCount</span>();<span class="comment">//总行号</span></span><br><span class="line">    ui-&gt;tableInfo-&gt;<span class="built_in">insertRow</span>(curRow);<span class="comment">//在表格尾部添加一行</span></span><br><span class="line">    <span class="built_in">createItemsARow</span>(curRow, <span class="string">&quot;新生&quot;</span>, <span class="string">&quot;女&quot;</span>,</span><br><span class="line">          QDate::<span class="built_in">fromString</span>(<span class="string">&quot;2000-1-1&quot;</span>,<span class="string">&quot;yyyy-M-d&quot;</span>),<span class="string">&quot;满族&quot;</span>,<span class="literal">false</span>,<span class="number">50</span> ); <span class="comment">//为某一行创建items</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_btnDelCurRow_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//删除当前行及其items</span></span><br><span class="line">    <span class="comment">//int curRow;</span></span><br><span class="line">    <span class="type">int</span> curRow=ui-&gt;tableInfo-&gt;<span class="built_in">currentRow</span>();<span class="comment">//当前行号</span></span><br><span class="line">    ui-&gt;tableInfo-&gt;<span class="built_in">removeRow</span>(curRow); <span class="comment">//删除当前行及其items</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>12.4 自动调整行高和列宽</strong><br>
QTableWidget 有几个函数自动调整表格的行高和列宽，分别如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">resizeColumnsToContents</span>()：自动调整所有列的宽度，以适应其内容。</span><br><span class="line"><span class="built_in">resizeColumnToContents</span>(<span class="type">int</span> column)：自动调整列号为 co/www 的列的宽度。</span><br><span class="line"><span class="built_in">resizeRowsToContents</span>()：自动调整所有行的高度，以适应其内容。</span><br><span class="line"><span class="built_in">resizeRowToContents</span>(<span class="type">int</span> row)：自动调整行号为 raw 的行的高度。</span><br><span class="line">    </span><br><span class="line">这几个函数实际上是 QTableWidget 的父类 QTableView 的函数。</span><br></pre></td></tr></table></figure>
<p><strong>12.4 其他属性控制</strong><br>
设置表格内容是否可编辑：QTableWidget 的 EditTriggers 属性表示是否可编辑，以及进入编辑状态的方式。界面上的&quot;表格可编辑&quot;复选框的槽函数代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_chkBoxTabEditable_clicked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//设置编辑模式</span></span><br><span class="line">    <span class="keyword">if</span> (checked)</span><br><span class="line">        <span class="comment">//双击或获取焦点后单击，进入编辑状态</span></span><br><span class="line">        ui-&gt;tableInfo-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::DoubleClicked | QAbstractItemView::SelectedClicked);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ui-&gt;tableInfo-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers); <span class="comment">//不允许编辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置行表头、列表头是否显示：horizontalHeader()获取行表头，verticalHeader()获取列表头，然后可设置其可见性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_chkBoxHeaderH_clicked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//是否显示水平表头</span></span><br><span class="line">    ui-&gt;tableInfo-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setVisible</span>(checked);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_chkBoxHeaderV_clicked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//是否显示垂直表头</span></span><br><span class="line">    ui-&gt;tableInfo-&gt;<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">setVisible</span>(checked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>间隔行底色：setAltematingRowColors() 函数可以设置表格的行是否用交替底色显示，若为交替底色，则间隔的一行会用灰色作为底色。具体底色的设置需要用 styleSheet。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_chkBoxRowColor_clicked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;tableInfo-&gt;<span class="built_in">setAlternatingRowColors</span>(checked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择模式：setSelectionBehavior() 函数可以设置选择方式为单元格选择，还是行选择：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_rBtnSelectItem_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//选择行为：单元格选择</span></span><br><span class="line">    ui-&gt;tableInfo-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::Selectltems);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_rBtnSelectRow_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//选择行为：行选择</span></span><br><span class="line">    ui-&gt;tableInfo-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>12.6 遍历表格读取数据</strong><br>
“读取表格内容到文本”按钮演示了将表格数据区的内容全部读出的方法，它将每个单元格的文字读出，同一行的单元格的文字用空格分隔开，作为文本的一行，然后将这行文字作为文本编辑器的一行内容，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ManagerInterface::saveMenuInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;menuInfo.dat&quot;</span>)</span></span>;</span><br><span class="line">	file.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">	<span class="keyword">if</span> (!file.<span class="built_in">isOpen</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;文件打开失败2&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		QDataStream <span class="built_in">out</span>(&amp;file);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ui-&gt;menuTable-&gt;<span class="built_in">rowCount</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			QTableWidgetItem* item = ui-&gt;menuTable-&gt;<span class="built_in">item</span>(i, <span class="number">0</span>);</span><br><span class="line">			QString menuName = item-&gt;<span class="built_in">text</span>();</span><br><span class="line">			item = ui-&gt;menuTable-&gt;<span class="built_in">item</span>(i, <span class="number">1</span>);</span><br><span class="line">			QString type = item-&gt;<span class="built_in">text</span>();</span><br><span class="line">			item = ui-&gt;menuTable-&gt;<span class="built_in">item</span>(i, <span class="number">2</span>);</span><br><span class="line">			<span class="type">double</span> price = item-&gt;<span class="built_in">text</span>().<span class="built_in">toDouble</span>();</span><br><span class="line">			item = ui-&gt;menuTable-&gt;<span class="built_in">item</span>(i, <span class="number">3</span>);</span><br><span class="line">			<span class="type">double</span> discount = item-&gt;<span class="built_in">text</span>().<span class="built_in">toDouble</span>();</span><br><span class="line"></span><br><span class="line">			item = ui-&gt;menuTable-&gt;<span class="built_in">item</span>(i, <span class="number">4</span>);</span><br><span class="line">			QString imagePath = item-&gt;<span class="built_in">text</span>();</span><br><span class="line"></span><br><span class="line">			out &lt;&lt; menuName &lt;&lt; type &lt;&lt; price &lt;&lt; discount&lt;&lt;imagePath;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		file.<span class="built_in">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>12.7 在一个qtablewidgetitem中设置复选框</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTableWidgetItem* item;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ui-&gt;menuTable-&gt;<span class="built_in">rowCount</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	item = ui-&gt;menuTable-&gt;<span class="built_in">item</span>(i,<span class="number">0</span>);</span><br><span class="line">	item-&gt;<span class="built_in">setCheckState</span>(Qt::Unchecked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//单一控制 利用QTableWidget::cellchanged()函数判断单元格内容的变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//批量删除被选择的行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ManagerInterface::on_deleteBut_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ui-&gt;menuTable-&gt;<span class="built_in">rowCount</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ui-&gt;menuTable-&gt;<span class="built_in">item</span>(i,<span class="number">0</span>)-&gt;<span class="built_in">checkState</span>() == Qt::Checked)</span><br><span class="line">			ui-&gt;menuTable-&gt;<span class="built_in">removeRow</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>订餐程序涉及知识</title>
    <url>/2024/05/16/%E8%AE%A2%E9%A4%90%E7%A8%8B%E5%BA%8F%E6%B6%89%E5%8F%8A%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>记录了一下项目制作过程中 所涉及的不熟悉的部分源码可至GitHub查看</p>
</blockquote>
<span id="more"></span>
<h1>相关知识</h1>
<h3 id="ctime-头文件"><strong>ctime 头文件</strong></h3>
<p><strong>1.1</strong>  <code>time_t time(time_t *timer)</code>: 返回自纪元以来经过的时间，以秒为单位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">time_t</span> currentTime;</span><br><span class="line"><span class="built_in">time</span>(&amp; currentTime);</span><br></pre></td></tr></table></figure>
<p><strong>1.2 <code>struct tm *localtime(const time_t *timer)</code>: 将 <code>time_t</code> 格式的时间转换为本地时间，返回一个指向 <code>tm</code> 结构体的指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">time_t</span> currTime;</span><br><span class="line"><span class="built_in">time</span>(&amp;currTime);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span>* timeTmp = <span class="built_in">locatime</span>(&amp;currTime);</span><br></pre></td></tr></table></figure>
<p><strong>1.3 <code>char *asctime(const struct tm *timeptr)</code>: 将 <code>tm</code> 结构体表示的时间转换为字符串形式的时间，并返回指向静态字符串的指针</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">time_t</span> currTime;</span><br><span class="line"><span class="built_in">time</span>(&amp;currTime);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span>* timeTmp = <span class="built_in">locatime</span>(&amp;currTime);</span><br><span class="line"><span class="type">char</span> *timeString = <span class="built_in">asctime</span>(&amp;timeTmp);</span><br></pre></td></tr></table></figure>
<p><strong>1.4 tm结构体(包含在ctime头文件中)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒（0-59）</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分钟（0-59）</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时（0-23）</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 一个月中的日期（1-31）</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 月份（0-11）</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 年份自1900年起</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的天数（0-6，星期日为0）</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的天数（0-365，1月1日为0）</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时标志（&gt;0 表示是夏令时，0 表示不是夏令时，-1 表示夏令时信息不可用）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>1.5 使用</strong></p>
<blockquote>
<p>先使用time()函数获取自1970年1月1日午夜（格林威治时间）起算的秒数，然后使用localtime()函数将其转化为本地时间 (使用tm结构体存储)，最后根据需要进行打印</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">time_t</span> now;</span><br><span class="line">    <span class="built_in">time</span>(&amp;now);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* lt = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Local time is: &quot;</span> &lt;&lt; lt-&gt;tm_year + <span class="number">1900</span> &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; lt-&gt;tm_mon + <span class="number">1</span> &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; lt-&gt;tm_mday &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lt-&gt;tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; lt-&gt;tm_min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; lt-&gt;tm_sec &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* timeStr = <span class="built_in">asctime</span>(lt);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Formatted time is: &quot;</span> &lt;&lt; timeStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">255</span>];</span><br><span class="line">    <span class="built_in">strftime</span>(buffer, <span class="number">255</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, lt);</span><br><span class="line">    <span class="comment">//sprintf(buffer,&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, lt-&gt;tm_year + 1900, lt-&gt;tm_mon + 1, lt-&gt;tm_mday, lt-&gt;tm_hour,lt-&gt;tm_min,lt-&gt;tm_sec);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Formatted time is: &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------输出结果-----------------</span><br><span class="line">Local time is: <span class="number">2024</span><span class="number">-4</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">42</span></span><br><span class="line">Formatted time is: Sun Apr <span class="number">28</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">42</span> <span class="number">2024</span></span><br><span class="line">Formatted time is: <span class="number">2024</span><span class="number">-04</span><span class="number">-28</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">42</span></span><br></pre></td></tr></table></figure>
<h3 id="CMake简单使用"><strong>CMake简单使用</strong></h3>
<p><strong>2.1 创建一个CMakeLists.txt文件</strong></p>
<p><strong>2.2 创建一个名为build的文件夹</strong></p>
<blockquote>
<p>避免编译产物与代码文件混在一起</p>
</blockquote>
<p><strong>2.3 在CMakeLists.txt中写入内容</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 CMake 的最低版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义项目名称</span></span><br><span class="line"><span class="keyword">project</span>(dinnerSystem)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件，并指定源文件</span></span><br><span class="line"><span class="comment"># 亦可写成  add_executable($&#123;PROJECT_NAME&#125;)</span></span><br><span class="line"><span class="keyword">add_executable</span>(dinnerSystem)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用file函数 globbing 匹配来获取所有的 .cpp 和 .h 文件,并将文件保存在sources变量中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将获取的源文件与目标文件相关联</span></span><br><span class="line"><span class="comment">#target_sources($&#123;PROJECT_NAME&#125; PBULIC $&#123;sources&#125;)</span></span><br><span class="line"><span class="keyword">target_sources</span>(dinnerSystem PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2.4 在build文件夹中打开cmd</strong></p>
<p>输入<code>cmake ..</code></p>
<p><code>cmake --build .</code></p>
<h3 id="解决中文乱码">解决中文乱码</h3>
<p>使用UTF-8 无BOM  可以在VS2022下载插件Force UTF-8(No BOM)</p>
<h3 id="Qt的基础使用">Qt的基础使用</h3>
<p>见另一篇笔记</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础</title>
    <url>/2024/04/27/C-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>C++ 一些基础知识</p>
</blockquote>
<span id="more"></span>
<h1>C++ 基础</h1>
<h3 id="0-前置知识">0. 前置知识</h3>
<h4 id="0-1-左-右值">0.1 左/右值</h4>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><mark>左值</mark>:在内存中有明确存储位置(即地址)的表达式，通常出现在赋值表达式的左侧。 左值可以取地址</p>
</li>
<li class="lvl-2">
<p><mark>右值</mark>：通常指临时的数据值(如字面量，求值过程中产生的临时对象)，在内存中没有固定的地址，它<strong>不能被赋值</strong></p>
</li>
</ul>
</blockquote>
<h4 id="0-2-单位">0.2 单位</h4>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p><mark>bit</mark>:<strong>比特</strong>，又称<strong>位</strong>，计算机内部储存数据的最小单位</p>
</li>
<li class="lvl-2">
<p><mark>Byte</mark>:<strong>字节</strong>，由<strong>8个比特</strong>组成，习惯上以大写<strong>B</strong>来表示，通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。<strong>这是内存寻址的最小单元</strong></p>
</li>
<li class="lvl-2">
<p><mark>word</mark>:<strong>字</strong>，由一个或多个字节组成，计算机的字长决定了其CPU一次操作实际处理的<strong>位数</strong>是多少，例如64位计算机的CPU一次最多能处理64位数据</p>
</li>
</ul>
</blockquote>
<h4 id="0-3-内存">0.3 内存</h4>
<blockquote>
<p>内存就是计算机的存储空间，用来存储程序的指令，数据和状态</p>
</blockquote>
<h5 id="0-3-1-内存四区">0.3.1 内存四区</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>代码区(code/text)</mark>:存放CPU执行的机器指令。通常代码区是可共享的，即另外的程序可以调用它。编写的所有代码都会放进代码区，其特点是<strong>共享和只读</strong></p>
</li>
<li class="lvl-2">
<p><mark>全局区/静态区(stactic)</mark>：用来存放全局变量，静态变量，常量</p>
<ul class="lvl-2">
<li class="lvl-4">data区：存放已初始化的全局变量，静态变量和常量</li>
<li class="lvl-4">bss区：存放初始化为0或者NULL或未初始化的全局变量，静态变量和常量。未初始化的在程序执行前会自动被系统初始化为0或者NULL</li>
<li class="lvl-4">常量区：顾名思义，存放常量，如const修饰的<strong>全局变量</strong>，字符串常量</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>栈(stack)</mark>:是一种先进后出的内存结构，由编译器自动分配</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>结构体和类的对象在默认情况下是分配在栈区</p>
</li>
<li class="lvl-4">
<p>存放<strong>函数的参数值，返回值，局部变量</strong>等，由const定义的局部变量也存储在栈里。</p>
</li>
<li class="lvl-4">
<p>内存地址<strong>由高到低</strong>方向生长，其最大大小由编译时确定，速度快但自由性差，最大空间比堆小</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>堆(heap)</mark>:用于动态内存分配</p>
<ul class="lvl-2">
<li class="lvl-4">内存地址<strong>由低到高</strong>方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大</li>
<li class="lvl-4">注意进行内存释放，否则会造成内存泄露</li>
</ul>
</li>
</ul>
<img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/8b2d920e3dd09f80d85824f19bd5f2e.jpg" alt="8b2d920e3dd09f80d85824f19bd5f2e" style="zoom: %;" />
<h5 id="0-3-2-内存编址">0.3.2 内存编址</h5>
<p>即给计算机的存储单元进行编号，而在CS中存储单元通常是指最小的可寻址单元即byte，也就是给每个byte一个编号，这个编号就是内存的<strong>地址</strong></p>
<img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240408194601136.png" alt="image-20240408194601136" style="zoom: 40%;" />
<h5 id="0-3-3-内存地址空间">0.3.3 内存地址空间</h5>
<blockquote>
<p>将所有byte的编号连起来就叫作内存的地址空间，而地址空间(可寻址内存)的大小与电脑是32位还是34位有关</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>32 位意味着可寻址的内存范围是 <code>2^32 byte = 4GB</code></p>
</li>
<li class="lvl-2">
<p>64位即 <code>2^64 byte</code></p>
</li>
</ul>
<h4 id="0-4-原码-反码-补码">0.4 原码 反码 补码</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>反码  原码按位取反  正数的反码是其本身</p>
</li>
<li class="lvl-2">
<p>补码  原码按位取反加一    正数的补码是其本身</p>
</li>
<li class="lvl-2">
<p><mark>计算机中使用补码来表示和操作整数</mark></p>
</li>
<li class="lvl-2">
<p>个人觉得反码和补码的引入 是为了便于理解在计算机中如何使用 <strong>正数来表示负数</strong></p>
</li>
</ul>
<blockquote>
<p>如 int 在内存中占据4个字节 表示有符号的整数 他的范围是 [-2^31 , 2^31 - 1]</p>
<p>unsigned int 在内存中占据四个字节 表示无符号整数 他的范围是[0,2^32-1]</p>
<p>而32位二进制数表示的范围是[0,2^32-1]，即把它从中间分一半，<strong>将 0 开头的32位二进制数用来表示正数，将 1 开头的用来表示负数</strong>，所以int表示的正数的范围是unsigned int 的一半 但二者表示的总数是一样的</p>
</blockquote>
<h4 id="0-5-进制转换">0.5 进制转换</h4>
<blockquote>
<p><strong>十进制： 都是以0-9这九个数字组成，不能以0开头。</strong></p>
<p><strong>二进制： 由0和1两个数字组成。</strong></p>
<p><strong>八进制： 由0-7数字组成，为了区分与其他进制的数字区别，开头都是以0开始。</strong></p>
<p><strong>十六进制：由0-9和A-F组成。为了区分于其他数字的区别，开头都是以0x开始。</strong></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>整数部分</p>
<p>十进制转n进制：十进制数除以2，反向取余数，直到商为0终止</p>
<img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240408204846887.png" alt="image-20240408204846887" style="zoom: 25%;" />
<p>n进制转十进制：将每一位乘以相应的权值，然后将乘积相加</p>
</li>
<li class="lvl-2">
<p>小数部分</p>
</li>
</ul>
<p>​	十进制转n进制: 乘n取整，顺序输出</p>
<p>​	n进制转十进制：如上</p>
<h3 id="1-变量">1.变量</h3>
<blockquote>
<p>变量名是变量地址的符号化体现</p>
</blockquote>
<h4 id="1-1-变量类型">1.1 变量类型</h4>
<h5 id="1-1-1-作用：">1.1.1 作用：</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存分配：告诉编译器该变量占据的内存大小，占了多少个字节</p>
</li>
<li class="lvl-2">
<p>操作限制：规定了该变量可以执行的操作</p>
</li>
<li class="lvl-2">
<p><mark>数据解释</mark>：决定了如何解释存储在内存中的<mark>位模式</mark>，决定了编译器如何解读对应的二进制数据</p>
</li>
</ul>
<blockquote>
<p><strong>位模式</strong>是指一系列的0和1，是计算机内存中数据最基本的形式，所有数据最终都会被表示为 位模式</p>
</blockquote>
<h5 id="1-1-2-种类">1.1.2 种类</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>基础类型 ：整数 字符 布尔 浮点</p>
</li>
<li class="lvl-2">
<p>修饰符：long short signed unsigned</p>
</li>
<li class="lvl-2">
<p>类类型：class</p>
</li>
<li class="lvl-2">
<p>结构体类型：struct</p>
</li>
<li class="lvl-2">
<p>数组类型</p>
</li>
<li class="lvl-2">
<p>指针类型</p>
</li>
<li class="lvl-2">
<p>引用类型</p>
</li>
<li class="lvl-2">
<p>复数类型(complex  C++11及以上)</p>
</li>
<li class="lvl-2">
<p>联合体 unio</p>
</li>
<li class="lvl-2">
<p>枚举体 enum</p>
</li>
</ul>
<h3 id="2-内存对齐">2. 内存对齐</h3>
<blockquote>
<p>为了提高数据访问的性能和效率，将数据存储在适当的内存地址上，以减少额外开销   <strong>以空间换时间</strong></p>
<p>对齐的长度一般为2的n次幂(1，2 ，4，8)</p>
</blockquote>
<h5 id="2-1-产生原因">2.1 产生原因</h5>
<p>为了适应CPU读取数据的行为，CPU一次读取4个字节或8个字节，由编译器和操作系统(32位或64位)决定</p>
<h5 id="2-2-更改对齐规则">2.2 更改对齐规则</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>使用编译器指令<code>（如 #pragma pack）</code>更改默认的对齐规则。这个命令是全局生效的。这可以用于减小数据结构的大小，但可能会降低访问性能。</p>
</li>
<li class="lvl-2">
<p>在 C++11 及更高版本中，可以使用 alignas 关键字为数据结构或变量指定对齐要求。这个命令是对某个类型或者对象生效的。例如，<code>alignas(16) int x</code>; 将确保 x 的地址是 16 的倍数。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 16) <span class="comment">//将当前对齐值推送到堆栈上，并将对齐值设置为16字节</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)  <span class="comment">//从堆栈中弹出对齐值，恢复之前的对齐值</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2-3-结构体对齐">2.3 结构体对齐</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>最大成员对齐：编译器会将数据成员补齐为最大成员大小的整数倍</p>
<p>如果结构体中含有数组成员，如 char a[5]，它的对齐方式<strong>和连续写 5 个 char 类型变量是一样的，也就是说它还是按一个字节对齐</strong></p>
</li>
<li class="lvl-2">
<p>填充字节(struct padding)：如果某成员大小满足对齐要求，编译器会插入一些字节进行填充</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu1</span> &#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">18</span>];  <span class="comment">//就本身而言占据18个字节   实际占据24个字节</span></span><br><span class="line">    <span class="type">double</span> b;    <span class="comment">//占据8个字节</span></span><br><span class="line">    <span class="type">char</span> c;      <span class="comment">//实际占据4个字节</span></span><br><span class="line">    <span class="type">int</span> d;       <span class="comment">//实际占据4个字节</span></span><br><span class="line">    <span class="type">short</span> e;     <span class="comment">//实际占据8个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stu1 s1;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(s1)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line">输出结果：</span><br><span class="line"><span class="built_in">sizeof</span>(s1)=<span class="number">48</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240416205302797.png" alt="image-20240416205302797"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu2</span> &#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    <span class="type">char</span> v[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu1</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;         <span class="comment">//实际占据8个字节</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stu2</span> b; <span class="comment">// 该结构体中最大的成员占据8个字节，实际占据24个字节</span></span><br><span class="line">    <span class="type">int</span> c;         <span class="comment">//实际占据8个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stu1 s1;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(s1)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line">输出结果：</span><br><span class="line"><span class="built_in">sizeof</span>(s1)=<span class="number">40</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240416210502232.png" alt="image-20240416210502232"></p>
<h5 id="2-4-类的内存对齐">2.4 类的内存对齐</h5>
<h6 id="2-4-1-空类的大小">2.4.1 空类的大小</h6>
<blockquote>
<p>空类和空结构体的<strong>实例化对象的</strong>大小都为1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    demo a;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a)&lt;&lt;endl;  <span class="comment">// 输出结果为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-4-2-添加成员函数，静态数据成员，静态成员函数">2.4.2 添加成员函数，静态数据成员，静态成员函数</h6>
<blockquote>
<p>结果依旧为1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">demo</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sharedFunc</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;hello this is a shared xxx&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> demo::a = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    demo x;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; endl;  <span class="comment">// 输出结果为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为成员函数，静态成员函数存储在<strong>代码段</strong>（.text）中，静态成员变量存储在<strong>全局/静态区</strong>(static)，他们不占用类的内存，不是每个对象分别存储</p>
<h6 id="2-4-3-类对象大小的影响因素">2.4.3 类对象大小的影响因素</h6>
<blockquote>
<p><mark>非静态成员变量</mark>和<mark>虚函数</mark></p>
<p>考虑是否存在vptr，若存在则计入考虑范围，整体上与结构体相同</p>
</blockquote>
<h3 id="3-类的多态">3.类的多态</h3>
<blockquote>
<p>允许使用一个接口来表示不同的类，而这些类的对象在运行时可以表现出不同的行为</p>
<p>父类指针可以指向子类对象，进而调用子类函数</p>
</blockquote>
<h5 id="3-1-虚表-vtable"><strong>3.1 虚表(vtable)</strong></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个存在虚函数的类，都有一个虚函数表</p>
</li>
<li class="lvl-2">
<p>虚函数表是一个指针数组，其元素是指向虚函数的<strong>函数指针</strong>(函数的地址)</p>
</li>
<li class="lvl-2">
<p>成员函数(包括虚函数)是类的一部分，<strong>不占用对象实例的内存空间</strong>，他们为同一个类的所有对象共享，存储在程序的<strong>代码段</strong>中</p>
</li>
</ul>
<h5 id="3-2虚表指针-vptr"><strong>3.2虚表指针(vptr)</strong></h5>
<blockquote>
<p>实现多态类的核心机制之一</p>
<p>每一个包含虚函数的类 的实例化对象所包含的<strong>隐含指针</strong></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>该指针指向类的虚表</p>
</li>
<li class="lvl-2">
<p>大多数实现上，虚函数表指针<strong>一般</strong>都放在对象第一个位置</p>
</li>
<li class="lvl-2">
<p>该指针是隐含的，<strong>不是</strong>类的成员变量，用户不能直接访问或修改它</p>
</li>
<li class="lvl-2">
<p>指针大小取决于操作系统或编译器，32位占4个字节，64位占8个字节</p>
</li>
</ul>
<h5 id="3-3-多态的实现"><strong>3.3 多态的实现</strong></h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>当派生类重写了基类的虚函数时，派生类的虚表中对应的函数指针将被更新，指向派生类中的新实现，即指向派生类中重写函数的地址</p>
</li>
</ul>
<img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240427112831155.png" alt="image-20240427112831155" style="zoom: 45%;" />
<h3 id="4-移动语义">4. 移动语义</h3>
<blockquote>
<p>允许资源从一个对象转移到另一个对象 避免了复制 提高了性能</p>
<p>在使用一个右值(即将被销毁的的对象)去初始化同类对象时该函数会被调用</p>
<p><strong><mark>如果一个类定义了移动构造函数或移动赋值运算符也必须定义拷贝操作,否则无法进行拷贝操作,哪些成员默认被删除</mark></strong></p>
</blockquote>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20241225135417491.png" alt="image-20241225135417491"></p>
<h5 id="4-1-特点">4.1 特点</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数名和类名相同 无返回值 因为它本身也是一个构造函数</p>
</li>
<li class="lvl-2">
<p>第一个参数为同类型的右值引用(&amp;&amp;)</p>
</li>
<li class="lvl-2">
<p>第一个参数<mark>不能设置为const</mark>因为它的资源在函数内部会被移动给当前对象</p>
</li>
<li class="lvl-2">
<p>移动构造函数执行后 需要确保右值引用的对象能被正确销毁</p>
</li>
</ul>
<h5 id="4-2-实例">4.2 实例</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CDate</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CDate</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day);</span><br><span class="line">    <span class="built_in">CDate</span>(CDate&amp;&amp; date) <span class="keyword">noexcept</span>;</span><br><span class="line">    CDate&amp; <span class="keyword">operator</span>=(CDate&amp;&amp; date) <span class="keyword">noexcept</span>;</span><br><span class="line">    ~<span class="built_in">CDate</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_year;</span><br><span class="line">    <span class="type">int</span> m_month;</span><br><span class="line">    <span class="type">int</span> m_day;</span><br><span class="line">    <span class="type">char</span>* str</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CDate::<span class="built_in">CDate</span>(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day)&#123;</span><br><span class="line">    m_year = year;</span><br><span class="line">	m_mon = mon;</span><br><span class="line">	m_day = day;</span><br><span class="line">	str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">100</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动构造函数</span></span><br><span class="line">CDate::<span class="built_in">CDate</span>(CDate&amp;&amp; date) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_year = date.m_year;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_month = date.m_month;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_day = data.m_day;</span><br><span class="line">    <span class="keyword">this</span>-&gt;str = date.str;</span><br><span class="line">    date.str = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动赋值运算符</span></span><br><span class="line">CDate&amp; CDate::<span class="keyword">operator</span>=(CDate&amp;&amp; date)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;date)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;str;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_year = date.m_year;</span><br><span class="line">    	<span class="keyword">this</span>-&gt;m_month = date.m_month;</span><br><span class="line">    	<span class="keyword">this</span>-&gt;m_day = date.m_day;</span><br><span class="line">    	<span class="keyword">this</span>-&gt;str = date.str;</span><br><span class="line">    	date.str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CDate::~<span class="built_in">CDate</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于移动操作“ 窃取” 资源， 它通常不分配任何资源。 因此, 移动操作<mark>通常</mark>不会抛出任何异常。<mark>不抛出异常的函数</mark>应该使用 <code>noexcept</code> 通知标准库，避免编译器为了处理异常而作一些额外的工作</p>
<h5 id="4-3-融合拷贝赋值运算符与移动赋值运算符">4.3 融合拷贝赋值运算符与移动赋值运算符</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CDate&amp; CDate::<span class="keyword">operator</span>=(CDate date)&#123;</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>,date);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此运算符有一个非引用参数 需要进行拷贝初始化 使用前最好定义一个拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<h3 id="5-完美转发-std-forward">5. 完美转发 std::forward</h3>
<blockquote>
<p>在通用引用的情境下，尽可能使用<code>forward()</code></p>
</blockquote>
<h5 id="5-2-通用引用-universal-reference">5.2 通用引用(universal reference)</h5>
<p><strong>构成通用引用的条件</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>必须满足<code>T&amp;&amp;</code>这种形式</p>
</li>
<li class="lvl-2">
<p>类型<code>T</code>必须是通过推断得到的</p>
</li>
</ul>
<p><strong>产生通用引用的可能情况</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数模板参数（function template parameters）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><code>auto</code>声明（auto declaration）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto &amp;&amp; var = ...;</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p><code>typedef</code>声明（typedef declaration）</p>
</li>
<li class="lvl-2">
<p><code>decltype</code>声明（decltype declaration）</p>
</li>
</ul>
<p><strong>与其他引用的区别</strong></p>
<p>​      会产生<mark>引用合成</mark></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T&amp; &amp; =&gt; T&amp;</span><br><span class="line">T&amp;&amp; &amp; =&gt; T&amp;</span><br><span class="line">T&amp; &amp;&amp; =&gt; T&amp;</span><br><span class="line">T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp;</span><br></pre></td></tr></table></figure>
<p>该合成规则用户是不允许使用的，只有编译器才能够使用这种合成规则</p>
<h3 id="6-删除的函数-deleted-function">6.删除的函数(deleted function)</h3>
<blockquote>
<p>指使用<mark>delete</mark>的函数 表示这类函数被禁用 不能被调用</p>
<p>当尝试调用一个被删除的函数时，编译器将会报错，指出该函数是被删除的，从而在编译时期提供了一种检查机制，防止了不期望的函数调用</p>
</blockquote>
<h5 id="用途">用途</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>防止拷贝</strong>:如果你有一个类，你不希望它的实例被拷贝，你可以删除拷贝构造函数和拷贝赋值运算符。</p>
</li>
<li class="lvl-2">
<p><strong>防止移动</strong></p>
</li>
<li class="lvl-2">
<p><strong>限制某些函数的使用</strong>:可以删除那些不应该被调用的函数版本，比如禁止某些类型的参数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OnlyInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 删除接受 double 类型的函数版本</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="7-多线程编程">7. 多线程编程</h3>
<h4 id="7-1-同步问题（Synchronization-Issues）">7.1 同步问题（Synchronization Issues）</h4>
<p>同步问题发生在当多个线程需要访问共享资源或数据，并且这些访问需要以某种特定的顺序执行时。如果同步不当，可能会导致数据不一致或竞态条件（Race Conditions）。</p>
<p><strong>例子：</strong></p>
<ol>
<li class="lvl-3">
<p><strong>竞态条件</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">两个线程同时读取一个共享变量，然后基于这个变量的值进行计算，最后将结果写回。如果两个线程同时读取到相同的值，然后都进行计算并写入，那么一个线程的写入可能会覆盖另一个线程的结果，导致错误。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>死锁</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">线程A持有资源1并等待资源2，而线程B持有资源2并等待资源1。如果线程A和B都不释放它们持有的资源，那么它们将永远等待对方释放资源，导致程序无法继续执行。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>饥饿</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">一个线程因为优先级较低，始终无法获得它需要的资源，即使这些资源在其他线程中是可用的。</li>
</ul>
</li>
</ol>
<p>为了解决同步问题，通常会使用以下机制：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>互斥锁（Mutexes）</strong>：确保同一时间只有一个线程可以访问共享资源。</p>
</li>
<li class="lvl-2">
<p><strong>条件变量（Condition Variables）</strong>：允许线程在某些条件下挂起或被唤醒。</p>
</li>
<li class="lvl-2">
<p><strong>读写锁（Read-Write Locks）</strong>：允许多个读操作同时进行，但写操作需要独占访问。</p>
</li>
<li class="lvl-2">
<p><strong>原子操作（Atomic Operations）</strong>：提供不可分割的操作，确保在多线程环境中对数据的操作是安全的。</p>
</li>
</ul>
<h4 id="7-2-并发问题（Concurrency-Issues）">7.2 并发问题（Concurrency Issues）</h4>
<p>并发问题是指多个线程同时执行，可能会导致性能问题或者需要特别设计算法来确保正确性的问题。</p>
<p><strong>例子：</strong></p>
<ol>
<li class="lvl-3">
<p><strong>线程安全</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">一个线程正在修改一个数据结构，而另一个线程正在读取该数据结构。如果修改操作不是原子的，那么读取操作可能会得到不一致的数据。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>内存可见性</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">一个线程修改了一个共享变量，但这个修改对其他线程来说不是立即可见的。这可能导致其他线程读取到旧值。</li>
</ul>
</li>
<li class="lvl-3">
<p><strong>性能问题</strong>：</p>
<ul class="lvl-2">
<li class="lvl-5">过多的线程竞争同一个资源可能会导致性能下降，因为线程需要频繁地等待资源变得可用。</li>
</ul>
</li>
</ol>
<p>为了解决并发问题，通常会使用以下策略：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>线程池</strong>：限制同时运行的线程数量，避免创建过多的线程导致的性能问题。</p>
</li>
<li class="lvl-2">
<p><strong>无锁编程（Lock-Free Programming）</strong>：使用原子操作来避免锁的使用，提高并发性能。</p>
</li>
<li class="lvl-2">
<p><strong>并行算法设计</strong>：设计可以同时在多个处理器上运行的算法，以利用多核处理器的优势</p>
</li>
</ul>
<h4 id="7-3-Mutex的种类">7.3 Mutex的种类</h4>
<h5 id="1-std-mutex-（基本互斥锁）"><strong>1. std::mutex （基本互斥锁）</strong></h5>
<p>std::mutex是C++标准库中提供的最基本的互斥锁类型之一。它用于实现线程间的互斥访问，即<mark>在一个时间点只允许一个线程获得锁</mark>，其他线程需要等待锁被释放才能继续执行。使用std::mutex可以保证多个线程对共享资源的访问顺序，并避免数据竞争产生的问题。</p>
<p><strong>常用函数</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>lock()</strong>	尝试获取互斥锁。如果未被其他线程占用，则当前线程获取锁；否则阻塞等待锁的释放。</p>
</li>
<li class="lvl-2">
<p><strong>unlock()</strong>	释放互斥锁。如果当前线程持有锁，则释放锁；否则行为未定义。</p>
</li>
<li class="lvl-2">
<p><strong>try_lock()</strong>	尝试获取互斥锁，不会阻塞线程。如果未被其他线程占用，则当前线程获取锁并返回true；否则返回false。</p>
</li>
</ul>
<h5 id="2-std-recursive-mutex-（递归互斥锁）"><strong>2. std::recursive_mutex （递归互斥锁）</strong></h5>
<p>std::recursive_mutex是C++标准库中提供的一个递归互斥锁类型，用于实现线程间的互斥访问。与std::mutex相比，std::recursive_mutex可以允许同一线程多次获取互斥锁，而不会导致死锁。简单来说就是<mark>允许同一个线程对互斥量多次上锁</mark>（即递归上锁），来获得对互斥量对象的多层所有权，<mark>释放互斥量时需要调用与该锁层次深度相同次数的 unlock()</mark></p>
<p>std::recursive_mutex定义在<mutex>头文件中。与std::mutex类似，可以通过定义std::recursive_mutex对象来创建一个递归互斥锁。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">//这里定义了一个名为mtx的std::recursive_mutex对象，用于保护某个共享资源的访问。</span></span><br><span class="line">std::recursive_mutex mtx;</span><br></pre></td></tr></table></figure>
<p>当同一线程多次尝试获取std::recursive_mutex时，<mark>它不会导致死锁</mark>，而是允许同一线程多次获取锁，需要相应次数的解锁操作才能完全释放锁。</p>
<h5 id="3-std-timed-mutex-（限时等待互斥锁）">3. std::timed_mutex （限时等待互斥锁）</h5>
<h5 id="4-std-recursive-timed-mutex-限时等待递归互斥锁">4. std::recursive_timed_mutex  (限时等待递归互斥锁)</h5>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ primer》文本查询程序一</title>
    <url>/2024/04/13/%E3%80%8AC-primer%E3%80%8B%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F%E4%B8%80/</url>
    <content><![CDATA[<blockquote>
<p>这是《C++ primer》中的一个示例程序，看了几遍仍觉有些细节没有明白，故手敲了一遍</p>
<p>需了解STL容器部分知识点，智能指针，文件流，string流</p>
</blockquote>
<span id="more"></span>
<h1>《C++ primer》文本查询程序一</h1>
<p>书上给的例子尚有瑕疵，如果单词在同一行出现多次，则只会记录为一次，本人能力有限，尚未解决此问题</p>
<h3 id="以下是写完程序后绘制的思维导图">以下是写完程序后绘制的思维导图</h3>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/image-20240413155500846.png" alt="image-20240413155500846"></p>
<h3 id="代码部分">代码部分</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>main.cpp</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;TextQuery.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ResultQuery.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">runQueries</span><span class="params">(ifstream&amp; fin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string filename;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入你要查询的文件名(包含后缀)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin &gt;&gt; filename;</span><br><span class="line">	<span class="function">ifstream <span class="title">readFile</span><span class="params">(filename, ios::in)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (readFile.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">runQueries</span>(readFile);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;the file open failed!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">runQueries</span><span class="params">(ifstream&amp; fin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">TextQuery <span class="title">tq</span><span class="params">(fin)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;please enter word to look for, or q to quit.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string needle;</span><br><span class="line">		<span class="keyword">if</span> (cin &gt;&gt; needle &amp;&amp; needle != <span class="string">&quot;q&quot;</span> &amp;&amp; needle != <span class="string">&quot;Q&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">MyPrint</span>(cout, tq.<span class="built_in">query</span>(needle)) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>TextQuery.h</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ResultQuery.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextQuery</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt; file;   <span class="comment">//智能指针 多个对象共享数据 存储地址</span></span><br><span class="line">	map&lt;string, shared_ptr&lt;set&lt;<span class="type">int</span>&gt;&gt;&gt; wm; <span class="comment">//间接实现单词与行号之间的映射</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TextQuery</span>(ifstream&amp; fin);   <span class="comment">//构造函数</span></span><br><span class="line">	<span class="function">ResultQuery <span class="title">query</span><span class="params">(string needle)</span></span>; <span class="comment">//用来整理出目标单词的相关信息，然后传递给ResultQuery</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>TextQuery.cpp</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TextQuery.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">TextQuery::<span class="built_in">TextQuery</span>(ifstream&amp; fin):<span class="built_in">file</span>(<span class="keyword">new</span> vector&lt;string&gt;)</span><br><span class="line">&#123;</span><br><span class="line">	string lineContent;</span><br><span class="line">	<span class="type">size_t</span> lineNo;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">getline</span>(fin,lineContent))    <span class="comment">// 将文件内容拆分为一行一行</span></span><br><span class="line">	&#123;</span><br><span class="line">		file-&gt;<span class="built_in">push_back</span>(lineContent);</span><br><span class="line">		lineNo = file-&gt;<span class="built_in">size</span>() - <span class="number">1</span>;    <span class="comment">//从零开始计数，方便之后利用迭代器进行输出查询结果</span></span><br><span class="line">		<span class="function">istringstream <span class="title">line</span><span class="params">(lineContent)</span></span>; <span class="comment">//利用string流 将一行内容再拆分为每个单词</span></span><br><span class="line">		string word;</span><br><span class="line">		<span class="keyword">while</span> (line &gt;&gt; word)     <span class="comment">//实现每个单词与对应行号之间的映射</span></span><br><span class="line">		&#123;</span><br><span class="line">			shared_ptr&lt;set&lt;<span class="type">int</span>&gt;&gt;&amp; NO = wm[word];  <span class="comment">// 在map中如果使用下标未找到对应的值，则会自动生成一个默认值</span></span><br><span class="line">			<span class="keyword">if</span> (!NO)</span><br><span class="line">			&#123;</span><br><span class="line">				NO.<span class="built_in">reset</span>(<span class="keyword">new</span> set&lt;<span class="type">int</span>&gt;);    <span class="comment">//清空默认值，使其是一个指向set&lt;int&gt;型的指针</span></span><br><span class="line">				NO-&gt;<span class="built_in">insert</span>(lineNo);        <span class="comment">//将这个单词所在的行号拷贝给 指针指向的那个空间</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				NO-&gt;<span class="built_in">insert</span>(lineNo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ResultQuery <span class="title">TextQuery::query</span><span class="params">(string needle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shared_ptr&lt;set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nothing</span> (<span class="keyword">new</span> set&lt;<span class="type">int</span>&gt;);</span><br><span class="line">	<span class="keyword">auto</span> result = wm.<span class="built_in">find</span>(needle);</span><br><span class="line">	<span class="keyword">if</span> (result == wm.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ResultQuery</span>(needle,file, nothing);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ResultQuery</span>(needle,file, result-&gt;second);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>ResultQuery.h</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResultQuery</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string needle;</span><br><span class="line">	shared_ptr&lt;vector&lt;string&gt;&gt; file;</span><br><span class="line">	shared_ptr&lt;set&lt;<span class="type">int</span>&gt;&gt; lines;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ResultQuery</span>(string n, shared_ptr&lt;vector&lt;string&gt;&gt; f, shared_ptr&lt;set&lt;<span class="type">int</span>&gt;&gt; l) :\</span><br><span class="line">		<span class="built_in">needle</span>(n), <span class="built_in">file</span>(f), <span class="built_in">lines</span>(l) &#123;&#125;    <span class="comment">//构造函数 进行初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">MyPrint</span><span class="params">(ostream&amp;, <span class="type">const</span> ResultQuery&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>ResultQuery.cpp</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ResultQuery.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">MyPrint</span><span class="params">(ostream&amp; os, <span class="type">const</span> ResultQuery&amp; rq)</span> </span>&#123;</span><br><span class="line">	os&lt;&lt; rq.needle &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; rq.lines-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;times in the file &quot;</span>  &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> line : *(rq.lines))</span><br><span class="line">	&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;\tline:&quot;</span>&lt;&lt;line+<span class="number">1</span>&lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;rq.file-&gt;<span class="built_in">begin</span>()[line]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Web前端基础</title>
    <url>/2024/04/05/Web%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>Web 前端的一些基础知识和相关工具的使用</p>
</blockquote>
<span id="more"></span>
<h1><u><strong>Java Web</strong></u></h1>
<p>文档查询网站:<a href="https://www.w3school.com.cn/index.html">https://www.w3school.com.cn/index.html</a></p>
<h1>Web前端</h1>
<h3 id="网页">网页</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>本质是<strong>前端代码</strong>经过浏览器的<strong>解析和渲染</strong>而成的</p>
</li>
<li class="lvl-2">
<p><strong>浏览器内核</strong>进行代码的解析和渲染</p>
</li>
</ul>
<h3 id="web标准">web标准</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>HTML：负责网页的结构（页面元素和内容）</p>
</li>
<li class="lvl-2">
<p>CSS：负责网页的表现（页面元素的外观，位置，颜色，大小等）</p>
</li>
<li class="lvl-2">
<p>JavaScript：负责网页的行为（交互效果）</p>
</li>
<li class="lvl-2">
<p>高级技术</p>
<ul class="lvl-2">
<li class="lvl-6">Vue.js</li>
<li class="lvl-6">ElementUI</li>
<li class="lvl-6">Ajax</li>
<li class="lvl-6">Axios</li>
<li class="lvl-6">…</li>
</ul>
</li>
</ul>
<h3 id="HTML（HyperText-Markup-Language）">HTML（HyperText Markup Language）</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>超文本标记语言（超越普通文本语言，由标签构成的语言）</p>
</li>
<li class="lvl-2">
<p>标签是预定好的，</p>
</li>
<li class="lvl-2">
<p>HTML代码直接在浏览器中运行，HTML标签由浏览器解析</p>
</li>
</ul>
<h4 id="特点">特点</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>不区分大小写</p>
</li>
<li class="lvl-2">
<p>属性可以使用单引号或者双引号</p>
</li>
<li class="lvl-2">
<p>语法松散</p>
</li>
</ul>
<h4 id="常用标签">常用标签</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>&lt;img&gt;</p>
<ul class="lvl-2">
<li class="lvl-6"><strong>src</strong>:指定图像的url（相对或绝对）</li>
<li class="lvl-6"><strong>width</strong></li>
<li class="lvl-6"><strong>height</strong></li>
</ul>
</li>
<li class="lvl-2">
<p>标题标签:&lt;h1&gt; - &lt;h6&gt;</p>
</li>
<li class="lvl-2">
<p>水平线标签:&lt;hr&gt;</p>
</li>
<li class="lvl-2">
<p>超链接&lt;a&gt;</p>
<ul class="lvl-2">
<li class="lvl-6">href指定访问资源的url</li>
<li class="lvl-6">target指定在何处打开资源(_self,_blank)</li>
</ul>
</li>
<li class="lvl-2">
<p>&lt;video&gt;视频</p>
<ul class="lvl-2">
<li class="lvl-6">controls显示播放控件</li>
<li class="lvl-6">src</li>
<li class="lvl-6">width</li>
</ul>
</li>
<li class="lvl-2">
<p>&lt;audio&gt;音频</p>
<ul class="lvl-2">
<li class="lvl-6">controls</li>
<li class="lvl-6">src</li>
<li class="lvl-6">width</li>
</ul>
</li>
<li class="lvl-2">
<p>&lt;b&gt;/&lt;strong&gt;加粗</p>
</li>
<li class="lvl-2">
<p>&lt;p&gt;分段落</p>
</li>
<li class="lvl-2">
<p><mark>表格标签</mark></p>
<ul class="lvl-2">
<li class="lvl-6">
<p>&lt;table&gt;定义表格整体</p>
<ul class="lvl-4">
<li class="lvl-10">border:规定边框宽度</li>
<li class="lvl-10">width:规定表格的宽度</li>
<li class="lvl-10">cellspacing:规定单元格之间的空隙大小</li>
</ul>
</li>
<li class="lvl-6">
<p>&lt;tr&gt;:表格的行</p>
</li>
<li class="lvl-6">
<p>&lt;td&gt;:表格单元格，（表头使用&lt;th&gt;）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;600px&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>角色名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">th</span>&gt;</span>图片<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>元素<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>国度<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>那维莱特<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://picx.zhimg.com/70/v2-5623d0ee6d0a7f7a63ffce7830fdbc7a_1440w.avis?source=172ae18b&amp;biz_tag=Post&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>水<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>枫丹<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>提纳里<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://patchwiki.biligame.com/images/ys/2/2b/hcwuh3cbgc5dyfcx4qlqp95qlzbp619.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>草<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>须弥<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>表单标签</mark></p>
<ul class="lvl-2">
<li class="lvl-6">负责采集数据，如登录，注册等信息</li>
<li class="lvl-6">&lt;form&gt;
<ul class="lvl-4">
<li class="lvl-10">
<p>&lt;input&gt;:定义表单项，通过type属性控制输入形式</p>
<ul class="lvl-6">
<li class="lvl-14"><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/4ea973bcae494ddcb335a2210f851a33.jpg" alt=""></li>
</ul>
</li>
<li class="lvl-10">
<p>&lt;select&gt;:定义下拉列表</p>
<ul class="lvl-6">
<li class="lvl-14">&lt;option&gt;定义列表项</li>
</ul>
</li>
<li class="lvl-10">
<p>&lt;textarea&gt;:定义文本域</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别:<span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    爱好:<span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span>java<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;genshin&quot;</span>&gt;</span>genshin<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sleep&quot;</span>&gt;</span>sleep<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    图像:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    生日:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    时间:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;time&quot;</span> <span class="attr">name</span>=<span class="string">&quot;time&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    日期时间:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;datetime-local&quot;</span> <span class="attr">name</span>=<span class="string">&quot;datetime&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    学历:<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;degree&quot;</span>&gt;</span></span><br><span class="line">    		 <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>-----------请选择---------<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   			 <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>大专<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   			 <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>本科<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   			 <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>硕士<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">   			 <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>博士<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">select</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    描述:<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 表单常见按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>属性</p>
<ul class="lvl-2">
<li class="lvl-6">action:规定提交表单时向<mark>何处</mark>发送表单数据，<mark>URL(如果不指定默认提交到当前页面)</mark></li>
<li class="lvl-6">method:规定用于发送表单数据的方式。GET，POST
<ul class="lvl-4">
<li class="lvl-10">get在url后面拼接表单数据</li>
<li class="lvl-10">post在消息体（请求体）中传递，参数长度无限制</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/e447b517ec4b4c0188f40c169819dee5.jpg" alt=""><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/6849f34158104e18a40762f0f110e73c.jpg" alt=""></p>
</li>
</ul>
<h3 id="CSS（Cascading-Style-Sheet）">CSS（Cascading Style Sheet）</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>层叠样式表，控制网页的表现</p>
</li>
</ul>
<h4 id="CSS选择器">CSS选择器</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>元素选择器<code>h1&#123;&#125;</code></p>
</li>
<li class="lvl-2">
<p>id选择器<code>#hid&#123;&#125;</code>(在style中)     <code>&lt;h1 id=&quot;hid&quot;&gt;</code>不能重复</p>
</li>
<li class="lvl-2">
<p>类选择器<code>.cls&#123;&#125;</code>(在style中)      <code>&lt;h1 class=&quot;cls&quot;&gt;</code></p>
</li>
</ul>
<h4 id="常用标签-2">常用标签</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>&lt;span&gt;无语义的布局标签，一行可显示多个</p>
</li>
<li class="lvl-2">
<p>&lt;div&gt;</p>
</li>
</ul>
<h4 id="属性">属性</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>color</p>
</li>
<li class="lvl-2">
<p>font-size：字体大小（加px）</p>
</li>
<li class="lvl-2">
<p>text-decoration:规定文本的修饰，none表示定义标准的文本</p>
</li>
<li class="lvl-2">
<p>text-align：控制对齐方式</p>
</li>
<li class="lvl-2">
<p>text-indent:首行缩进</p>
</li>
<li class="lvl-2">
<p>line-height：行高</p>
</li>
<li class="lvl-2">
<p>空格占位符：&amp;nbsp</p>
</li>
</ul>
<h4 id="盒子模型">盒子模型</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>&lt;div&gt;无语义的布局标签，一行只占一个</p>
</li>
<li class="lvl-2">
<p>组成：内容区域(content)，内边距区域(padding)，边框区域(border)，外边距区域(margin)</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/f16d206f52b2485fa07da58b55eb814d.jpg" alt=""></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="language-css">       <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">102</span>, <span class="number">97</span>, <span class="number">97</span>);</span></span><br><span class="line"><span class="language-css">     &#125;</span></span><br><span class="line"><span class="language-css">   //类选择器</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.time</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">241</span>, <span class="number">3</span>, <span class="number">3</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    //标签选择器</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:black;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    //id选择器</span></span><br><span class="line"><span class="language-css">   <span class="selector-id">#wangmc</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: right;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">28px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:chocolate;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    </span></span><br><span class="line"><span class="language-css">    <span class="comment">/*&lt;div id=&quot;center&quot;&gt;*/</span></span></span><br><span class="line"><span class="language-css">   <span class="selector-id">#center</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>:<span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">box-sizing</span>: border-box;<span class="comment">/*指定width为盒子宽度*/</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">219</span>, <span class="number">235</span>, <span class="number">235</span>);</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">20px</span>; <span class="comment">/*内边距 上右下左*/</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid red;<span class="comment">/*边框宽度 线条类型 颜色*/</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>:auto;<span class="comment">/*外边距 */</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="JavaScript（简称：js）">JavaScript（简称：js）</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>跨平台，面向对象的脚本语言，使网页可以交互</p>
</li>
</ul>
<h4 id="js引入方式">js引入方式</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>内部脚本（定义在HTML页面）</p>
<ul class="lvl-2">
<li class="lvl-6">js代码<strong>必须</strong>位于&lt;script&gt;&lt;/script&gt;之间</li>
<li class="lvl-6">可以放在任意地方，放置任意数量</li>
<li class="lvl-6">一般位于&lt;body&gt;元素的底部，改善显示速度</li>
</ul>
</li>
<li class="lvl-2">
<p>外部脚本（js代码定义在外部角色文件中，然后引入到HTML中）</p>
<ul class="lvl-2">
<li class="lvl-6">外部js文件中只包含js代码，不含有&lt;script&gt;标签</li>
<li class="lvl-6">&lt;script&gt;标签<strong>不能自闭合</strong></li>
</ul>
</li>
</ul>
<h4 id="基础语法">基础语法</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>书写语法</p>
<ul class="lvl-2">
<li class="lvl-6">区分大小写</li>
<li class="lvl-6">每条语句结束可以不写分号</li>
</ul>
</li>
<li class="lvl-2">
<p>输出语句</p>
<ul class="lvl-2">
<li class="lvl-6">window.alert()  写入警告框</li>
<li class="lvl-6">document.write()  写入HTML输出</li>
<li class="lvl-6">console.log()  写入浏览器控制台</li>
</ul>
</li>
</ul>
<h4 id="变量">变量</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>利用<strong>var，let，const关键字</strong>来声明变量</p>
</li>
<li class="lvl-2">
<p>因为js是弱类型的语言，所以变量<strong>可以存放不同类型</strong>的值</p>
</li>
<li class="lvl-2">
<p>利用var定义出来的是全局变量，可以重复定义</p>
</li>
<li class="lvl-2">
<p>利用let定义出来的是<strong>局部变量</strong>，只在代码块中有效，不可重复定义</p>
</li>
</ul>
<h4 id="数据类型">数据类型</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>原始类型</p>
<ul class="lvl-2">
<li class="lvl-6">number，string，boolean，null，undefined</li>
</ul>
</li>
<li class="lvl-2">
<p>引用类型</p>
<ul class="lvl-2">
<li class="lvl-6">js中的对象</li>
</ul>
</li>
<li class="lvl-2">
<p>利用<strong>typeof</strong>来获取数据类型</p>
</li>
</ul>
<h4 id="运算符">运算符</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>==：会进行类型转换</p>
</li>
<li class="lvl-2">
<p>===：<strong>不会</strong>进行类型转换</p>
</li>
</ul>
<h4 id="js函数">js函数</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>通过function关键字进行定义</p>
</li>
<li class="lvl-2">
<p>不需要定义形参和返回值的类型</p>
</li>
</ul>
<h4 id="js对象">js对象</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>Array</mark></p>
<ul class="lvl-2">
<li class="lvl-6">var 变量名 =  [元素列表]</li>
<li class="lvl-6">var 变量名 = new Array（元素列表）</li>
<li class="lvl-6">属性：length，返回数组中的元素数量</li>
<li class="lvl-6">方法
<ul class="lvl-4">
<li class="lvl-10">forEach()：遍历数组中每一个有值的元素，并调用一次传入的函数
<ul class="lvl-6">
<li class="lvl-14">箭头函数:<mark>arry.forEach(item=&gt;{console.log(item);})</mark></li>
</ul>
</li>
<li class="lvl-10">push()：将新元素添加到数组末尾，并返回新的长度</li>
<li class="lvl-10">splice(start,number)：从数组中删除元素</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>String</mark></p>
<ul class="lvl-2">
<li class="lvl-6">属性：length</li>
<li class="lvl-6">方法
<ul class="lvl-4">
<li class="lvl-10">charAt()：返回指定位置的字符</li>
<li class="lvl-10">indexOf()：检索字符串所在的位置</li>
<li class="lvl-10">trim()：去除字符串两边的空格</li>
<li class="lvl-10">substring(start,end):提取字符串中两个指定的索引号之间的字符(左闭右开)</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>JSON(JavaScript Object Notation)</mark></p>
<ul class="lvl-2">
<li class="lvl-6">通过JavaScript对象标记法写的<strong>文本</strong></li>
<li class="lvl-6">多作为<strong>数据载体</strong>，进行数据传输</li>
<li class="lvl-6">自定义对象
<ul class="lvl-4">
<li class="lvl-10"><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/fef698ce3a1442548684b60d271ab794.jpg" alt=""></li>
</ul>
</li>
<li class="lvl-6">格式与自定义对象类似，但变量名要加双引号</li>
<li class="lvl-6">定义
<ul class="lvl-4">
<li class="lvl-10"><code>var 变量名 = '&#123;&quot;key1&quot;: value1,&quot;key2&quot;:value2&#125;'</code></li>
<li class="lvl-10"><code>var userStr = '&#123;&quot;name&quot;:&quot;Jerry&quot;,&quot;age&quot;:18,&quot;addr&quot;:[&quot;原神&quot;,&quot;星铁&quot;,&quot;绝区零&quot;]&#125;'</code></li>
<li class="lvl-10">该对象是文本，整体要加单引号</li>
</ul>
</li>
<li class="lvl-6">方法
<ul class="lvl-4">
<li class="lvl-10">JSON.parse()    将 JSON 字符串解析为 JavaScript 对象</li>
<li class="lvl-10">JSON.stringify()</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>BOM(Browser Object Model)</mark></p>
<ul class="lvl-2">
<li class="lvl-6">浏览器对象模型，允许js与浏览器对话，js将<strong>浏览器各个组成部分</strong>封装为对象</li>
<li class="lvl-6">组成
<ul class="lvl-4">
<li class="lvl-10">Window:浏览器窗口对象
<ul class="lvl-6">
<li class="lvl-14">方法
<ul class="lvl-8">
<li class="lvl-18">alert()显示带有一段消息和一个确认按钮的警告框</li>
<li class="lvl-18">confirm()显示带有一段消息以及一个确认和取消按钮的对话框</li>
<li class="lvl-18">setInterval()按照指定的周期来调用函数</li>
<li class="lvl-18">setTimeout()在指定的毫秒数后调用函数</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-10">Navigator:浏览器对象</li>
<li class="lvl-10">Screen</li>
<li class="lvl-10">History</li>
<li class="lvl-10">Location:地址栏对象
<ul class="lvl-6">
<li class="lvl-14">属性：href</li>
<li class="lvl-14"><code>location.href = &quot;</code><a href="https://www.xxxx.cn%22%60">https://www.xxxx.cn&quot;`</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="lvl-2">
<p><mark>DOM(Document Object Model)</mark></p>
<ul class="lvl-2">
<li class="lvl-6">将<strong>标记语言</strong>的各个组成部分封装为对应的对象
<ul class="lvl-4">
<li class="lvl-10">Document:整个文档对象</li>
<li class="lvl-10">Element:元素对象</li>
<li class="lvl-10">Attribute:属性对象</li>
<li class="lvl-10">Text:文本对象</li>
<li class="lvl-10">Comment:注释对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="js事件监听">js事件监听</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>指发生在HTML元素上的事情，如按钮被点击，按下鼠标快捷键,执行相应代码</p>
</li>
<li class="lvl-2">
<p>事件绑定</p>
<ul class="lvl-2">
<li class="lvl-6"><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/13eb553b0c2641fa98fba14050304d0f.jpg" alt=""></li>
</ul>
</li>
<li class="lvl-2">
<p>常见事件</p>
<ul class="lvl-2">
<li class="lvl-6"><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/0d7b9d055cc4489fa75047028cb7b01f.jpg" alt=""></li>
</ul>
</li>
</ul>
<h3 id="Vue">Vue</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>前端框架，免除js中的DOM操作，基于MVVM思想，实现数据双向绑定</p>
</li>
</ul>
<h4 id="插值表达式-swig￼11">插值表达式:</h4>
<h4 id="常用属性">常用属性</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>el指示vue编译器从什么地方开始解析 vue的语法</p>
</li>
<li class="lvl-2">
<p>data存储变量</p>
</li>
<li class="lvl-2">
<p>methods存放函数</p>
</li>
<li class="lvl-2">
<p>template设置模板</p>
</li>
<li class="lvl-2">
<p>watch</p>
</li>
<li class="lvl-2">
<p>computed</p>
</li>
<li class="lvl-2">
<p>render创建真正的Virtual Dom</p>
</li>
</ul>
<h4 id="常用指令">常用指令</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>v-model在<a href="####%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE">表单元素</a>上创建双向数据绑定</p>
</li>
<li class="lvl-2">
<p>v-bind为HTML标签绑定属性值，如href，css样式</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;yuanshen&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>原神<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>:<span class="string">&quot;hello vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#yuanshen&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>:<span class="string">&quot;https://www.yuanshen.com/#/&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>v-on为HTML标签绑定事件</p>
<ul class="lvl-2">
<li class="lvl-6"><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/1728dacdc3684d4da2335099fb847944.jpg" alt=""></li>
</ul>
</li>
<li class="lvl-2">
<p>v-if, v-else-if, v-else条件性的渲染某元素</p>
</li>
<li class="lvl-2">
<p>v-show根据条件展示某元素，区别在于切换的是display属性的值</p>
</li>
<li class="lvl-2">
<p>v-for列表渲染，遍历容器中的元素或者对象的属性</p>
<ul class="lvl-2">
<li class="lvl-6"><code>&lt;div v-for=&quot;变量名 in 遍历对象&quot;&gt;&#123;&#123;变量名&#125;&#125;&lt;/div&gt;</code></li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;addr in addrs&quot;</span>&#123;&#123;<span class="attr">addr</span>&#125;&#125;&lt;/<span class="attr">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(addr,index) in addrs&quot;</span>&#123;&#123;<span class="attr">index</span>+<span class="attr">1</span>&#125;&#125;<span class="attr">:</span>&#123;&#123;<span class="attr">addr</span>&#125;&#125;&lt;/<span class="attr">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">	...</span><br><span class="line">	addrs:[&#x27;beijing&#x27;,&#x27;shanghai&#x27;,&#x27;hongkong&#x27;,&#x27;nanjing&#x27;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>案例</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;60%&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>等级<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(arr,index) in users&quot;</span>&gt;</span> //遍历users数组中的元素，并赋值给arr</span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;index+1&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;arr.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;arr.age&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;arr.gender==1&quot;</span>&gt;</span>boy<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;arr.gender==0&quot;</span>&gt;</span>girl<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;arr.score&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;arr.score&gt;=90&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;arr.score&gt;=60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>=<span class="string">&quot;arr.score 60&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:red &quot;</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">users</span>:[&#123;<span class="attr">name</span>:<span class="string">&quot;纳西妲&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;500&quot;</span>,<span class="attr">gender</span>:<span class="number">0</span>,<span class="attr">score</span>:<span class="number">100</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">name</span>:<span class="string">&quot;芙宁娜&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;530&quot;</span>,<span class="attr">gender</span>:<span class="number">0</span>,<span class="attr">score</span>:<span class="number">80</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">name</span>:<span class="string">&quot;荒泷一斗&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;101&quot;</span>,<span class="attr">gender</span>:<span class="number">1</span>,<span class="attr">score</span>:<span class="number">55</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">name</span>:<span class="string">&quot;旅行者&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;666&quot;</span>,<span class="attr">gender</span>:<span class="number">1</span>,<span class="attr">score</span>:<span class="number">90</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">name</span>:<span class="string">&quot;派蒙&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;320&quot;</span>,<span class="attr">gender</span>:<span class="number">0</span>,<span class="attr">score</span>:<span class="number">66</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">name</span>:<span class="string">&quot;七七&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;432&quot;</span>,<span class="attr">gender</span>:<span class="number">0</span>,<span class="attr">score</span>:<span class="number">77</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123;<span class="attr">name</span>:<span class="string">&quot;天理&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;999&quot;</span>,<span class="attr">gender</span>:<span class="number">0</span>,<span class="attr">score</span>:<span class="number">150</span>&#125;]</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="生命周期">生命周期</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>每触发一个生命周期事件，会自动执行一个生命周期方法（钩子）</p>
</li>
<li class="lvl-2">
<p>八个阶段</p>
<ul class="lvl-2">
<li class="lvl-6">beforeCreate</li>
<li class="lvl-6">created</li>
<li class="lvl-6">beforeMount</li>
<li class="lvl-6">mounted挂载完成</li>
<li class="lvl-6">beforeUpdate</li>
<li class="lvl-6">updated</li>
<li class="lvl-6">beforeDestroy</li>
<li class="lvl-6">destroyed</li>
</ul>
</li>
</ul>
<h4 id="Vue路由-Vue-Router">Vue路由(Vue Router)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>Vue router 路由器类，根据路由请求在路由视图中动态渲染选中的组件</p>
</li>
<li class="lvl-2">
<p><code>&lt;router-link&gt;</code>请求链接组件，会被浏览器解析为<code>&lt;a&gt;</code></p>
</li>
<li class="lvl-2">
<p><code>&lt;router-view&gt;</code>动态视图组件，用来渲染展示与路由路径对应的组件</p>
</li>
</ul>
<h3 id="Ajax-Asynchronous-Javascript-Anderson-XML">Ajax(Asynchronous Javascript Anderson XML)</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>异步</strong>的Javascript和XML</p>
</li>
</ul>
<h4 id="作用">作用</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据交换：通过它可以向服务器发送请求，并获取服务器响应的数据</p>
</li>
<li class="lvl-2">
<p>异步交互：不刷新整个页面的同时，进行局部刷新</p>
</li>
</ul>
<h4 id="Axios">Axios</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>对原生的Ajax进行了封装，简化书写，快速开发</p>
</li>
<li class="lvl-2">
<p>入门程序</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;获取数据GET&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;get()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;删除数据POST&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;post()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">url</span>:<span class="string">&quot;http://yuanshen.com&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">-------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="language-javascript">            axios.<span class="title function_">get</span>(<span class="string">&quot;http://yuanshen.com&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>)&#125;) <span class="comment">//简化模式</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/MengChangWang/Blog_Image@main/img/5da623d6d2e9467ca984a9b4ca3dec8d.jpg" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>结合Vue中的mounted生命周期事件</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    	<span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    	<span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">emps</span>:[]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    	<span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            axios.<span class="title function_">get</span>(<span class="string">&quot;http://www.xxxx.xxx.com&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">emps</span> = result.<span class="property">data</span>.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;);   </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="YApi">YApi</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>高效，易用，功能强大的api管理平台</p>
</li>
<li class="lvl-2">
<p>用于模拟前端所需要的数据</p>
</li>
</ul>
<h3 id="前端工程化">前端工程化</h3>
<h4 id="定义">定义</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>指把前端开发所需的工具，技术，流程，经验等进行规范化，标准化</p>
</li>
</ul>
<h4 id="vue脚手架的环境准备">vue脚手架的环境准备</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>安装node.js</p>
</li>
<li class="lvl-2">
<p>配置npm的全局安装路径   <code>npm config set prefix &quot;node.js的安装路径&quot;</code></p>
</li>
<li class="lvl-2">
<p>切换npm的镜像  <code>npm config set registry 镜像地址</code></p>
<ul class="lvl-2">
<li class="lvl-5">腾讯 镜像: <a href="https://mirrors.cloud.tencent.com/npm/">https://mirrors.cloud.tencent.com/npm/</a></li>
<li class="lvl-4">华为 镜像: <a href="https://mirrors.huaweicloud.com/repository/npm/">https://mirrors.huaweicloud.com/repository/npm/</a></li>
<li class="lvl-4">阿里 镜像：<a href="https://npm.aliyun.com">https://npm.aliyun.com</a></li>
</ul>
</li>
<li class="lvl-2">
<p>安装vue-cli <code>npm install -g @vue/cli</code></p>
</li>
<li class="lvl-2">
<p>确认是否安装成功 <code>vue --version</code></p>
</li>
</ul>
<h4 id="Vue项目">Vue项目</h4>
<h5 id="创建">创建</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>命令行 <code>vue create vue-project01</code></p>
</li>
<li class="lvl-2">
<p>图形化界面<code>vue ui</code></p>
</li>
</ul>
<h5 id="目录结构">目录结构</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>node_modules 整个项目的依赖包</p>
</li>
<li class="lvl-2">
<p>public 存放项目的静态文件</p>
</li>
<li class="lvl-2">
<p><mark>src</mark>       存放项目的源代码</p>
<ul class="lvl-2">
<li class="lvl-4"><mark>assets</mark>静态资源</li>
<li class="lvl-4"><mark>components</mark>可重用的组件</li>
<li class="lvl-4"><mark>router</mark>路由配置</li>
<li class="lvl-4"><mark>views</mark>视图组件（页面）</li>
<li class="lvl-4"><mark>App.vue</mark>入口页面（根组件）</li>
<li class="lvl-4"><mark>main.js</mark>入口js文件</li>
</ul>
</li>
<li class="lvl-2">
<p>package.json   模板基本信息，项目开发所需要的模块，版本信息</p>
</li>
<li class="lvl-2">
<p>vue.config.js     保存vue配置的文件，如：代理，端口的配置</p>
</li>
</ul>
<h5 id="更改端口号">更改端口号</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>进入vue.config.js文件</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="comment">//添加以下内容，将端口号改为7000</span></span><br><span class="line">  <span class="attr">devServer</span>:&#123;</span><br><span class="line">    <span class="attr">port</span>:<span class="number">7000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Vue的组件文件以.vue结尾，每个组件由三部分组成<code>&lt;template&gt;，&lt;script&gt;，&lt;style&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span>  //模板部分，生成HTML代码</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">data</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>:<span class="string">&quot;hello vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  //控制模板的数据来源和行为</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  //css样式部分</span><br></pre></td></tr></table></figure>
<h3 id="Element-Vue组件库">Element(Vue组件库)</h3>
<p><strong>组件</strong>：组成网页的部件，如超链接，按钮，图片，表格，表单，分页条等</p>
<p>url：<a href="https://element-plus.org/zh-CN/#/zh-CN">一个 Vue 3 UI 框架 | Element Plus (element-plus.org)</a></p>
<h4 id="如何使用">如何使用</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>在创建好的Vue项目中安装ElementUI组件库 <code> npm install element-plus --save</code></p>
</li>
<li class="lvl-2">
<p>引入ElementUI组件库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2">
<p>访问官网，复制组件代码，调整</p>
</li>
</ul>
<h4 id="打包部署">打包部署</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>先打包<code>npm run build</code> 再部署</p>
</li>
<li class="lvl-2">
<p>将打包好的dist目录下的文件，复制到<mark>nginx</mark>安装目录下的<mark>html目录</mark></p>
</li>
<li class="lvl-2">
<p><strong>启动</strong>：双击nginx.exe文件，nginx服务器默认占用<u>本机80端口号</u></p>
<ul class="lvl-2">
<li class="lvl-4">如果80端口号被占用，可以在<strong>nginx.conf</strong>中修改端口号</li>
<li class="lvl-4">查看端口被谁占用<code>netstat -ano | findStr 80</code></li>
</ul>
</li>
<li class="lvl-2">
<p>访问：浏览器输入 <code>localhost:端口号</code></p>
</li>
</ul>
<h4 id="Nginx">Nginx</h4>
<p>一款轻量级的web服务器，反向代理服务器，电子邮件代理服务器</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
</search>
