[{"title":"Hello World","url":"/2025/05/15/hello-world/","content":"Welcome to my personal blog, this is the first attemp.\n"},{"title":"windows批处理脚本相关概念","url":"/2025/10/20/windows/windows%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/","content":"\n想自动化创建markdown文件时了解到的相关技术，利用AI进行了整理简单了解即可\n\n\n批处理脚本（BAT）完整教程：语法、概念与实践\n目录\n\n\n基本概念\n\n\n常用命令\n\n\n变量系统\n\n\n特殊参数扩展\n\n\n命令行参数处理\n\n\n特殊符号\n\n\n控制结构\n\n\n高级概念\n\n\n实用脚本示例\n\n\n基本概念\n批处理脚本（.bat 或 .cmd 文件）是Windows系统下的脚本文件，包含一系列DOS命令，用于自动化执行任务。它是一种解释性语言，由命令提示符（cmd.exe）解释执行。\n特点：\n\n\n无需编译，直接执行\n\n\n逐行解释执行\n\n\n可以调用系统命令和其他程序\n\n\n支持变量、条件判断和循环等基本编程结构\n\n\n常用命令\n文件操作\n\n\ndir - 显示目录内容\n\n\ncd - 改变当前目录\n\n\nmd/mkdir - 创建目录\n\n\nrd/rmdir - 删除目录\n\n\ncopy - 复制文件\n\n\nmove - 移动文件\n\n\ndel - 删除文件\n\n\nren/rename - 重命名文件\n\n\n系统操作\n\n\necho - 显示文本或关闭/打开命令回显\n\n\ncls - 清空屏幕\n\n\ntype - 显示文件内容\n\n\ndate - 显示或设置日期\n\n\ntime - 显示或设置时间\n\n\nver - 显示Windows版本\n\n\ntitle - 设置命令提示符窗口标题\n\n\n程序执行\n\n\nstart - 启动一个新窗口执行程序\n\n\ncall - 调用另一个批处理文件\n\n\nexit - 退出批处理程序\n\n\npause - 暂停程序执行，等待用户按键\n\n\n变量系统\n系统变量\n\n\n\n变量\n说明\n\n\n\n\n%SystemRoot%\nWindows系统目录（通常是C:\\Windows）\n\n\n%SystemDrive%\n系统所在驱动器（通常是C:）\n\n\n%UserProfile%\n当前用户的个人文件夹\n\n\n%PATH%\n可执行文件路径\n\n\n%TEMP%/%TMP%\n临时文件夹路径\n\n\n%DATE%\n当前日期\n\n\n%TIME%\n当前时间\n\n\n%CD%\n当前目录\n\n\n%ALLUSERSPROFILE%\n所有用户配置文件位置\n\n\n%APPDATA%\n应用程序数据存储位置\n\n\n%CMDCMDLINE%\n启动当前Cmd.exe的命令行\n\n\n%CMDEXTVERSION%\n命令处理程序扩展版本号\n\n\n%COMPUTERNAME%\n计算机名称\n\n\n%COMSPEC%\n命令行解释器可执行程序路径\n\n\n%ERRORLEVEL%\n上一条命令的错误代码\n\n\n%HOMEDRIVE%\n用户主目录所在驱动器\n\n\n%HOMEPATH%\n用户主目录完整路径\n\n\n%HOMESHARE%\n用户共享主目录的网络路径\n\n\n%LOGONSERVER%\n验证当前登录会话的域控制器名称\n\n\n%NUMBER_OF_PROCESSORS%\n安装的处理器数目\n\n\n%OS%\n操作系统名称\n\n\n%PATHEXT%\n操作系统认为可执行的文件扩展名列表\n\n\n%PROCESSOR_ARCHITECTURE%\n处理器芯片体系结构\n\n\n%PROCESSOR_IDENTFIER%\n处理器说明\n\n\n%PROCESSOR_LEVEL%\n处理器型号\n\n\n%PROCESSOR_REVISION%\n处理器版本号\n\n\n%PROMPT%\n当前命令提示符设置\n\n\n%RANDOM%\n0到32767之间的随机数\n\n\n%USERDOMAIN%\n包含用户帐户的域名称\n\n\n%USERNAME%\n当前登录用户名\n\n\n%WINDIR%\n操作系统目录位置\n\n\n\n用户自定义变量\n@echo offset var=Hello Worldecho %var%:: 设置带空格的变量值set &quot;var=Hello World with spaces&quot;echo %var%:: 数值计算set /a num=10+5echo %num%:: 删除变量set var=\n特殊参数扩展\n根据官方文档，批处理脚本提供了强大的参数扩展功能，使用%~语法可以对参数进行各种转换。\n基础扩展修饰符\n\n\n\n语法\n说明\n\n\n\n\n%~1\n展开%1并删除周围的引号\n\n\n%~f1\n将%1扩展到完全限定的路径名\n\n\n%~d1\n仅将%1扩展为驱动器号\n\n\n%~p1\n仅将%1扩展到路径\n\n\n%~n1\n仅将%1扩展到文件名\n\n\n%~x1\n仅将%1扩展到文件扩展名\n\n\n%~s1\n扩展路径只包含短名称\n\n\n%~a1\n将%1扩展到文件属性\n\n\n%~t1\n将%1扩展到文件的日期和时间\n\n\n%~z1\n将%1扩展到文件的大小\n\n\n%~$PATH:1\n搜索PATH环境变量中的目录，将%1扩展到找到的第一个文件的完整路径\n\n\n\n%~dp0详解\n%~dp0是最常用的特殊扩展之一：\n\n\nd = 驱动器号\n\n\np = 路径\n\n\n0 = 表示批处理文件本身\n\n\n例如，如果批处理文件位于F:\\Temp\\Batch\\test.bat，则：\necho %~dp0  :: 输出 F:\\Temp\\Batch\\echo %~f0  :: 输出 F:\\Temp\\Batch\\test.batecho %~n0  :: 输出 testecho %~x0  :: 输出 .bat\n组合扩展示例\n\n\n\n语法\n说明\n\n\n\n\n%~dp1\n将%1扩展到驱动器号和路径\n\n\n%~nx1\n将%1扩展到文件名和扩展名\n\n\n%~dp$PATH:1\n在PATH中搜索%1，扩展到找到的第一个文件的驱动器号和路径\n\n\n%~ftza1\n将%1扩展为类似dir命令的输出行\n\n\n\n命令行参数处理\n基本参数访问\n@echo offecho 批处理文件名: %0echo 第一个参数: %1echo 第二个参数: %2echo 第三个参数: %3\n%*的含义\n%*表示传递给批处理文件的所有参数（不包括%0），保留参数中的引号和空格。\n@echo offecho 所有参数: %*\n处理超过9个参数\n使用shift命令可以处理超过9个参数：\n@echo off:loopif &quot;%1&quot;==&quot;&quot; goto endecho 参数: %1shiftgoto loop:end\n参数解析示例\n@echo offsetlocal enabledelayedexpansionset &quot;source=&quot;set &quot;destination=&quot;set &quot;verbose=false&quot;:parse_argsif &quot;%1&quot;==&quot;&quot; goto end_parseif &quot;%1&quot;==&quot;/v&quot; (    set &quot;verbose=true&quot;    shift    goto parse_args)if not defined source (    set &quot;source=%1&quot;) else if not defined destination (    set &quot;destination=%1&quot;)shiftgoto parse_args:end_parseecho 源: %source%echo 目标: %destination%echo 详细模式: %verbose%endlocal\n特殊符号\n重定向符号\n\n\n&gt; - 输出重定向（覆盖文件）\n\n\n&gt;&gt; - 输出重定向（追加到文件）\n\n\n&lt; - 输入重定向\n\n\n| - 管道符号，将前一个命令的输出作为后一个命令的输入\n\n\n通配符\n\n\n* - 匹配任意字符序列\n\n\n? - 匹配任意单个字符\n\n\n其他符号\n\n\n@ - 隐藏命令本身的显示\n\n\n: - 标签定义\n\n\n:: - 注释（与rem类似，但执行更快）\n\n\n&amp; - 命令分隔符，在同一行执行多个命令\n\n\n&amp;&amp; - 逻辑与，前一个命令成功才执行后一个\n\n\n|| - 逻辑或，前一个命令失败才执行后一个\n\n\n() - 命令块，将多个命令作为一个整体执行\n\n\n^ - 转义字符，用于显示特殊字符本身\n\n\n高级重定向示例\n@echo off:: 将命令输出同时保存到文件和显示在屏幕上dir | tee output.txt:: 错误重定向command 2&gt; error.log  :: 将错误输出到文件command 2&gt;&amp;1          :: 将错误输出重定向到标准输出command &gt; output.log 2&gt;&amp;1  :: 将所有输出重定向到文件\n控制结构\nif 语句\n@echo offset var=10:: 基本if语句if %var% equ 10 (    echo 变量等于10):: if-else语句if %var% gtr 5 (    echo 变量大于5) else (    echo 变量小于等于5):: 文件/目录检查if exist &quot;file.txt&quot; (    echo 文件存在)if not exist &quot;folder&quot; (    mkdir &quot;folder&quot;):: 字符串比较if &quot;string1&quot;==&quot;string2&quot; (    echo 字符串相等)\nfor 循环\n@echo off:: 遍历文件for %%f in (*.txt) do (    echo 文件: %%f):: 遍历目录for /d %%d in (*) do (    echo 目录: %%d):: 遍历数字序列for /l %%i in (1,1,5) do (    echo 数字: %%i):: 遍历命令输出for /f &quot;delims=&quot; %%a in (&#x27;dir /b *.txt&#x27;) do (    echo 文件: %%a):: 遍历文件内容for /f &quot;tokens=1,2 delims=,&quot; %%a in (data.csv) do (    echo 列1: %%a, 列2: %%b)\ngoto 语句和标签\n@echo offecho 开始goto middle:startecho 这是开始标签goto end:middleecho 这是中间标签goto start:endecho 这是结束标签\ncall 语句\n@echo offcall :subroutine &quot;Hello World&quot;goto end:subroutineecho 接收到的参数: %1exit /b  :: 返回主程序:endecho 主程序结束\n高级概念\n延迟变量扩展\n延迟变量扩展允许在代码块中更新和使用变量：\n@echo offsetlocal enabledelayedexpansionset count=0for %%i in (*.txt) do (    set /a count+=1    echo !count!: %%i  :: 使用!而非%来访问延迟扩展变量)echo 总共有 !count! 个txt文件endlocal\n错误处理\n@echo off:: 检查命令执行结果copy file1.txt file2.txtif %ERRORLEVEL% equ 0 (    echo 复制成功) else (    echo 复制失败，错误代码: %ERRORLEVEL%):: 使用条件执行符号copy file1.txt file2.txt &amp;&amp; echo 复制成功 || echo 复制失败:: 设置错误级别@echo offif &quot;%1&quot;==&quot;&quot; (    echo 参数缺失    exit /b 1  :: 设置错误级别为1)echo 参数: %1exit /b 0  :: 设置错误级别为0\n环境变量操作\n@echo off:: 显示所有环境变量set:: 设置临时环境变量set temp_var=临时值echo %temp_var%:: 永久设置环境变量（需要管理员权限）setx permanent_var &quot;永久值&quot;:: 读取注册表中的环境变量for /f &quot;skip=2 tokens=3*&quot; %%a in (&#x27;reg query &quot;HKCU\\Environment&quot; /v PATH&#x27;) do (    echo 当前用户PATH: %%a %%b)\n数组\n虽然批处理不直接支持数组，但可以模拟数组功能：\n@echo offsetlocal enabledelayedexpansion:: 定义数组set arr[0]=第一个元素set arr[1]=第二个元素set arr[2]=第三个元素:: 访问数组元素echo %arr[0]%echo %arr[1]%echo %arr[2]%:: 遍历数组for /l %%i in (0,1,2) do (    echo !arr[%%i]!):: 获取数组长度set &quot;array_length=0&quot;:count_loopif defined arr[%array_length%] (    set /a array_length+=1    goto count_loop)echo 数组长度: %array_length%endlocal\n字符串操作\n@echo offsetlocal enabledelayedexpansion:: 字符串连接set str1=Helloset str2=Worldset combined=%str1% %str2%echo %combined%:: 字符串长度set test_str=This is a test stringset &quot;len=0&quot;:len_loopif &quot;!test_str:~%len%!&quot; neq &quot;&quot; (    set /a len+=1    goto len_loop)echo 字符串长度: %len%:: 字符串截取set full_str=Hello Worldecho 前5个字符: %full_str:~0,5%echo 从第6个字符开始: %full_str:~5%echo 最后5个字符: %full_str:~-5%:: 字符串替换set original=Hello Worldset replaced=%original:World=Batch%echo %replaced%endlocal\n实用脚本示例\n文件备份脚本\n@echo offsetlocal enabledelayedexpansion:: 设置备份参数set &quot;source=C:\\Data&quot;set &quot;backup_root=D:\\Backup&quot;set &quot;backup_folder=%backup_root%\\%DATE:/=-%_%TIME::=-%&quot;set &quot;log_file=%backup_root%\\backup.log&quot;:: 创建备份目录mkdir &quot;%backup_folder%&quot; &gt;nul 2&gt;&amp;1:: 开始备份echo ======================================== &gt;&gt; &quot;%log_file%&quot;echo 备份开始: %DATE% %TIME% &gt;&gt; &quot;%log_file%&quot;echo 源目录: %source% &gt;&gt; &quot;%log_file%&quot;echo 备份目录: %backup_folder% &gt;&gt; &quot;%log_file%&quot;:: 执行备份xcopy &quot;%source%&quot; &quot;%backup_folder%&quot; /E /H /R /Y /Z &gt;&gt; &quot;%log_file%&quot; 2&gt;&amp;1:: 检查备份结果if %ERRORLEVEL% equ 0 (    echo 备份成功完成 &gt;&gt; &quot;%log_file%&quot;    echo 备份文件已保存到: %backup_folder%    echo 日志文件: %log_file%) else (    echo 备份失败 &gt;&gt; &quot;%log_file%&quot;    echo 备份过程中发生错误，请查看日志文件: %log_file%    exit /b 1)echo 备份结束: %DATE% %TIME% &gt;&gt; &quot;%log_file%&quot;echo ======================================== &gt;&gt; &quot;%log_file%&quot;:: 清理旧备份（保留最近7天）forfiles /p &quot;%backup_root%&quot; /s /m * /d -7 /c &quot;cmd /c if @isdir==TRUE rmdir /s /q @path&quot; &gt;&gt; &quot;%log_file%&quot; 2&gt;&amp;1endlocalpause\n系统信息收集脚本\n@echo offsetlocal enabledelayedexpansionset &quot;report_file=system_info_%DATE:/=-%_%TIME::=-%.txt&quot;:: 收集系统信息echo 系统信息报告 &gt; &quot;%report_file%&quot;echo ======================== &gt;&gt; &quot;%report_file%&quot;echo 生成时间: %DATE% %TIME% &gt;&gt; &quot;%report_file%&quot;echo ======================== &gt;&gt; &quot;%report_file%&quot;echo. &gt;&gt; &quot;%report_file%&quot;echo 【操作系统信息】 &gt;&gt; &quot;%report_file%&quot;ver &gt;&gt; &quot;%report_file%&quot;echo 操作系统: %OS% &gt;&gt; &quot;%report_file%&quot;echo 系统目录: %SystemRoot% &gt;&gt; &quot;%report_file%&quot;echo. &gt;&gt; &quot;%report_file%&quot;echo 【硬件信息】 &gt;&gt; &quot;%report_file%&quot;echo 计算机名称: %COMPUTERNAME% &gt;&gt; &quot;%report_file%&quot;echo 处理器架构: %PROCESSOR_ARCHITECTURE% &gt;&gt; &quot;%report_file%&quot;echo 处理器型号: %PROCESSOR_IDENTFIER% &gt;&gt; &quot;%report_file%&quot;echo 处理器数量: %NUMBER_OF_PROCESSORS% &gt;&gt; &quot;%report_file%&quot;echo. &gt;&gt; &quot;%report_file%&quot;echo 【内存信息】 &gt;&gt; &quot;%report_file%&quot;systeminfo | findstr /C:&quot;Total Physical Memory&quot; &gt;&gt; &quot;%report_file%&quot;systeminfo | findstr /C:&quot;Available Physical Memory&quot; &gt;&gt; &quot;%report_file%&quot;echo. &gt;&gt; &quot;%report_file%&quot;echo 【磁盘信息】 &gt;&gt; &quot;%report_file%&quot;wmic logicaldisk get caption,size,freespace &gt;&gt; &quot;%report_file%&quot;echo. &gt;&gt; &quot;%report_file%&quot;echo 【用户信息】 &gt;&gt; &quot;%report_file%&quot;echo 当前用户: %USERNAME% &gt;&gt; &quot;%report_file%&quot;echo 用户域: %USERDOMAIN% &gt;&gt; &quot;%report_file%&quot;echo 用户配置文件: %USERPROFILE% &gt;&gt; &quot;%report_file%&quot;echo. &gt;&gt; &quot;%report_file%&quot;echo 【网络信息】 &gt;&gt; &quot;%report_file%&quot;ipconfig /all | findstr /C:&quot;IPv4 Address&quot; /C:&quot;Subnet Mask&quot; /C:&quot;Default Gateway&quot; &gt;&gt; &quot;%report_file%&quot;echo. &gt;&gt; &quot;%report_file%&quot;echo 【环境变量】 &gt;&gt; &quot;%report_file%&quot;echo PATH: %PATH% &gt;&gt; &quot;%report_file%&quot;echo. &gt;&gt; &quot;%report_file%&quot;echo 报告已生成: %report_file%start notepad &quot;%report_file%&quot;endlocalpause\n文件批量重命名脚本\n@echo offsetlocal enabledelayedexpansionif &quot;%1&quot;==&quot;&quot; (    echo 用法: %0 [文件类型] [前缀]    echo 示例: %0 .txt &quot;文档_&quot;    exit /b 1)set &quot;file_type=%1&quot;set &quot;prefix=%2&quot;set &quot;count=1&quot;echo 开始重命名%file_type%文件...echo 前缀: %prefix%for /f &quot;delims=&quot; %%f in (&#x27;dir /b /a-d /o:n *%file_type%&#x27;) do (    set &quot;extension=%%~xf&quot;    set &quot;new_name=%prefix%!count!!extension!&quot;        echo &quot;%%f&quot; -^&gt; &quot;!new_name!&quot;    ren &quot;%%f&quot; &quot;!new_name!&quot;        set /a count+=1)echo 重命名完成，共处理了 %count% 个文件endlocalpause\n批量文件处理脚本\n@echo offsetlocal enabledelayedexpansion:: 检查参数if &quot;%1&quot;==&quot;&quot; (    echo 用法: %0 [源目录] [目标目录]    exit /b 1)set &quot;source_dir=%1&quot;set &quot;dest_dir=%2&quot;:: 创建目标目录if not exist &quot;%dest_dir%&quot; (    mkdir &quot;%dest_dir%&quot;    echo 创建目标目录: %dest_dir%):: 处理所有txt文件set &quot;count=0&quot;for /r &quot;%source_dir%&quot; %%f in (*.txt) do (    set /a count+=1        :: 获取文件名和路径    set &quot;file_name=%%~nxf&quot;    set &quot;file_path=%%~dpFf&quot;        :: 复制文件    copy &quot;%%f&quot; &quot;%dest_dir%\\!file_name!&quot; &gt;nul        :: 显示进度    echo 处理文件 !count!: !file_name!)echo 处理完成，共复制了 %count% 个文件endlocalpause\n这个完整的批处理脚本教程涵盖了从基础概念到高级技巧的所有内容，包括特殊变量扩展、参数处理、控制结构和实用脚本示例。掌握这些知识可以帮助你创建强大的自动化脚本，提高工作效率。\n","categories":["操作系统"],"tags":["windows"]},{"title":"文法与语言","url":"/2025/10/20/compiler_principle/%E6%96%87%E6%B3%95%E4%B8%8E%E8%AF%AD%E8%A8%80/","content":"\n编译原理文法语言的相关概念\n\n\n文法与语言\n2.1 引言：文法的“编译角色”\n文法是编译过程“语法分析阶段”的形式化工具，核心作用是将“自然语言式的语法规则”转化为“机器可推导的严格规则”。\n\n\n编译流程中，词法分析处理“正则文法（3型）”（描述标识符、关键字等词法单元的模式）；语法分析处理“上下文无关文法（2型）”（描述表达式、语句等语法结构）。\n\n\n程序设计语言需“无歧义”：若语法存在歧义（如“id+id*id有两种解释”），编译器无法确定代码的逻辑结构，因此必须用“形式化文法”严格约束语法。\n\n\n2.2 字母表-符号串-运算（形式语言基础）\n这是“用数学符号描述语言”的底层逻辑，需明确集合、序列、运算的形式化定义：\n（1）字母表（Σ）\n\n\n定义：非空有限的符号集合。例：Σ₁ = {0, 1}（二进制字母表）；Σ₂ = {a, b, ..., z}（小写字母表）；Σ₃ = {id, +, *, (, )}（某算术表达式的终结符集合）。\n\n\n（2）符号串（String）\n\n\n定义：设Σ为字母表，符号串x是Σ中符号的有限序列。\n\n长度：|x|表示符号串的符号个数。例：x = abc，则|x| = 3；\n空串：ε（长度为0的符号串，|ε| = 0）。\n\n\n\n（3）符号串的运算\n\n\n连接（Concatenation）：若x = &quot;ab&quot;，y = &quot;cd&quot;，则x·y = &quot;abcd&quot;（简记为xy）。性质：不满足交换律（xy ≠ yx，除非x=y或特殊构造）。\n\n\n幂（Power）：\n\nx⁰ = ε（空串）；\nx¹ = x；\nxⁿ = xⁿ⁻¹ · x（递归定义，例：x=&quot;ab&quot;，则x²=&quot;abab&quot;）。\n\n\n\n闭包（Closure）：\n\n星闭包（Σ*）：Σ中符号组成的**所有可能的符号串（含空串ε）**的集合。例：Σ = {a, b}，则Σ* = {ε, a, b, aa, ab, ba, bb, aaa, ...}。\n正闭包（Σ+）：Σ中符号组成的所有非空符号串的集合（即Σ* - {ε}）。例：Σ = {a, b}，则Σ+ = {a, b, aa, ab, ba, bb, ...}。\n\n\n\n2.3 文法模型★（形式化四元组）\n文法是描述语言语法的四元组 G = (VN, VT, P, S)，各组件需结合“算术表达式文法”实例理解：\n（1）非终结符（VN：Non-terminal Symbols）\n\n\n定义：语法变量，表示“语法范畴/中间推导结果”，最终不会出现在“语言的句子”中。\n\n\n例：描述“算术表达式”的文法中，V_N = {E, T, F}（E表示“表达式”，T表示“项”，F表示“因子”）。\n\n\n（2）终结符（VT：Terminal Symbols）\n\n\n定义：语法的最小单位，是语言的“最终符号”，无法再被推导分解。\n\n\n例：算术表达式文法中，V_T = {id, +, *, (, )}（id为标识符，+/*为运算符，()为括号）。\n\n\n（3）产生式（P：Productions）\n\n\n形式：α → β（读作“α定义为β”），表示“用β替换α”。\n\nα（左部）：至少包含一个非终结符（否则无法推导）；\nβ（右部）：可由“终结符、非终结符的任意组合”或空串ε组成。\n\n\n\n例：算术表达式的核心产生式：\n\nE → E + T（“表达式可以是‘表达式 + 项’”）；\nT → T * F（“项可以是‘项 * 因子’”）；\nF → (E)（“因子可以是‘括号中的表达式’”）；\nF → id（“因子可以是‘标识符’”）。\n\n\n\n（4）开始符号（S：Start Symbol）\n\n\n定义：V_N中指定的“起始语法变量”，所有推导从S开始。\n\n\n例：算术表达式文法中，S = E（推导从“表达式E”开始）。\n\n\n2.4 推导与句型（文法的“动态推导过程”）\n推导是“从开始符号出发，用产生式逐步替换非终结符”的过程；句型和句子是推导的“中间/最终结果”，需用推导符号（⇒、⇒*、⇒+）形式化描述：\n（1）推导符号\n\n\nα ⇒ β：一步推导（用一条产生式，将α中的某部分替换为β）；\n\n\nα ⇒* β：零步或多步推导（α可直接等于β，或经若干步推导得到β）；\n\n\nα ⇒+ β：一步或多步推导（α经至少一步推导得到β）。\n\n\n（2）推导类型\n\n\n最左推导：每次优先替换“最左侧”的非终结符；\n\n\n最右推导（规范推导）：每次优先替换“最右侧”的非终结符（编译中“语法分析”的核心方式，对应“规范归约”）。\n\n\n（3）句型与句子\n\n\n句型：若S ⇒* α且α ∈ (V_N ∪ V_T)*（α含终结符或非终结符），则α是句型；\n\n\n句子：若S ⇒* α且α ∈ V_T*（α仅含终结符），则α是句子（语言的“合法最终形式”）。\n\n\n实例：算术表达式的最左推导\n文法：E → E+T | T；T → T*F | F；F → (E) | id。推导句子id+id*id的最左推导过程：\n\n\nE ⇒ E+T（用E→E+T，替换最左的E）；\n\n\nT+T ⇒ F+T（用T→F，替换最左的T）；\n\n\nid+T ⇒ id+T*F（用T→T*F，替换最左的T）；\n\n\nid+F*F ⇒ id+id*F（用F→id，替换最左的F）；\n\n\nid+id*id（用F→id，替换最左的F）。\n\n\n\n\n中间结果如E+T、T+T、id+T、id+T*F、id+F*F、id+id*F都是句型（含非终结符）；\n\n\n最终结果id+id*id是句子（仅含终结符）。\n\n\n2.5 文法的类型（乔姆斯基分类）\n乔姆斯基将文法分为4类（限制逐渐严格，呈“包含关系：3型 ⊂ 2型 ⊂ 1型 ⊂ 0型”），核心区别是“产生式的限制规则”，需结合自动机、语言类型联动理解：\n\n\n\n文法类型\n别称\n产生式限制\n生成的语言\n对应自动机\n编译中的应用\n\n\n\n\n0型（无限制）\n短语结构文法（PSG）\nα→β，其中α至少含一个非终结符，β为(V_N∪V_T)*中任意串（可含ε）\n递归可枚举语言\n图灵机\n理论基础，无直接编译应用\n\n\n1型（上下文有关）\n上下文有关文法（CSG）\nα→β满足`\nα\n≤\nβ\n\n\n2型（上下文无关）\n上下文无关文法（CFG）\n产生式左部为单个非终结符（即A→β，A∈V_N，β∈(V_N∪V_T)*）\n上下文无关语言\n下推自动机（PDA）\n描述程序设计语言的语法核心（如表达式、语句、函数定义）\n\n\n3型（正则文法）\n正则文法（RG）\n产生式为左线性（A→Ba 或 A→a）或右线性（A→aB 或 A→a），其中A,B∈V_N，a∈V_T∪{ε} 右侧最多一个非终结符且必须在最左或最右\n正则语言\n有限自动机（FA）\n描述词法规则（如标识符、关键字、常数的模式）\n\n\n\n2.6 文法的构造与简化★\n（1）文法构造：“自然语言→产生式”的转化\n需将“语法规则的自然描述”转化为“形式化产生式”，核心是设计非终结符同步语法结构。\n\n\n例1：构造语言 L = {aⁿbⁿ | n≥1}（“n个a后跟n个b”的所有串）的文法。思路：用非终结符S同步a和b的数量，产生式需保证“每生成一个a，就对应生成一个b”。文法：G = ({S}, {a, b}, {S→aSb | ab}, S)。推导验证：n=1时，S⇒ab；n=2时，S⇒aSb⇒aabbb，符合aⁿbⁿ。\n\n\n例2：构造“以字母开头，后跟字母或数字”的标识符文法。思路：用I表示“标识符”，L表示“字母”，D表示“数字”，通过产生式串联结构。文法：G = ({I, L, D}, {a,...,z,0,...,9}, {I→LI | L, L→LI | LD | L | D}, I)（L可推导为字母或数字，I以L开头，后跟L或D）。\n\n\n（2）文法简化：消除冗余，便于分析\n需消除无用符号、ε产生式、单产生式，使文法更简洁。\n\n\n消除无用符号：无用符号包括“不可达符号”（从S推导不出的符号）和“不可终止符号”（无法推导出终结符串的符号）。例：文法G = ({S, A, B, C}, {a, b}, {S→aA, A→bB, B→aA, C→aB}, S)。\n\n“不可达符号”：C（S无法推导出C），需删除含C的产生式；\n简化后文法：G' = ({S, A, B}, {a, b}, {S→aA, A→bB, B→aA}, S)。\n\n\n\n消除ε产生式：若产生式含A→ε（A非开始符号），需将其他产生式中A的出现替换为ε的可能。例：文法G = ({S, A}, {a, b}, {S→aA | ε, A→b | ε}, S)。\n\n因A→ε，S→aA可推导出S→a（当A→ε时）；\n简化后文法：G' = ({S, A}, {a, b}, {S→aA | a | ε, A→b}, S)。\n\n\n\n消除单产生式（形如A→B，A,B∈V_N）：需将A的产生式替换为B的所有“非单产生式”。例：文法G = ({S, A, B}, {a, b}, {S→A, A→B | a, B→b | A}, S)。\n\nS→A等价于S→B | a（因A→B | a）；\nA→B等价于A→b | a（因B→b | A，但A→A是无用循环，最终保留A→b | a）；\n简化后文法：G' = ({S, A, B}, {a, b}, {S→B | a, A→b | a, B→b | a}, S)。\n\n\n\n2.7 语法树（推导的“可视化表示”）\n语法树（推导树）是直观展示推导层次结构的树结构，各节点与文法组件一一对应：\n\n\n根节点：开始符号S；\n\n\n内部节点：非终结符（对应产生式左部）；\n\n\n叶节点：终结符或空串ε（对应产生式右部的符号）。\n\n\n实例：表达式id+id*id的语法树\n基于文法E→E+T | T；T→T*F | F；F→(E) | id，语法树结构为：\ngraph TD    E --&gt; E1[E]    E --&gt; op_plus[+]    E --&gt; T1[T]    E1 --&gt; T2[T]    T2 --&gt; F1[F]    F1 --&gt; id1[id]    T1 --&gt; T3[T]    T1 --&gt; op_mul[*]    T1 --&gt; F2[F]    T3 --&gt; F3[F]    F3 --&gt; id2[id]    F2 --&gt; id3[id]\n语法树的作用：\n\n\n直观展示“语法层次”（如“乘法先于加法”的结构）；\n\n\n判断文法二义性（若一个句子对应多棵语法树，文法是二义的）。\n\n\n2.8 文法的二义性（关键问题与解决）\n若一个文法存在某个句子有“多棵语法树”或“多种最左/最右推导”，则称该文法是二义的。\n（1）二义性实例：表达式文法\n文法G = ({E}, {id, +, *, (, )}, {E→E+E | E*E | (E) | id}, E)对句子id+id*id存在两种最左推导：\n\n\n推导1（先加后乘）：E ⇒ E+E ⇒ id+E ⇒ id+E*E ⇒ id+id*E ⇒ id+id*id。\n\n\n推导2（先乘后加）：E ⇒ E*E ⇒ E+E*E ⇒ id+E*E ⇒ id+id*E ⇒ id+id*id。\n\n\n对应的两棵语法树也不同，因此该文法是二义的。\n（2）消除二义性：改写文法（规定优先级/结合性）\n通过“分层产生式”让产生式隐含“运算符优先级/结合性”，从而消除歧义。\n例：规定“*优先级高于+，且均为左结合”，改写文法为：\nE → E+T | T       （`+`左结合，优先级低于`*`）T → T*F | F       （`*`左结合，优先级高于`+`）F → (E) | id      （最底层因子）\n此时，句子id+id*id的最左推导唯一：E ⇒ E+T ⇒ T+T ⇒ F+T ⇒ id+T ⇒ id+T*F ⇒ id+F*F ⇒ id+id*F ⇒ id+id*id，且仅对应一棵语法树，消除了二义性。\n","categories":["编译原理"]},{"title":"四元式:操作符与表示方法","url":"/2025/10/20/compiler_principle/%E5%9B%9B%E5%85%83%E5%BC%8F/","content":"\n四元式操作符的种类与对应表示方法\n\n\n四元式：操作符与表示方法\n四元式基本概念\n四元式是编译过程中使用的一种中间代码形式，它将代码分解为一系列基本操作，每个操作由四个部分组成：\n(操作符, 操作数1, 操作数2, 结果)\n这种结构类似于汇编语言，便于后续的代码优化和目标代码生成。\n四元式操作符分类\n1. 算术运算操作符\n用于执行基本的数学运算：\n\n\n\n操作符\n含义\n示例\n说明\n\n\n\n\n+\n加法\n(+, a, b, t1)\nt1 = a + b\n\n\n-\n减法\n(-, a, b, t1)\nt1 = a - b\n\n\n*\n乘法\n(*, a, b, t1)\nt1 = a * b\n\n\n/\n除法\n(/, a, b, t1)\nt1 = a / b\n\n\n%\n取模\n(%, a, b, t1)\nt1 = a % b\n\n\nU-\n一元负号\n(U-, a, null, t1)\nt1 = -a\n\n\n\n2. 关系运算操作符\n用于比较两个值，结果通常是布尔值（0或1）：\n\n\n\n操作符\n含义\n示例\n说明\n\n\n\n\n&gt;\n大于\n(&gt;, a, b, t1)\nt1 = (a &gt; b) ? 1 : 0\n\n\n&lt;\n小于\n(&lt;, a, b, t1)\nt1 = (a &lt; b) ? 1 : 0\n\n\n&gt;=\n大于等于\n(&gt;=, a, b, t1)\nt1 = (a &gt;= b) ? 1 : 0\n\n\n&lt;=\n小于等于\n(&lt;=, a, b, t1)\nt1 = (a &lt;= b) ? 1 : 0\n\n\n==\n等于\n(==, a, b, t1)\nt1 = (a == b) ? 1 : 0\n\n\n!=\n不等于\n(!=, a, b, t1)\nt1 = (a != b) ? 1 : 0\n\n\n\n3. 逻辑运算操作符\n用于执行布尔逻辑运算：\n\n\n\n操作符\n含义\n示例\n说明\n\n\n\n\n&amp;&amp;\n逻辑与\n(&amp;&amp;, a, b, t1)\nt1 = a &amp;&amp; b\n\n\n||\n逻辑或\n`(\n\n\n\n!\n逻辑非\n(!, a, null, t1)\nt1 = !a\n\n\n\n4. 赋值操作符\n用于将值赋给变量：\n\n\n\n操作符\n含义\n示例\n说明\n\n\n\n\n=\n赋值\n(=, a, null, b)\nb = a\n\n\n\n5. 控制流操作符\n用于控制程序的执行顺序：\n\n\n\n操作符\n含义\n示例\n说明\n\n\n\n\njmp\n无条件跳转\n(jmp, null, null, L1)\n跳转到标签L1\n\n\njnz\n非零跳转\n(jnz, a, null, L1)\n如果a≠0，跳转到L1\n\n\njz\n零跳转\n(jz, a, null, L1)\n如果a=0，跳转到L1\n\n\nje\n等于跳转\n(je, a, b, L1)\n如果a==b，跳转到L1\n\n\njne\n不等于跳转\n(jne, a, b, L1)\n如果a!=b，跳转到L1\n\n\njg\n大于跳转\n(jg, a, b, L1)\n如果a&gt;b，跳转到L1\n\n\njl\n小于跳转\n(jl, a, b, L1)\n如果a&lt;b，跳转到L1\n\n\njge\n大于等于跳转\n(jge, a, b, L1)\n如果a&gt;=b，跳转到L1\n\n\njle\n小于等于跳转\n(jle, a, b, L1)\n如果a&lt;=b，跳转到L1\n\n\n\n6. 函数调用操作符\n用于函数的调用和返回：\n\n\n\n操作符\n含义\n示例\n说明\n\n\n\n\nparam\n参数传递\n(param, a, null, null)\n将a作为参数传递\n\n\ncall\n函数调用\n(call, func, null, t1)\n调用函数func，结果存t1\n\n\nret\n返回\n(ret, a, null, null)\n从函数返回a的值\n\n\n\n7. 数组操作符\n用于数组元素的访问：\n\n\n\n操作符\n含义\n示例\n说明\n\n\n\n\n[]\n数组访问\n([], arr, i, t1)\nt1 = arr[i]\n\n\n[]=\n数组赋值\n([]=, arr, i, val)\narr[i] = val\n\n\n\n8. 其他操作符\n\n\n\n操作符\n含义\n示例\n说明\n\n\n\n\nlabel\n标签定义\n(label, null, null, L1)\n定义标签L1\n\n\nread\n读操作\n(read, null, null, a)\n从输入读取值到a\n\n\nwrite\n写操作\n(write, a, null, null)\n将a的值输出\n\n\n\n不同情况的表示方法示例\n1. 表达式计算\n对于表达式 x = (a + b) * c - d：\n(+, a, b, t1)      ; t1 = a + b(*, t1, c, t2)     ; t2 = t1 * c(-, t2, d, t3)     ; t3 = t2 - d(=, t3, null, x)   ; x = t3\n2. 条件语句\n对于 if (a &gt; b) then x = 1 else x = 0：\n(&gt;, a, b, t1)      ; t1 = (a &gt; b) ? 1 : 0(jz, t1, null, L1) ; 如果t1=0，跳转到L1(=, 1, null, x)    ; x = 1(jmp, null, null, L2) ; 跳转到L2(label, null, null, L1) ; 标签L1(=, 0, null, x)    ; x = 0(label, null, null, L2) ; 标签L2\n3. 循环语句\n对于 while (i &lt; 10) { i = i + 1; }：\n(label, null, null, L1) ; 循环开始标签(&lt;, i, 10, t1)     ; t1 = (i &lt; 10) ? 1 : 0(jz, t1, null, L2) ; 如果i&gt;=10，退出循环(+, i, 1, t2)      ; t2 = i + 1(=, t2, null, i)   ; i = t2(jmp, null, null, L1) ; 跳回循环开始(label, null, null, L2) ; 循环结束标签\n4. 函数调用\n对于 y = func(a, b)：\n(param, a, null, null) ; 传递第一个参数a(param, b, null, null) ; 传递第二个参数b(call, func, null, y)  ; 调用函数func，结果存到y\n","categories":["编译原理"]},{"title":"DOM&BOM对象的方法和属性","url":"/2025/10/19/web/DOM&BOM%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/","content":"\n如题，结合官方文档与网络帖子，利用AI整理\n\n\nDOM &amp; BOM 对象方法属性全面总结\nDOM（文档对象模型）\n概念介绍\nDOM (Document Object Model) 是浏览器把HTML或XML文档结构化成对象的方式，并提供了一套API让JavaScript去操作这些对象，从而动态控制网页内容、结构和样式。\n核心特点：\n\n\nDOM将文档表示为节点树结构\n\n\n每个节点都是一个对象，可以被JavaScript访问和修改\n\n\nDOM不是JavaScript语言的一部分，而是浏览器提供的Web API\n\n\n支持跨平台和跨语言访问\n\n\nDocument对象\n概念：代表整个HTML文档，是DOM树的根节点\n常用属性\n\n\n\n属性名\n说明\n\n\n\n\ndocument.documentElement\n获取&lt;html&gt;元素\n\n\ndocument.body\n获取&lt;body&gt;元素\n\n\ndocument.head\n获取&lt;head&gt;元素\n\n\ndocument.title\n获取或设置文档标题\n\n\ndocument.URL\n获取当前文档的URL\n\n\ndocument.domain\n获取文档的域名\n\n\ndocument.cookie\n获取或设置cookie\n\n\ndocument.referrer\n获取引用页面的URL\n\n\ndocument.characterSet\n获取文档的字符编码\n\n\ndocument.readyState\n获取文档的加载状态\n\n\ndocument.doctype\n获取文档类型声明\n\n\ndocument.activeElement\n获取当前获得焦点的元素\n\n\ndocument.hidden\n获取文档是否隐藏\n\n\ndocument.visibilityState\n获取文档的可见性状态\n\n\n\n常用方法\n\n\n\n方法名\n说明\n\n\n\n\ngetElementById(id)\n通过ID获取元素\n\n\ngetElementsByClassName(className)\n通过类名获取元素集合\n\n\ngetElementsByTagName(tagName)\n通过标签名获取元素集合\n\n\nquerySelector(selector)\n通过CSS选择器获取第一个匹配元素\n\n\nquerySelectorAll(selector)\n通过CSS选择器获取所有匹配元素\n\n\ncreateElement(tagName)\n创建新的元素节点\n\n\ncreateTextNode(text)\n创建新的文本节点\n\n\ncreateDocumentFragment()\n创建文档片段\n\n\nwrite(content)\n向文档写入内容\n\n\nopen()\n打开文档以便写入\n\n\nclose()\n关闭文档写入\n\n\naddEventListener(eventName, listener)\n添加事件监听器\n\n\nremoveEventListener(eventName, listener)\n移除事件监听器\n\n\ndispatchEvent(event)\n派发事件\n\n\n\nElement对象\n概念：代表HTML元素，是DOM树中的元素节点\n常用属性\n\n\n\n属性名\n说明\n\n\n\n\nelement.id\n获取或设置元素的ID\n\n\nelement.className\n获取或设置元素的类名\n\n\nelement.classList\n获取元素的类列表对象\n\n\nelement.style\n获取元素的内联样式对象\n\n\nelement.innerHTML\n获取或设置元素的HTML内容\n\n\nelement.textContent\n获取或设置元素的文本内容\n\n\nelement.attributes\n获取元素的所有属性\n\n\nelement.parentElement\n获取父元素\n\n\nelement.children\n获取子元素集合\n\n\nelement.firstElementChild\n获取第一个子元素\n\n\nelement.lastElementChild\n获取最后一个子元素\n\n\nelement.previousElementSibling\n获取前一个兄弟元素\n\n\nelement.nextElementSibling\n获取后一个兄弟元素\n\n\nelement.offsetTop\n获取元素相对于offsetParent的顶部偏移\n\n\nelement.offsetLeft\n获取元素相对于offsetParent的左侧偏移\n\n\nelement.offsetWidth\n获取元素的宽度（包括边框和内边距）\n\n\nelement.offsetHeight\n获取元素的高度（包括边框和内边距）\n\n\nelement.clientWidth\n获取元素的内容宽度（不包括边框）\n\n\nelement.clientHeight\n获取元素的内容高度（不包括边框）\n\n\nelement.scrollTop\n获取或设置元素的垂直滚动位置\n\n\nelement.scrollLeft\n获取或设置元素的水平滚动位置\n\n\nelement.scrollWidth\n获取元素的总宽度（包括不可见部分）\n\n\nelement.scrollHeight\n获取元素的总高度（包括不可见部分）\n\n\nelement.dataset\n获取元素的自定义数据属性\n\n\n\n常用方法\n\n\n\n方法名\n说明\n\n\n\n\nsetAttribute(name, value)\n设置元素属性\n\n\ngetAttribute(name)\n获取元素属性值\n\n\nremoveAttribute(name)\n移除元素属性\n\n\nhasAttribute(name)\n检查元素是否有指定属性\n\n\nappendChild(child)\n添加子元素到末尾\n\n\ninsertBefore(newChild, refChild)\n在指定位置插入子元素\n\n\nremoveChild(child)\n移除子元素\n\n\nreplaceChild(newChild, oldChild)\n替换子元素\n\n\ncloneNode(deep)\n克隆元素节点\n\n\ncontains(node)\n检查元素是否包含指定节点\n\n\nscrollIntoView(behavior)\n滚动到视图中\n\n\nfocus()\n使元素获得焦点\n\n\nblur()\n使元素失去焦点\n\n\nclick()\n模拟点击元素\n\n\nclassList.add(className)\n添加类名\n\n\nclassList.remove(className)\n移除类名\n\n\nclassList.toggle(className)\n切换类名\n\n\nclassList.contains(className)\n检查是否有类名\n\n\n\nNode对象\n概念：DOM树中的所有节点都继承自Node接口\n节点类型\n\n\n\n节点类型\n值\n说明\n\n\n\n\nELEMENT_NODE\n1\n元素节点\n\n\nTEXT_NODE\n3\n文本节点\n\n\nCOMMENT_NODE\n8\n注释节点\n\n\nDOCUMENT_NODE\n9\n文档节点\n\n\nDOCUMENT_TYPE_NODE\n10\n文档类型节点\n\n\nDOCUMENT_FRAGMENT_NODE\n11\n文档片段节点\n\n\n\n常用属性\n\n\n\n属性名\n说明\n\n\n\n\nnodeType\n节点类型\n\n\nnodeName\n节点名称\n\n\nnodeValue\n节点值\n\n\nparentNode\n父节点\n\n\nchildNodes\n子节点集合\n\n\nfirstChild\n第一个子节点\n\n\nlastChild\n最后一个子节点\n\n\npreviousSibling\n前一个兄弟节点\n\n\nnextSibling\n后一个兄弟节点\n\n\nownerDocument\n所属文档\n\n\ntextContent\n文本内容\n\n\n\n常用方法\n\n\n\n方法名\n说明\n\n\n\n\nappendChild(child)\n添加子节点\n\n\ninsertBefore(newChild, refChild)\n插入子节点\n\n\nremoveChild(child)\n移除子节点\n\n\nreplaceChild(newChild, oldChild)\n替换子节点\n\n\ncloneNode(deep)\n克隆节点\n\n\nnormalize()\n规范化节点\n\n\nisEqualNode(node)\n检查节点是否相等\n\n\ncontains(node)\n检查是否包含节点\n\n\nhasChildNodes()\n检查是否有子节点\n\n\n\nDOM事件处理\n事件级别\n\n\nDOM0级事件：直接通过元素属性绑定\n\n\nDOM2级事件：使用addEventListener，支持事件捕获和冒泡\n\n\nDOM3级事件：扩展了事件类型，增加了更多事件接口\n\n\n事件流阶段\n\n\n捕获阶段：事件从文档根节点向下传播到目标元素\n\n\n目标阶段：事件到达目标元素\n\n\n冒泡阶段：事件从目标元素向上传播到文档根节点\n\n\n常用事件方法\n\n\n\n方法名\n说明\n\n\n\n\naddEventListener(type, listener, useCapture)\n添加事件监听器\n\n\nremoveEventListener(type, listener, useCapture)\n移除事件监听器\n\n\ndispatchEvent(event)\n派发事件\n\n\npreventDefault()\n阻止事件默认行为\n\n\nstopPropagation()\n阻止事件传播\n\n\nstopImmediatePropagation()\n立即阻止事件传播\n\n\n\n常见事件类型\n鼠标事件：\n\n\nclick - 鼠标点击\n\n\ndblclick - 鼠标双击\n\n\nmousedown - 鼠标按下\n\n\nmouseup - 鼠标释放\n\n\nmouseover - 鼠标悬停\n\n\nmouseout - 鼠标离开\n\n\nmousemove - 鼠标移动\n\n\nmouseenter - 鼠标进入\n\n\nmouseleave - 鼠标离开\n\n\n键盘事件：\n\n\nkeydown - 键盘按下\n\n\nkeyup - 键盘释放\n\n\ninput - 输入事件\n\n\n表单事件：\n\n\nsubmit - 表单提交\n\n\nreset - 表单重置\n\n\nchange - 值改变\n\n\nfocus - 获得焦点\n\n\nblur - 失去焦点\n\n\n文档事件：\n\n\nload - 页面加载完成\n\n\nunload - 页面卸载\n\n\nbeforeunload - 页面即将卸载\n\n\nDOMContentLoaded - DOM加载完成\n\n\nresize - 窗口大小改变\n\n\nscroll - 页面滚动\n\n\nBOM（浏览器对象模型）\n概念介绍\nBOM (Browser Object Model) 是浏览器对象模型，提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的window对象是BOM的顶层对象。\n核心特点：\n\n\nBOM没有正式的标准，但所有浏览器都支持基本的对象和方法\n\n\nwindow对象是BOM的核心，也是JavaScript的全局对象\n\n\n提供了操作浏览器窗口、导航、历史记录等功能\n\n\n包含DOM的document对象作为其子对象\n\n\nWindow对象\n概念：代表浏览器窗口，是BOM的顶层对象\n常用属性\n\n\n\n属性名\n说明\n\n\n\n\nwindow.innerWidth\n视口宽度\n\n\nwindow.innerHeight\n视口高度\n\n\nwindow.outerWidth\n浏览器窗口宽度\n\n\nwindow.outerHeight\n浏览器窗口高度\n\n\nwindow.scrollX\n水平滚动距离\n\n\nwindow.scrollY\n垂直滚动距离\n\n\nwindow.screenX\n窗口相对于屏幕的X坐标\n\n\nwindow.screenY\n窗口相对于屏幕的Y坐标\n\n\nwindow.closed\n检查窗口是否关闭\n\n\nwindow.frames\n获取窗口中的框架集合\n\n\nwindow.parent\n获取父窗口\n\n\nwindow.top\n获取顶级窗口\n\n\nwindow.self\n获取当前窗口\n\n\nwindow.name\n获取或设置窗口名称\n\n\nwindow.location\n获取位置对象\n\n\nwindow.history\n获取历史对象\n\n\nwindow.navigator\n获取导航对象\n\n\nwindow.screen\n获取屏幕对象\n\n\nwindow.document\n获取文档对象\n\n\nwindow.localStorage\n获取本地存储\n\n\nwindow.sessionStorage\n获取会话存储\n\n\nwindow.console\n获取控制台对象\n\n\n\n常用方法\n\n\n\n方法名\n说明\n\n\n\n\nalert(message)\n显示警告框\n\n\nconfirm(message)\n显示确认框\n\n\nprompt(message, defaultText)\n显示输入框\n\n\nopen(url, name, features)\n打开新窗口\n\n\nclose()\n关闭窗口\n\n\nfocus()\n使窗口获得焦点\n\n\nblur()\n使窗口失去焦点\n\n\nprint()\n打印窗口内容\n\n\nscrollTo(x, y)\n滚动到指定位置\n\n\nscrollBy(x, y)\n相对滚动\n\n\nresizeTo(width, height)\n调整窗口大小\n\n\nresizeBy(width, height)\n相对调整窗口大小\n\n\nsetTimeout(callback, delay)\n设置超时器\n\n\nsetInterval(callback, interval)\n设置定时器\n\n\nclearTimeout(timeoutId)\n清除超时器\n\n\nclearInterval(intervalId)\n清除定时器\n\n\nrequestAnimationFrame(callback)\n请求动画帧\n\n\ncancelAnimationFrame(requestId)\n取消动画帧\n\n\nbtoa(string)\nBase64编码\n\n\natob(string)\nBase64解码\n\n\nencodeURI(uri)\n编码URI\n\n\ndecodeURI(uri)\n解码URI\n\n\nencodeURIComponent(uriComponent)\n编码URI组件\n\n\ndecodeURIComponent(uriComponent)\n解码URI组件\n\n\n\nLocation对象\n概念：包含有关当前URL的信息\n常用属性\n\n\n\n属性名\n说明\n\n\n\n\nlocation.href\n完整URL\n\n\nlocation.protocol\n协议（http:或https:）\n\n\nlocation.host\n主机名和端口\n\n\nlocation.hostname\n主机名\n\n\nlocation.port\n端口号\n\n\nlocation.pathname\n路径部分\n\n\nlocation.search\n查询字符串\n\n\nlocation.hash\n哈希值\n\n\nlocation.origin\n源（协议+主机名+端口）\n\n\n\n常用方法\n\n\n\n方法名\n说明\n\n\n\n\nassign(url)\n跳转到指定URL\n\n\nreplace(url)\n替换当前URL\n\n\nreload(forceGet)\n重新加载页面\n\n\ntoString()\n返回完整URL字符串\n\n\n\nHistory对象\n概念：包含浏览器的历史记录\n常用属性\n\n\n\n属性名\n说明\n\n\n\n\nhistory.length\n历史记录数量\n\n\nhistory.state\n当前历史状态\n\n\nhistory.scrollRestoration\n滚动恢复模式\n\n\n\n常用方法\n\n\n\n方法名\n说明\n\n\n\n\nback()\n返回上一页\n\n\nforward()\n前进到下一页\n\n\ngo(delta)\n跳转到指定页面\n\n\npushState(state, title, url)\n添加历史记录\n\n\nreplaceState(state, title, url)\n替换当前历史记录\n\n\n\nNavigator对象\n概念：包含浏览器的相关信息\n常用属性\n\n\n\n属性名\n说明\n\n\n\n\nnavigator.userAgent\n用户代理字符串\n\n\nnavigator.appName\n浏览器名称\n\n\nnavigator.appVersion\n浏览器版本\n\n\nnavigator.platform\n操作系统平台\n\n\nnavigator.language\n浏览器语言\n\n\nnavigator.onLine\n是否在线\n\n\nnavigator.cookieEnabled\n是否启用cookie\n\n\nnavigator.geolocation\n地理位置接口\n\n\nnavigator.mediaDevices\n媒体设备接口\n\n\nnavigator.hardwareConcurrency\nCPU核心数\n\n\nnavigator.deviceMemory\n设备内存\n\n\n\nScreen对象\n概念：包含屏幕的相关信息\n常用属性\n\n\n\n属性名\n说明\n\n\n\n\nscreen.width\n屏幕宽度\n\n\nscreen.height\n屏幕高度\n\n\nscreen.availWidth\n可用屏幕宽度\n\n\nscreen.availHeight\n可用屏幕高度\n\n\nscreen.colorDepth\n颜色深度\n\n\nscreen.pixelDepth\n像素深度\n\n\nscreen.orientation\n屏幕方向\n\n\n\nStorage对象\n概念：提供本地存储功能\n存储类型\n\n\nlocalStorage：永久存储，无过期时间，容量约5MB\n\n\nsessionStorage：会话存储，关闭页面后清除，容量约5MB\n\n\n常用方法\n\n\n\n方法名\n说明\n\n\n\n\nsetItem(key, value)\n设置存储项\n\n\ngetItem(key)\n获取存储项\n\n\nremoveItem(key)\n移除存储项\n\n\nclear()\n清除所有存储项\n\n\nkey(index)\n获取指定索引的键名\n\n\n\n实际使用示例\nDOM操作示例\n元素选择和操作\n// 获取元素const element = document.getElementById(&#x27;myElement&#x27;);const elements = document.querySelectorAll(&#x27;.myClass&#x27;);const firstDiv = document.querySelector(&#x27;div&#x27;);// 修改内容element.textContent = &#x27;新的文本内容&#x27;;element.innerHTML = &#x27;&lt;strong&gt;加粗文本&lt;/strong&gt;&#x27;;// 修改样式element.style.color = &#x27;red&#x27;;element.style.fontSize = &#x27;16px&#x27;;element.classList.add(&#x27;active&#x27;);element.classList.remove(&#x27;inactive&#x27;);element.classList.toggle(&#x27;visible&#x27;);// 修改属性element.setAttribute(&#x27;src&#x27;, &#x27;image.jpg&#x27;);element.getAttribute(&#x27;href&#x27;);element.removeAttribute(&#x27;disabled&#x27;);\n创建和插入元素\n// 创建元素const newDiv = document.createElement(&#x27;div&#x27;);newDiv.textContent = &#x27;新创建的元素&#x27;;newDiv.className = &#x27;new-element&#x27;;// 插入元素const container = document.getElementById(&#x27;container&#x27;);container.appendChild(newDiv);// 在指定位置插入const referenceElement = document.getElementById(&#x27;reference&#x27;);container.insertBefore(newDiv, referenceElement);// 使用文档片段批量插入const fragment = document.createDocumentFragment();for (let i = 0; i &lt; 10; i++) &#123;    const item = document.createElement(&#x27;div&#x27;);    item.textContent = `项目 $&#123;i + 1&#125;`;    fragment.appendChild(item);&#125;container.appendChild(fragment);\n事件处理\n// DOM0级事件const button = document.getElementById(&#x27;myButton&#x27;);button.onclick = function() &#123;    alert(&#x27;按钮被点击了！&#x27;);&#125;;// DOM2级事件button.addEventListener(&#x27;click&#x27;, function(event) &#123;    console.log(&#x27;事件类型:&#x27;, event.type);    console.log(&#x27;目标元素:&#x27;, event.target);        // 阻止默认行为    event.preventDefault();        // 阻止事件传播    event.stopPropagation();&#125;);// 事件委托document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, function(event) &#123;    if (event.target.tagName === &#x27;LI&#x27;) &#123;        console.log(&#x27;列表项被点击:&#x27;, event.target.textContent);    &#125;&#125;);\nBOM操作示例\n窗口操作\n// 窗口信息console.log(&#x27;窗口宽度:&#x27;, window.innerWidth);console.log(&#x27;窗口高度:&#x27;, window.innerHeight);console.log(&#x27;滚动位置:&#x27;, window.scrollX, window.scrollY);// 滚动操作window.scrollTo(0, 100); // 滚动到指定位置window.scrollBy(0, 50);  // 相对滚动window.scrollTo(&#123;    top: 100,    left: 0,    behavior: &#x27;smooth&#x27; // 平滑滚动&#125;);// 弹出框alert(&#x27;这是一个警告框&#x27;);const result = confirm(&#x27;确定要删除吗？&#x27;);const name = prompt(&#x27;请输入您的姓名:&#x27;, &#x27;张三&#x27;);// 打开和关闭窗口const newWindow = window.open(&#x27;https://www.example.com&#x27;, &#x27;_blank&#x27;, &#x27;width=800,height=600&#x27;);newWindow.close();\n位置和导航\n// 位置信息console.log(&#x27;当前URL:&#x27;, location.href);console.log(&#x27;协议:&#x27;, location.protocol);console.log(&#x27;主机名:&#x27;, location.hostname);console.log(&#x27;路径:&#x27;, location.pathname);console.log(&#x27;查询参数:&#x27;, location.search);// 导航操作location.href = &#x27;https://www.example.com&#x27;; // 跳转location.assign(&#x27;https://www.example.com&#x27;); // 跳转location.replace(&#x27;https://www.example.com&#x27;); // 替换当前页面location.reload(); // 刷新页面location.reload(true); // 强制刷新// 解析查询参数function getQueryParams() &#123;    const params = new URLSearchParams(location.search);    const result = &#123;&#125;;    for (const [key, value] of params) &#123;        result[key] = value;    &#125;    return result;&#125;\n历史记录\n// 历史记录操作console.log(&#x27;历史记录数量:&#x27;, history.length);history.back(); // 返回上一页history.forward(); // 前进到下一页history.go(-2); // 返回前两页// HTML5 History APIhistory.pushState(&#123;page: 1&#125;, &#x27;页面 1&#x27;, &#x27;?page=1&#x27;);history.replaceState(&#123;page: 2&#125;, &#x27;页面 2&#x27;, &#x27;?page=2&#x27;);// 监听历史状态变化window.addEventListener(&#x27;popstate&#x27;, function(event) &#123;    console.log(&#x27;历史状态变化:&#x27;, event.state);&#125;);\n本地存储\n// localStoragelocalStorage.setItem(&#x27;username&#x27;, &#x27;张三&#x27;);localStorage.setItem(&#x27;settings&#x27;, JSON.stringify(&#123;theme: &#x27;dark&#x27;&#125;));const username = localStorage.getItem(&#x27;username&#x27;);const settings = JSON.parse(localStorage.getItem(&#x27;settings&#x27;));localStorage.removeItem(&#x27;username&#x27;);// localStorage.clear();// sessionStoragesessionStorage.setItem(&#x27;tempData&#x27;, &#x27;临时数据&#x27;);const tempData = sessionStorage.getItem(&#x27;tempData&#x27;);// 监听存储变化window.addEventListener(&#x27;storage&#x27;, function(event) &#123;    console.log(&#x27;存储变化:&#x27;, event.key, event.newValue);&#125;);\n","categories":["编程"],"tags":["web"]},{"title":"Axios指北","url":"/2025/10/16/web/Axios%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","content":"\n如题，结合官方文档与网络帖子，利用AI整理\n\n\nAxios 使用指南\nDate: October 16, 2025\nCode: https://github.com/axios/axios\n\n目录\n\n\n引言\n\n\nAxios 基础介绍\n\n\n安装与环境配置\n\n\n基础使用方法\n\n\n一般场景应用\n\n\nVue 项目中的使用\n\n\nAxios 封装最佳实践\n\n\n网络知识科普\n\n\n安全性考虑\n\n\n性能优化\n\n\n常见问题与解决方案\n\n\n总结\n\n\n\n引言\n在现代前端开发中，与后端服务器进行数据交互是不可或缺的环节。Axios 作为一款基于 Promise 的 HTTP 客户端，已经成为众多开发者的首选工具。本指南将从基础概念到高级应用，全面介绍 Axios 的使用方法，帮助开发者构建更加健壮和高效的网络请求系统。\n\nAxios 基础介绍\n什么是 Axios\nAxios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 Node.js 中。它本质上是对原生 XMLHttpRequest 的封装，但提供了更简洁的 API 和更强大的功能。\n核心特性\n\n\n支持 Promise API：使用现代化的异步编程模式\n\n\n拦截请求和响应：统一处理请求前和响应后的逻辑\n\n\n自动转换 JSON 数据：无需手动处理数据格式转换\n\n\n取消请求：支持中止长时间未响应的请求\n\n\n客户端防御 XSRF：提供安全防护机制\n\n\n跨平台支持：同时支持浏览器和 Node.js 环境\n\n\n为什么选择 Axios\n相比原生 XMLHttpRequest 和 fetch API，Axios 具有以下优势：\n\n\n更简洁的 API：链式调用，代码更易读\n\n\n更好的错误处理：统一的错误处理机制\n\n\n拦截器功能：全局请求/响应处理\n\n\n取消请求：避免内存泄漏和不必要的网络请求\n\n\n浏览器兼容性：支持更多浏览器版本\n\n\n\n安装与环境配置\n使用 npm 安装\nnpm install axios# 或者yarn add axios# 或者pnpm add axios\n使用 CDN\n&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n环境配置\n在项目中创建基础配置文件：\n// src/utils/axiosConfig.jsimport axios from &#x27;axios&#x27;;// 创建 axios 实例const axiosInstance = axios.create(&#123;  baseURL: process.env.VUE_APP_API_BASE_URL || &#x27;http://localhost:3000/api&#x27;,  timeout: 10000, // 超时时间  headers: &#123;    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;  &#125;&#125;);export default axiosInstance;\n\n基础使用方法\n发起 GET 请求\nimport axios from &#x27;axios&#x27;;// 基础 GET 请求axios.get(&#x27;/users&#x27;)  .then(response =&gt; &#123;    console.log(response.data);  &#125;)  .catch(error =&gt; &#123;    console.error(&#x27;Error:&#x27;, error);  &#125;);// 带参数的 GET 请求axios.get(&#x27;/users&#x27;, &#123;  params: &#123;    id: 123,    name: &#x27;John&#x27;  &#125;&#125;).then(response =&gt; &#123;  console.log(response.data);&#125;);// 使用 async/awaitasync function getUser() &#123;  try &#123;    const response = await axios.get(&#x27;/users/123&#x27;);    console.log(response.data);  &#125; catch (error) &#123;    console.error(&#x27;Error:&#x27;, error);  &#125;&#125;\n发起 POST 请求\n// 基础 POST 请求axios.post(&#x27;/users&#x27;, &#123;  username: &#x27;john_doe&#x27;,  email: &#x27;john@example.com&#x27;,  password: &#x27;password123&#x27;&#125;).then(response =&gt; &#123;  console.log(&#x27;User created:&#x27;, response.data);&#125;).catch(error =&gt; &#123;  console.error(&#x27;Error:&#x27;, error);&#125;);// 带请求头的 POST 请求axios.post(&#x27;/login&#x27;,   &#123; username: &#x27;admin&#x27;, password: &#x27;admin123&#x27; &#125;,  &#123;    headers: &#123;      &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;    &#125;  &#125;).then(response =&gt; &#123;  console.log(&#x27;Login successful:&#x27;, response.data);&#125;);\n其他请求方法\n// PUT 请求 - 更新整个资源axios.put(&#x27;/users/123&#x27;, &#123;  name: &#x27;John Updated&#x27;,  email: &#x27;john.updated@example.com&#x27;&#125;);// PATCH 请求 - 部分更新axios.patch(&#x27;/users/123&#x27;, &#123;  email: &#x27;new.email@example.com&#x27;&#125;);// DELETE 请求axios.delete(&#x27;/users/123&#x27;);// HEAD 请求 - 获取响应头axios.head(&#x27;/users/123&#x27;);// OPTIONS 请求 - 获取资源支持的方法axios.options(&#x27;/users&#x27;);\n\n一般场景应用\n处理并发请求\n// 同时发起多个请求function getUserAccount() &#123;  return axios.get(&#x27;/user/123&#x27;);&#125;function getUserPermissions() &#123;  return axios.get(&#x27;/user/123/permissions&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()])  .then(axios.spread((account, permissions) =&gt; &#123;    console.log(&#x27;Account:&#x27;, account.data);    console.log(&#x27;Permissions:&#x27;, permissions.data);  &#125;));// 使用 Promise.allPromise.all([  axios.get(&#x27;/users&#x27;),  axios.get(&#x27;/posts&#x27;),  axios.get(&#x27;/comments&#x27;)]).then(([usersRes, postsRes, commentsRes]) =&gt; &#123;  console.log(&#x27;Users:&#x27;, usersRes.data);  console.log(&#x27;Posts:&#x27;, postsRes.data);  console.log(&#x27;Comments:&#x27;, commentsRes.data);&#125;);\n请求配置详解\nconst config = &#123;  url: &#x27;/users&#x27;,  method: &#x27;get&#x27;, // default  baseURL: &#x27;https://api.example.com&#x27;,  transformRequest: [function (data, headers) &#123;    // 对请求数据进行转换处理    return data;  &#125;],  transformResponse: [function (data) &#123;    // 对响应数据进行转换处理    return data;  &#125;],  headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;,  params: &#123;    ID: 12345  &#125;,  paramsSerializer: function(params) &#123;    return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;)  &#125;,  data: &#123;    firstName: &#x27;Fred&#x27;  &#125;,  timeout: 1000,  withCredentials: false, // default  adapter: function (config) &#123;    /* ... */  &#125;,  auth: &#123;    username: &#x27;janedoe&#x27;,    password: &#x27;s00pers3cret&#x27;  &#125;,  responseType: &#x27;json&#x27;, // default  responseEncoding: &#x27;utf8&#x27;, // default  xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // default  xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // default  onUploadProgress: function (progressEvent) &#123;    // 处理上传进度  &#125;,  onDownloadProgress: function (progressEvent) &#123;    // 处理下载进度  &#125;,  maxContentLength: 2000,  validateStatus: function (status) &#123;    return status &gt;= 200 &amp;&amp; status &lt; 300; // default  &#125;,  maxRedirects: 5, // default  socketPath: null, // default  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),  proxy: &#123;    host: &#x27;127.0.0.1&#x27;,    port: 9000,    auth: &#123;      username: &#x27;mikeymike&#x27;,      password: &#x27;rapunz3l&#x27;    &#125;  &#125;,  cancelToken: new axios.CancelToken(function (cancel) &#123;  &#125;)&#125;;axios(config)  .then(response =&gt; &#123;    console.log(response.data);  &#125;);\n错误处理\naxios.get(&#x27;/users&#x27;)  .then(response =&gt; &#123;    console.log(response.data);  &#125;)  .catch(error =&gt; &#123;    if (error.response) &#123;      // 请求已发出，服务器返回状态码不在 2xx 范围内      console.log(error.response.data);      console.log(error.response.status);      console.log(error.response.headers);    &#125; else if (error.request) &#123;      // 请求已发出，但没有收到响应      console.log(error.request);    &#125; else &#123;      // 发生了一些设置请求时的错误      console.log(&#x27;Error:&#x27;, error.message);    &#125;    console.log(error.config);  &#125;);\n\nVue 项目中的使用\nVue 3 中的基础使用\n// src/main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import axios from &#x27;axios&#x27;;const app = createApp(App);// 全局配置 axiosaxios.defaults.baseURL = process.env.VUE_APP_API_URL;axios.defaults.timeout = 10000;// 添加到全局属性app.config.globalProperties.$axios = axios;app.mount(&#x27;#app&#x27;);\n在组件中使用\n&lt;template&gt;  &lt;div class=&quot;user-profile&quot;&gt;    &lt;div v-if=&quot;loading&quot; class=&quot;loading&quot;&gt;Loading...&lt;/div&gt;    &lt;div v-else-if=&quot;error&quot; class=&quot;error&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/div&gt;    &lt;div v-else class=&quot;profile&quot;&gt;      &lt;h2&gt;&#123;&#123; user.name &#125;&#125;&lt;/h2&gt;      &lt;p&gt;&#123;&#123; user.email &#125;&#125;&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;import axios from &#x27;axios&#x27;;const user = ref(null);const loading = ref(false);const error = ref(null);onMounted(async () =&gt; &#123;  loading.value = true;  try &#123;    const response = await axios.get(&#x27;/users/profile&#x27;);    user.value = response.data;  &#125; catch (err) &#123;    error.value = &#x27;Failed to load user data&#x27;;    console.error(err);  &#125; finally &#123;    loading.value = false;  &#125;&#125;);&lt;/script&gt;&lt;style scoped&gt;.loading &#123; color: #666; &#125;.error &#123; color: #dc3545; &#125;.profile &#123; padding: 20px; &#125;&lt;/style&gt;\n结合 Pinia 进行状态管理\n// src/stores/userStore.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;;import axios from &#x27;@/utils/axiosConfig&#x27;;export const useUserStore = defineStore(&#x27;user&#x27;, &#123;  state: () =&gt; (&#123;    user: null,    loading: false,    error: null  &#125;),    actions: &#123;    async fetchUserProfile() &#123;      this.loading = true;      this.error = null;            try &#123;        const response = await axios.get(&#x27;/users/profile&#x27;);        this.user = response.data;        return response.data;      &#125; catch (err) &#123;        this.error = err.message || &#x27;Failed to fetch user profile&#x27;;        throw err;      &#125; finally &#123;        this.loading = false;      &#125;    &#125;,        async updateUserProfile(data) &#123;      this.loading = true;      this.error = null;            try &#123;        const response = await axios.put(&#x27;/users/profile&#x27;, data);        this.user = response.data;        return response.data;      &#125; catch (err) &#123;        this.error = err.message || &#x27;Failed to update profile&#x27;;        throw err;      &#125; finally &#123;        this.loading = false;      &#125;    &#125;  &#125;&#125;);\n在 Vue Router 中使用\n// src/router/index.jsimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;import Home from &#x27;../views/Home.vue&#x27;;import axios from &#x27;@/utils/axiosConfig&#x27;;const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;Home&#x27;,    component: Home  &#125;,  &#123;    path: &#x27;/dashboard&#x27;,    name: &#x27;Dashboard&#x27;,    component: () =&gt; import(&#x27;../views/Dashboard.vue&#x27;),    beforeEnter: async (to, from, next) =&gt; &#123;      try &#123;        // 检查用户是否已登录        const response = await axios.get(&#x27;/auth/me&#x27;);        if (response.data.isAuthenticated) &#123;          next();        &#125; else &#123;          next(&#x27;/login&#x27;);        &#125;      &#125; catch (error) &#123;        next(&#x27;/login&#x27;);      &#125;    &#125;  &#125;];const router = createRouter(&#123;  history: createWebHistory(process.env.BASE_URL),  routes&#125;);export default router;\n\nAxios 封装最佳实践\n创建基础请求类\n// src/utils/request.jsimport axios from &#x27;axios&#x27;;import &#123; ElMessage, ElLoading &#125; from &#x27;element-plus&#x27;;class Request &#123;  constructor() &#123;    this.instance = axios.create(&#123;      baseURL: process.env.VUE_APP_API_BASE_URL,      timeout: 10000,      headers: &#123;        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;      &#125;    &#125;);        this.setupInterceptors();    this.loadingInstance = null;    this.requestCount = 0;  &#125;    // 设置拦截器  setupInterceptors() &#123;    // 请求拦截器    this.instance.interceptors.request.use(      (config) =&gt; &#123;        this.showLoading(config);                // 添加认证 token        const token = localStorage.getItem(&#x27;token&#x27;);        if (token) &#123;          config.headers.Authorization = `Bearer $&#123;token&#125;`;        &#125;                return config;      &#125;,      (error) =&gt; &#123;        this.hideLoading();        return Promise.reject(error);      &#125;    );        // 响应拦截器    this.instance.interceptors.response.use(      (response) =&gt; &#123;        this.hideLoading();        return this.handleResponse(response);      &#125;,      (error) =&gt; &#123;        this.hideLoading();        return this.handleError(error);      &#125;    );  &#125;    // 显示加载状态  showLoading(config) &#123;    if (config.showLoading !== false) &#123;      this.requestCount++;      if (this.requestCount === 1) &#123;        this.loadingInstance = ElLoading.service(&#123;          fullscreen: true,          text: &#x27;Loading...&#x27;,          background: &#x27;rgba(0, 0, 0, 0.5)&#x27;        &#125;);      &#125;    &#125;  &#125;    // 隐藏加载状态  hideLoading() &#123;    if (this.requestCount &gt; 0) &#123;      this.requestCount--;      if (this.requestCount === 0 &amp;&amp; this.loadingInstance) &#123;        this.loadingInstance.close();        this.loadingInstance = null;      &#125;    &#125;  &#125;    // 处理响应数据  handleResponse(response) &#123;    const &#123; data, status &#125; = response;        // 根据后端返回格式统一处理    if (status === 200) &#123;      if (data.code === 200) &#123;        return data.data;      &#125; else &#123;        ElMessage.error(data.message || &#x27;Request failed&#x27;);        return Promise.reject(data);      &#125;    &#125;        return data;  &#125;    // 处理错误  handleError(error) &#123;    const &#123; response &#125; = error;        if (response) &#123;      const &#123; status, data &#125; = response;            switch (status) &#123;        case 401:          // 未授权，跳转到登录页          ElMessage.error(&#x27;Authentication failed, please login again&#x27;);          localStorage.removeItem(&#x27;token&#x27;);          window.location.href = &#x27;/login&#x27;;          break;        case 403:          ElMessage.error(&#x27;Access denied&#x27;);          break;        case 404:          ElMessage.error(&#x27;Resource not found&#x27;);          break;        case 500:          ElMessage.error(&#x27;Server error&#x27;);          break;        default:          ElMessage.error(data.message || &#x27;Request error&#x27;);      &#125;    &#125; else if (error.request) &#123;      ElMessage.error(&#x27;Network error&#x27;);    &#125; else &#123;      ElMessage.error(error.message);    &#125;        return Promise.reject(error);  &#125;    // 请求方法  request(config) &#123;    return this.instance.request(config);  &#125;    get(url, params, config = &#123;&#125;) &#123;    return this.instance.get(url, &#123; params, ...config &#125;);  &#125;    post(url, data, config = &#123;&#125;) &#123;    return this.instance.post(url, data, config);  &#125;    put(url, data, config = &#123;&#125;) &#123;    return this.instance.put(url, data, config);  &#125;    patch(url, data, config = &#123;&#125;) &#123;    return this.instance.patch(url, data, config);  &#125;    delete(url, config = &#123;&#125;) &#123;    return this.instance.delete(url, config);  &#125;&#125;export default new Request();\n创建 API 服务层\n// src/api/index.jsimport request from &#x27;@/utils/request&#x27;;// 统一导出所有 APIexport * from &#x27;./auth&#x27;;export * from &#x27;./user&#x27;;export * from &#x27;./post&#x27;;export * from &#x27;./comment&#x27;;// src/api/auth.jsexport const authAPI = &#123;  login: (data) =&gt; request.post(&#x27;/auth/login&#x27;, data),  logout: () =&gt; request.post(&#x27;/auth/logout&#x27;),  register: (data) =&gt; request.post(&#x27;/auth/register&#x27;, data),  getProfile: () =&gt; request.get(&#x27;/auth/profile&#x27;),  refreshToken: () =&gt; request.post(&#x27;/auth/refresh-token&#x27;)&#125;;// src/api/user.jsexport const userAPI = &#123;  getUserList: (params) =&gt; request.get(&#x27;/users&#x27;, params),  getUserById: (id) =&gt; request.get(`/users/$&#123;id&#125;`),  createUser: (data) =&gt; request.post(&#x27;/users&#x27;, data),  updateUser: (id, data) =&gt; request.put(`/users/$&#123;id&#125;`, data),  deleteUser: (id) =&gt; request.delete(`/users/$&#123;id&#125;`),  updatePassword: (data) =&gt; request.post(&#x27;/users/password&#x27;, data)&#125;;\n在组件中使用封装后的 API\n&lt;template&gt;  &lt;div class=&quot;user-management&quot;&gt;    &lt;div class=&quot;search-bar&quot;&gt;      &lt;el-input v-model=&quot;searchKeyword&quot; placeholder=&quot;Search users...&quot; /&gt;      &lt;el-button @click=&quot;fetchUsers&quot;&gt;Search&lt;/el-button&gt;    &lt;/div&gt;        &lt;el-table :data=&quot;userList&quot; border&gt;      &lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot; width=&quot;80&quot; /&gt;      &lt;el-table-column prop=&quot;name&quot; label=&quot;Name&quot; /&gt;      &lt;el-table-column prop=&quot;email&quot; label=&quot;Email&quot; /&gt;      &lt;el-table-column prop=&quot;status&quot; label=&quot;Status&quot; /&gt;      &lt;el-table-column label=&quot;Actions&quot; width=&quot;200&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;el-button @click=&quot;editUser(scope.row)&quot;&gt;Edit&lt;/el-button&gt;          &lt;el-button type=&quot;danger&quot; @click=&quot;deleteUser(scope.row.id)&quot;&gt;Delete&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;        &lt;el-pagination      v-model:current-page=&quot;currentPage&quot;      v-model:page-size=&quot;pageSize&quot;      :total=&quot;total&quot;      @current-change=&quot;fetchUsers&quot;    /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;import &#123; userAPI &#125; from &#x27;@/api&#x27;;const userList = ref([]);const searchKeyword = ref(&#x27;&#x27;);const currentPage = ref(1);const pageSize = ref(10);const total = ref(0);const fetchUsers = async () =&gt; &#123;  try &#123;    const params = &#123;      page: currentPage.value,      pageSize: pageSize.value    &#125;;        if (searchKeyword.value) &#123;      params.keyword = searchKeyword.value;    &#125;        const response = await userAPI.getUserList(params);    userList.value = response.list;    total.value = response.total;  &#125; catch (error) &#123;    console.error(&#x27;Failed to fetch users:&#x27;, error);  &#125;&#125;;const deleteUser = async (id) =&gt; &#123;  try &#123;    await userAPI.deleteUser(id);    ElMessage.success(&#x27;User deleted successfully&#x27;);    fetchUsers(); // 重新加载列表  &#125; catch (error) &#123;    console.error(&#x27;Failed to delete user:&#x27;, error);  &#125;&#125;;onMounted(() =&gt; &#123;  fetchUsers();&#125;);&lt;/script&gt;\n\n网络知识科普\nHTTP 协议基础\nHTTP 协议概述\nHTTP（HyperText Transfer Protocol）是超文本传输协议，是用于传输超媒体文档（如 HTML）的应用层协议。它基于 TCP/IP 协议，采用客户端-服务器模型。\nHTTP 请求方法\n\n\n\n方法\n用途\n安全性\n幂等性\n\n\n\n\nGET\n获取资源\n安全\n幂等\n\n\nPOST\n创建资源\n不安全\n不幂等\n\n\nPUT\n更新整个资源\n不安全\n幂等\n\n\nPATCH\n部分更新资源\n不安全\n不幂等\n\n\nDELETE\n删除资源\n不安全\n幂等\n\n\nHEAD\n获取响应头\n安全\n幂等\n\n\nOPTIONS\n获取资源支持的方法\n安全\n幂等\n\n\n\nHTTP 状态码\n1xx: 信息性状态码  100 Continue - 继续处理请求  101 Switching Protocols - 协议切换2xx: 成功状态码  200 OK - 请求成功  201 Created - 资源创建成功  204 No Content - 成功但无返回内容3xx: 重定向状态码  301 Moved Permanently - 永久重定向  302 Found - 临时重定向  304 Not Modified - 资源未修改4xx: 客户端错误状态码  400 Bad Request - 请求参数错误  401 Unauthorized - 未授权  403 Forbidden - 禁止访问  404 Not Found - 资源不存在  429 Too Many Requests - 请求过于频繁5xx: 服务器错误状态码  500 Internal Server Error - 服务器内部错误  502 Bad Gateway - 网关错误  503 Service Unavailable - 服务不可用\nRESTful API 设计规范\n核心原则\n\n\n资源导向：所有操作都是针对资源的\n\n\n无状态性：每个请求都包含完整的信息\n\n\n统一接口：使用标准的 HTTP 方法\n\n\n可缓存性：支持缓存机制\n\n\n分层系统：客户端不需要了解系统架构\n\n\nURL 设计规范\n# 正确的 URL 设计GET    /users          # 获取用户列表GET    /users/123      # 获取指定用户POST   /users          # 创建新用户PUT    /users/123      # 更新用户信息DELETE /users/123      # 删除用户# 错误的 URL 设计GET    /getUsers       # 使用动词GET    /user/123       # 单数形式POST   /users/create   # 冗余动词\n查询参数设计\n# 过滤GET /users?role=admin&amp;status=active# 排序GET /users?sort=name&amp;order=asc# 分页GET /users?page=1&amp;pageSize=20# 字段筛选GET /users?fields=id,name,email\n跨域资源共享（CORS）\n什么是 CORS\nCORS（Cross-Origin Resource Sharing）是一种机制，允许浏览器向跨源服务器发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。\nCORS 工作原理\n\n\n简单请求：直接发送请求，服务器返回 CORS 相关头\n\n\n预检请求：复杂请求会先发送 OPTIONS 请求进行预检\n\n\n常见 CORS 配置\n// 服务器端 CORS 配置示例（Node.js/Express）const express = require(&#x27;express&#x27;);const cors = require(&#x27;cors&#x27;);const app = express();app.use(cors(&#123;  origin: [&#x27;http://localhost:3000&#x27;, &#x27;https://example.com&#x27;],  methods: [&#x27;GET&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;DELETE&#x27;, &#x27;OPTIONS&#x27;],  allowedHeaders: [&#x27;Content-Type&#x27;, &#x27;Authorization&#x27;],  credentials: true,  maxAge: 86400 // 预检缓存时间&#125;));\nHTTP 缓存机制\n缓存类型\n\n\n强缓存：Expires 和 Cache-Control 头控制\n\n\n协商缓存：Last-Modified/If-Modified-Since 和 ETag/If-None-Match\n\n\n缓存控制头\n# Cache-Control 指令Cache-Control: public, max-age=3600, must-revalidate# 响应头示例Cache-Control: private, max-age=0, no-cacheETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT\n\n安全性考虑\n认证与授权\nJWT 认证实现\n// JWT 工具类class JWTUtils &#123;  static setToken(token) &#123;    localStorage.setItem(&#x27;token&#x27;, token);    // 也可以使用 HttpOnly Cookie    // document.cookie = `token=$&#123;token&#125;; HttpOnly; Secure; SameSite=Strict`;  &#125;    static getToken() &#123;    return localStorage.getItem(&#x27;token&#x27;);  &#125;    static removeToken() &#123;    localStorage.removeItem(&#x27;token&#x27;);  &#125;    static isTokenExpired(token) &#123;    try &#123;      const payload = JSON.parse(atob(token.split(&#x27;.&#x27;)[1]));      return payload.exp * 1000 &lt; Date.now();    &#125; catch (error) &#123;      return true;    &#125;  &#125;&#125;// 请求拦截器中的认证处理instance.interceptors.request.use(config =&gt; &#123;  const token = JWTUtils.getToken();    if (token) &#123;    if (JWTUtils.isTokenExpired(token)) &#123;      // Token 过期，尝试刷新      return refreshToken()        .then(newToken =&gt; &#123;          JWTUtils.setToken(newToken);          config.headers.Authorization = `Bearer $&#123;newToken&#125;`;          return config;        &#125;)        .catch(() =&gt; &#123;          JWTUtils.removeToken();          window.location.href = &#x27;/login&#x27;;          return Promise.reject(new Error(&#x27;Token expired&#x27;));        &#125;);    &#125;        config.headers.Authorization = `Bearer $&#123;token&#125;`;  &#125;    return config;&#125;);\nCSRF 防护\nCSRF 攻击原理\nCSRF（Cross-Site Request Forgery）跨站请求伪造，攻击者利用用户已认证的身份执行非预期的操作。\n防护措施\n// 1. 使用 CSRF Tokenconst csrfToken = document.querySelector(&#x27;meta[name=&quot;csrf-token&quot;]&#x27;).content;axios.post(&#x27;/api/action&#x27;, &#123;  data: &#x27;value&#x27;&#125;, &#123;  headers: &#123;    &#x27;X-CSRF-Token&#x27;: csrfToken  &#125;&#125;);// 2. 使用 SameSite Cookie// Set-Cookie: sessionid=abc123; SameSite=Strict; Secure; HttpOnly// 3. 验证 Origin/Referer 头app.use((req, res, next) =&gt; &#123;  const origin = req.headers.origin;  const allowedOrigins = [&#x27;https://example.com&#x27;, &#x27;http://localhost:3000&#x27;];    if (allowedOrigins.includes(origin)) &#123;    res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, origin);    next();  &#125; else &#123;    res.status(403).send(&#x27;Forbidden&#x27;);  &#125;&#125;);\nXSS 防护\nXSS 攻击类型\n\n\n存储型 XSS：恶意脚本存储在服务器\n\n\n反射型 XSS：恶意脚本通过 URL 参数注入\n\n\nDOM 型 XSS：客户端 JavaScript 处理不当\n\n\n防护措施\n// 1. 输入验证function sanitizeInput(input) &#123;  return input    .replace(/&amp;/g, &#x27;&amp;amp;&#x27;)    .replace(/&lt;/g, &#x27;&amp;lt;&#x27;)    .replace(/&gt;/g, &#x27;&amp;gt;&#x27;)    .replace(/&quot;/g, &#x27;&amp;quot;&#x27;)    .replace(/&#x27;/g, &#x27;&amp;#039;&#x27;);&#125;// 2. 使用 Content Security Policy// Content-Security-Policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27;; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; img-src &#x27;self&#x27; data:;// 3. Vue 中的 v-text 和 v-bind&lt;template&gt;  &lt;!-- 安全的文本绑定 --&gt;  &lt;div v-text=&quot;userInput&quot;&gt;&lt;/div&gt;    &lt;!-- 安全的属性绑定 --&gt;  &lt;div :title=&quot;sanitizedTitle&quot;&gt;&lt;/div&gt;&lt;/template&gt;\n数据传输安全\nHTTPS 配置\n// 强制使用 HTTPSif (process.env.NODE_ENV === &#x27;production&#x27; &amp;&amp; window.location.protocol !== &#x27;https:&#x27;) &#123;  window.location.href = `https:$&#123;window.location.href.substring(window.location.protocol.length)&#125;`;&#125;// 安全的 cookie 设置document.cookie = &#x27;session=abc123; Secure; HttpOnly; SameSite=Strict; Path=/; Max-Age=86400&#x27;;\n\n性能优化\n请求优化\n请求合并与批处理\nclass RequestBatcher &#123;  constructor() &#123;    this.queue = new Map();    this.timer = null;  &#125;    // 添加请求到批处理队列  addRequest(url, params, callback) &#123;    const key = `$&#123;url&#125;-$&#123;JSON.stringify(params)&#125;`;        if (!this.queue.has(key)) &#123;      this.queue.set(key, &#123; url, params, callbacks: [] &#125;);    &#125;        this.queue.get(key).callbacks.push(callback);        this.scheduleBatch();  &#125;    // 调度批处理  scheduleBatch() &#123;    if (this.timer) return;        this.timer = setTimeout(() =&gt; &#123;      this.processBatch();    &#125;, 100); // 100ms 延迟合并请求  &#125;    // 处理批处理请求  async processBatch() &#123;    const batchRequests = Array.from(this.queue.values());        try &#123;      // 发送批处理请求      const response = await axios.post(&#x27;/api/batch&#x27;, &#123;        requests: batchRequests.map(req =&gt; (&#123;          url: req.url,          params: req.params        &#125;))      &#125;);            // 分发响应结果      response.data.forEach((result, index) =&gt; &#123;        const request = batchRequests[index];        request.callbacks.forEach(callback =&gt; callback(result));      &#125;);    &#125; catch (error) &#123;      batchRequests.forEach(request =&gt; &#123;        request.callbacks.forEach(callback =&gt; callback(null, error));      &#125;);    &#125; finally &#123;      this.queue.clear();      this.timer = null;    &#125;  &#125;&#125;const batcher = new RequestBatcher();\n请求缓存\nclass RequestCache &#123;  constructor() &#123;    this.cache = new Map();    this.maxAge = 5 * 60 * 1000; // 默认缓存 5 分钟  &#125;    // 获取缓存数据  get(key) &#123;    const item = this.cache.get(key);        if (!item) return null;        // 检查缓存是否过期    if (Date.now() - item.timestamp &gt; this.maxAge) &#123;      this.cache.delete(key);      return null;    &#125;        return item.data;  &#125;    // 设置缓存数据  set(key, data, maxAge = this.maxAge) &#123;    this.cache.set(key, &#123;      data,      timestamp: Date.now(),      maxAge    &#125;);        // 设置过期清理    setTimeout(() =&gt; &#123;      this.cache.delete(key);    &#125;, maxAge);  &#125;    // 生成缓存 key  generateKey(url, params = &#123;&#125;) &#123;    return `$&#123;url&#125;?$&#123;new URLSearchParams(params).toString()&#125;`;  &#125;    // 缓存请求  async cachedRequest(url, params = &#123;&#125;, config = &#123;&#125;) &#123;    const cacheKey = this.generateKey(url, params);    const cachedData = this.get(cacheKey);        if (cachedData &amp;&amp; !config.forceRefresh) &#123;      return cachedData;    &#125;        try &#123;      const response = await axios.get(url, &#123; params, ...config &#125;);      this.set(cacheKey, response.data, config.maxAge);      return response.data;    &#125; catch (error) &#123;      // 如果有缓存，即使请求失败也返回缓存数据      if (cachedData) &#123;        console.warn(&#x27;Using cached data due to request failure&#x27;);        return cachedData;      &#125;      throw error;    &#125;  &#125;&#125;const requestCache = new RequestCache();\n响应优化\n数据压缩\n// 服务器端启用 Gzip 压缩const compression = require(&#x27;compression&#x27;);app.use(compression());// 客户端请求压缩数据axios.get(&#x27;/api/data&#x27;, &#123;  headers: &#123;    &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;  &#125;&#125;);\n图片优化\n// 图片懒加载const loadImage = (url) =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    const img = new Image();    img.onload = () =&gt; resolve(img);    img.onerror = reject;    img.src = url;  &#125;);&#125;;// 使用 WebP 格式const getWebPImage = (url) =&gt; &#123;  return new Promise((resolve) =&gt; &#123;    const webpData = &#x27;data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA&#x27;;    const img = new Image();        img.onload = () =&gt; &#123;      if (img.width &gt; 0 &amp;&amp; img.height &gt; 0) &#123;        resolve(url.replace(/\\.(jpg|jpeg|png)$/, &#x27;.webp&#x27;));      &#125; else &#123;        resolve(url);      &#125;    &#125;;        img.onerror = () =&gt; resolve(url);    img.src = webpData;  &#125;);&#125;;\n连接优化\nHTTP/2 支持\n// 检查 HTTP/2 支持if (window.location.protocol === &#x27;https:&#x27;) &#123;  fetch(&#x27;/api/check-http2&#x27;)    .then(response =&gt; &#123;      const isHttp2 = response.headers.get(&#x27;x-http2&#x27;) === &#x27;h2&#x27;;      console.log(&#x27;HTTP/2 supported:&#x27;, isHttp2);    &#125;);&#125;\n连接池管理\n// 自定义 Axios 适配器优化连接池const http = require(&#x27;http&#x27;);const https = require(&#x27;https&#x27;);const httpAgent = new http.Agent(&#123;  keepAlive: true,  maxSockets: 50,  maxFreeSockets: 10,  timeout: 60000,  freeSocketTimeout: 30000&#125;);const httpsAgent = new https.Agent(&#123;  keepAlive: true,  maxSockets: 50,  maxFreeSockets: 10,  timeout: 60000,  freeSocketTimeout: 30000&#125;);const axiosInstance = axios.create(&#123;  httpAgent,  httpsAgent,  timeout: 10000&#125;);\n\n常见问题与解决方案\n跨域问题\n问题描述\n前端应用与后端 API 不在同一个域名下，导致浏览器阻止请求。\n解决方案\n// 1. 开发环境代理配置（Vue CLI）// vue.config.jsmodule.exports = &#123;  devServer: &#123;    proxy: &#123;      &#x27;/api&#x27;: &#123;        target: &#x27;http://localhost:3000&#x27;,        changeOrigin: true,        pathRewrite: &#123;          &#x27;^/api&#x27;: &#x27;&#x27;        &#125;,        cookieDomainRewrite: &#123;          &#x27;localhost:3000&#x27;: &#x27;localhost:8080&#x27;        &#125;      &#125;    &#125;  &#125;&#125;;// 2. Vite 代理配置// vite.config.jsexport default &#123;  server: &#123;    proxy: &#123;      &#x27;/api&#x27;: &#123;        target: &#x27;http://localhost:3000&#x27;,        changeOrigin: true,        rewrite: (path) =&gt; path.replace(/^\\/api/, &#x27;&#x27;)      &#125;    &#125;  &#125;&#125;;\n请求超时处理\n全局超时配置\nconst axiosInstance = axios.create(&#123;  timeout: 10000 // 全局超时时间&#125;);// 单个请求超时配置axios.get(&#x27;/api/data&#x27;, &#123;  timeout: 5000 // 覆盖全局配置&#125;);// 超时重试机制class RetryHandler &#123;  static async requestWithRetry(config, retries = 3, delay = 1000) &#123;    try &#123;      return await axios(config);    &#125; catch (error) &#123;      if (retries &gt; 0 &amp;&amp; this.isRetryable(error)) &#123;        await this.delay(delay);        return this.requestWithRetry(config, retries - 1, delay * 2);      &#125;      throw error;    &#125;  &#125;    static isRetryable(error) &#123;    return (      error.code === &#x27;ECONNABORTED&#x27; ||      (error.response &amp;&amp; error.response.status &gt;= 500)    );  &#125;    static delay(ms) &#123;    return new Promise(resolve =&gt; setTimeout(resolve, ms));  &#125;&#125;\n重复请求处理\n防止重复提交\nclass RequestDeduplicator &#123;  constructor() &#123;    this.pendingRequests = new Map();  &#125;    async request(config) &#123;    const key = this.generateKey(config);        // 如果请求正在进行中，返回同一个 Promise    if (this.pendingRequests.has(key)) &#123;      return this.pendingRequests.get(key);    &#125;        try &#123;      const promise = axios(config).finally(() =&gt; &#123;        this.pendingRequests.delete(key);      &#125;);            this.pendingRequests.set(key, promise);      return promise;    &#125; catch (error) &#123;      this.pendingRequests.delete(key);      throw error;    &#125;  &#125;    generateKey(config) &#123;    const &#123; method = &#x27;get&#x27;, url, params, data &#125; = config;    return `$&#123;method&#125;-$&#123;url&#125;-$&#123;JSON.stringify(params)&#125;-$&#123;JSON.stringify(data)&#125;`;  &#125;    cancelPendingRequests() &#123;    this.pendingRequests.forEach((promise, key) =&gt; &#123;      // 如果支持取消，取消请求      if (config.cancelToken) &#123;        config.cancelToken.cancel(&#x27;Request canceled by deduplicator&#x27;);      &#125;      this.pendingRequests.delete(key);    &#125;);  &#125;&#125;const deduplicator = new RequestDeduplicator();\n错误处理最佳实践\n统一错误处理\n// 错误类型定义class ApiError extends Error &#123;  constructor(message, status = 500, code = &#x27;UNKNOWN_ERROR&#x27;, data = null) &#123;    super(message);    this.name = &#x27;ApiError&#x27;;    this.status = status;    this.code = code;    this.data = data;  &#125;&#125;// 错误处理中间件function errorHandler(error) &#123;  if (error instanceof ApiError) &#123;    return &#123;      success: false,      error: &#123;        message: error.message,        code: error.code,        status: error.status      &#125;    &#125;;  &#125;    if (axios.isAxiosError(error)) &#123;    const response = error.response;        if (response) &#123;      return &#123;        success: false,        error: &#123;          message: response.data.message || &#x27;Request failed&#x27;,          code: response.data.code || &#x27;API_ERROR&#x27;,          status: response.status        &#125;      &#125;;    &#125;        return &#123;      success: false,      error: &#123;        message: error.message || &#x27;Network error&#x27;,        code: &#x27;NETWORK_ERROR&#x27;,        status: 0      &#125;    &#125;;  &#125;    return &#123;    success: false,    error: &#123;      message: error.message || &#x27;Unknown error&#x27;,      code: &#x27;UNKNOWN_ERROR&#x27;,      status: 500    &#125;  &#125;;&#125;\n\n核心要点回顾\n\n\n基础使用：掌握了 GET、POST、PUT、DELETE 等基本请求方法\n\n\nVue 集成：学会了在 Vue 项目中优雅地使用 Axios\n\n\n高级封装：构建了可复用的请求类和 API 服务层\n\n\n网络知识：深入理解了 HTTP 协议、RESTful API、CORS 等概念\n\n\n安全性：掌握了认证、授权、CSRF、XSS 等安全防护措施\n\n\n性能优化：学会了请求合并、缓存、连接池等优化技巧\n\n\n最佳实践建议\n\n\n统一封装：始终对 Axios 进行二次封装，便于统一管理\n\n\n错误处理：建立完善的错误处理机制，提升用户体验\n\n\n安全意识：重视网络安全，保护用户数据和系统安全\n\n\n性能优化：合理使用缓存、连接池等技术提升性能\n\n\n代码规范：保持良好的代码组织和命名规范\n\n\n技术发展趋势\n随着 Web 技术的不断发展，我们还需要关注：\n\n\nHTTP/3：基于 QUIC 协议的新一代 HTTP 协议\n\n\nGraphQL：作为 RESTful API 的补充和替代方案\n\n\nWebSocket：实时通信的重要技术\n\n\n边缘计算：在 CDN 边缘节点处理请求，提升性能\n\n\n\n参考资源\n\n\nAxios 官方文档\n\n\nMDN HTTP 文档\n\n\nRESTful API 设计指南\n\n\nHTTP/2 规范\n\n\n\n","categories":["编程"],"tags":["Web"]},{"title":"Vuex学习笔记","url":"/2025/10/16/web/Vuex%20%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/","content":"\n如题，结合官方文档与网络帖子，利用AI整理\n\n\nVuex 学习指南（组合式 API 版）\nDate: October 16, 2025\nCode: https://github.com/vuejs/vuex\n目录\n\n\n什么是 Vuex\n\n\n为什么需要 Vuex\n\n\nVuex 核心概念\n\n\n组合式 API 基本使用\n\n\n模块化管理\n\n\n实际项目应用\n\n\n最佳实践\n\n\n性能优化\n\n\n常见问题\n\n\nVuex 4 新特性\n\n\n什么是 Vuex\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\nVuex 的核心思想\n\n\n单一状态树：整个应用的状态被存储在一个单一的对象中\n\n\n状态是只读的：唯一改变状态的方法是提交 mutation\n\n\n使用纯函数来执行修改：Mutation 必须是同步函数\n\n\n为什么需要 Vuex\n传统组件通信的问题\n在大型 Vue 应用中，组件间通信会变得非常复杂：\n&lt;!-- 传统的组件通信方式 --&gt;&lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;div&gt;    &lt;ChildA :data=&quot;data&quot; @update=&quot;handleUpdate&quot; /&gt;    &lt;ChildB :data=&quot;data&quot; @update=&quot;handleUpdate&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;import ChildA from &#x27;./ChildA.vue&#x27;import ChildB from &#x27;./ChildB.vue&#x27;const data = ref(&#123; count: 0 &#125;)const handleUpdate = (newData) =&gt; &#123;  data.value = newData&#125;&lt;/script&gt;//子组件this.$emit(update,&#x27;newdata&#x27;)\nVuex 解决的问题\n\n\n多个视图依赖于同一状态\n\n\n来自不同视图的行为需要变更同一状态\n\n\n复杂的组件树中，跨层级通信困难\n\n\n什么时候使用 Vuex\n\n\n构建中大型单页应用\n\n\n需要在多个组件间共享状态\n\n\n状态逻辑复杂，需要统一管理\n\n\n需要追踪状态变更历史\n\n\nVuex 核心概念\n1. State\nState 是存储应用状态的地方，就像组件中的 data：\n// store/index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;const store = createStore(&#123;  state() &#123;    return &#123;      count: 0,      user: &#123;        name: &#x27;&#x27;,        isLogin: false      &#125;,      products: []    &#125;  &#125;&#125;)export default store\n在组件中访问 State（组合式 API）：\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed &#125; from &#x27;vue&#x27;const store = useStore()// 直接访问const count = computed(() =&gt; store.state.count)const user = computed(() =&gt; store.state.user)// 或者使用 mapState（仍然支持）import &#123; mapState &#125; from &#x27;vuex&#x27;const &#123; count, user &#125; = mapState(&#123;  count: state =&gt; state.count,  user: state =&gt; state.user&#125;)&lt;/script&gt;\n2. Mutations\nMutations 是修改状态的唯一方法，必须是同步函数：\n// store/index.jsconst store = createStore(&#123;  state() &#123;    return &#123;      count: 0    &#125;  &#125;,  mutations: &#123;    // 基本 mutation    increment(state) &#123;      state.count++    &#125;,        // 带参数的 mutation    incrementBy(state, payload) &#123;      state.count += payload.amount    &#125;  &#125;&#125;)\n提交 Mutation（组合式 API）：\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;const store = useStore()// 直接提交const increment = () =&gt; &#123;  store.commit(&#x27;increment&#x27;)&#125;const incrementBy = () =&gt; &#123;  store.commit(&#x27;incrementBy&#x27;, &#123; amount: 5 &#125;)&#125;// 或者使用 mapMutationsimport &#123; mapMutations &#125; from &#x27;vuex&#x27;const &#123; increment, incrementBy &#125; = mapMutations([  &#x27;increment&#x27;,  &#x27;incrementBy&#x27;])&lt;/script&gt;\n3. Actions\nActions 用于处理异步操作，可以包含任意异步代码：\n// store/index.jsconst store = createStore(&#123;  state() &#123;    return &#123;      user: null,      loading: false    &#125;  &#125;,  mutations: &#123;    setUser(state, user) &#123;      state.user = user    &#125;,    setLoading(state, status) &#123;      state.loading = status    &#125;  &#125;,  actions: &#123;    // 登录异步操作    async login(&#123; commit &#125;, credentials) &#123;      commit(&#x27;setLoading&#x27;, true)      try &#123;        const response = await api.login(credentials)        commit(&#x27;setUser&#x27;, response.data)        return response.data      &#125; catch (error) &#123;        throw error      &#125; finally &#123;        commit(&#x27;setLoading&#x27;, false)      &#125;    &#125;  &#125;&#125;)\n分发 Action（组合式 API）：\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;const store = useStore()// 直接分发const handleLogin = async () =&gt; &#123;  try &#123;    const user = await store.dispatch(&#x27;login&#x27;, &#123;       username: &#x27;admin&#x27;,       password: &#x27;123456&#x27;     &#125;)    console.log(&#x27;登录成功:&#x27;, user)  &#125; catch (error) &#123;    console.error(&#x27;登录失败:&#x27;, error)  &#125;&#125;// 或者使用 mapActionsimport &#123; mapActions &#125; from &#x27;vuex&#x27;const &#123; login &#125; = mapActions([  &#x27;login&#x27;])const handleLogin = async () =&gt; &#123;  try &#123;    await login(&#123; username: &#x27;admin&#x27;, password: &#x27;123456&#x27; &#125;)  &#125; catch (error) &#123;    console.error(error)  &#125;&#125;&lt;/script&gt;\n4. Getters\nGetters 用于从 state 中派生出一些状态，类似于计算属性：\n// store/index.jsconst store = createStore(&#123;  state() &#123;    return &#123;      todos: [        &#123; id: 1, text: &#x27;学习Vuex&#x27;, done: true &#125;,        &#123; id: 2, text: &#x27;编写代码&#x27;, done: false &#125;      ]    &#125;  &#125;,  getters: &#123;    // 基础 getter    doneTodos: (state) =&gt; &#123;      return state.todos.filter(todo =&gt; todo.done)    &#125;,        // 带参数的 getter    getTodoById: (state) =&gt; (id) =&gt; &#123;      return state.todos.find(todo =&gt; todo.id === id)    &#125;,        // 基于其他 getter 的计算    doneTodosCount: (state, getters) =&gt; &#123;      return getters.doneTodos.length    &#125;  &#125;&#125;)\n使用 Getters（组合式 API）：\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed &#125; from &#x27;vue&#x27;const store = useStore()// 直接访问const doneTodos = computed(() =&gt; store.getters.doneTodos)const todoById = (id) =&gt; store.getters.getTodoById(id)// 或者使用 mapGettersimport &#123; mapGetters &#125; from &#x27;vuex&#x27;const &#123; doneTodos, doneTodosCount &#125; = mapGetters([  &#x27;doneTodos&#x27;,  &#x27;doneTodosCount&#x27;])&lt;/script&gt;\n组合式 API 基本使用\n1. 安装 Vuex\n# Vue 3npm install vuex@4 --save\n2. 创建 Store\n// store/index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;const store = createStore(&#123;  state() &#123;    return &#123;      count: 0    &#125;  &#125;,  mutations: &#123;    increment(state) &#123;      state.count++    &#125;  &#125;,  actions: &#123;    incrementAsync(&#123; commit &#125;) &#123;      return new Promise((resolve) =&gt; &#123;        setTimeout(() =&gt; &#123;          commit(&#x27;increment&#x27;)          resolve()        &#125;, 1000)      &#125;)    &#125;  &#125;,  getters: &#123;    doubleCount: (state) =&gt; state.count * 2  &#125;&#125;)export default store\n3. 在 Vue 应用中注入 Store\n// main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &#x27;./store&#x27;const app = createApp(App)app.use(store)app.mount(&#x27;#app&#x27;)\n4. 在组件中使用（组合式 API）\n&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;p&gt;Double Count: &#123;&#123; doubleCount &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;handleIncrement&quot;&gt;Increment&lt;/button&gt;    &lt;button @click=&quot;handleIncrementAsync&quot;&gt;Increment Async&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed &#125; from &#x27;vue&#x27;const store = useStore()// 访问状态const count = computed(() =&gt; store.state.count)const doubleCount = computed(() =&gt; store.getters.doubleCount)// 提交 mutationconst handleIncrement = () =&gt; &#123;  store.commit(&#x27;increment&#x27;)&#125;// 分发 actionconst handleIncrementAsync = async () =&gt; &#123;  await store.dispatch(&#x27;incrementAsync&#x27;)&#125;&lt;/script&gt;\n5. 组合式 API 的优势\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed, watch &#125; from &#x27;vue&#x27;const store = useStore()// 可以更好地组织相关的逻辑const count = computed(() =&gt; store.state.count)const doubleCount = computed(() =&gt; count.value * 2)// 可以使用watch监听状态变化watch(count, (newVal, oldVal) =&gt; &#123;  console.log(`Count changed from $&#123;oldVal&#125; to $&#123;newVal&#125;`)&#125;)// 可以将逻辑抽取为组合函数const useCounter = () =&gt; &#123;  const count = computed(() =&gt; store.state.count)    const increment = () =&gt; &#123;    store.commit(&#x27;increment&#x27;)  &#125;    return &#123;    count,    increment  &#125;&#125;const &#123; count, increment &#125; = useCounter()&lt;/script&gt;\n模块化管理\n当应用变得复杂时，需要将 Store 分割成模块：\n1. 模块结构\nstore/├── index.js          # 组装模块├── getters.js        # 全局 getters└── modules/    ├── user.js       # 用户模块    ├── cart.js       # 购物车模块    └── product.js    # 商品模块\n2. 创建模块\n// store/modules/user.jsexport default &#123;  namespaced: true,  // 启用命名空间  state() &#123;    return &#123;      token: localStorage.getItem(&#x27;token&#x27;) || &#x27;&#x27;,      userInfo: JSON.parse(localStorage.getItem(&#x27;userInfo&#x27;)) || &#123;&#125;    &#125;  &#125;,  mutations: &#123;    SET_TOKEN(state, token) &#123;      state.token = token      localStorage.setItem(&#x27;token&#x27;, token)    &#125;,    SET_USER_INFO(state, userInfo) &#123;      state.userInfo = userInfo      localStorage.setItem(&#x27;userInfo&#x27;, JSON.stringify(userInfo))    &#125;,    LOGOUT(state) &#123;      state.token = &#x27;&#x27;      state.userInfo = &#123;&#125;      localStorage.removeItem(&#x27;token&#x27;)      localStorage.removeItem(&#x27;userInfo&#x27;)    &#125;  &#125;,  actions: &#123;    async login(&#123; commit &#125;, credentials) &#123;      const response = await api.login(credentials)      commit(&#x27;SET_TOKEN&#x27;, response.token)      commit(&#x27;SET_USER_INFO&#x27;, response.userInfo)      return response    &#125;,        logout(&#123; commit &#125;) &#123;      commit(&#x27;LOGOUT&#x27;)    &#125;  &#125;,  getters: &#123;    isAuthenticated: (state) =&gt; !!state.token,    userRole: (state) =&gt; state.userInfo.role || &#x27;&#x27;  &#125;&#125;\n3. 注册模块\n// store/index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;import user from &#x27;./modules/user&#x27;import cart from &#x27;./modules/cart&#x27;import product from &#x27;./modules/product&#x27;import getters from &#x27;./getters&#x27;const store = createStore(&#123;  modules: &#123;    user,    cart,    product  &#125;,  getters&#125;)export default store\n4. 使用模块化 Store（组合式 API）\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed &#125; from &#x27;vue&#x27;const store = useStore()// 访问模块状态const token = computed(() =&gt; store.state.user.token)const isAuthenticated = computed(() =&gt; store.getters[&#x27;user/isAuthenticated&#x27;])// 提交模块 mutationconst setToken = (token) =&gt; &#123;  store.commit(&#x27;user/SET_TOKEN&#x27;, token)&#125;// 分发模块 actionconst handleLogin = async (credentials) =&gt; &#123;  try &#123;    await store.dispatch(&#x27;user/login&#x27;, credentials)  &#125; catch (error) &#123;    console.error(error)  &#125;&#125;// 或者使用 createNamespacedHelpersimport &#123; createNamespacedHelpers &#125; from &#x27;vuex&#x27;const &#123; mapState, mapGetters, mapMutations, mapActions &#125; = createNamespacedHelpers(&#x27;user&#x27;)const &#123; token, userInfo &#125; = mapState([  &#x27;token&#x27;,  &#x27;userInfo&#x27;])const &#123; isAuthenticated &#125; = mapGetters([  &#x27;isAuthenticated&#x27;])const &#123; SET_TOKEN &#125; = mapMutations([  &#x27;SET_TOKEN&#x27;])const &#123; login, logout &#125; = mapActions([  &#x27;login&#x27;,  &#x27;logout&#x27;])&lt;/script&gt;\n实际项目应用\n购物车示例\n// store/modules/cart.jsexport default &#123;  namespaced: true,  state() &#123;    return &#123;      items: JSON.parse(localStorage.getItem(&#x27;cart&#x27;)) || [],      totalPrice: 0    &#125;  &#125;,  mutations: &#123;    ADD_TO_CART(state, product) &#123;      const existingItem = state.items.find(item =&gt; item.id === product.id)            if (existingItem) &#123;        existingItem.quantity++      &#125; else &#123;        state.items.push(&#123; ...product, quantity: 1 &#125;)      &#125;            localStorage.setItem(&#x27;cart&#x27;, JSON.stringify(state.items))      this.commit(&#x27;cart/CALCULATE_TOTAL&#x27;)    &#125;,        REMOVE_FROM_CART(state, productId) &#123;      state.items = state.items.filter(item =&gt; item.id !== productId)      localStorage.setItem(&#x27;cart&#x27;, JSON.stringify(state.items))      this.commit(&#x27;cart/CALCULATE_TOTAL&#x27;)    &#125;,        UPDATE_QUANTITY(state, &#123; productId, quantity &#125;) &#123;      const item = state.items.find(item =&gt; item.id === productId)      if (item) &#123;        item.quantity = quantity        localStorage.setItem(&#x27;cart&#x27;, JSON.stringify(state.items))        this.commit(&#x27;cart/CALCULATE_TOTAL&#x27;)      &#125;    &#125;,        CLEAR_CART(state) &#123;      state.items = []      localStorage.removeItem(&#x27;cart&#x27;)      this.commit(&#x27;cart/CALCULATE_TOTAL&#x27;)    &#125;,        CALCULATE_TOTAL(state) &#123;      state.totalPrice = state.items.reduce((total, item) =&gt; &#123;        return total + (item.price * item.quantity)      &#125;, 0)    &#125;  &#125;,  actions: &#123;    addToCart(&#123; commit &#125;, product) &#123;      commit(&#x27;ADD_TO_CART&#x27;, product)    &#125;,        removeFromCart(&#123; commit &#125;, productId) &#123;      commit(&#x27;REMOVE_FROM_CART&#x27;, productId)    &#125;,        updateQuantity(&#123; commit &#125;, payload) &#123;      commit(&#x27;UPDATE_QUANTITY&#x27;, payload)    &#125;,        clearCart(&#123; commit &#125;) &#123;      commit(&#x27;CLEAR_CART&#x27;)    &#125;  &#125;,  getters: &#123;    cartItems: (state) =&gt; state.items,    cartCount: (state) =&gt; state.items.reduce((count, item) =&gt; count + item.quantity, 0),    totalPrice: (state) =&gt; state.totalPrice,    isEmpty: (state) =&gt; state.items.length === 0  &#125;&#125;\n在组件中使用购物车（组合式 API）\n&lt;template&gt;  &lt;div class=&quot;cart&quot;&gt;    &lt;h2&gt;购物车&lt;/h2&gt;        &lt;div v-if=&quot;isEmpty&quot; class=&quot;empty-cart&quot;&gt;      购物车为空    &lt;/div&gt;        &lt;div v-else&gt;      &lt;div v-for=&quot;item in cartItems&quot; :key=&quot;item.id&quot; class=&quot;cart-item&quot;&gt;        &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt;        &lt;span&gt;¥&#123;&#123; item.price &#125;&#125;&lt;/span&gt;        &lt;div class=&quot;quantity-controls&quot;&gt;          &lt;button @click=&quot;updateQuantity(item.id, item.quantity - 1)&quot; :disabled=&quot;item.quantity &lt;= 1&quot;&gt;            -          &lt;/button&gt;          &lt;span&gt;&#123;&#123; item.quantity &#125;&#125;&lt;/span&gt;          &lt;button @click=&quot;updateQuantity(item.id, item.quantity + 1)&quot;&gt;            +          &lt;/button&gt;          &lt;button @click=&quot;removeFromCart(item.id)&quot; class=&quot;remove-btn&quot;&gt;            删除          &lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;            &lt;div class=&quot;cart-summary&quot;&gt;        &lt;p&gt;总计: ¥&#123;&#123; totalPrice &#125;&#125;&lt;/p&gt;        &lt;p&gt;商品数量: &#123;&#123; cartCount &#125;&#125;&lt;/p&gt;        &lt;button @click=&quot;clearCart&quot; class=&quot;clear-btn&quot;&gt;          清空购物车        &lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed &#125; from &#x27;vue&#x27;const store = useStore()// 获取购物车状态const cartItems = computed(() =&gt; store.getters[&#x27;cart/cartItems&#x27;])const cartCount = computed(() =&gt; store.getters[&#x27;cart/cartCount&#x27;])const totalPrice = computed(() =&gt; store.getters[&#x27;cart/totalPrice&#x27;])const isEmpty = computed(() =&gt; store.getters[&#x27;cart/isEmpty&#x27;])// 购物车操作const addToCart = (product) =&gt; &#123;  store.dispatch(&#x27;cart/addToCart&#x27;, product)&#125;const removeFromCart = (productId) =&gt; &#123;  store.dispatch(&#x27;cart/removeFromCart&#x27;, productId)&#125;const updateQuantity = (productId, quantity) =&gt; &#123;  if (quantity &lt;= 0) &#123;    removeFromCart(productId)    return  &#125;    store.dispatch(&#x27;cart/updateQuantity&#x27;, &#123;    productId,    quantity  &#125;)&#125;const clearCart = () =&gt; &#123;  store.dispatch(&#x27;cart/clearCart&#x27;)&#125;&lt;/script&gt;\n用户认证示例\n// store/modules/auth.jsexport default &#123;  namespaced: true,  state() &#123;    return &#123;      token: localStorage.getItem(&#x27;token&#x27;) || &#x27;&#x27;,      user: JSON.parse(localStorage.getItem(&#x27;user&#x27;)) || null,      loading: false,      error: null    &#125;  &#125;,  mutations: &#123;    SET_TOKEN(state, token) &#123;      state.token = token      localStorage.setItem(&#x27;token&#x27;, token)    &#125;,        SET_USER(state, user) &#123;      state.user = user      localStorage.setItem(&#x27;user&#x27;, JSON.stringify(user))    &#125;,        SET_LOADING(state, loading) &#123;      state.loading = loading    &#125;,        SET_ERROR(state, error) &#123;      state.error = error    &#125;,        CLEAR_AUTH(state) &#123;      state.token = &#x27;&#x27;      state.user = null      localStorage.removeItem(&#x27;token&#x27;)      localStorage.removeItem(&#x27;user&#x27;)    &#125;  &#125;,  actions: &#123;    async login(&#123; commit &#125;, &#123; email, password &#125;) &#123;      try &#123;        commit(&#x27;SET_LOADING&#x27;, true)        commit(&#x27;SET_ERROR&#x27;, null)                const response = await fetch(&#x27;/api/auth/login&#x27;, &#123;          method: &#x27;POST&#x27;,          headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;,          body: JSON.stringify(&#123; email, password &#125;)        &#125;)                const data = await response.json()                if (!response.ok) &#123;          throw new Error(data.message || &#x27;Login failed&#x27;)        &#125;                commit(&#x27;SET_TOKEN&#x27;, data.token)        commit(&#x27;SET_USER&#x27;, data.user)                return data.user      &#125; catch (error) &#123;        commit(&#x27;SET_ERROR&#x27;, error.message)        throw error      &#125; finally &#123;        commit(&#x27;SET_LOADING&#x27;, false)      &#125;    &#125;,        async logout(&#123; commit, state &#125;) &#123;      try &#123;        commit(&#x27;SET_LOADING&#x27;, true)                await fetch(&#x27;/api/auth/logout&#x27;, &#123;          method: &#x27;POST&#x27;,          headers: &#123;            &#x27;Authorization&#x27;: `Bearer $&#123;state.token&#125;`          &#125;        &#125;)      &#125; finally &#123;        commit(&#x27;CLEAR_AUTH&#x27;)        commit(&#x27;SET_LOADING&#x27;, false)      &#125;    &#125;,        async checkAuth(&#123; commit, state &#125;) &#123;      if (!state.token) return false            try &#123;        commit(&#x27;SET_LOADING&#x27;, true)                const response = await fetch(&#x27;/api/auth/me&#x27;, &#123;          headers: &#123;            &#x27;Authorization&#x27;: `Bearer $&#123;state.token&#125;`          &#125;        &#125;)                if (!response.ok) &#123;          commit(&#x27;CLEAR_AUTH&#x27;)          return false        &#125;                const user = await response.json()        commit(&#x27;SET_USER&#x27;, user)        return true      &#125; catch (error) &#123;        commit(&#x27;CLEAR_AUTH&#x27;)        return false      &#125; finally &#123;        commit(&#x27;SET_LOADING&#x27;, false)      &#125;    &#125;  &#125;,  getters: &#123;    isAuthenticated: (state) =&gt; !!state.token,    currentUser: (state) =&gt; state.user,    isLoading: (state) =&gt; state.loading,    authError: (state) =&gt; state.error,    userRole: (state) =&gt; state.user?.role || &#x27;user&#x27;  &#125;&#125;\n最佳实践\n1. 使用组合函数封装逻辑\n// composables/useAuth.jsimport &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed &#125; from &#x27;vue&#x27;export function useAuth() &#123;  const store = useStore()    // 状态  const isAuthenticated = computed(() =&gt; store.getters[&#x27;auth/isAuthenticated&#x27;])  const currentUser = computed(() =&gt; store.getters[&#x27;auth/currentUser&#x27;])  const isLoading = computed(() =&gt; store.getters[&#x27;auth/isLoading&#x27;])  const authError = computed(() =&gt; store.getters[&#x27;auth/authError&#x27;])    // 方法  const login = async (credentials) =&gt; &#123;    return store.dispatch(&#x27;auth/login&#x27;, credentials)  &#125;    const logout = async () =&gt; &#123;    return store.dispatch(&#x27;auth/logout&#x27;)  &#125;    const checkAuth = async () =&gt; &#123;    return store.dispatch(&#x27;auth/checkAuth&#x27;)  &#125;    return &#123;    // 状态    isAuthenticated,    currentUser,    isLoading,    authError,        // 方法    login,    logout,    checkAuth  &#125;&#125;\n2. 在组件中使用组合函数\n&lt;script setup&gt;import &#123; useAuth &#125; from &#x27;@/composables/useAuth&#x27;import &#123; onMounted &#125; from &#x27;vue&#x27;const &#123;  isAuthenticated,  currentUser,  isLoading,  authError,  login,  checkAuth&#125; = useAuth()// 组件挂载时检查认证状态onMounted(async () =&gt; &#123;  await checkAuth()&#125;)const handleLogin = async (email, password) =&gt; &#123;  try &#123;    await login(&#123; email, password &#125;)    // 登录成功后的处理  &#125; catch (error) &#123;    console.error(&#x27;Login failed:&#x27;, error)  &#125;&#125;&lt;/script&gt;\n3. 状态持久化\n// store/index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;import createPersistedState from &#x27;vuex-persistedstate&#x27;const store = createStore(&#123;  plugins: [    createPersistedState(&#123;      paths: [&#x27;auth.token&#x27;, &#x27;auth.user&#x27;, &#x27;cart.items&#x27;]    &#125;)  ]&#125;)\n4. 严格模式\nconst store = createStore(&#123;  strict: process.env.NODE_ENV !== &#x27;production&#x27;&#125;)\n5. 模块化最佳实践\n// 1. 每个模块独立文件// 2. 启用命名空间// 3. 按业务功能划分模块// 4. 模块内部状态私有// 5. 使用组合函数封装模块逻辑\n6. 异步操作规范\n// store/modules/example.jsactions: &#123;  async fetchData(&#123; commit &#125;, params) &#123;    try &#123;      commit(&#x27;SET_LOADING&#x27;, true)      commit(&#x27;SET_ERROR&#x27;, null)            const data = await api.fetchData(params)      commit(&#x27;SET_DATA&#x27;, data)            return data    &#125; catch (error) &#123;      commit(&#x27;SET_ERROR&#x27;, error.message)      throw error    &#125; finally &#123;      commit(&#x27;SET_LOADING&#x27;, false)    &#125;  &#125;&#125;\n性能优化\n1. 使用计算属性缓存\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed &#125; from &#x27;vue&#x27;const store = useStore()// ✅ 正确：使用计算属性缓存const filteredItems = computed(() =&gt; &#123;  return store.state.items.filter(item =&gt; item.active)&#125;)// ❌ 错误：每次访问都会重新计算const getFilteredItems = () =&gt; &#123;  return store.state.items.filter(item =&gt; item.active)&#125;&lt;/script&gt;\n2. 避免不必要的状态更新\n// store/mutations.jsmutations: &#123;  SET_USER(state, user) &#123;    // 只有当用户信息真正改变时才更新    if (JSON.stringify(state.user) !== JSON.stringify(user)) &#123;      state.user = user    &#125;  &#125;&#125;\n3. 使用 shallowRef 优化大对象\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; shallowRef, watch &#125; from &#x27;vue&#x27;const store = useStore()// 对于大对象，使用 shallowRef 避免深层响应式转换const largeData = shallowRef(store.state.largeData)// 监听状态变化并手动更新watch(  () =&gt; store.state.largeData,  (newData) =&gt; &#123;    largeData.value = newData  &#125;,  &#123; deep: true &#125;)&lt;/script&gt;\n4. 模块懒加载\n// 动态注册模块const registerModule = async () =&gt; &#123;  const module = await import(&#x27;./store/modules/lazyModule&#x27;)  store.registerModule(&#x27;lazy&#x27;, module.default)&#125;// 在路由懒加载中使用const routes = [  &#123;    path: &#x27;/lazy&#x27;,    component: () =&gt; &#123;      registerModule()      return import(&#x27;./views/LazyView.vue&#x27;)    &#125;  &#125;]\n5. 使用 createSelector 优化 getter\n// store/getters.jsimport &#123; createSelector &#125; from &#x27;vuex&#x27;const selectItems = state =&gt; state.itemsconst selectFilter = state =&gt; state.filter// 使用 createSelector 创建记忆化的 selectorexport const selectFilteredItems = createSelector(  [selectItems, selectFilter],  (items, filter) =&gt; &#123;    return items.filter(item =&gt; item.name.includes(filter))  &#125;)\n常见问题\n1. 如何在组合式 API 中使用 map 辅助函数\n&lt;script setup&gt;import &#123; mapState, mapGetters, mapMutations, mapActions &#125; from &#x27;vuex&#x27;import &#123; toRefs &#125; from &#x27;vue&#x27;// 使用 toRefs 将对象转换为响应式引用const &#123; count &#125; = toRefs(mapState(&#123;  count: state =&gt; state.count&#125;))const &#123; doubleCount &#125; = toRefs(mapGetters([  &#x27;doubleCount&#x27;]))const &#123; increment &#125; = mapMutations([  &#x27;increment&#x27;])const &#123; fetchData &#125; = mapActions([  &#x27;fetchData&#x27;])&lt;/script&gt;\n2. 如何处理 v-model 和 Vuex 的冲突\n&lt;template&gt;  &lt;!-- 使用计算属性的 get 和 set --&gt;  &lt;input v-model=&quot;userName&quot;&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed &#125; from &#x27;vue&#x27;const store = useStore()const userName = computed(&#123;  get() &#123;    return store.state.user.name  &#125;,  set(value) &#123;    store.commit(&#x27;updateUserName&#x27;, value)  &#125;&#125;)&lt;/script&gt;\n3. 如何在组合式 API 中监听状态变化\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; watch, computed &#125; from &#x27;vue&#x27;const store = useStore()const count = computed(() =&gt; store.state.count)// 监听状态变化watch(count, (newVal, oldVal) =&gt; &#123;  console.log(`Count changed from $&#123;oldVal&#125; to $&#123;newVal&#125;`)&#125;)// 监听深层对象变化watch(  () =&gt; store.state.user,  (newUser, oldUser) =&gt; &#123;    console.log(&#x27;User changed&#x27;)  &#125;,  &#123; deep: true &#125;)&lt;/script&gt;\n4. 如何在模块间通信\n// store/modules/moduleA.jsactions: &#123;  async moduleAAction(&#123; dispatch, commit, rootGetters &#125;) &#123;    // 调用其他模块的 action    await dispatch(&#x27;moduleB/moduleBAction&#x27;, payload, &#123; root: true &#125;)        // 提交其他模块的 mutation    commit(&#x27;moduleB/moduleBMutation&#x27;, payload, &#123; root: true &#125;)        // 访问其他模块的 getter    const data = rootGetters[&#x27;moduleB/moduleBGetter&#x27;]  &#125;&#125;\n5. 如何处理异步数据加载状态\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed &#125; from &#x27;vue&#x27;const store = useStore()const data = computed(() =&gt; store.state.data)const loading = computed(() =&gt; store.state.loading)const error = computed(() =&gt; store.state.error)const fetchData = async () =&gt; &#123;  try &#123;    await store.dispatch(&#x27;fetchData&#x27;)  &#125; catch (error) &#123;    console.error(error)  &#125;&#125;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;div v-if=&quot;loading&quot;&gt;加载中...&lt;/div&gt;    &lt;div v-else-if=&quot;error&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/div&gt;    &lt;div v-else&gt;      &lt;!-- 显示数据 --&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\nVuex 4 新特性\n1. 与 Vue 3 的兼容性\n// Vue 3 中创建 Storeimport &#123; createStore &#125; from &#x27;vuex&#x27;const store = createStore(&#123;  state() &#123;    return &#123;      count: 0    &#125;  &#125;&#125;)\n2. Composition API 支持\n&lt;script setup&gt;import &#123; useStore &#125; from &#x27;vuex&#x27;import &#123; computed &#125; from &#x27;vue&#x27;const store = useStore()const count = computed(() =&gt; store.state.count)const increment = () =&gt; store.commit(&#x27;increment&#x27;)&lt;/script&gt;\n3. 新的插件系统\n// 创建插件const loggerPlugin = (store) =&gt; &#123;  store.subscribe((mutation, state) =&gt; &#123;    console.log(`[$&#123;mutation.type&#125;]:`, mutation.payload)  &#125;)&#125;// 使用插件const store = createStore(&#123;  plugins: [loggerPlugin]&#125;)\n4. 改进的 TypeScript 支持\n// TypeScript 支持interface State &#123;  count: number  user: User | null&#125;interface User &#123;  id: number  name: string&#125;const store = createStore&lt;State&gt;(&#123;  state: &#123;    count: 0,    user: null  &#125;,  mutations: &#123;    setUser(state, user: User) &#123;      state.user = user    &#125;  &#125;&#125;)\n5. 更好的 DevTools 集成\n// 自定义 devtools 配置const store = createStore(&#123;  devtools: &#123;    enabled: process.env.NODE_ENV !== &#x27;production&#x27;,    features: &#123;      timeTravel: true,      persistState: true    &#125;  &#125;&#125;)\n关键要点：组合式 API 集成：使用 useStore() 在组合式 API 中访问 Store\n\n\n组合函数封装：将相关的状态和逻辑封装为可复用的组合函数\n\n\n模块化设计：按业务功能划分模块，启用命名空间\n\n\n类型安全：Vuex 4 提供了更好的 TypeScript 支持\n\n\n性能优化：利用计算属性缓存、shallowRef 等特性优化性能\n\n\n何时使用 Vuex：\n\n\n构建中大型单页应用\n\n\n需要在多个组件间共享状态\n\n\n状态逻辑复杂，需要统一管理\n\n\n需要追踪状态变更历史\n\n\n通过合理使用 Vuex 和组合式 API，可以显著提高 Vue 3 应用的可维护性和可扩展性，让状态管理变得更加清晰和可控。\n参考资源：\n\n\nVuex 官方文档\n\n\nVue 3 组合式 API 文档\n\n\nVue Devtools\n\n\n","categories":["编程"],"tags":["Web"]},{"title":"C++并发编程核心知识体系","url":"/2025/10/11/C++/C++%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%9A%E4%BB%8E%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%88%B0%E5%93%B2%E5%AD%A6%E6%80%9D%E6%83%B3/","content":"\n如题，结合官方文档与网络帖子，利用AI整理\n\n\nC++ 并发编程核心知识体系：从技术实现到哲学思想\n目录\n\n\n并发编程概述\n\n\nC++ 线程基础：std::thread\n\n\n互斥锁机制：std::mutex 家族\n\n\n条件变量：线程间通信的艺术\n\n\n并发设计模式\n\n\n内存模型与原子操作\n\n\n异步操作：非阻塞编程范式\n\n\n并发编程哲学思想\n\n\n最佳实践与设计原则\n\n\n常见问题与解决方案\n\n\n1. 并发编程概述\n1.1 什么是并发编程\n并发编程是指在同一时间间隔内执行多个任务的编程范式。在 C++ 中，这主要通过多线程来实现，每个线程代表一个独立的执行路径。\n1.2 并发编程的核心挑战\n\n\n数据竞争：多个线程同时访问共享数据\n\n\n死锁：线程间相互等待对方释放资源\n\n\n活锁：线程不断改变状态但无法继续执行\n\n\n内存可见性：CPU 缓存导致的操作不可见问题\n\n\n指令重排序：编译器和 CPU 的优化导致执行顺序变化\n\n\n1.3 C++ 并发编程的发展历程\n\n\nC++11：引入了标准的并发编程支持\n\n\nC++14：完善了并发库功能\n\n\nC++17：新增了共享锁等特性\n\n\nC++20：引入了协程等高级特性\n\n\n2. C++ 线程基础：std::thread\n2.1 线程的创建与管理\n基本线程创建\n#include &lt;iostream&gt;#include &lt;thread&gt;void thread_function() &#123;    std::cout &lt;&lt; &quot;Hello from thread!&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t(thread_function);  // 创建线程    t.join();                        // 等待线程完成    return 0;&#125;\n传递参数\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;void print_message(const std::string&amp; message, int count) &#123;    for (int i = 0; i &lt; count; ++i) &#123;        std::cout &lt;&lt; message &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    std::string msg = &quot;Hello&quot;;    std::thread t(print_message, msg, 5);    t.join();    return 0;&#125;\n2.2 线程的生命周期管理\njoin() vs detach()\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;void long_running_task() &#123;    std::this_thread::sleep_for(std::chrono::seconds(3));    std::cout &lt;&lt; &quot;Task completed!&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t(long_running_task);        // 使用join()：主线程等待子线程完成    // t.join();        // 使用detach()：子线程在后台运行    t.detach();        std::cout &lt;&lt; &quot;Main thread exiting...&quot; &lt;&lt; std::endl;    return 0;&#125;\n2.3 线程属性控制\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;void thread_with_high_priority() &#123;    // 在支持的平台上设置线程优先级    #ifdef _WIN32        // Windows平台设置优先级        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);    #elif defined(__linux__)        // Linux平台设置优先级        struct sched_param param;        param.sched_priority = 99;        pthread_setschedparam(pthread_self(), SCHED_FIFO, &amp;param);    #endif        std::cout &lt;&lt; &quot;High priority thread running...&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t(thread_with_high_priority);    t.join();    return 0;&#125;\n3. 互斥锁机制：std::mutex 家族\n3.1 互斥锁的基本概念\n互斥锁（Mutex）是保证线程间互斥访问共享资源的同步原语。\n3.2 各种互斥锁类型\nstd::mutex - 基本互斥锁\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;vector&gt;std::mutex mtx;int shared_counter = 0;void increment_counter() &#123;    for (int i = 0; i &lt; 100000; ++i) &#123;        mtx.lock();        shared_counter++;        mtx.unlock();    &#125;&#125;int main() &#123;    std::vector&lt;std::thread&gt; threads;        for (int i = 0; i &lt; 10; ++i) &#123;        threads.emplace_back(increment_counter);    &#125;        for (auto&amp; t : threads) &#123;        t.join();    &#125;        std::cout &lt;&lt; &quot;Final counter value: &quot; &lt;&lt; shared_counter &lt;&lt; std::endl;    return 0;&#125;\nstd::lock_guard - RAII 风格的锁管理\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;vector&gt;std::mutex mtx;int shared_counter = 0;void increment_counter() &#123;    for (int i = 0; i &lt; 100000; ++i) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        shared_counter++;        // 锁会在离开作用域时自动释放    &#125;&#125;int main() &#123;    std::vector&lt;std::thread&gt; threads;        for (int i = 0; i &lt; 10; ++i) &#123;        threads.emplace_back(increment_counter);    &#125;        for (auto&amp; t : threads) &#123;        t.join();    &#125;        std::cout &lt;&lt; &quot;Final counter value: &quot; &lt;&lt; shared_counter &lt;&lt; std::endl;    return 0;&#125;\nstd::unique_lock - 更灵活的锁管理\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;vector&gt;std::mutex mtx;int shared_counter = 0;void increment_counter() &#123;    for (int i = 0; i &lt; 100000; ++i) &#123;        std::unique_lock&lt;std::mutex&gt; lock(mtx);        shared_counter++;                // 可以手动解锁和重新锁定        lock.unlock();        // 执行一些不需要锁的操作        lock.lock();        shared_counter++;    &#125;&#125;int main() &#123;    std::vector&lt;std::thread&gt; threads;        for (int i = 0; i &lt; 10; ++i) &#123;        threads.emplace_back(increment_counter);    &#125;        for (auto&amp; t : threads) &#123;        t.join();    &#125;        std::cout &lt;&lt; &quot;Final counter value: &quot; &lt;&lt; shared_counter &lt;&lt; std::endl;    return 0;&#125;\nC++17 共享锁：std::shared_mutex\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;shared_mutex&gt;#include &lt;vector&gt;std::shared_mutex rw_mutex;int shared_data = 0;// 读操作：可以多个线程同时进行void reader_thread(int id) &#123;    std::shared_lock&lt;std::shared_mutex&gt; lock(rw_mutex);    std::cout &lt;&lt; &quot;Reader &quot; &lt;&lt; id &lt;&lt; &quot; read data: &quot; &lt;&lt; shared_data &lt;&lt; std::endl;&#125;// 写操作：独占访问void writer_thread(int id) &#123;    std::unique_lock&lt;std::shared_mutex&gt; lock(rw_mutex);    shared_data++;    std::cout &lt;&lt; &quot;Writer &quot; &lt;&lt; id &lt;&lt; &quot; wrote data: &quot; &lt;&lt; shared_data &lt;&lt; std::endl;&#125;int main() &#123;    std::vector&lt;std::thread&gt; threads;        // 创建多个读者线程    for (int i = 0; i &lt; 5; ++i) &#123;        threads.emplace_back(reader_thread, i);    &#125;        // 创建写者线程    for (int i = 0; i &lt; 2; ++i) &#123;        threads.emplace_back(writer_thread, i);    &#125;        for (auto&amp; t : threads) &#123;        t.join();    &#125;        return 0;&#125;\n3.3 避免死锁的技术\n1. 统一锁获取顺序\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mutex1, mutex2;void thread1() &#123;    std::lock(mutex1, mutex2);  // 同时获取多个锁    std::lock_guard&lt;std::mutex&gt; lock1(mutex1, std::adopt_lock);    std::lock_guard&lt;std::mutex&gt; lock2(mutex2, std::adopt_lock);        std::cout &lt;&lt; &quot;Thread 1 acquired both mutexes&quot; &lt;&lt; std::endl;&#125;void thread2() &#123;    std::lock(mutex1, mutex2);  // 保持相同的获取顺序    std::lock_guard&lt;std::mutex&gt; lock1(mutex1, std::adopt_lock);    std::lock_guard&lt;std::mutex&gt; lock2(mutex2, std::adopt_lock);        std::cout &lt;&lt; &quot;Thread 2 acquired both mutexes&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(thread1);    std::thread t2(thread2);        t1.join();    t2.join();        return 0;&#125;\n2. 使用 try_lock 避免死锁\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;std::mutex mutex1, mutex2;void thread1() &#123;    while (true) &#123;        if (mutex1.try_lock()) &#123;            std::cout &lt;&lt; &quot;Thread 1 acquired mutex1&quot; &lt;&lt; std::endl;                        if (mutex2.try_lock()) &#123;                std::cout &lt;&lt; &quot;Thread 1 acquired mutex2&quot; &lt;&lt; std::endl;                // 执行操作                mutex2.unlock();                mutex1.unlock();                break;            &#125; else &#123;                mutex1.unlock();                std::this_thread::sleep_for(std::chrono::milliseconds(10));            &#125;        &#125; else &#123;            std::this_thread::sleep_for(std::chrono::milliseconds(10));        &#125;    &#125;&#125;int main() &#123;    std::thread t1(thread1);    t1.join();    return 0;&#125;\n4. 条件变量：线程间通信的艺术\n4.1 条件变量的基本概念\n条件变量（Condition Variable）用于线程间的通信，允许一个线程等待另一个线程满足某个条件。\n4.2 std::condition_variable 的使用\n生产者 - 消费者模式\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;chrono&gt;std::mutex mtx;std::condition_variable cv;std::queue&lt;int&gt; data_queue;bool stop_flag = false;// 生产者线程void producer() &#123;    for (int i = 0; i &lt; 10; ++i) &#123;        &#123;            std::lock_guard&lt;std::mutex&gt; lock(mtx);            data_queue.push(i);            std::cout &lt;&lt; &quot;Produced: &quot; &lt;&lt; i &lt;&lt; std::endl;        &#125;        cv.notify_one();  // 通知消费者        std::this_thread::sleep_for(std::chrono::milliseconds(500));    &#125;        // 通知消费者停止    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        stop_flag = true;    &#125;    cv.notify_one();&#125;// 消费者线程void consumer() &#123;    while (true) &#123;        std::unique_lock&lt;std::mutex&gt; lock(mtx);                // 等待条件：队列不为空或停止标志为true        cv.wait(lock, []&#123;             return !data_queue.empty() || stop_flag;         &#125;);                // 检查是否需要停止        if (stop_flag &amp;&amp; data_queue.empty()) &#123;            break;        &#125;                // 处理数据        if (!data_queue.empty()) &#123;            int data = data_queue.front();            data_queue.pop();            std::cout &lt;&lt; &quot;Consumed: &quot; &lt;&lt; data &lt;&lt; std::endl;        &#125;    &#125;    std::cout &lt;&lt; &quot;Consumer stopped&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::thread prod_thread(producer);    std::thread cons_thread(consumer);        prod_thread.join();    cons_thread.join();        return 0;&#125;\n4.3 条件变量的高级用法\n多个条件变量的协调\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;queue&gt;#include &lt;chrono&gt;std::mutex mtx;std::condition_variable cv_producer;std::condition_variable cv_consumer;std::queue&lt;int&gt; data_queue;const int MAX_QUEUE_SIZE = 5;bool stop_flag = false;void producer() &#123;    for (int i = 0; i &lt; 10; ++i) &#123;        std::unique_lock&lt;std::mutex&gt; lock(mtx);                // 等待队列有空间        cv_producer.wait(lock, []&#123;            return data_queue.size() &lt; MAX_QUEUE_SIZE || stop_flag;        &#125;);                if (stop_flag) break;                data_queue.push(i);        std::cout &lt;&lt; &quot;Produced: &quot; &lt;&lt; i &lt;&lt; &quot;, Queue size: &quot; &lt;&lt; data_queue.size() &lt;&lt; std::endl;                cv_consumer.notify_one();  // 通知消费者    &#125;        // 通知消费者停止    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        stop_flag = true;    &#125;    cv_consumer.notify_all();&#125;void consumer() &#123;    while (true) &#123;        std::unique_lock&lt;std::mutex&gt; lock(mtx);                // 等待队列有数据        cv_consumer.wait(lock, []&#123;            return !data_queue.empty() || stop_flag;        &#125;);                if (stop_flag &amp;&amp; data_queue.empty()) &#123;            break;        &#125;                if (!data_queue.empty()) &#123;            int data = data_queue.front();            data_queue.pop();            std::cout &lt;&lt; &quot;Consumed: &quot; &lt;&lt; data &lt;&lt; &quot;, Queue size: &quot; &lt;&lt; data_queue.size() &lt;&lt; std::endl;                        cv_producer.notify_one();  // 通知生产者队列有空间        &#125;    &#125;&#125;int main() &#123;    std::thread prod_thread(producer);    std::thread cons_thread1(consumer);    std::thread cons_thread2(consumer);        prod_thread.join();    cons_thread1.join();    cons_thread2.join();        return 0;&#125;\n5. 并发设计模式\n5.1 Fork-Join 模式\nFork-Join 模式将大任务分解为多个小任务并行执行，然后合并结果。\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;numeric&gt;template&lt;typename Iterator, typename T&gt;struct accumulate_block &#123;    void operator()(Iterator first, Iterator last, T&amp; result) &#123;        result = std::accumulate(first, last, result);    &#125;&#125;;template&lt;typename Iterator, typename T&gt;T parallel_accumulate(Iterator first, Iterator last, T init) &#123;    unsigned long const length = std::distance(first, last);        if (!length)        return init;        unsigned long const min_per_thread = 25;    unsigned long const max_threads = (length + min_per_thread - 1) / min_per_thread;    unsigned long const hardware_threads = std::thread::hardware_concurrency();    unsigned long const num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads);    unsigned long const block_size = length / num_threads;        std::vector&lt;T&gt; results(num_threads);    std::vector&lt;std::thread&gt; threads(num_threads - 1);        Iterator block_start = first;    for (unsigned long i = 0; i &lt; (num_threads - 1); ++i) &#123;        Iterator block_end = block_start;        std::advance(block_end, block_size);        threads[i] = std::thread(            accumulate_block&lt;Iterator, T&gt;(),            block_start, block_end, std::ref(results[i])        );        block_start = block_end;    &#125;        accumulate_block&lt;Iterator, T&gt;()(block_start, last, results[num_threads - 1]);        for (auto&amp; entry : threads) &#123;        entry.join();    &#125;        return std::accumulate(results.begin(), results.end(), init);&#125;int main() &#123;    std::vector&lt;int&gt; numbers(1000000, 1);        int result = parallel_accumulate(numbers.begin(), numbers.end(), 0);        std::cout &lt;&lt; &quot;Parallel accumulate result: &quot; &lt;&lt; result &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Expected result: &quot; &lt;&lt; numbers.size() &lt;&lt; std::endl;        return 0;&#125;\n5.2 线程池模式\n线程池预先创建一组线程，用于执行多个任务。\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;functional&gt;#include &lt;future&gt;#include &lt;stdexcept&gt;class ThreadPool &#123;public:    ThreadPool(size_t threads);        template&lt;class F, class... Args&gt;    auto enqueue(F&amp;&amp; f, Args&amp;&amp;... args)         -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;;        ~ThreadPool();    private:    std::vector&lt;std::thread&gt; workers;    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;        std::mutex queue_mutex;    std::condition_variable condition;    bool stop;&#125;;ThreadPool::ThreadPool(size_t threads)     : stop(false) &#123;        for (size_t i = 0; i &lt; threads; ++i) &#123;        workers.emplace_back([this] &#123;            for (;;) &#123;                std::function&lt;void()&gt; task;                                &#123;                    std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex);                    this-&gt;condition.wait(lock, [this] &#123;                        return this-&gt;stop || !this-&gt;tasks.empty();                    &#125;);                                        if (this-&gt;stop &amp;&amp; this-&gt;tasks.empty())                        return;                                        task = std::move(this-&gt;tasks.front());                    this-&gt;tasks.pop();                &#125;                                task();            &#125;        &#125;);    &#125;&#125;template&lt;class F, class... Args&gt;auto ThreadPool::enqueue(F&amp;&amp; f, Args&amp;&amp;... args)     -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; &#123;        using return_type = typename std::result_of&lt;F(Args...)&gt;::type;        auto task = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(        std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)    );        std::future&lt;return_type&gt; res = task-&gt;get_future();        &#123;        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex);                if (stop)            throw std::runtime_error(&quot;enqueue on stopped ThreadPool&quot;);                tasks.emplace([task]() &#123; (*task)(); &#125;);    &#125;        condition.notify_one();    return res;&#125;ThreadPool::~ThreadPool() &#123;    &#123;        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex);        stop = true;    &#125;        condition.notify_all();        for (std::thread&amp; worker : workers)        worker.join();&#125;// 使用示例int calculate_square(int x) &#123;    return x * x;&#125;int main() &#123;    ThreadPool pool(4);    std::vector&lt;std::future&lt;int&gt;&gt; results;        for (int i = 0; i &lt; 8; ++i) &#123;        results.emplace_back(            pool.enqueue(calculate_square, i)        );    &#125;        for (auto&amp;&amp; result : results) &#123;        std::cout &lt;&lt; result.get() &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;        return 0;&#125;\n5.3 读写锁模式\n读写锁允许多个读者同时访问，但写者需要独占访问。\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;shared_mutex&gt;#include &lt;vector&gt;#include &lt;chrono&gt;class SharedData &#123;private:    int data_;    mutable std::shared_mutex mutex_;    public:    SharedData(int initial_data) : data_(initial_data) &#123;&#125;        // 读操作：共享访问    int read_data() const &#123;        std::shared_lock&lt;std::shared_mutex&gt; lock(mutex_);        std::this_thread::sleep_for(std::chrono::milliseconds(10));        return data_;    &#125;        // 写操作：独占访问    void write_data(int new_value) &#123;        std::unique_lock&lt;std::shared_mutex&gt; lock(mutex_);        std::this_thread::sleep_for(std::chrono::milliseconds(100));        data_ = new_value;    &#125;&#125;;void reader_thread(SharedData&amp; data, int id) &#123;    for (int i = 0; i &lt; 5; ++i) &#123;        int value = data.read_data();        std::cout &lt;&lt; &quot;Reader &quot; &lt;&lt; id &lt;&lt; &quot; read: &quot; &lt;&lt; value &lt;&lt; std::endl;        std::this_thread::sleep_for(std::chrono::milliseconds(50));    &#125;&#125;void writer_thread(SharedData&amp; data, int id, int start_value) &#123;    for (int i = 0; i &lt; 3; ++i) &#123;        int new_value = start_value + i;        data.write_data(new_value);        std::cout &lt;&lt; &quot;Writer &quot; &lt;&lt; id &lt;&lt; &quot; wrote: &quot; &lt;&lt; new_value &lt;&lt; std::endl;        std::this_thread::sleep_for(std::chrono::milliseconds(200));    &#125;&#125;int main() &#123;    SharedData data(0);    std::vector&lt;std::thread&gt; threads;        // 创建5个读者线程    for (int i = 0; i &lt; 5; ++i) &#123;        threads.emplace_back(reader_thread, std::ref(data), i);    &#125;        // 创建2个写者线程    threads.emplace_back(writer_thread, std::ref(data), 0, 100);    threads.emplace_back(writer_thread, std::ref(data), 1, 200);        for (auto&amp; t : threads) &#123;        t.join();    &#125;        return 0;&#125;\n6. 内存模型与原子操作\n6.1 C++ 内存模型基础\nC++ 内存模型定义了多线程环境下内存操作的可见性和顺序性规则。\n6.2 原子操作详解\n基本原子类型\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;vector&gt;std::atomic&lt;int&gt; atomic_counter(0);int normal_counter = 0;void increment_counters() &#123;    for (int i = 0; i &lt; 100000; ++i) &#123;        atomic_counter++;        normal_counter++;    &#125;&#125;int main() &#123;    std::vector&lt;std::thread&gt; threads;        for (int i = 0; i &lt; 10; ++i) &#123;        threads.emplace_back(increment_counters);    &#125;        for (auto&amp; t : threads) &#123;        t.join();    &#125;        std::cout &lt;&lt; &quot;Atomic counter: &quot; &lt;&lt; atomic_counter &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Normal counter: &quot; &lt;&lt; normal_counter &lt;&lt; std::endl;        return 0;&#125;\n原子操作的内存顺序\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;vector&gt;std::atomic&lt;bool&gt; x(false), y(false);std::atomic&lt;int&gt; z(0);void write_x() &#123;    x.store(true, std::memory_order_release);&#125;void write_y() &#123;    y.store(true, std::memory_order_release);&#125;void read_x_then_y() &#123;    while (!x.load(std::memory_order_acquire));    if (y.load(std::memory_order_acquire)) &#123;        z++;    &#125;&#125;void read_y_then_x() &#123;    while (!y.load(std::memory_order_acquire));    if (x.load(std::memory_order_acquire)) &#123;        z++;    &#125;&#125;int main() &#123;    for (int i = 0; i &lt; 10000; ++i) &#123;        x = false;        y = false;        z = 0;                std::thread a(write_x);        std::thread b(write_y);        std::thread c(read_x_then_y);        std::thread d(read_y_then_x);                a.join();        b.join();        c.join();        d.join();                if (z.load() == 0) &#123;            std::cout &lt;&lt; &quot;z is 0 after &quot; &lt;&lt; i + 1 &lt;&lt; &quot; iterations&quot; &lt;&lt; std::endl;        &#125;    &#125;        return 0;&#125;\n无锁数据结构\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;vector&gt;template&lt;typename T&gt;class LockFreeStack &#123;private:    struct Node &#123;        T data;        Node* next;                Node(const T&amp; data) : data(data), next(nullptr) &#123;&#125;    &#125;;        std::atomic&lt;Node*&gt; head;    public:    LockFreeStack() : head(nullptr) &#123;&#125;        ~LockFreeStack() &#123;        while (Node* old_head = head.load()) &#123;            head.store(old_head-&gt;next);            delete old_head;        &#125;    &#125;        void push(const T&amp; data) &#123;        Node* new_node = new Node(data);        new_node-&gt;next = head.load();                // 使用compare_exchange_weak处理并发        while (!head.compare_exchange_weak(new_node-&gt;next, new_node)) &#123;            // 重试直到成功        &#125;    &#125;        bool pop(T&amp; result) &#123;        Node* old_head = head.load();                while (old_head &amp;&amp; !head.compare_exchange_weak(old_head, old_head-&gt;next)) &#123;            // 重试直到成功或栈为空        &#125;                if (!old_head) &#123;            return false;        &#125;                result = old_head-&gt;data;        delete old_head;        return true;    &#125;        bool empty() const &#123;        return head.load() == nullptr;    &#125;&#125;;void push_to_stack(LockFreeStack&lt;int&gt;&amp; stack, int start, int end) &#123;    for (int i = start; i &lt; end; ++i) &#123;        stack.push(i);    &#125;&#125;void pop_from_stack(LockFreeStack&lt;int&gt;&amp; stack, int count, std::vector&lt;int&gt;&amp; results) &#123;    int value;    for (int i = 0; i &lt; count; ++i) &#123;        if (stack.pop(value)) &#123;            results.push_back(value);        &#125;    &#125;&#125;int main() &#123;    LockFreeStack&lt;int&gt; stack;    std::vector&lt;int&gt; results1, results2;        std::thread pusher1(push_to_stack, std::ref(stack), 0, 1000);    std::thread pusher2(push_to_stack, std::ref(stack), 1000, 2000);    std::thread popper1(pop_from_stack, std::ref(stack), 1000, std::ref(results1));    std::thread popper2(pop_from_stack, std::ref(stack), 1000, std::ref(results2));        pusher1.join();    pusher2.join();    popper1.join();    popper2.join();        std::cout &lt;&lt; &quot;Pushed 2000 elements&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Popped &quot; &lt;&lt; results1.size() + results2.size() &lt;&lt; &quot; elements&quot; &lt;&lt; std::endl;        return 0;&#125;\n7. 异步操作：非阻塞编程范式\n7.1 异步编程概述\n7.1.1 什么是异步编程\n异步编程是一种编程范式，它允许程序在等待操作完成（如网络请求、文件 I/O、数据库查询等）时继续执行其他任务。与同步编程不同，异步操作不会阻塞当前执行流程。\n7.1.2 同步 vs 异步的本质区别\n\n\n\n特性\n同步 (Synchronous)\n异步 (Asynchronous)\n\n\n\n\n执行方式\n顺序执行，一步接一步\n并发执行，无需等待\n\n\n等待行为\n阻塞等待结果返回\n非阻塞，立即返回\n\n\n资源利用\n低效（CPU 常闲置等待）\n高效（CPU 持续工作）\n\n\n编程模型\n直线式思维，易于理解\n事件驱动 / 回调思维\n\n\n复杂度\n简单直接\n较复杂（回调地狱风险）\n\n\n适用场景\nCPU 密集型任务、简单脚本\nI/O 密集型、高并发服务\n\n\n\n7.1.3 生活中的异步哲学\n同步场景：在快餐店排队点餐 - 必须等前一个人完成才能点餐异步场景：在正餐厅桌边点餐 - 点餐后可以做其他事，服务员会送餐\n7.2 C++ 异步编程组件\n7.2.1 std::future - 异步结果的占位符\nstd::future 表示一个异步操作的结果，可以在未来某个时间点获取。\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;chrono&gt;// 模拟耗时计算int expensive_calculation(int x, int y) &#123;    std::this_thread::sleep_for(std::chrono::seconds(2));    return x * y;&#125;int main() &#123;    std::cout &lt;&lt; &quot;Main thread started&quot; &lt;&lt; std::endl;        // 启动异步任务    std::future&lt;int&gt; result_future = std::async(expensive_calculation, 10, 20);        // 主线程可以继续执行其他任务    std::cout &lt;&lt; &quot;Main thread is doing other work...&quot; &lt;&lt; std::endl;    for (int i = 0; i &lt; 5; ++i) &#123;        std::cout &lt;&lt; &quot;Main: &quot; &lt;&lt; i &lt;&lt; std::endl;        std::this_thread::sleep_for(std::chrono::milliseconds(300));    &#125;        // 获取异步任务结果（如果未完成会阻塞）    std::cout &lt;&lt; &quot;Waiting for async result...&quot; &lt;&lt; std::endl;    int result = result_future.get();    std::cout &lt;&lt; &quot;Async result: &quot; &lt;&lt; result &lt;&lt; std::endl;        return 0;&#125;\n7.2.2 std::async - 异步任务启动器\nstd::async 是启动异步任务的便捷函数，返回一个 std::future 对象。\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;vector&gt;// 并行计算示例int parallel_sum(const std::vector&lt;int&gt;&amp; data, int start, int end) &#123;    int sum = 0;    for (int i = start; i &lt; end; ++i) &#123;        sum += data[i];    &#125;    return sum;&#125;int main() &#123;    std::vector&lt;int&gt; large_data(1000000, 1);        // 将数据分成4个部分并行计算    int mid1 = large_data.size() / 4;    int mid2 = large_data.size() / 2;    int mid3 = 3 * large_data.size() / 4;        std::future&lt;int&gt; f1 = std::async(parallel_sum, std::ref(large_data), 0, mid1);    std::future&lt;int&gt; f2 = std::async(parallel_sum, std::ref(large_data), mid1, mid2);    std::future&lt;int&gt; f3 = std::async(parallel_sum, std::ref(large_data), mid2, mid3);    std::future&lt;int&gt; f4 = std::async(parallel_sum, std::ref(large_data), mid3, large_data.size());        // 汇总结果    int total = f1.get() + f2.get() + f3.get() + f4.get();    std::cout &lt;&lt; &quot;Total sum: &quot; &lt;&lt; total &lt;&lt; std::endl;        return 0;&#125;\n7.2.3 std::promise - 主动设置异步结果\nstd::promise 允许一个线程设置结果，另一个线程通过 std::future 获取结果。\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;thread&gt;#include &lt;chrono&gt;void worker_thread(std::promise&lt;int&gt;&amp; prom) &#123;    try &#123;        std::cout &lt;&lt; &quot;Worker thread started&quot; &lt;&lt; std::endl;        std::this_thread::sleep_for(std::chrono::seconds(2));                // 模拟计算        int result = 42;                // 设置结果        prom.set_value(result);        std::cout &lt;&lt; &quot;Worker thread finished&quot; &lt;&lt; std::endl;    &#125; catch (...) &#123;        // 设置异常        prom.set_exception(std::current_exception());    &#125;&#125;int main() &#123;    std::promise&lt;int&gt; prom;    std::future&lt;int&gt; fut = prom.get_future();        // 启动工作线程    std::thread t(worker_thread, std::ref(prom));        std::cout &lt;&lt; &quot;Main thread waiting for result...&quot; &lt;&lt; std::endl;        // 获取结果    try &#123;        int result = fut.get();        std::cout &lt;&lt; &quot;Result from worker: &quot; &lt;&lt; result &lt;&lt; std::endl;    &#125; catch (const std::exception&amp; e) &#123;        std::cerr &lt;&lt; &quot;Exception from worker: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;        t.join();    return 0;&#125;\n7.2.4 std::packaged_task - 任务包装器\nstd::packaged_task 将可调用对象包装起来，方便作为线程函数使用。\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;thread&gt;#include &lt;vector&gt;// 矩阵乘法的一部分void matrix_multiply_part(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; A,                          const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; B,                          std::vector&lt;std::vector&lt;int&gt;&gt;&amp; C,                          int start_row, int end_row) &#123;    int cols_B = B[0].size();    int cols_A = A[0].size();        for (int i = start_row; i &lt; end_row; ++i) &#123;        for (int j = 0; j &lt; cols_B; ++j) &#123;            C[i][j] = 0;            for (int k = 0; k &lt; cols_A; ++k) &#123;                C[i][j] += A[i][k] * B[k][j];            &#125;        &#125;    &#125;&#125;int main() &#123;    const int size = 100;    std::vector&lt;std::vector&lt;int&gt;&gt; A(size, std::vector&lt;int&gt;(size, 1));    std::vector&lt;std::vector&lt;int&gt;&gt; B(size, std::vector&lt;int&gt;(size, 2));    std::vector&lt;std::vector&lt;int&gt;&gt; C(size, std::vector&lt;int&gt;(size, 0));        int num_threads = std::thread::hardware_concurrency();    int rows_per_thread = size / num_threads;        std::vector&lt;std::future&lt;void&gt;&gt; futures;        for (int i = 0; i &lt; num_threads; ++i) &#123;        int start = i * rows_per_thread;        int end = (i == num_threads - 1) ? size : (i + 1) * rows_per_thread;                // 使用packaged_task包装任务        std::packaged_task&lt;void()&gt; task([&amp;, start, end]() &#123;            matrix_multiply_part(A, B, C, start, end);        &#125;);                futures.push_back(task.get_future());                // 启动线程执行任务        std::thread t(std::move(task));        t.detach();    &#125;        // 等待所有任务完成    for (auto&amp; fut : futures) &#123;        fut.get();    &#125;        std::cout &lt;&lt; &quot;Matrix multiplication completed&quot; &lt;&lt; std::endl;    return 0;&#125;\n7.3 异步编程的设计原理\n7.3.1 异步编程的核心原理\n1. 事件驱动模型\n异步编程基于事件驱动模型，程序通过响应事件来处理任务完成。\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;queue&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;functional&gt;class EventLoop &#123;private:    std::queue&lt;std::function&lt;void()&gt;&gt; events_;    std::mutex mtx_;    std::condition_variable cv_;    bool running_;    public:    EventLoop() : running_(true) &#123;&#125;        void post(std::function&lt;void()&gt; event) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);        events_.push(event);        cv_.notify_one();    &#125;        void run() &#123;        while (running_) &#123;            std::unique_lock&lt;std::mutex&gt; lock(mtx_);            cv_.wait(lock, [this]&#123; return !events_.empty() || !running_; &#125;);                        if (!running_) break;                        auto event = events_.front();            events_.pop();            lock.unlock();                        event();        &#125;    &#125;        void stop() &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);        running_ = false;        cv_.notify_one();    &#125;&#125;;// 使用事件循环的异步任务void async_task(EventLoop&amp; loop, int id) &#123;    std::cout &lt;&lt; &quot;Async task &quot; &lt;&lt; id &lt;&lt; &quot; started&quot; &lt;&lt; std::endl;        // 模拟异步操作    std::thread([&amp;loop, id]() &#123;        std::this_thread::sleep_for(std::chrono::seconds(1));                // 任务完成后发布事件        loop.post([id]() &#123;            std::cout &lt;&lt; &quot;Async task &quot; &lt;&lt; id &lt;&lt; &quot; completed&quot; &lt;&lt; std::endl;        &#125;);    &#125;).detach();&#125;int main() &#123;    EventLoop loop;        // 启动事件循环线程    std::thread loop_thread([&amp;loop]() &#123;        loop.run();    &#125;);        // 提交多个异步任务    for (int i = 0; i &lt; 5; ++i) &#123;        async_task(loop, i);        std::this_thread::sleep_for(std::chrono::milliseconds(200));    &#125;        // 等待所有任务完成    std::this_thread::sleep_for(std::chrono::seconds(2));        loop.stop();    loop_thread.join();        return 0;&#125;\n2. 回调机制\n回调是异步编程的基础机制，当异步操作完成时调用预设的函数。\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;functional&gt;#include &lt;chrono&gt;// 异步文件读取模拟void async_file_read(const std::string&amp; filename,                     std::function&lt;void(const std::string&amp;)&gt; callback) &#123;    std::thread([filename, callback]() &#123;        std::this_thread::sleep_for(std::chrono::seconds(1));                // 模拟文件内容        std::string content = &quot;File content of &quot; + filename;                // 调用回调函数        callback(content);    &#125;).detach();&#125;// 链式异步操作void process_data_chain() &#123;    // 第一步：读取文件    async_file_read(&quot;data.txt&quot;, [](const std::string&amp; content) &#123;        std::cout &lt;&lt; &quot;Step 1: File read completed&quot; &lt;&lt; std::endl;                // 第二步：处理数据        std::string processed = content + &quot; (processed)&quot;;                // 第三步：保存结果        async_file_read(&quot;result.txt&quot;, [processed](const std::string&amp;) &#123;            std::cout &lt;&lt; &quot;Step 3: Result saved&quot; &lt;&lt; std::endl;            std::cout &lt;&lt; &quot;Final data: &quot; &lt;&lt; processed &lt;&lt; std::endl;        &#125;);    &#125;);&#125;int main() &#123;    std::cout &lt;&lt; &quot;Starting async processing chain...&quot; &lt;&lt; std::endl;    process_data_chain();        // 等待异步操作完成    std::this_thread::sleep_for(std::chrono::seconds(3));        return 0;&#125;\n7.3.2 异步编程模式\n1. 生产者 - 消费者模式的异步实现\n#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;chrono&gt;template&lt;typename T&gt;class AsyncQueue &#123;private:    std::queue&lt;T&gt; queue_;    std::mutex mtx_;    std::condition_variable cv_;    bool stopped_;    public:    AsyncQueue() : stopped_(false) &#123;&#125;        void push(const T&amp; item) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);        if (!stopped_) &#123;            queue_.push(item);            cv_.notify_one();        &#125;    &#125;        bool pop(T&amp; item, std::chrono::milliseconds timeout = std::chrono::milliseconds(0)) &#123;        std::unique_lock&lt;std::mutex&gt; lock(mtx_);                if (timeout.count() == 0) &#123;            cv_.wait(lock, [this]&#123; return !queue_.empty() || stopped_; &#125;);        &#125; else &#123;            if (!cv_.wait_for(lock, timeout, [this]&#123; return !queue_.empty() || stopped_; &#125;)) &#123;                return false;            &#125;        &#125;                if (stopped_ &amp;&amp; queue_.empty()) &#123;            return false;        &#125;                item = queue_.front();        queue_.pop();        return true;    &#125;        void stop() &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);        stopped_ = true;        cv_.notify_all();    &#125;        bool empty() const &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);        return queue_.empty();    &#125;&#125;;// 异步生产者void producer(AsyncQueue&lt;int&gt;&amp; queue) &#123;    for (int i = 0; i &lt; 10; ++i) &#123;        std::cout &lt;&lt; &quot;Producing: &quot; &lt;&lt; i &lt;&lt; std::endl;        queue.push(i);        std::this_thread::sleep_for(std::chrono::milliseconds(300));    &#125;    queue.stop();&#125;// 异步消费者void consumer(AsyncQueue&lt;int&gt;&amp; queue, const std::string&amp; name) &#123;    int item;    while (queue.pop(item)) &#123;        std::cout &lt;&lt; &quot;Consumer &quot; &lt;&lt; name &lt;&lt; &quot; processing: &quot; &lt;&lt; item &lt;&lt; std::endl;        std::this_thread::sleep_for(std::chrono::milliseconds(500));    &#125;    std::cout &lt;&lt; &quot;Consumer &quot; &lt;&lt; name &lt;&lt; &quot; stopped&quot; &lt;&lt; std::endl;&#125;int main() &#123;    AsyncQueue&lt;int&gt; queue;        // 启动生产者    std::thread prod_thread(producer, std::ref(queue));        // 启动消费者    std::thread cons_thread1(consumer, std::ref(queue), &quot;A&quot;);    std::thread cons_thread2(consumer, std::ref(queue), &quot;B&quot;);        prod_thread.join();    cons_thread1.join();    cons_thread2.join();        return 0;&#125;\n2. 异步工作池模式\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;future&gt;#include &lt;functional&gt;#include &lt;stdexcept&gt;class AsyncWorkerPool &#123;private:    std::vector&lt;std::thread&gt; workers_;    std::queue&lt;std::function&lt;void()&gt;&gt; tasks_;    std::mutex mtx_;    std::condition_variable cv_;    bool stop_;    public:    AsyncWorkerPool(size_t num_workers) : stop_(false) &#123;        for (size_t i = 0; i &lt; num_workers; ++i) &#123;            workers_.emplace_back([this] &#123;                while (true) &#123;                    std::function&lt;void()&gt; task;                                        &#123;                        std::unique_lock&lt;std::mutex&gt; lock(this-&gt;mtx_);                        this-&gt;cv_.wait(lock, [this] &#123;                            return this-&gt;stop_ || !this-&gt;tasks_.empty();                        &#125;);                                                if (this-&gt;stop_ &amp;&amp; this-&gt;tasks_.empty()) &#123;                            return;                        &#125;                                                task = std::move(this-&gt;tasks_.front());                        this-&gt;tasks_.pop();                    &#125;                                        task();                &#125;            &#125;);        &#125;    &#125;        template&lt;class F, class... Args&gt;    auto enqueue(F&amp;&amp; f, Args&amp;&amp;... args)         -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; &#123;                using return_type = typename std::result_of&lt;F(Args...)&gt;::type;                auto task = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(            std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)        );                std::future&lt;return_type&gt; res = task-&gt;get_future();                &#123;            std::unique_lock&lt;std::mutex&gt; lock(mtx_);                        if (stop_) &#123;                throw std::runtime_error(&quot;enqueue on stopped AsyncWorkerPool&quot;);            &#125;                        tasks_.emplace([task]() &#123; (*task)(); &#125;);        &#125;                cv_.notify_one();        return res;    &#125;        ~AsyncWorkerPool() &#123;        &#123;            std::unique_lock&lt;std::mutex&gt; lock(mtx_);            stop_ = true;        &#125;                cv_.notify_all();                for (std::thread&amp; worker : workers_) &#123;            worker.join();        &#125;    &#125;&#125;;// 复杂计算任务int complex_calculation(int x, int y) &#123;    std::this_thread::sleep_for(std::chrono::milliseconds(100));    return x * y;&#125;int main() &#123;    AsyncWorkerPool pool(4);    std::vector&lt;std::future&lt;int&gt;&gt; results;        // 提交多个异步任务    for (int i = 0; i &lt; 16; ++i) &#123;        results.emplace_back(            pool.enqueue(complex_calculation, i, i + 1)        );    &#125;        // 获取结果    for (auto&amp;&amp; result : results) &#123;        std::cout &lt;&lt; result.get() &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;        return 0;&#125;\n7.4 异步编程的哲学思想\n7.4.1 异步的时间哲学\n异步编程体现了对时间资源的深刻理解和优化利用：\n// 同步思维：浪费时间等待void synchronous_thinking() &#123;    // 等待每个操作完成后再进行下一个    auto result1 = operation1();  // 等待2秒    auto result2 = operation2(result1);  // 等待3秒    auto result3 = operation3(result2);  // 等待1秒        // 总时间：6秒，CPU利用率低&#125;// 异步思维：充分利用等待时间void asynchronous_thinking() &#123;    // 启动所有操作，在等待时做其他事情    auto future1 = async_operation1();    auto future2 = async_operation2();    auto future3 = async_operation3();        // 在等待结果时处理其他任务    do_other_work();        // 获取结果    auto result1 = future1.get();    auto result2 = future2.get();    auto result3 = future3.get();        // 总时间：3秒（取决于最慢的操作），CPU利用率高&#125;\n7.4.2 异步的资源哲学\n异步编程最大化了系统资源的利用效率：\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;chrono&gt;#include &lt;vector&gt;// I/O密集型任务void io_bound_task(int id) &#123;    std::cout &lt;&lt; &quot;Task &quot; &lt;&lt; id &lt;&lt; &quot; started (I/O bound)&quot; &lt;&lt; std::endl;        // 模拟I/O等待时间    std::this_thread::sleep_for(std::chrono::seconds(2));        std::cout &lt;&lt; &quot;Task &quot; &lt;&lt; id &lt;&lt; &quot; completed&quot; &lt;&lt; std::endl;&#125;int main() &#123;    const int num_tasks = 100;    std::vector&lt;std::future&lt;void&gt;&gt; futures;        auto start_time = std::chrono::high_resolution_clock::now();        // 异步执行多个I/O密集型任务    for (int i = 0; i &lt; num_tasks; ++i) &#123;        futures.emplace_back(std::async(std::launch::async, io_bound_task, i));    &#125;        // 等待所有任务完成    for (auto&amp; fut : futures) &#123;        fut.get();    &#125;        auto end_time = std::chrono::high_resolution_clock::now();    auto duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(        end_time - start_time    );        std::cout &lt;&lt; &quot;All &quot; &lt;&lt; num_tasks &lt;&lt; &quot; tasks completed in &quot;               &lt;&lt; duration.count() &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;        return 0;&#125;\n7.4.3 异步的责任链哲学\n异步编程建立了清晰的责任边界和协作模式：\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;functional&gt;#include &lt;string&gt;// 异步处理管道class AsyncPipeline &#123;public:    template&lt;typename T, typename Func&gt;    static auto process(const T&amp; input, Func&amp;&amp; func) &#123;        return std::async(std::launch::async, std::forward&lt;Func&gt;(func), input);    &#125;        template&lt;typename Future, typename Func&gt;    static auto then(Future&amp;&amp; future, Func&amp;&amp; func) &#123;        return std::async(std::launch::async, [future = std::move(future), func = std::forward&lt;Func&gt;(func)]() mutable &#123;            return func(future.get());        &#125;);    &#125;&#125;;// 数据处理步骤std::string read_data(const std::string&amp; filename) &#123;    std::cout &lt;&lt; &quot;Step 1: Reading data from &quot; &lt;&lt; filename &lt;&lt; std::endl;    return &quot;raw_data_from_&quot; + filename;&#125;std::string process_data(const std::string&amp; data) &#123;    std::cout &lt;&lt; &quot;Step 2: Processing data&quot; &lt;&lt; std::endl;    return data + &quot;_processed&quot;;&#125;void save_data(const std::string&amp; processed_data) &#123;    std::cout &lt;&lt; &quot;Step 3: Saving processed data&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Final data: &quot; &lt;&lt; processed_data &lt;&lt; std::endl;&#125;int main() &#123;    // 构建异步处理管道    auto final_future = AsyncPipeline::then(        AsyncPipeline::then(            AsyncPipeline::process(&quot;input.txt&quot;, read_data),            process_data        ),        save_data    );        // 等待整个管道完成    final_future.get();        return 0;&#125;\n7.5 异步编程的最佳实践\n7.5.1 避免回调地狱\n// ❌ 回调地狱：深层嵌套的回调函数void callback_hell() &#123;    async_operation1([](Result1 res1) &#123;        async_operation2(res1, [](Result2 res2) &#123;            async_operation3(res2, [](Result3 res3) &#123;                async_operation4(res3, [](Result4 res4) &#123;                    // 更多嵌套...                &#125;);            &#125;);        &#125;);    &#125;);&#125;// ✅ 使用future避免回调地狱void using_futures() &#123;    auto future1 = async_operation1();    auto future2 = future1.then([](Result1 res1) &#123;        return async_operation2(res1);    &#125;);    auto future3 = future2.then([](Result2 res2) &#123;        return async_operation3(res2);    &#125;);    auto future4 = future3.then([](Result3 res3) &#123;        return async_operation4(res3);    &#125;);        auto final_result = future4.get();&#125;\n7.5.2 正确处理异步异常\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;stdexcept&gt;#include &lt;chrono&gt;void may_throw(bool should_throw) &#123;    std::this_thread::sleep_for(std::chrono::seconds(1));        if (should_throw) &#123;        throw std::runtime_error(&quot;Something went wrong in async task&quot;);    &#125;        std::cout &lt;&lt; &quot;Async task completed successfully&quot; &lt;&lt; std::endl;&#125;int main() &#123;    try &#123;        // 启动可能抛出异常的异步任务        auto future1 = std::async(std::launch::async, may_throw, true);        auto future2 = std::async(std::launch::async, may_throw, false);                // 处理异常        try &#123;            future1.get();        &#125; catch (const std::exception&amp; e) &#123;            std::cerr &lt;&lt; &quot;Caught exception from first task: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        &#125;                future2.get();            &#125; catch (const std::exception&amp; e) &#123;        std::cerr &lt;&lt; &quot;Caught unexpected exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;        return 0;&#125;\n7.5.3 合理设置超时\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;chrono&gt;#include &lt;stdexcept&gt;void long_running_task() &#123;    std::this_thread::sleep_for(std::chrono::seconds(5));    std::cout &lt;&lt; &quot;Long running task completed&quot; &lt;&lt; std::endl;&#125;int main() &#123;    auto future = std::async(std::launch::async, long_running_task);        std::cout &lt;&lt; &quot;Waiting for task with timeout...&quot; &lt;&lt; std::endl;        // 设置2秒超时    auto status = future.wait_for(std::chrono::seconds(2));        if (status == std::future_status::ready) &#123;        std::cout &lt;&lt; &quot;Task completed within timeout&quot; &lt;&lt; std::endl;        future.get();    &#125; else if (status == std::future_status::timeout) &#123;        std::cout &lt;&lt; &quot;Task timed out after 2 seconds&quot; &lt;&lt; std::endl;        // 注意：无法直接取消std::future任务    &#125; else if (status == std::future_status::deferred) &#123;        std::cout &lt;&lt; &quot;Task is deferred&quot; &lt;&lt; std::endl;    &#125;        return 0;&#125;\n7.5.4 异步任务的取消机制\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;future&gt;#include &lt;chrono&gt;class CancellableTask &#123;private:    std::atomic&lt;bool&gt; cancelled_;    std::future&lt;void&gt; future_;    public:    template&lt;typename Func&gt;    CancellableTask(Func&amp;&amp; func) &#123;        cancelled_ = false;                future_ = std::async(std::launch::async, [this, func = std::forward&lt;Func&gt;(func)]() &#123;            func([this]() &#123; return cancelled_.load(); &#125;);        &#125;);    &#125;        void cancel() &#123;        cancelled_ = true;    &#125;        void wait() &#123;        if (future_.valid()) &#123;            future_.wait();        &#125;    &#125;        bool is_cancelled() const &#123;        return cancelled_.load();    &#125;&#125;;// 可取消的任务函数void cancellable_operation(const std::function&lt;bool()&gt;&amp; is_cancelled) &#123;    for (int i = 0; i &lt; 10; ++i) &#123;        // 检查是否被取消        if (is_cancelled()) &#123;            std::cout &lt;&lt; &quot;Task cancelled at iteration &quot; &lt;&lt; i &lt;&lt; std::endl;            return;        &#125;                std::cout &lt;&lt; &quot;Task iteration &quot; &lt;&lt; i &lt;&lt; std::endl;        std::this_thread::sleep_for(std::chrono::seconds(1));    &#125;        std::cout &lt;&lt; &quot;Task completed normally&quot; &lt;&lt; std::endl;&#125;int main() &#123;    std::cout &lt;&lt; &quot;Starting cancellable task...&quot; &lt;&lt; std::endl;        CancellableTask task(cancellable_operation);        // 运行3秒后取消任务    std::this_thread::sleep_for(std::chrono::seconds(3));    std::cout &lt;&lt; &quot;Cancelling task...&quot; &lt;&lt; std::endl;    task.cancel();        task.wait();        std::cout &lt;&lt; &quot;Main thread exiting&quot; &lt;&lt; std::endl;        return 0;&#125;\n7.6 异步编程的应用场景\n7.6.1 I/O 密集型应用\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;chrono&gt;// 模拟网络请求std::string fetch_data_from_network(const std::string&amp; url) &#123;    std::cout &lt;&lt; &quot;Fetching data from &quot; &lt;&lt; url &lt;&lt; std::endl;    std::this_thread::sleep_for(std::chrono::milliseconds(500));    return &quot;Data from &quot; + url;&#125;int main() &#123;    std::vector&lt;std::string&gt; urls = &#123;        &quot;http://example.com/api/data1&quot;,        &quot;http://example.com/api/data2&quot;,         &quot;http://example.com/api/data3&quot;,        &quot;http://example.com/api/data4&quot;    &#125;;        std::vector&lt;std::future&lt;std::string&gt;&gt; futures;        auto start_time = std::chrono::high_resolution_clock::now();        // 异步获取所有URL数据    for (const auto&amp; url : urls) &#123;        futures.emplace_back(            std::async(std::launch::async, fetch_data_from_network, url)        );    &#125;        // 处理结果    std::vector&lt;std::string&gt; results;    for (auto&amp; fut : futures) &#123;        results.push_back(fut.get());    &#125;        auto end_time = std::chrono::high_resolution_clock::now();    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(        end_time - start_time    );        std::cout &lt;&lt; &quot;All data fetched in &quot; &lt;&lt; duration.count() &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;        for (const auto&amp; result : results) &#123;        std::cout &lt;&lt; result &lt;&lt; std::endl;    &#125;        return 0;&#125;\n7.6.2 并行计算\n#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;algorithm&gt;// 并行求和template&lt;typename Iterator&gt;typename Iterator::value_type parallel_sum(Iterator begin, Iterator end) &#123;    auto distance = std::distance(begin, end);        // 小数据集直接计算    if (distance &lt;= 1000) &#123;        return std::accumulate(begin, end, 0);    &#125;        auto mid = begin;    std::advance(mid, distance / 2);        // 递归并行计算    auto future_left = std::async(std::launch::async, parallel_sum&lt;Iterator&gt;, begin, mid);    auto right_sum = parallel_sum(mid, end);    auto left_sum = future_left.get();        return left_sum + right_sum;&#125;int main() &#123;    std::vector&lt;int&gt; large_data(10000000, 1);        auto start_time = std::chrono::high_resolution_clock::now();        int total = parallel_sum(large_data.begin(), large_data.end());        auto end_time = std::chrono::high_resolution_clock::now();    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(        end_time - start_time    );        std::cout &lt;&lt; &quot;Total sum: &quot; &lt;&lt; total &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Time taken: &quot; &lt;&lt; duration.count() &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;        return 0;&#125;\n7.6.3 异步事件处理\n#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;thread&gt;#include &lt;functional&gt;#include &lt;chrono&gt;#include &lt;random&gt;class EventDispatcher &#123;private:    std::queue&lt;std::function&lt;void()&gt;&gt; events_;    std::mutex mtx_;    std::condition_variable cv_;    std::thread dispatcher_thread_;    bool running_;    public:    EventDispatcher() : running_(true) &#123;        dispatcher_thread_ = std::thread([this] &#123;            dispatch_loop();        &#125;);    &#125;        ~EventDispatcher() &#123;        stop();        if (dispatcher_thread_.joinable()) &#123;            dispatcher_thread_.join();        &#125;    &#125;        template&lt;typename Func&gt;    void post(Func&amp;&amp; func) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);        if (running_) &#123;            events_.emplace(std::forward&lt;Func&gt;(func));            cv_.notify_one();        &#125;    &#125;        void stop() &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);        running_ = false;        cv_.notify_one();    &#125;    private:    void dispatch_loop() &#123;        while (running_) &#123;            std::function&lt;void()&gt; event;                        &#123;                std::unique_lock&lt;std::mutex&gt; lock(mtx_);                cv_.wait(lock, [this] &#123;                    return !events_.empty() || !running_;                &#125;);                                if (!running_ &amp;&amp; events_.empty()) &#123;                    break;                &#125;                                if (!events_.empty()) &#123;                    event = std::move(events_.front());                    events_.pop();                &#125;            &#125;                        if (event) &#123;                try &#123;                    event();                &#125; catch (const std::exception&amp; e) &#123;                    std::cerr &lt;&lt; &quot;Event processing error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;                &#125;            &#125;        &#125;    &#125;&#125;;// 事件源class EventSource &#123;private:    EventDispatcher&amp; dispatcher_;    std::thread event_thread_;    std::atomic&lt;bool&gt; running_;    std::mt19937 rng_;    std::uniform_int_distribution&lt;&gt; dist_;    public:    EventSource(EventDispatcher&amp; dispatcher)         : dispatcher_(dispatcher), running_(true), rng_(std::random_device&#123;&#125;()), dist_(100, 1000) &#123;                event_thread_ = std::thread([this] &#123;            generate_events();        &#125;);    &#125;        ~EventSource() &#123;        running_ = false;        if (event_thread_.joinable()) &#123;            event_thread_.join();        &#125;    &#125;    private:    void generate_events() &#123;        int event_id = 0;                while (running_) &#123;            int delay = dist_(rng_);            std::this_thread::sleep_for(std::chrono::milliseconds(delay));                        // 发布事件            dispatcher_.post([event_id, delay] &#123;                std::cout &lt;&lt; &quot;Processing event &quot; &lt;&lt; event_id                           &lt;&lt; &quot; (generated after &quot; &lt;&lt; delay &lt;&lt; &quot;ms)&quot; &lt;&lt; std::endl;            &#125;);                        event_id++;        &#125;    &#125;&#125;;int main() &#123;    EventDispatcher dispatcher;    EventSource source(dispatcher);        std::cout &lt;&lt; &quot;Event system running. Press Enter to exit...&quot; &lt;&lt; std::endl;    std::cin.get();        return 0;&#125;\n8. 并发编程哲学思想\n8.1 并发编程的哲学基础\n8.1.1 共享内存 vs 消息传递\n共享内存模型：\n\n\n线程通过共享内存进行通信\n\n\n需要显式同步机制（锁、原子操作）\n\n\nC++ 标准采用的主要模型\n\n\n消息传递模型：\n\n\n线程通过发送消息进行通信\n\n\n数据在传递过程中所有权转移\n\n\nGo 语言的 goroutine+channel 是典型代表\n\n\n8.1.2 并发的本质：时间与空间的权衡\n并发编程本质上是在有限的物理资源（CPU 核心）上，通过时间分片来模拟并行执行。\n// 时间分片的哲学体现void concurrent_tasks() &#123;    // 任务A和任务B在同一个CPU核心上交替执行    std::thread t1([]&#123;        for (int i = 0; i &lt; 1000; ++i) &#123;            // 任务A的计算            std::this_thread::yield();  // 主动让出CPU时间片        &#125;    &#125;);        std::thread t2([]&#123;        for (int i = 0; i &lt; 1000; ++i) &#123;            // 任务B的计算            std::this_thread::yield();        &#125;    &#125;);        t1.join();    t2.join();&#125;\n8.2 并发编程的设计哲学\n8.2.1 最小同步原则\n只在必要时使用同步机制，减少锁竞争。\n// 不好的设计：过度同步class BadDesign &#123;private:    std::mutex mtx;    int a, b, c;    public:    void update_all(int new_a, int new_b, int new_c) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        a = new_a;        b = new_b;        c = new_c;    &#125;        // 即使只需要读取一个变量，也要获取整个对象的锁    int get_a() const &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        return a;    &#125;&#125;;// 更好的设计：细粒度同步class BetterDesign &#123;private:    std::mutex mtx_a, mtx_b, mtx_c;    int a, b, c;    public:    void update_a(int new_a) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_a);        a = new_a;    &#125;        int get_a() const &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_a);        return a;    &#125;        // 其他成员的类似方法...&#125;;\n8.2.2 不可变性原则\n使用不可变对象减少同步需求。\n// 不可变对象：创建后状态不再改变class ImmutableData &#123;private:    const int value_;    const std::string name_;    public:    ImmutableData(int value, const std::string&amp; name)        : value_(value), name_(name) &#123;&#125;        int get_value() const &#123; return value_; &#125;    std::string get_name() const &#123; return name_; &#125;        // 没有修改状态的方法&#125;;// 不可变对象可以安全地在多个线程间共享void process_data(const ImmutableData&amp; data) &#123;    // 读取操作不需要同步    std::cout &lt;&lt; data.get_name() &lt;&lt; &quot;: &quot; &lt;&lt; data.get_value() &lt;&lt; std::endl;&#125;\n8.2.3 单一职责原则在并发中的应用\n每个线程应该有明确的职责，避免功能耦合。\n// 职责分离的设计class DataProducer &#123;private:    std::queue&lt;int&gt; data_queue_;    std::mutex mtx_;    std::condition_variable cv_;    public:    void produce_data(int data) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);        data_queue_.push(data);        cv_.notify_one();    &#125;        bool consume_data(int&amp; data) &#123;        std::unique_lock&lt;std::mutex&gt; lock(mtx_);        if (cv_.wait_for(lock, std::chrono::seconds(1),             [this]&#123; return !data_queue_.empty(); &#125;)) &#123;            data = data_queue_.front();            data_queue_.pop();            return true;        &#125;        return false;    &#125;&#125;;// 专门的生产者线程void producer_task(DataProducer&amp; producer) &#123;    for (int i = 0; i &lt; 100; ++i) &#123;        producer.produce_data(i);        std::this_thread::sleep_for(std::chrono::milliseconds(10));    &#125;&#125;// 专门的消费者线程void consumer_task(DataProducer&amp; producer) &#123;    int data;    while (producer.consume_data(data)) &#123;        std::cout &lt;&lt; &quot;Consumed: &quot; &lt;&lt; data &lt;&lt; std::endl;    &#125;&#125;\n8.3 异步编程的哲学深化\n8.3.1 异步的 “等待哲学”\n异步编程重新定义了 “等待” 的概念：\n// 同步等待：消极等待，浪费时间void synchronous_waiting() &#123;    auto result = blocking_operation();  // 等待时什么都做不了    process_result(result);&#125;// 异步等待：积极等待，充分利用时间void asynchronous_waiting() &#123;    auto future = async_operation();        // 在等待结果时做其他有意义的事情    do_other_useful_work();        auto result = future.get();    process_result(result);&#125;\n8.3.2 异步的 “责任转移” 哲学\n异步操作体现了责任的转移和委托：\n// 同步模式：调用者承担所有责任Result synchronous_mode() &#123;    // 调用者必须等待并处理所有细节    return perform_complex_operation();&#125;// 异步模式：责任转移给系统std::future&lt;Result&gt; asynchronous_mode() &#123;    // 系统承担执行和通知的责任    return std::async(perform_complex_operation);&#125;\n8.3.3 异步的 “事件驱动” 哲学\n异步编程基于事件驱动的世界观：\n// 事件驱动的思维模式class EventDrivenSystem &#123;private:    EventDispatcher dispatcher_;    public:    void initialize() &#123;        // 注册事件处理器        dispatcher_.register_handler&lt;DataReceivedEvent&gt;(            [this](const DataReceivedEvent&amp; event) &#123;                this-&gt;handle_data(event.data);            &#125;        );                dispatcher_.register_handler&lt;TimeoutEvent&gt;(            [this](const TimeoutEvent&amp; event) &#123;                this-&gt;handle_timeout(event.timeout);            &#125;        );    &#125;        void start() &#123;        // 启动事件循环        dispatcher_.run();    &#125;    private:    void handle_data(const std::string&amp; data) &#123;        // 处理收到的数据        auto processed = process_data(data);                // 触发新事件        dispatcher_.post_event(DataProcessedEvent&#123;processed&#125;);    &#125;        void handle_timeout(int timeout) &#123;        // 处理超时事件        dispatcher_.post_event(TimeoutHandledEvent&#123;timeout&#125;);    &#125;&#125;;\n8.4 并发编程的性能哲学\n8.4.1 Amdahl 定律：串行部分的限制\nAmdahl 定律指出，程序的加速比受限于串行执行部分的比例。\n// 假设程序有80%的并行部分和20%的串行部分void parallelizable_task() &#123;    // 80%的计算可以并行执行    std::vector&lt;std::thread&gt; threads;    for (int i = 0; i &lt; 4; ++i) &#123;        threads.emplace_back([]&#123;            // 并行计算        &#125;);    &#125;        for (auto&amp; t : threads) &#123;        t.join();    &#125;&#125;void serial_task() &#123;    // 20%的计算必须串行执行&#125;void main_task() &#123;    serial_task();          // 串行部分（20%）    parallelizable_task();  // 并行部分（80%）&#125;\n8.4.2 Gustafson 定律：问题规模的影响\nGustafson 定律表明，随着问题规模的增加，并行计算的收益也会增加。\n// 处理更大规模的数据时，并行的优势更明显template&lt;typename T&gt;void process_large_data(const std::vector&lt;T&gt;&amp; data) &#123;    const size_t num_threads = std::thread::hardware_concurrency();    const size_t chunk_size = data.size() / num_threads;        std::vector&lt;std::thread&gt; threads;        for (size_t i = 0; i &lt; num_threads; ++i) &#123;        size_t start = i * chunk_size;        size_t end = (i == num_threads - 1) ? data.size() : (i + 1) * chunk_size;                threads.emplace_back([start, end, &amp;data]&#123;            for (size_t j = start; j &lt; end; ++j) &#123;                // 处理单个数据元素                process_element(data[j]);            &#125;        &#125;);    &#125;        for (auto&amp; t : threads) &#123;        t.join();    &#125;&#125;\n9. 最佳实践与设计原则\n9.1 线程安全设计原则\n9.1.1 优先使用高层抽象\n// 不好的做法：手动管理线程和共享数据void bad_example() &#123;    int result = 0;    std::mutex mtx;        std::thread t([&amp;]&#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        result = expensive_calculation();    &#125;);        t.join();    std::cout &lt;&lt; result &lt;&lt; std::endl;&#125;// 好的做法：使用std::asyncvoid good_example() &#123;    auto future = std::async(std::launch::async, expensive_calculation);    std::cout &lt;&lt; future.get() &lt;&lt; std::endl;&#125;\n9.1.2 始终使用 RAII 管理资源\n// 不好的做法：手动管理锁void bad_lock_management() &#123;    std::mutex mtx;    mtx.lock();        try &#123;        // 可能抛出异常的操作        risky_operation();        mtx.unlock();    &#125; catch (...) &#123;        mtx.unlock();        throw;    &#125;&#125;// 好的做法：使用RAII锁void good_lock_management() &#123;    std::mutex mtx;    std::lock_guard&lt;std::mutex&gt; lock(mtx);        // 即使抛出异常，锁也会自动释放    risky_operation();&#125;\n9.1.3 避免共享可变状态\n// 不好的做法：共享可变状态class SharedState &#123;private:    std::mutex mtx;    int state_;    public:    void update_state(int new_state) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        state_ = new_state;    &#125;&#125;;// 好的做法：使用消息传递class MessagePassing &#123;private:    std::queue&lt;int&gt; messages_;    std::mutex mtx_;    std::condition_variable cv_;    public:    void send_message(int message) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);        messages_.push(message);        cv_.notify_one();    &#125;        int receive_message() &#123;        std::unique_lock&lt;std::mutex&gt; lock(mtx_);        cv_.wait(lock, [this]&#123; return !messages_.empty(); &#125;);                int message = messages_.front();        messages_.pop();        return message;    &#125;&#125;;\n9.2 异步编程最佳实践\n9.2.1 选择合适的异步模型\n// 根据场景选择不同的异步模型// 1. 简单的异步计算：使用std::asyncauto async_result = std::async(std::launch::async, []&#123;    return expensive_calculation();&#125;);// 2. 需要主动设置结果：使用std::promisestd::promise&lt;int&gt; prom;std::future&lt;int&gt; fut = prom.get_future();std::thread([&amp;prom]&#123;    prom.set_value(calculate_result());&#125;).detach();// 3. 复杂的异步工作流：使用事件循环EventLoop loop;loop.post([]&#123;    // 异步任务&#125;);\n9.2.2 正确处理异步错误\n// 异步操作中的异常处理void async_with_exception_handling() &#123;    try &#123;        auto future = std::async(std::launch::async, []&#123;            try &#123;                // 可能抛出异常的操作                return risky_operation();            &#125; catch (...) &#123;                // 在异步任务中处理或重新抛出                std::throw_with_nested(std::runtime_error(&quot;Async operation failed&quot;));            &#125;        &#125;);                auto result = future.get();    &#125; catch (const std::exception&amp; e) &#123;        std::cerr &lt;&lt; &quot;Async error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;\n9.2.3 避免过度异步化\n// 不是所有操作都需要异步化// 适合异步的场景：I/O密集型操作auto io_future = std::async(std::launch::async, []&#123;    return read_large_file();  // I/O操作，适合异步&#125;);// 不适合异步的场景：简单计算int simple_calc = add_numbers(1, 2);  // 直接同步调用更高效// 权衡异步的开销if (operation_is_io_bound() &amp;&amp; operation_will_take_long_time()) &#123;    use_async();&#125; else &#123;    use_sync();&#125;\n9.3 性能优化原则\n9.3.1 减少锁竞争\n// 高竞争场景的优化class HighContentionData &#123;private:    std::vector&lt;std::mutex&gt; mutexes_;    std::vector&lt;int&gt; data_;    size_t num_shards_;    public:    HighContentionData(size_t size, size_t num_shards)        : num_shards_(num_shards), mutexes_(num_shards), data_(size) &#123;&#125;        void update(size_t index, int value) &#123;        size_t shard = index % num_shards_;        std::lock_guard&lt;std::mutex&gt; lock(mutexes_[shard]);        data_[index] = value;    &#125;        int get(size_t index) const &#123;        size_t shard = index % num_shards_;        std::lock_guard&lt;std::mutex&gt; lock(mutexes_[shard]);        return data_[index];    &#125;&#125;;\n9.3.2 使用无锁数据结构\n// 当适用时，无锁结构可以提供更好的性能#include &lt;atomic&gt;class LockFreeCounter &#123;private:    std::atomic&lt;int&gt; count_;    public:    LockFreeCounter() : count_(0) &#123;&#125;        void increment() &#123;        count_.fetch_add(1, std::memory_order_relaxed);    &#125;        int get_count() const &#123;        return count_.load(std::memory_order_relaxed);    &#125;&#125;;\n9.3.3 合理使用线程局部存储\n// 线程局部存储可以避免共享数据thread_local int thread_specific_data = 0;void thread_function(int id) &#123;    thread_specific_data = id;    // 每个线程都有自己的副本    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; has data: &quot; &lt;&lt; thread_specific_data &lt;&lt; std::endl;&#125;int main() &#123;    std::thread t1(thread_function, 1);    std::thread t2(thread_function, 2);        t1.join();    t2.join();        return 0;&#125;\n9.4 错误处理原则\n9.4.1 线程内异常处理\nvoid thread_with_exception_handling() &#123;    try &#123;        // 可能抛出异常的操作        risky_operation();    &#125; catch (const std::exception&amp; e) &#123;        std::cerr &lt;&lt; &quot;Thread caught exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        // 适当的清理和错误处理    &#125; catch (...) &#123;        std::cerr &lt;&lt; &quot;Thread caught unknown exception&quot; &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    std::thread t(thread_with_exception_handling);    t.join();    return 0;&#125;\n9.4.2 优雅的线程终止\nclass GracefulShutdown &#123;private:    std::atomic&lt;bool&gt; stop_flag_;    std::thread worker_thread_;    public:    GracefulShutdown() : stop_flag_(false) &#123;        worker_thread_ = std::thread([this]&#123;            while (!stop_flag_.load(std::memory_order_acquire)) &#123;                // 执行工作                do_work();                std::this_thread::sleep_for(std::chrono::milliseconds(100));            &#125;            std::cout &lt;&lt; &quot;Thread shutting down gracefully&quot; &lt;&lt; std::endl;        &#125;);    &#125;        ~GracefulShutdown() &#123;        stop_flag_.store(true, std::memory_order_release);        if (worker_thread_.joinable()) &#123;            worker_thread_.join();        &#125;    &#125;    private:    void do_work() &#123;        // 实际的工作内容    &#125;&#125;;\n10. 常见问题与解决方案\n10.1 死锁问题\n10.1.1 死锁的产生条件\n\n\n互斥条件：资源只能被一个线程持有\n\n\n持有并等待：线程持有资源并等待其他资源\n\n\n不可剥夺：资源不能被强制剥夺\n\n\n循环等待：线程间形成等待循环\n\n\n10.1.2 死锁检测与避免\n// 死锁示例std::mutex mutex1, mutex2;void deadlock_example1() &#123;    std::lock_guard&lt;std::mutex&gt; lock1(mutex1);    std::this_thread::sleep_for(std::chrono::milliseconds(10));    std::lock_guard&lt;std::mutex&gt; lock2(mutex2);  // 可能死锁&#125;void deadlock_example2() &#123;    std::lock_guard&lt;std::mutex&gt; lock2(mutex2);    std::this_thread::sleep_for(std::chrono::milliseconds(10));    std::lock_guard&lt;std::mutex&gt; lock1(mutex1);  // 可能死锁&#125;// 死锁解决方案：统一锁获取顺序void deadlock_solution1() &#123;    std::lock(mutex1, mutex2);    std::lock_guard&lt;std::mutex&gt; lock1(mutex1, std::adopt_lock);    std::lock_guard&lt;std::mutex&gt; lock2(mutex2, std::adopt_lock);&#125;// 死锁解决方案：使用try_lockvoid deadlock_solution2() &#123;    while (true) &#123;        if (mutex1.try_lock()) &#123;            if (mutex2.try_lock()) &#123;                // 成功获取两个锁                std::lock_guard&lt;std::mutex&gt; lock1(mutex1, std::adopt_lock);                std::lock_guard&lt;std::mutex&gt; lock2(mutex2, std::adopt_lock);                break;            &#125; else &#123;                mutex1.unlock();                std::this_thread::sleep_for(std::chrono::milliseconds(10));            &#125;        &#125; else &#123;            std::this_thread::sleep_for(std::chrono::milliseconds(10));        &#125;    &#125;&#125;\n10.2 数据竞争问题\n10.2.1 数据竞争的检测\n// 数据竞争示例int shared_data = 0;void竞争_condition() &#123;    for (int i = 0; i &lt; 100000; ++i) &#123;        shared_data++;  // 数据竞争！    &#125;&#125;// 解决方案：使用原子操作std::atomic&lt;int&gt; atomic_data(0);void no_race_condition() &#123;    for (int i = 0; i &lt; 100000; ++i) &#123;        atomic_data++;  // 原子操作，无数据竞争    &#125;&#125;\n10.3 异步编程常见问题\n10.3.1 异步任务的取消问题\n// std::future不支持直接取消，需要自己实现class CancellableFuture &#123;private:    std::future&lt;void&gt; future_;    std::atomic&lt;bool&gt;&amp; cancelled_;    public:    CancellableFuture(std::future&lt;void&gt;&amp;&amp; future, std::atomic&lt;bool&gt;&amp; cancelled)        : future_(std::move(future)), cancelled_(cancelled) &#123;&#125;        bool wait_for(const std::chrono::milliseconds&amp; timeout) &#123;        auto status = future_.wait_for(timeout);                if (status == std::future_status::ready) &#123;            return true;        &#125; else if (cancelled_.load()) &#123;            return false;        &#125;                return status == std::future_status::ready;    &#125;&#125;;\n10.3.2 异步结果的生命周期管理\n// 确保异步结果的正确生命周期管理class AsyncResultManager &#123;private:    std::vector&lt;std::future&lt;void&gt;&gt; active_futures_;    std::mutex mtx_;    public:    template&lt;typename Func&gt;    void start_async_task(Func&amp;&amp; func) &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);                auto future = std::async(std::launch::async, [this, func = std::forward&lt;Func&gt;(func)]() &#123;            func();            cleanup_completed_tasks();        &#125;);                active_futures_.emplace_back(std::move(future));    &#125;    private:    void cleanup_completed_tasks() &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx_);                active_futures_.erase(            std::remove_if(active_futures_.begin(), active_futures_.end(),                [](auto&amp; future) &#123;                    return future.wait_for(std::chrono::seconds(0)) == std::future_status::ready;                &#125;),            active_futures_.end()        );    &#125;&#125;;\n10.4 调试技巧\n10.4.1 线程安全的调试宏\n#ifdef DEBUG#define LOCK_GUARD(mutex) \\    std::lock_guard&lt;std::mutex&gt; lock(mutex); \\    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; locked &quot; &lt;&lt; #mutex &lt;&lt; &quot; at &quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; std::endl;#else#define LOCK_GUARD(mutex) \\    std::lock_guard&lt;std::mutex&gt; lock(mutex);#endifclass DebuggableData &#123;private:    std::mutex mtx_;    int data_;    public:    void update(int value) &#123;        LOCK_GUARD(mtx_);        data_ = value;    &#125;&#125;;\n10.4.2 异步操作的调试\n// 异步操作的调试辅助class AsyncDebugger &#123;public:    template&lt;typename T&gt;    static std::future&lt;T&gt; debug_future(std::future&lt;T&gt;&amp;&amp; future, const std::string&amp; name) &#123;        return std::async(std::launch::async, [future = std::move(future), name]() mutable &#123;            std::cout &lt;&lt; &quot;Waiting for future: &quot; &lt;&lt; name &lt;&lt; std::endl;                        try &#123;                auto result = future.get();                std::cout &lt;&lt; &quot;Future completed: &quot; &lt;&lt; name &lt;&lt; std::endl;                return result;            &#125; catch (const std::exception&amp; e) &#123;                std::cerr &lt;&lt; &quot;Future failed: &quot; &lt;&lt; name &lt;&lt; &quot; - &quot; &lt;&lt; e.what() &lt;&lt; std::endl;                throw;            &#125;        &#125;);    &#125;&#125;;\n总结\nC++ 并发编程是一个复杂而强大的领域，需要开发者同时掌握：\n技术层面\n\n\n线程管理：std::thread 的创建、销毁和同步\n\n\n同步机制：mutex、condition_variable 的正确使用\n\n\n异步编程：future、promise、async 的灵活应用\n\n\n内存模型：原子操作和内存顺序的理解\n\n\n设计模式：各种并发和异步设计模式的应用\n\n\n哲学思想层面\n\n\n并发本质：时间分片与空间共享的权衡\n\n\n异步哲学：重新定义等待，最大化资源利用\n\n\n设计原则：最小同步、不可变性、单一职责\n\n\n性能权衡：在正确性和性能之间找到平衡点\n\n\n最佳实践\n\n\n始终使用 RAII 管理资源\n\n\n优先选择高层抽象\n\n\n避免共享可变状态\n\n\n合理处理异常和错误\n\n\n重视测试和调试\n\n\n掌握这些知识和思想，能够帮助开发者编写出安全、高效、可维护的并发 C++ 程序。并发编程不仅是技术问题，更是一种思维方式和设计哲学的体现。\nDate: October 17, 2025\nCode: https://github.com/cplusplus-concurrency\n","categories":["编程"],"tags":["C++"]},{"title":"Pinia学习笔记","url":"/2025/10/10/web/Pinia%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/","content":"\n如题，结合官方文档与网络帖子，利用AI整理\n\n\nPinia 知识点整理：从基础到进阶\n目录\n\n\n简介\n\n\n安装和基本配置\n\n\n核心概念\n\n\n基础用法\n\n\n进阶用法\n\n\n插件系统\n\n\nTypeScript 支持\n\n\n最佳实践\n\n\n与 Vuex 的对比\n\n\n总结\n\n\n简介\n什么是 Pinia？\nPinia 是 Vue.js 的专属状态管理库，它允许你跨组件或页面共享状态。Pinia 起始于 2019 年 11 月的一次实验，其目的是设计一个拥有组合式 API 的 Vue 状态管理库。\n为什么选择 Pinia？\nPinia 相比传统的状态管理方案具有以下优势：\n\n\nTypeScript 支持：原生支持 TypeScript，提供完善的类型推断\n\n\n简洁的 API：比 Vuex 更简洁，减少了样板代码\n\n\n组合式 API：支持 Vue 3 的组合式 API 风格\n\n\nDevTools 支持：完整的 DevTools 集成，支持时间旅行调试\n\n\n插件系统：强大的插件系统，可以扩展 Pinia 的功能\n\n\n服务端渲染支持：原生支持服务端渲染\n\n\n热更新：开发时无需重载页面即可修改 Store\n\n\n核心特性\nPinia 的核心概念包括：\n\n\nStore：存储应用状态的容器\n\n\nState：存储具体状态数据\n\n\nGetters：计算属性，用于派生状态\n\n\nActions：用于修改状态的方法，可以是同步或异步\n\n\n安装和基本配置\n安装 Pinia\n使用 npm 或 yarn 安装 Pinia：\n# npmnpm install pinia# yarnyarn add pinia# pnpmpnpm add pinia# bunbun add pinia\nVue 2 兼容性\n如果使用 Vue 2，还需要安装 composition-api：\nnpm install pinia @vue/composition-api\n基本配置\n在 main.ts 中初始化 Pinia：\n// src/main.tsimport &#123; createApp &#125; from &#x27;vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)const pinia = createPinia()app.use(pinia)app.mount(&#x27;#app&#x27;)\n核心概念\nStore\nStore 是 Pinia 的核心概念，每个 Store 都是一个独立的模块：\n// src/stores/counter.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;// 组合式语法（推荐）export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123;  const count = ref(0)  const name = ref(&#x27;Pinia&#x27;)    const doubleCount = computed(() =&gt; count.value * 2)    function increment() &#123;    count.value++  &#125;    async function fetchData() &#123;    const data = await fetch(&#x27;/api/data&#x27;)    name.value = data.name  &#125;    return &#123; count, name, doubleCount, increment, fetchData &#125;&#125;)\nState\nState 是存储应用状态的地方，相当于组件中的 data：\n// 组合式const count = ref(0)const user = ref(null)const todos = ref([])\nGetters\nGetters 是计算属性，用于从 State 中派生出新的状态：\n// 组合式const doubleCount = computed(() =&gt; count.value * 2)const doublePlusOne = computed(() =&gt; doubleCount.value + 1)\nActions\nActions 用于修改状态，可以是同步或异步的：\n// 组合式function increment() &#123;  count.value++&#125;async function fetchUser() &#123;  const response = await fetch(&#x27;/api/user&#x27;)  user.value = await response.json()&#125;\n基础用法\n在组件中使用 Store\n&lt;!-- src/components/Counter.vue --&gt;&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;&#123;&#123; counterStore.name &#125;&#125;&lt;/h2&gt;    &lt;p&gt;Count: &#123;&#123; counterStore.count &#125;&#125;&lt;/p&gt;    &lt;p&gt;Double Count: &#123;&#123; counterStore.doubleCount &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;counterStore.increment&quot;&gt;Increment&lt;/button&gt;    &lt;button @click=&quot;counterStore.fetchData&quot;&gt;Fetch Data&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27;const counterStore = useCounterStore()&lt;/script&gt;\n解构 Store\n直接解构会失去响应性，需要使用 storeToRefs：\n&lt;script setup lang=&quot;ts&quot;&gt;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27;const counterStore = useCounterStore()// 保持响应性const &#123; count, doubleCount &#125; = storeToRefs(counterStore)// 方法可以直接解构const &#123; increment, fetchData &#125; = counterStore&lt;/script&gt;\n修改 State\n有多种方式可以修改 State：\n&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27;const counterStore = useCounterStore()// 1. 直接修改counterStore.count++// 2. 使用 $patch 批量修改counterStore.$patch(&#123;  count: counterStore.count + 1,  name: &#x27;New Name&#x27;&#125;)// 3. 使用 $patch 函数形式（推荐用于复杂修改）counterStore.$patch((state) =&gt; &#123;  state.count++  state.todos.push(&#123; id: 1, text: &#x27;Learn Pinia&#x27; &#125;)&#125;)// 4. 使用 actions（推荐）counterStore.increment()&lt;/script&gt;\n进阶用法\n监听 State 变化\n使用 $subscribe 监听状态变化：\n&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27;const counterStore = useCounterStore()// 监听单个 storeconst unsubscribe = counterStore.$subscribe((mutation, state) =&gt; &#123;  console.log(&#x27;State changed:&#x27;, mutation, state)  // 持久化到本地存储  localStorage.setItem(&#x27;counter&#x27;, JSON.stringify(state))&#125;)// 监听所有 storeconst pinia = usePinia()pinia.use((&#123; store &#125;) =&gt; &#123;  store.$subscribe((mutation, state) =&gt; &#123;    console.log(`Store $&#123;store.$id&#125; changed`)  &#125;)&#125;)// 停止监听// unsubscribe()&lt;/script&gt;\nGetter 高级用法\n访问其他 Store\n// src/stores/user.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; useCounterStore &#125; from &#x27;./counter&#x27;export const useUserStore = defineStore(&#x27;user&#x27;, &#123;  state: () =&gt; (&#123;    userId: 1  &#125;),  getters: &#123;    // 访问其他 store    userWithCount: (state) =&gt; &#123;      const counterStore = useCounterStore()      return &#123;        userId: state.userId,        count: counterStore.count      &#125;    &#125;  &#125;&#125;)\nGetter 参数化\n// 组合式const getUserById = computed(() =&gt; &#123;  return (userId: number) =&gt; users.value.find(user =&gt; user.id === userId)&#125;)// 在组件中使用const user = userStore.getUserById(1)\nAction 高级用法\n异步 Actions\n// src/stores/user.tsexport const useUserStore = defineStore(&#x27;user&#x27;, &#123;  state: () =&gt; (&#123;    users: [],    loading: false,    error: null  &#125;),  actions: &#123;    async fetchUsers() &#123;      this.loading = true      this.error = null      try &#123;        const response = await fetch(&#x27;/api/users&#x27;)        this.users = await response.json()      &#125; catch (error) &#123;        this.error = error.message      &#125; finally &#123;        this.loading = false      &#125;    &#125;,    async addUser(userData) &#123;      const response = await fetch(&#x27;/api/users&#x27;, &#123;        method: &#x27;POST&#x27;,        body: JSON.stringify(userData)      &#125;)      const newUser = await response.json()      this.users.push(newUser)      return newUser    &#125;  &#125;&#125;)\nAction 间的调用\nactions: &#123;  async fetchAndProcessData() &#123;    // 调用其他 action    await this.fetchUsers()    this.processUserData()  &#125;,  processUserData() &#123;    // 处理用户数据    this.users = this.users.map(user =&gt; (&#123;      ...user,      fullName: `$&#123;user.firstName&#125; $&#123;user.lastName&#125;`    &#125;))  &#125;&#125;\n插件系统\n自定义插件\n// src/plugins/pinia-logger.tsexport function piniaLogger() &#123;  return (context) =&gt; &#123;    const &#123; store &#125; = context        // 监听 action 调用    store.$onAction((&#123; name, args, after, onError &#125;) =&gt; &#123;      console.log(`[Pinia Logger] Action &quot;$&#123;name&#125;&quot; started with args:`, args)            after((result) =&gt; &#123;        console.log(`[Pinia Logger] Action &quot;$&#123;name&#125;&quot; succeeded with result:`, result)      &#125;)            onError((error) =&gt; &#123;        console.error(`[Pinia Logger] Action &quot;$&#123;name&#125;&quot; failed with error:`, error)      &#125;)    &#125;)        // 监听 state 变化    store.$subscribe((mutation) =&gt; &#123;      console.log(`[Pinia Logger] State changed in store &quot;$&#123;store.$id&#125;&quot;:`, mutation)    &#125;)  &#125;&#125;\n使用插件\n// src/main.tsimport &#123; createPinia &#125; from &#x27;pinia&#x27;import &#123; piniaLogger &#125; from &#x27;./plugins/pinia-logger&#x27;const pinia = createPinia()pinia.use(piniaLogger())\n状态持久化插件\n使用 pinia-plugin-persistedstate 实现状态持久化：\nnpm install pinia-plugin-persistedstate// src/main.tsimport &#123; createPinia &#125; from &#x27;pinia&#x27;import piniaPluginPersist from &#x27;pinia-plugin-persistedstate&#x27;const pinia = createPinia()pinia.use(piniaPluginPersist)// src/stores/user.tsexport const useUserStore = defineStore(&#x27;user&#x27;, &#123;  state: () =&gt; (&#123;    token: &#x27;&#x27;,    userInfo: null  &#125;),  // 配置持久化  persist: &#123;    enabled: true,    strategies: [      &#123;        key: &#x27;user-store&#x27;,        storage: localStorage,        paths: [&#x27;token&#x27;, &#x27;userInfo&#x27;]      &#125;    ]  &#125;&#125;)\nTypeScript 支持\n类型定义\n// src/types/index.tsinterface User &#123;  id: number  name: string  email: string&#125;interface CounterState &#123;  count: number  name: string  user: User | null&#125;// src/stores/counter.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;import type &#123; CounterState &#125; from &#x27;@/types&#x27;export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;  state: (): CounterState =&gt; (&#123;    count: 0,    name: &#x27;Pinia&#x27;,    user: null  &#125;),  getters: &#123;    userName: (state): string =&gt; state.user?.name || &#x27;Guest&#x27;  &#125;,  actions: &#123;    setUser(user: User | null) &#123;      this.user = user    &#125;  &#125;&#125;)\n组合式 API 类型\n// src/stores/user.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; ref, computed &#125; from &#x27;vue&#x27;import type &#123; User &#125; from &#x27;@/types&#x27;export const useUserStore = defineStore(&#x27;user&#x27;, () =&gt; &#123;  const users = ref&lt;User[]&gt;([])  const loading = ref(false)    const userCount = computed(() =&gt; users.value.length)  const activeUsers = computed(() =&gt;     users.value.filter(user =&gt; user.active)  )    const fetchUsers = async (): Promise&lt;void&gt; =&gt; &#123;    loading.value = true    const response = await fetch(&#x27;/api/users&#x27;)    users.value = await response.json()    loading.value = false  &#125;    const addUser = (user: Omit&lt;User, &#x27;id&#x27;&gt;): void =&gt; &#123;    const newUser = &#123; ...user, id: Date.now() &#125;    users.value.push(newUser)  &#125;    return &#123;    users,    loading,    userCount,    activeUsers,    fetchUsers,    addUser  &#125;&#125;)\n最佳实践\n项目结构\n推荐的项目结构：\nsrc/├── stores/│   ├── index.ts           # Pinia 实例│   ├── modules/│   │   ├── system/        # 系统级状态│   │   │   ├── app.ts     # 应用配置│   │   │   ├── user.ts    # 用户信息│   │   │   └── permission.ts # 权限管理│   │   └── business/      # 业务模块│   │       ├── cart.ts    # 购物车│   │       └── product.ts # 产品管理└── types/                 # 类型定义    └── index.ts\n模块化设计\n// src/stores/index.tsexport * from &#x27;./modules/system/app&#x27;export * from &#x27;./modules/system/user&#x27;export * from &#x27;./modules/system/permission&#x27;export * from &#x27;./modules/business/cart&#x27;export * from &#x27;./modules/business/product&#x27;\n状态设计原则\n\n\n单一职责：每个 Store 应该专注于一个特定的业务领域\n\n\n最小状态：只存储必要的状态，避免存储可以计算得出的数据\n\n\n不可变性：虽然 Pinia 允许直接修改状态，但复杂对象建议使用不可变模式\n\n\n类型安全：为所有状态和操作添加类型定义\n\n\n性能优化\n\n\n避免过度使用全局状态：只将真正需要共享的状态放入 Store\n\n\n合理使用 Getters：利用缓存机制提高性能\n\n\n批量更新：使用 $patch 进行批量状态更新\n\n\n按需加载：对于大型应用，可以考虑动态注册 Store\n\n\n测试策略\n// tests/stores/counter.test.tsimport &#123; setActivePinia, createPinia &#125; from &#x27;pinia&#x27;import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27;describe(&#x27;Counter Store&#x27;, () =&gt; &#123;  beforeEach(() =&gt; &#123;    setActivePinia(createPinia())  &#125;)    it(&#x27;should initialize with count 0&#x27;, () =&gt; &#123;    const counterStore = useCounterStore()    expect(counterStore.count).toBe(0)  &#125;)    it(&#x27;should increment count&#x27;, () =&gt; &#123;    const counterStore = useCounterStore()    counterStore.increment()    expect(counterStore.count).toBe(1)  &#125;)    it(&#x27;should calculate double count correctly&#x27;, () =&gt; &#123;    const counterStore = useCounterStore()    counterStore.count = 2    expect(counterStore.doubleCount).toBe(4)  &#125;)&#125;)\n与 Vuex 的对比\n核心差异\n\n\n\n特性\nPinia\nVuex\n\n\n\n\nTypeScript 支持\n原生支持，类型推断完善\n需要额外类型声明\n\n\n模块化设计\n每个 store 独立，无嵌套\n需要通过 modules 嵌套\n\n\n状态修改\n直接修改 state\n必须通过 mutations\n\n\nActions\n支持同步和异步\n异步操作需要通过 actions\n\n\nMutations\n已废弃\n必须使用 mutations 修改状态\n\n\n代码简洁性\n更简洁，减少样板代码\n相对繁琐\n\n\nDevTools 支持\n完整支持\n完整支持\n\n\n\n迁移指南\n从 Vuex 迁移到 Pinia：\n// Vuexconst store = new Vuex.Store(&#123;  state: &#123; count: 0 &#125;,  mutations: &#123;    increment(state) &#123;      state.count++    &#125;  &#125;,  actions: &#123;    incrementAsync(&#123; commit &#125;) &#123;      setTimeout(() =&gt; commit(&#x27;increment&#x27;), 1000)    &#125;  &#125;,  getters: &#123;    doubleCount: state =&gt; state.count * 2  &#125;&#125;)// Pinia 等效代码export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;  state: () =&gt; (&#123; count: 0 &#125;),  actions: &#123;    increment() &#123;      this.count++    &#125;,    incrementAsync() &#123;      setTimeout(() =&gt; this.increment(), 1000)    &#125;  &#125;,  getters: &#123;    doubleCount: state =&gt; state.count * 2  &#125;&#125;)\nPinia 的优势\n\n\n现代化设计：基于 Vue 3 的组合式 API 设计\n\n\n优秀的 TypeScript 支持：提供完善的类型推断\n\n\n简洁的 API：减少了 Vuex 中的样板代码\n\n\n强大的插件系统：可以轻松扩展功能\n\n\n良好的开发体验：完整的 DevTools 支持和热更新\n\n\n适用场景\n\n\n中大型 Vue 3 项目：需要集中管理状态的应用\n\n\nTypeScript 项目：需要类型安全的状态管理\n\n\n需要服务端渲染的项目：Pinia 原生支持 SSR\n\n\n从 Vuex 迁移的项目：提供更简洁的 API\n\n\n学习建议\n\n\n掌握基础概念：理解 Store、State、Getters、Actions 的基本用法\n\n\n实践组合式 API：推荐使用组合式语法定义 Store\n\n\n学会插件开发：利用插件扩展 Pinia 的功能\n\n\n关注最佳实践：合理设计状态结构，避免过度使用全局状态\n\n\n持续学习：关注 Pinia 的最新特性和最佳实践\n\n\nPinia 作为 Vue 官方推荐的状态管理库，正在成为 Vue 生态系统中的标准选择。掌握 Pinia 将有助于构建更加健壮、可维护的 Vue 应用。\n参考资源：\n\n\nPinia 官方文档\n\n\nVue 官方文档\n\n\nPinia GitHub 仓库\n\n\n","categories":["编程"],"tags":["Web"]},{"title":"Vue路由","url":"/2025/10/09/web/Vue%20%E8%B7%AF%E7%94%B1/","content":"\n如题，结合官方文档与网络帖子，利用AI整理\n\n\nVue 路由\n1. 安装与基础配置\nVue Router 是 Vue 3 构建单页面应用（SPA）的核心工具，第一步需完成安装与基础配置，确保路由功能正常运行：\n\n\n安装：通过 npm 安装适配 Vue 3 的 Vue Router 4 版本，命令如下：\nnpm install vue-router@4\n\n\n路由配置：在项目根目录创建 router/index.js 文件，定义路由规则。核心是通过 createRouter 创建路由实例，createWebHistory 设置 History 模式，同时导入需路由管理的组件（如 Home、About），并配置路由路径（path）、路由名称（name）及对应组件（component）：\nimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;import Home from &#x27;@/views/Home.vue&#x27;;import About from &#x27;@/views/About.vue&#x27;;const routes = [  &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home &#125;,  &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: About &#125;];const router = createRouter(&#123;  history: createWebHistory(), // 采用 HTML5 History 模式  routes // 注入路由规则&#125;);export default router;\n\n\n注册路由：在项目入口文件 main.js 中，导入路由实例并通过 use(router) 注册到 Vue 应用，确保路由功能全局可用：\nimport &#123; createApp &#125; from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import router from &#x27;./router&#x27;;createApp(App).use(router).mount(&#x27;#app&#x27;);\n\n\n路由出口与导航：在 App.vue 中，使用 &lt;router-view&gt; 作为路由组件的渲染容器（匹配的路由组件会在此处渲染），使用 &lt;router-link&gt; 实现页面导航（替代传统 &lt;a&gt; 标签，避免页面刷新）：\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;nav&gt;      &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;!-- 跳转到首页路由 --&gt;      &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt; &lt;!-- 跳转到关于路由 --&gt;    &lt;/nav&gt;    &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 路由组件渲染出口 --&gt;  &lt;/div&gt;&lt;/template&gt;\n\n\n2. 核心功能\nVue Router 提供 4 个核心功能，满足日常路由管理需求，包括动态路由、嵌套路由、编程式导航和路由懒加载：\n\n\n动态路由：用于匹配同一类路径（如不同用户的详情页），通过 : 在路由 path 中定义动态参数（如 id），组件内通过 useRoute() 获取路由实例，再通过 route.params 访问动态参数：\n\n路由配置：{ path: '/user/:id', component: User }\n组件内获取参数：&lt;script setup&gt;import &#123; useRoute &#125; from &#x27;vue-router&#x27;;const route = useRoute();console.log(route.params.id); // 输出动态参数 id 的值&lt;/script&gt;\n\n\n\n\n嵌套路由：实现路由的层级结构（如仪表盘下的个人资料、设置页面），通过 children 字段在父路由中配置子路由，且父组件必须包含 &lt;router-view&gt; 以渲染子路由组件：\n&#123;  path: &#x27;/dashboard&#x27;, // 父路由路径  component: Dashboard, // 父路由组件  children: [    &#123; path: &#x27;profile&#x27;, component: Profile &#125;, // 子路由 1，访问路径 /dashboard/profile    &#123; path: &#x27;settings&#x27;, component: Settings &#125; // 子路由 2，访问路径 /dashboard/settings  ]&#125;\n\n\n编程式导航：不依赖 &lt;router-link&gt;，通过代码实现页面跳转，核心方法是 router.push()，支持 4 种跳转形式：\n// 1. 字符串路径：直接传入目标路由路径router.push(&#x27;/about&#x27;);// 2. 对象形式：传入含 path 的对象router.push(&#123; path: &#x27;/user/123&#x27; &#125;);// 3. 命名路由 + 参数：需配合路由 name 和 params（推荐，参数更清晰）router.push(&#123; name: &#x27;User&#x27;, params: &#123; id: &#x27;123&#x27; &#125; &#125;);// 4. 查询参数：通过 query 传递参数，URL 会显示为 /search?keyword=vuerouter.push(&#123; path: &#x27;/search&#x27;, query: &#123; keyword: &#x27;vue&#x27; &#125; &#125;);\n\n\n路由懒加载：优化初始加载性能，减少首屏加载体积，通过动态导入（() =&gt; import('组件路径')）的方式定义路由组件，只有当路由被访问时才会加载对应组件：\n&#123; path: &#x27;/admin&#x27;, component: () =&gt; import(&#x27;@/views/Admin.vue&#x27;) &#125;\n\n\n3. 高级特性\nVue Router 提供 4 个高级特性，满足复杂场景下的路由控制与个性化需求：\n\n\n导航守卫：控制路由跳转逻辑，分为 3 类，分别作用于全局、单个路由和组件内部：\n\n全局守卫：在 router/index.js 中定义，作用于所有路由，包括前置守卫（beforeEach，跳转前执行，需调用 next() 控制跳转）和后置守卫（afterEach，跳转后执行，无 next()）：// 全局前置守卫：判断是否需要登录router.beforeEach((to, from, next) =&gt; &#123;  if (to.meta.requiresAuth &amp;&amp; !isAuthenticated) &#123; // to.meta.requiresAuth 来自路由元信息    next(&#x27;/login&#x27;); // 未登录则重定向到登录页  &#125; else &#123;    next(); // 已登录则放行  &#125;&#125;);// 全局后置守卫：修改页面标题router.afterEach((to, from) =&gt; &#123;  document.title = to.meta.title || &#x27;默认标题&#x27;; // 从路由元信息获取标题&#125;);\n\n路由独享守卫：在单个路由配置中定义，仅作用于该路由，通过 beforeEnter 实现：&#123;  path: &#x27;/admin&#x27;,  component: Admin,  beforeEnter: (to, from, next) =&gt; &#123;    // 仅对 /admin 路由生效的验证逻辑  &#125;&#125;\n\n组件内守卫：在组件内部定义，作用于当前组件对应的路由，常用 onBeforeRouteLeave（离开组件路由前执行）：&lt;script setup&gt;import &#123; onBeforeRouteLeave &#125; from &#x27;vue-router&#x27;;const unsavedChanges = true; // 模拟未保存的修改onBeforeRouteLeave((to, from, next) =&gt; &#123;  if (unsavedChanges) &#123;    // 有未保存修改时，提示用户确认    confirm(&#x27;确定离开？未保存的修改将丢失！&#x27;) ? next() : next(false);  &#125; else &#123;    next(); // 无未保存修改则放行  &#125;&#125;);&lt;/script&gt;\n\n\n\n\n路由元信息：为路由附加额外数据（如是否需要登录、页面标题），通过 meta 字段在路由配置中定义，在导航守卫、组件中可通过 to.meta 或 route.meta 访问：\n&#123;  path: &#x27;/dashboard&#x27;,  meta: &#123;     requiresAuth: true, // 标记该路由需要登录才能访问    title: &#x27;控制台&#x27; // 该路由对应的页面标题  &#125;&#125;\n\n\n滚动行为：自定义页面切换后的滚动位置，在创建路由实例时通过 scrollBehavior 配置，支持 3 种场景：滚动到锚点、恢复之前滚动位置、滚动到顶部：\nconst router = createRouter(&#123;  scrollBehavior(to, from, savedPosition) &#123;    if (to.hash) &#123;      // 若目标路由有锚点（如 /page#section1），滚动到锚点位置，且平滑滚动      return &#123; el: to.hash, behavior: &#x27;smooth&#x27; &#125;;    &#125; else if (savedPosition) &#123;      // 若存在之前的滚动位置（如浏览器后退），恢复该位置      return savedPosition;    &#125; else &#123;      // 其他情况，默认滚动到页面顶部      return &#123; top: 0 &#125;;    &#125;  &#125;&#125;);\n\n\n路由模式：控制 URL 的表现形式，分为 2 种模式，各有特点：\n\n\n\n模式类型\n核心方法\n特点\n适用场景\n\n\n\n\nHash 模式\ncreateWebHashHistory()\nURL 中带 #（如 http://xxx/#/home），兼容性好（支持所有浏览器），无需服务器配置\n对 URL 美观度要求不高、兼容性要求高的场景\n\n\nHistory 模式\ncreateWebHistory()\nURL 中无 #（如 http://xxx/home），美观度高，但需服务器配置（如 Nginx 配置 fallback 到 index.html），否则刷新会 404\n对 URL 美观度要求高、可配置服务器的场景\n\n\n\n\n\n4. 常见场景处理\n针对路由使用中的 3 种常见场景（404 页面、路由重定向、路由别名），提供具体解决方案：\n\n\n404 页面：捕获所有未匹配的路由，显示 404 页面，通过通配符 /:pathMatch(.*)* 配置路由路径，确保所有未定义的路由都指向 404 组件：\n&#123; path: &#x27;/:pathMatch(.*)*&#x27;, component: NotFound &#125; // NotFound 为自定义 404 组件\n\n\n路由重定向：将一个路由路径重定向到另一个路由，通过 redirect 字段配置，支持 2 种形式（重定向到固定路径、重定向到命名路由）：\n// 1. 重定向到固定路径：访问 /old 时，自动跳转到 /new&#123; path: &#x27;/old&#x27;, redirect: &#x27;/new&#x27; &#125;// 2. 重定向到命名路由：访问 /home 时，自动跳转到 name 为 Home 的路由&#123; path: &#x27;/home&#x27;, redirect: &#123; name: &#x27;Home&#x27; &#125; &#125;\n\n\n路由别名：为一个路由路径设置多个访问入口，通过 alias 字段配置（支持字符串单个别名、数组多个别名），访问别名路径时，会渲染原路由的组件，且浏览器地址栏保持别名路径（不跳转）：\n// 配置 /dashboard 的别名为 /home、/main、/control-panelconst routes = [  &#123;    path: &#x27;/dashboard&#x27;, // 原路由路径    component: Dashboard, // 原路由组件    alias: [&#x27;/home&#x27;, &#x27;/main&#x27;, &#x27;/control-panel&#x27;] // 多个别名，访问任意别名都渲染 Dashboard 组件  &#125;];\n路由别名与重定向的核心区别：\n\n\n\n特性\n路由别名（alias）\n路由重定向（redirect）\n\n\n\n\nURL 变化\n地址栏显示别名路径，不变化\n地址栏跳转到目标路径，发生变化\n\n\n本质\n多入口访问同一组件\n路径跳转\n\n\n场景\n多语言支持、简化 URL、推广链接追踪\n旧路径迁移、统一访问入口\n\n\n\n\n\n5. 组合式 API 使用\nVue 3 中推荐使用组合式 API 操作路由，核心是 useRouter 和 useRoute 两个钩子，替代 Vue 2 中的 $router 和 $route：\n\n\n核心 API 说明：\n\nuseRouter：获取路由实例，用于执行路由跳转操作（如 push、replace）；\nuseRoute：获取当前路由信息，用于访问路由参数（query、params）、路由元信息（meta）等。\n\n\n\n使用示例：\n&lt;script setup&gt;import &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;;// 获取路由实例和当前路由信息const router = useRouter();const route = useRoute();// 1. 路由跳转：点击按钮跳转到 /about 路由const goToAbout = () =&gt; &#123;  router.push(&#x27;/about&#x27;);&#125;;// 2. 获取路由参数：获取 URL 中的 query 参数 id（如 /page?id=123）console.log(route.query.id); // 输出 &#x27;123&#x27;// 3. 获取动态路由参数：获取 /user/:id 中的 id（如 /user/456）console.log(route.params.id); // 输出 &#x27;456&#x27;&lt;/script&gt;\n\n\n6. 路由传参\nVue Router 提供 3 种路由传参方式，分别是 Query 参数、Params 参数和 Props 解耦，适用于不同场景：\n\n\nQuery 参数：通过 URL 的查询字符串（? 后的部分）传递参数，特点是参数可见、无需预先在路由配置中声明，适合传递非敏感、可选的参数（如筛选条件、分页信息）：\n\n传递参数：通过 router.push() 传入含 query 的对象：import &#123; useRouter &#125; from &#x27;vue-router&#x27;;const router = useRouter();// 传递 keyword 和 sort 两个 Query 参数router.push(&#123;  path: &#x27;/search&#x27;, // 目标路由路径  query: &#123; keyword: &#x27;vue&#x27;, sort: &#x27;desc&#x27; &#125; // Query 参数对象&#125;);// 生成的 URL：/search?keyword=vue&amp;sort=desc\n\n接收参数：在目标组件中，通过 useRoute() 获取 route.query：import &#123; useRoute &#125; from &#x27;vue-router&#x27;;const route = useRoute();const keyword = route.query.keyword; // 取值 &#x27;vue&#x27;const sort = route.query.sort; // 取值 &#x27;desc&#x27;\n\n\n\n\nParams 参数：通过 URL 路径的动态段传递参数，特点是参数需在路由配置中预先声明（用 : 定义）、参数可见，适合传递必要、结构化的参数（如资源 ID）：\n\n路由配置：先在 path 中用 : 声明动态参数（如 userId、postId）：const routes = [  &#123;    path: &#x27;/user/:userId/post/:postId&#x27;, // 声明 2 个动态参数：userId 和 postId    component: UserPost, // 目标组件    name: &#x27;UserPost&#x27; // 路由名称，用于编程式导航  &#125;];\n\n传递参数：支持 2 种方式（使用命名路由、使用路径拼接）：import &#123; useRouter &#125; from &#x27;vue-router&#x27;;const router = useRouter();const userId = 123;const postId = 456;// 方式 1：使用命名路由（推荐，参数与路径解耦）router.push(&#123;  name: &#x27;UserPost&#x27;, // 匹配路由的 name  params: &#123; userId, postId &#125; // Params 参数对象，与路由声明的参数对应&#125;);// 方式 2：使用路径拼接（需手动拼接参数）router.push(`/user/$&#123;userId&#125;/post/$&#123;postId&#125;`);// 生成的 URL：/user/123/post/456\n\n接收参数：在目标组件中，通过 useRoute() 获取 route.params：import &#123; useRoute &#125; from &#x27;vue-router&#x27;;const route = useRoute();const userId = route.params.userId; // 取值 &#x27;123&#x27;（注意：Params 参数值为字符串类型）const postId = route.params.postId; // 取值 &#x27;456&#x27;\n\n\n\n\nProps 解耦：让组件不直接依赖 $route 或 useRoute()，通过 props 接收路由参数，提升组件复用性和可测试性，仅支持 Params 参数：\n\n路由配置：在路由中设置 props: true，Vue Router 会自动将 Params 参数转换为组件的 props：&#123;  path: &#x27;/user/:id&#x27;, // 声明动态参数 id  component: UserDetail,  props: true // 开启 Props 传参，Params 参数会作为 props 传入组件&#125;\n\n组件接收：在组件中通过 props 接收参数，像使用普通 props 一样使用：// 选项式 APIexport default &#123;  props: [&#x27;id&#x27;], // 声明接收 id props  setup(props) &#123;    console.log(props.id); // 直接使用参数，无需依赖 useRoute()  &#125;&#125;;// 组合式 API（&lt;script setup&gt;）const props = defineProps([&#x27;id&#x27;]);console.log(props.id); // 直接使用参数\n\n\n\n\n三种传参方式对比：\n\n\n\n对比维度\nQuery 参数\nParams 参数\nProps 解耦\n\n\n\n\nURL 表现\n?key=value（查询字符串）\n/path/value（路径动态段）\n同 Params 参数\n\n\n路由配置依赖\n无需预先声明\n需在 path 中用 : 声明\n需在 path 中用 : 声明，且路由需设 props: true\n\n\n参数类型\n字符串（自动转换基本类型）\n字符串（需手动转换类型）\n同 Params 参数，但通过 props 可定义类型\n\n\n组件依赖\n依赖 useRoute()\n依赖 useRoute()\n不依赖 useRoute()，依赖 props\n\n\n适用场景\n可选参数、筛选条件、分页\n资源 ID、必要标识符\n组件复用性要求高的场景（如独立组件库）\n\n\n\n\n\n7. 注意事项\n使用 Vue Router 时需注意 3 个关键问题，避免功能异常或性能问题：\n\n\n路由参数变化时组件复用：当路由参数变化（如从 /user/123 跳转到 /user/456），组件会复用（不会重新创建），若需监听参数变化，需使用 beforeRouteUpdate 守卫或监听 route.params：\n// 方式 1：使用 beforeRouteUpdate 守卫onBeforeRouteUpdate((to, from) =&gt; &#123;  console.log(&#x27;参数变化：&#x27;, to.params.id);&#125;);// 方式 2：监听 route.paramswatch(() =&gt; route.params.id, (newId) =&gt; &#123;  console.log(&#x27;参数变化：&#x27;, newId);&#125;);\n\n\nHistory 模式部署：History 模式下，刷新页面会向服务器发送请求，若服务器未配置 fallback 到 index.html，会返回 404。需配置服务器（如 Nginx）：\nlocation / &#123;  try_files $uri $uri/ /index.html;&#125;\n\n\n导航守卫异步操作：若导航守卫中存在异步操作（如请求接口验证权限），需确保 next() 仅调用一次，避免多次跳转。可通过 async/await 处理：\nrouter.beforeEach(async (to, from, next) =&gt; &#123;  const isAuthenticated = await checkAuth(); // 异步验证权限  if (to.meta.requiresAuth &amp;&amp; !isAuthenticated) &#123;    next(&#x27;/login&#x27;);  &#125; else &#123;    next();  &#125;&#125;);\n\n\n\n关键问题\n问题 1：Vue Router 中 Query 参数和 Params 参数的核心区别是什么？在实际项目中如何选择？\n答案：\n两者核心区别体现在 路由配置依赖、URL 表现 和 适用场景 上，具体如下：\n\n\n路由配置依赖：Query 参数无需在路由 path 中预先声明，直接通过 router.push({path, query}) 传递；Params 参数必须在路由 path 中用 : 声明动态段（如 /user/:id），否则无法传递。\n\n\nURL 表现：Query 参数显示在 URL 的查询字符串中（如 /search?keyword=vue）；Params 参数作为 URL 路径的一部分（如 /user/123）。\n\n\n参数稳定性：两者刷新页面后参数均保留，但 Query 参数更适合传递可选、非结构化数据，Params 参数更适合传递必要、结构化数据（如资源 ID）。\n\n\n实际选择时：\n\n\n若参数为 可选、非敏感（如筛选条件、分页页码、搜索关键词），选 Query 参数；\n\n\n若参数为 必要、标识资源（如用户 ID、文章 ID），选 Params 参数，使 URL 更符合 RESTful 规范。\n\n\n问题 2：Vue Router 的导航守卫有哪几类？分别适用于什么场景？\n答案：\nVue Router 导航守卫分为 全局守卫、路由独享守卫 和 组件内守卫 三类，适用场景各有不同：\n\n\n全局守卫：作用于所有路由，定义在 router/index.js 中，包括 beforeEach（跳转前）和 afterEach（跳转后）：\n\n适用场景：全局权限控制（如登录验证）、全局页面标题修改、全局埋点统计。\n\n\n\n路由独享守卫：仅作用于单个路由，通过路由配置的 beforeEnter 定义：\n\n适用场景：单个路由的特殊权限验证（如管理员页面额外验证角色）、特定路由的跳转限制。\n\n\n\n组件内守卫：作用于组件对应的路由，定义在组件内部，常用 onBeforeRouteLeave（离开路由前）：\n\n适用场景：组件内未保存修改的提示（如表单未提交时离开页面）、组件销毁前的资源清理（如取消请求）。\n\n\n\n问题 3：Vue Router 中路由懒加载的实现原理是什么？如何结合路由分组进一步优化性能？\n答案：\n\n\n实现原理：路由懒加载基于 ES6 的 动态导入语法（() =&gt; import('组件路径')），在初始打包时，懒加载的路由组件会被分割成独立的代码块（chunk），而非打包进主文件；只有当用户访问该路由时，浏览器才会异步加载对应的代码块，从而减少首屏加载体积，提升初始加载速度。\n\n\n结合路由分组优化性能：当多个路由属于同一功能模块（如用户相关的 /user/login、/user/register、/user/profile），可通过 命名代码块 将它们分组打包，避免生成过多小代码块（减少 HTTP 请求数）。实现方式是在动态导入时添加 /* webpackChunkName: &quot;group-user&quot; */ 注释（webpack 支持）：\nconst routes = [  // 用户模块路由，打包为名为 &quot;group-user&quot; 的代码块  &#123; path: &#x27;/user/login&#x27;, component: () =&gt; import(/* webpackChunkName: &quot;group-user&quot; */ &#x27;@/views/user/Login.vue&#x27;) &#125;,  &#123; path: &#x27;/user/register&#x27;, component: () =&gt; import(/* webpackChunkName: &quot;group-user&quot; */ &#x27;@/views/user/Register.vue&#x27;) &#125;,  &#123; path: &#x27;/user/profile&#x27;, component: () =&gt; import(/* webpackChunkName: &quot;group-user&quot; */ &#x27;@/views/user/Profile.vue&#x27;) &#125;,  // 其他模块路由，打包为其他代码块  &#123; path: &#x27;/admin/dashboard&#x27;, component: () =&gt; import(/* webpackChunkName: &quot;group-admin&quot; */ &#x27;@/views/admin/Dashboard.vue&#x27;) &#125;];\n优化效果：访问用户模块任意路由时，会加载 “group-user” 代码块，后续访问该模块其他路由无需重复加载，减少 HTTP 请求，提升后续访问速度。\n\n\n","categories":["编程"],"tags":["Web"]},{"title":"Vue+IndexedDB+idb","url":"/2025/10/09/web/Vue%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20idb%20%E6%93%8D%E4%BD%9C%20IndexedDB%20%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/","content":"\n如题，结合官方文档与网络帖子，利用AI整理\n\n\nVue 中使用 idb 操作 IndexedDB 完整指南\n目录\n\n\n什么是 IndexedDB 和 idb\n\n\n环境准备与安装\n\n\n基础概念\n\n\n数据库连接管理\n\n\n数据操作（CRUD）\n\n\n事务处理\n\n\n数据库版本管理\n\n\n索引使用\n\n\n高级查询操作\n\n\nVue 中的最佳实践\n\n\n常见问题与解决方案\n\n\n性能优化\n\n\n什么是 IndexedDB 和 idb\nIndexedDB 简介\nIndexedDB 是浏览器提供的一种本地存储方案，具有以下特点：\n\n\nNoSQL 数据库：基于键值对存储\n\n\n异步操作：所有操作都是异步的，不会阻塞主线程\n\n\n大容量存储：相比 localStorage 有更大的存储容量（通常是 GB 级别）\n\n\n支持事务：确保数据操作的原子性\n\n\n支持索引：可以在对象的属性上创建索引，提高查询效率\n\n\n同源策略：遵循浏览器的同源策略\n\n\nidb 库简介\nidb 是由 Google 工程师 Jake Archibald 开发的一个轻量级 IndexedDB 包装库：\n\n\n体积小巧：只有 1KB 大小\n\n\nPromise API：将原生的回调式 API 转换为 Promise 式\n\n\nTypeScript 支持：提供完整的类型定义\n\n\n简化操作：简化了复杂的 IndexedDB 操作流程\n\n\n活跃维护：持续更新和维护\n\n\nGitHub 地址：https://github.com/jakearchibald/idb\n环境准备与安装\n安装 idb\n# 使用npmnpm install idb# 使用yarnyarn add idb# 使用pnpmpnpm add idb\n在 Vue 中引入\n// 在Vue组件中直接引入import &#123; openDB &#125; from &#x27;idb&#x27;// 或者创建一个专门的数据库管理文件// src/utils/indexedDB.jsimport &#123; openDB &#125; from &#x27;idb&#x27;export const useIndexedDB = () =&gt; &#123;  // 数据库操作逻辑&#125;\n基础概念\n数据库（Database）\n\n\n数据库是存储数据的容器\n\n\n每个数据库有一个唯一的名称\n\n\n数据库可以包含多个对象仓库（store）\n\n\n数据库有版本号，版本号只能递增\n\n\n对象仓库（Object Store）\n\n\n对象仓库类似于关系数据库中的表\n\n\n每个对象仓库存储一组相关的数据\n\n\n每个对象仓库必须有一个主键（key）\n\n\n主键可以是对象的属性（keyPath）或自动生成（autoIncrement）\n\n\n事务（Transaction）\n\n\n事务是一组操作的集合\n\n\n事务具有 ACID 特性：原子性、一致性、隔离性、持久性\n\n\n事务有三种模式：readwrite（读写）、readonly（只读）、versionchange（版本变更）\n\n\n索引（Index）\n\n\n索引是对象仓库的排序副本\n\n\n可以基于对象的属性创建索引\n\n\n索引可以提高查询效率\n\n\n一个对象仓库可以有多个索引\n\n\n数据库连接管理\n创建数据库连接\n// src/utils/indexedDB.jsimport &#123; openDB &#125; from &#x27;idb&#x27;export const DB_NAME = &#x27;MyVueAppDB&#x27;export const DB_VERSION = 1// 创建数据库连接export const initDB = async () =&gt; &#123;  return openDB(DB_NAME, DB_VERSION, &#123;    upgrade(db) &#123;      // 数据库版本升级时的操作      console.log(&#x27;数据库升级中...&#x27;)            // 创建用户对象仓库      if (!db.objectStoreNames.contains(&#x27;users&#x27;)) &#123;        db.createObjectStore(&#x27;users&#x27;, &#123;           keyPath: &#x27;id&#x27;,          autoIncrement: true         &#125;)      &#125;            // 创建商品对象仓库      if (!db.objectStoreNames.contains(&#x27;products&#x27;)) &#123;        db.createObjectStore(&#x27;products&#x27;, &#123;           keyPath: &#x27;id&#x27;        &#125;)      &#125;            // 创建设置对象仓库（类似localStorage）      if (!db.objectStoreNames.contains(&#x27;settings&#x27;)) &#123;        db.createObjectStore(&#x27;settings&#x27;)      &#125;    &#125;,        blocked() &#123;      // 数据库被其他连接占用时触发      console.log(&#x27;数据库连接被阻塞，请关闭其他标签页后重试&#x27;)    &#125;,        blocking() &#123;      // 当前连接阻塞了新连接的版本升级时触发      console.log(&#x27;数据库需要升级，正在关闭当前连接...&#x27;)    &#125;  &#125;)&#125;// 获取数据库实例let dbInstance = nullexport const getDB = async () =&gt; &#123;  if (!dbInstance) &#123;    dbInstance = await initDB()  &#125;  return dbInstance&#125;\n连接管理最佳实践\n// 在Vue应用中管理数据库连接// src/plugins/indexedDB.jsimport &#123; getDB &#125; from &#x27;@/utils/indexedDB&#x27;export default &#123;  install(app) &#123;    // 提供全局的数据库实例    app.provide(&#x27;$db&#x27;, getDB())        // 在组件中可以通过 inject(&#x27;$db&#x27;) 获取  &#125;&#125;// main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import IndexedDB from &#x27;./plugins/indexedDB&#x27;const app = createApp(App)app.use(IndexedDB)app.mount(&#x27;#app&#x27;)\n数据操作（CRUD）\n创建数据（Create）\n// src/api/user.jsimport &#123; getDB &#125; from &#x27;@/utils/indexedDB&#x27;export const createUser = async (userData) =&gt; &#123;  const db = await getDB()    try &#123;    // 使用add方法添加新数据（主键不存在）    const userId = await db.add(&#x27;users&#x27;, &#123;      ...userData,      createdAt: new Date().toISOString(),      updatedAt: new Date().toISOString()    &#125;)        return &#123; success: true, userId &#125;  &#125; catch (error) &#123;    console.error(&#x27;创建用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;export const createOrUpdateUser = async (userData) =&gt; &#123;  const db = await getDB()    try &#123;    // 使用put方法添加或更新数据    const userId = await db.put(&#x27;users&#x27;, &#123;      ...userData,      updatedAt: new Date().toISOString()    &#125;)        return &#123; success: true, userId &#125;  &#125; catch (error) &#123;    console.error(&#x27;创建或更新用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n读取数据（Read）\n// 获取单个用户export const getUserById = async (userId) =&gt; &#123;  const db = await getDB()    try &#123;    const user = await db.get(&#x27;users&#x27;, userId)    return &#123; success: true, data: user &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 获取所有用户export const getAllUsers = async () =&gt; &#123;  const db = await getDB()    try &#123;    const users = await db.getAll(&#x27;users&#x27;)    return &#123; success: true, data: users &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取所有用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 获取指定数量的用户export const getUsersByLimit = async (limit, offset = 0) =&gt; &#123;  const db = await getDB()    try &#123;    const users = await db.getAll(&#x27;users&#x27;, undefined, limit, offset)    return &#123; success: true, data: users &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取用户列表失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 获取用户总数export const getUserCount = async () =&gt; &#123;  const db = await getDB()    try &#123;    const count = await db.count(&#x27;users&#x27;)    return &#123; success: true, count &#125;  &#125; catch (error) &#123;    console.error(&#x27;获取用户总数失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n更新数据（Update）\nexport const updateUser = async (userId, updateData) =&gt; &#123;  const db = await getDB()    try &#123;    // 先获取当前用户数据    const user = await db.get(&#x27;users&#x27;, userId)        if (!user) &#123;      return &#123; success: false, error: &#x27;用户不存在&#x27; &#125;    &#125;        // 更新用户数据    const updatedUser = &#123;      ...user,      ...updateData,      updatedAt: new Date().toISOString()    &#125;        await db.put(&#x27;users&#x27;, updatedUser)    return &#123; success: true, data: updatedUser &#125;  &#125; catch (error) &#123;    console.error(&#x27;更新用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n删除数据（Delete）\n// 删除单个用户export const deleteUser = async (userId) =&gt; &#123;  const db = await getDB()    try &#123;    await db.delete(&#x27;users&#x27;, userId)    return &#123; success: true &#125;  &#125; catch (error) &#123;    console.error(&#x27;删除用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 清空用户表export const clearAllUsers = async () =&gt; &#123;  const db = await getDB()    try &#123;    await db.clear(&#x27;users&#x27;)    return &#123; success: true &#125;  &#125; catch (error) &#123;    console.error(&#x27;清空用户表失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n事务处理\n基本事务操作\n// 批量创建用户（使用事务确保原子性）export const batchCreateUsers = async (usersData) =&gt; &#123;  const db = await getDB()    try &#123;    // 开始一个读写事务    const tx = db.transaction(&#x27;users&#x27;, &#x27;readwrite&#x27;)    const store = tx.objectStore(&#x27;users&#x27;)        const results = []    for (const userData of usersData) &#123;      const userId = await store.add(&#123;        ...userData,        createdAt: new Date().toISOString(),        updatedAt: new Date().toISOString()      &#125;)      results.push(userId)    &#125;        // 等待事务完成    await tx.done        return &#123; success: true, userIds: results &#125;  &#125; catch (error) &#123;    console.error(&#x27;批量创建用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n跨存储事务\n// 同时操作多个对象仓库export const createOrderWithProducts = async (orderData, productIds) =&gt; &#123;  const db = await getDB()    try &#123;    // 开始一个跨存储的读写事务    const tx = db.transaction([&#x27;orders&#x27;, &#x27;products&#x27;, &#x27;inventory&#x27;], &#x27;readwrite&#x27;)        const orderStore = tx.objectStore(&#x27;orders&#x27;)    const productStore = tx.objectStore(&#x27;products&#x27;)    const inventoryStore = tx.objectStore(&#x27;inventory&#x27;)        // 1. 创建订单    const orderId = await orderStore.add(&#123;      ...orderData,      createdAt: new Date().toISOString(),      status: &#x27;pending&#x27;    &#125;)        // 2. 获取相关产品信息    const products = []    for (const productId of productIds) &#123;      const product = await productStore.get(productId)      if (product) &#123;        products.push(product)                // 3. 更新库存        const inventory = await inventoryStore.get(productId)        if (inventory &amp;&amp; inventory.quantity &gt; 0) &#123;          await inventoryStore.put(&#123;            ...inventory,            quantity: inventory.quantity - 1          &#125;)        &#125; else &#123;          throw new Error(`产品 $&#123;product.name&#125; 库存不足`)        &#125;      &#125;    &#125;        // 等待事务完成    await tx.done        return &#123;      success: true,      orderId,      products    &#125;  &#125; catch (error) &#123;    console.error(&#x27;创建订单失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n事务错误处理\n// 事务错误处理示例export const safeTransaction = async (storeNames, mode, operation) =&gt; &#123;  const db = await getDB()    try &#123;    const tx = db.transaction(storeNames, mode)        // 监听事务错误    tx.onerror = (event) =&gt; &#123;      console.error(&#x27;事务错误:&#x27;, event.target.error)      // 阻止错误冒泡到全局      event.preventDefault()    &#125;        tx.onabort = () =&gt; &#123;      console.log(&#x27;事务被中止&#x27;)    &#125;        tx.oncomplete = () =&gt; &#123;      console.log(&#x27;事务完成&#x27;)    &#125;        const result = await operation(tx)    await tx.done        return &#123; success: true, result &#125;  &#125; catch (error) &#123;    console.error(&#x27;事务操作失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 使用安全事务export const transferPoints = async (fromUserId, toUserId, amount) =&gt; &#123;  return safeTransaction([&#x27;users&#x27;], &#x27;readwrite&#x27;, async (tx) =&gt; &#123;    const store = tx.objectStore(&#x27;users&#x27;)        // 获取用户数据    const fromUser = await store.get(fromUserId)    const toUser = await store.get(toUserId)        if (!fromUser) throw new Error(&#x27;源用户不存在&#x27;)    if (!toUser) throw new Error(&#x27;目标用户不存在&#x27;)    if (fromUser.points &lt; amount) throw new Error(&#x27;积分不足&#x27;)        // 更新积分    await store.put(&#123;      ...fromUser,      points: fromUser.points - amount,      updatedAt: new Date().toISOString()    &#125;)        await store.put(&#123;      ...toUser,      points: toUser.points + amount,      updatedAt: new Date().toISOString()    &#125;)        // 记录交易    const transaction = &#123;      id: Date.now(),      fromUserId,      toUserId,      amount,      timestamp: new Date().toISOString()    &#125;        return transaction  &#125;)&#125;\n数据库版本管理\n版本升级策略\n// src/utils/indexedDB.js - 版本升级示例export const DB_NAME = &#x27;MyVueAppDB&#x27;export const DB_VERSION = 3 // 升级到版本3export const initDB = async () =&gt; &#123;  return openDB(DB_NAME, DB_VERSION, &#123;    upgrade(db, oldVersion, newVersion) &#123;      console.log(`数据库升级: $&#123;oldVersion&#125; -&gt; $&#123;newVersion&#125;`)            // 版本 0 -&gt; 1: 初始版本      if (oldVersion &lt; 1) &#123;        // 创建用户表        const userStore = db.createObjectStore(&#x27;users&#x27;, &#123;           keyPath: &#x27;id&#x27;,          autoIncrement: true         &#125;)                // 创建商品表        db.createObjectStore(&#x27;products&#x27;, &#123; keyPath: &#x27;id&#x27; &#125;)                // 创建设置表        db.createObjectStore(&#x27;settings&#x27;)      &#125;            // 版本 1 -&gt; 2: 添加订单表和索引      if (oldVersion &lt; 2) &#123;        // 创建订单表        const orderStore = db.createObjectStore(&#x27;orders&#x27;, &#123;           keyPath: &#x27;id&#x27;,          autoIncrement: true         &#125;)                // 为订单表创建用户ID索引        orderStore.createIndex(&#x27;userId&#x27;, &#x27;userId&#x27;)        orderStore.createIndex(&#x27;status&#x27;, &#x27;status&#x27;)        orderStore.createIndex(&#x27;createdAt&#x27;, &#x27;createdAt&#x27;)                // 为用户表添加索引        const userStore = db.transaction(&#x27;users&#x27;, &#x27;readwrite&#x27;).objectStore(&#x27;users&#x27;)        userStore.createIndex(&#x27;email&#x27;, &#x27;email&#x27;, &#123; unique: true &#125;)        userStore.createIndex(&#x27;username&#x27;, &#x27;username&#x27;, &#123; unique: true &#125;)      &#125;            // 版本 2 -&gt; 3: 添加库存表和修改用户表结构      if (oldVersion &lt; 3) &#123;        // 创建库存表        db.createObjectStore(&#x27;inventory&#x27;, &#123; keyPath: &#x27;productId&#x27; &#125;)                // 修改用户表结构        const userStore = db.transaction(&#x27;users&#x27;, &#x27;readwrite&#x27;).objectStore(&#x27;users&#x27;)                // 如果用户表没有points字段，添加默认值        userStore.openCursor().then(function cursorIterate(cursor) &#123;          if (!cursor) return                    const user = cursor.value          if (user.points === undefined) &#123;            user.points = 0 // 默认积分            user.level = 1 // 默认等级            cursor.update(user)          &#125;                    return cursor.continue().then(cursorIterate)        &#125;)                // 为用户表添加新的索引        userStore.createIndex(&#x27;level&#x27;, &#x27;level&#x27;)        userStore.createIndex(&#x27;points&#x27;, &#x27;points&#x27;)      &#125;    &#125;  &#125;)&#125;\n版本管理最佳实践\n// 数据库版本管理工具export const getCurrentDBVersion = async () =&gt; &#123;  try &#123;    const db = await openDB(DB_NAME, 1, &#123; upgrade: () =&gt; &#123;&#125; &#125;)    const version = db.version    db.close()    return version  &#125; catch (error) &#123;    if (error.name === &#x27;NotFoundError&#x27;) &#123;      return 0 // 数据库不存在    &#125;    throw error  &#125;&#125;// 数据库迁移工具export const migrateDB = async (targetVersion) =&gt; &#123;  const currentVersion = await getCurrentDBVersion()    if (currentVersion &gt;= targetVersion) &#123;    console.log(`数据库版本已是 $&#123;currentVersion&#125;，无需迁移`)    return true  &#125;    console.log(`开始数据库迁移: $&#123;currentVersion&#125; -&gt; $&#123;targetVersion&#125;`)    try &#123;    const db = await openDB(DB_NAME, targetVersion, &#123;      upgrade(db, oldVersion, newVersion) &#123;        console.log(`执行升级: $&#123;oldVersion&#125; -&gt; $&#123;newVersion&#125;`)        // 这里可以执行具体的升级逻辑      &#125;    &#125;)        db.close()    console.log(&#x27;数据库迁移完成&#x27;)    return true  &#125; catch (error) &#123;    console.error(&#x27;数据库迁移失败:&#x27;, error)    throw error  &#125;&#125;\n索引使用\n创建索引\n// 在数据库升级时创建索引export const initDBWithIndexes = async () =&gt; &#123;  return openDB(&#x27;MyAppDB&#x27;, 2, &#123;    upgrade(db) &#123;      // 用户表索引      if (db.objectStoreNames.contains(&#x27;users&#x27;)) &#123;        const userStore = db.transaction(&#x27;users&#x27;, &#x27;readwrite&#x27;).objectStore(&#x27;users&#x27;)                // 创建普通索引        if (!userStore.indexNames.contains(&#x27;email&#x27;)) &#123;          userStore.createIndex(&#x27;email&#x27;, &#x27;email&#x27;, &#123; unique: true &#125;)        &#125;                // 创建复合索引        if (!userStore.indexNames.contains(&#x27;nameAge&#x27;)) &#123;          userStore.createIndex(&#x27;nameAge&#x27;, [&#x27;name&#x27;, &#x27;age&#x27;])        &#125;                // 创建多字段索引        if (!userStore.indexNames.contains(&#x27;addressCity&#x27;)) &#123;          userStore.createIndex(&#x27;addressCity&#x27;, &#x27;address.city&#x27;)        &#125;      &#125;            // 订单表索引      if (!db.objectStoreNames.contains(&#x27;orders&#x27;)) &#123;        const orderStore = db.createObjectStore(&#x27;orders&#x27;, &#123;           keyPath: &#x27;id&#x27;,          autoIncrement: true         &#125;)                // 创建多个索引        orderStore.createIndex(&#x27;userId&#x27;, &#x27;userId&#x27;)        orderStore.createIndex(&#x27;status&#x27;, &#x27;status&#x27;)        orderStore.createIndex(&#x27;createdAt&#x27;, &#x27;createdAt&#x27;)        orderStore.createIndex(&#x27;totalAmount&#x27;, &#x27;totalAmount&#x27;)                // 创建唯一索引        orderStore.createIndex(&#x27;orderNumber&#x27;, &#x27;orderNumber&#x27;, &#123; unique: true &#125;)      &#125;    &#125;  &#125;)&#125;\n使用索引查询\n// 通过索引查询export const getUserByEmail = async (email) =&gt; &#123;  const db = await getDB()    try &#123;    const user = await db.getFromIndex(&#x27;users&#x27;, &#x27;email&#x27;, email)    return &#123; success: true, data: user &#125;  &#125; catch (error) &#123;    console.error(&#x27;通过邮箱查询用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 通过索引获取多个结果export const getOrdersByUserId = async (userId) =&gt; &#123;  const db = await getDB()    try &#123;    const orders = await db.getAllFromIndex(&#x27;orders&#x27;, &#x27;userId&#x27;, userId)    return &#123; success: true, data: orders &#125;  &#125; catch (error) &#123;    console.error(&#x27;通过用户ID查询订单失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 通过索引获取范围数据export const getHighValueOrders = async (minAmount) =&gt; &#123;  const db = await getDB()    try &#123;    // 获取金额大于等于minAmount的订单    const range = IDBKeyRange.lowerBound(minAmount)    const orders = await db.getAllFromIndex(&#x27;orders&#x27;, &#x27;totalAmount&#x27;, range)        return &#123; success: true, data: orders &#125;  &#125; catch (error) &#123;    console.error(&#x27;查询高价值订单失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n索引管理\n// 索引管理工具export const getIndexNames = async (storeName) =&gt; &#123;  const db = await getDB()    try &#123;    const tx = db.transaction(storeName, &#x27;readonly&#x27;)    const store = tx.objectStore(storeName)    const indexes = Array.from(store.indexNames)        await tx.done    return &#123; success: true, indexes &#125;  &#125; catch (error) &#123;    console.error(`获取$&#123;storeName&#125;索引列表失败:`, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 删除索引export const deleteIndex = async (storeName, indexName) =&gt; &#123;  const db = await getDB()    try &#123;    const tx = db.transaction(storeName, &#x27;readwrite&#x27;)    const store = tx.objectStore(storeName)        if (store.indexNames.contains(indexName)) &#123;      store.deleteIndex(indexName)      await tx.done      return &#123; success: true, message: `索引 $&#123;indexName&#125; 删除成功` &#125;    &#125; else &#123;      return &#123; success: false, error: `索引 $&#123;indexName&#125; 不存在` &#125;    &#125;  &#125; catch (error) &#123;    console.error(`删除索引 $&#123;indexName&#125; 失败:`, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n高级查询操作\n区间查找\n// 区间查找工具export const getUsersByAgeRange = async (minAge, maxAge) =&gt; &#123;  const db = await getDB()    try &#123;    // 创建区间对象    const ageRange = IDBKeyRange.bound(minAge, maxAge)        // 通过索引查询区间数据    const users = await db.getAllFromIndex(&#x27;users&#x27;, &#x27;age&#x27;, ageRange)        return &#123; success: true, data: users &#125;  &#125; catch (error) &#123;    console.error(&#x27;按年龄区间查询用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 复杂区间查询export const getRecentOrdersByStatus = async (status, days = 7) =&gt; &#123;  const db = await getDB()    try &#123;    const date = new Date()    date.setDate(date.getDate() - days)    const minDate = date.toISOString()        // 使用复合查询：状态和日期范围    const tx = db.transaction(&#x27;orders&#x27;, &#x27;readonly&#x27;)    const store = tx.objectStore(&#x27;orders&#x27;)        // 先按状态筛选    const statusIndex = store.index(&#x27;status&#x27;)    const statusRange = IDBKeyRange.only(status)        const orders = []        // 使用游标遍历结果并进一步筛选日期    await new Promise((resolve, reject) =&gt; &#123;      const cursorRequest = statusIndex.openCursor(statusRange)            cursorRequest.onsuccess = (event) =&gt; &#123;        const cursor = event.target.result        if (cursor) &#123;          const order = cursor.value          if (order.createdAt &gt;= minDate) &#123;            orders.push(order)          &#125;          cursor.continue()        &#125; else &#123;          resolve()        &#125;      &#125;            cursorRequest.onerror = (event) =&gt; &#123;        reject(event.target.error)      &#125;    &#125;)        await tx.done    return &#123; success: true, data: orders &#125;  &#125; catch (error) &#123;    console.error(&#x27;查询最近订单失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n游标操作\n// 使用游标遍历所有数据export const iterateAllUsers = async (callback) =&gt; &#123;  const db = await getDB()    try &#123;    const tx = db.transaction(&#x27;users&#x27;, &#x27;readonly&#x27;)    const store = tx.objectStore(&#x27;users&#x27;)        await new Promise((resolve, reject) =&gt; &#123;      const cursorRequest = store.openCursor()            cursorRequest.onsuccess = (event) =&gt; &#123;        const cursor = event.target.result        if (cursor) &#123;          // 调用回调函数处理当前记录          const shouldContinue = callback(cursor.value, cursor.key)                    if (shouldContinue !== false) &#123;            cursor.continue()          &#125; else &#123;            resolve() // 停止遍历          &#125;        &#125; else &#123;          resolve() // 遍历完成        &#125;      &#125;            cursorRequest.onerror = (event) =&gt; &#123;        reject(event.target.error)      &#125;    &#125;)        await tx.done    return &#123; success: true &#125;  &#125; catch (error) &#123;    console.error(&#x27;遍历用户数据失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 使用游标进行分页查询export const getUsersByPage = async (page = 1, pageSize = 20) =&gt; &#123;  const db = await getDB()    try &#123;    const tx = db.transaction(&#x27;users&#x27;, &#x27;readonly&#x27;)    const store = tx.objectStore(&#x27;users&#x27;)        const users = []    const totalCount = await store.count()    const totalPages = Math.ceil(totalCount / pageSize)    const skip = (page - 1) * pageSize        let count = 0        await new Promise((resolve, reject) =&gt; &#123;      const cursorRequest = store.openCursor()            cursorRequest.onsuccess = (event) =&gt; &#123;        const cursor = event.target.result        if (cursor) &#123;          if (count &gt;= skip &amp;&amp; count &lt; skip + pageSize) &#123;            users.push(cursor.value)          &#125;                    count++                    if (count &lt; skip + pageSize) &#123;            cursor.continue()          &#125; else &#123;            resolve()          &#125;        &#125; else &#123;          resolve()        &#125;      &#125;            cursorRequest.onerror = (event) =&gt; &#123;        reject(event.target.error)      &#125;    &#125;)        await tx.done        return &#123;      success: true,      data: users,      pagination: &#123;        page,        pageSize,        totalCount,        totalPages      &#125;    &#125;  &#125; catch (error) &#123;    console.error(&#x27;分页查询用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n复杂查询组合\n// 复杂查询示例：多条件筛选和排序export const searchUsers = async (filters = &#123;&#125;, sort = &#123; field: &#x27;createdAt&#x27;, order: &#x27;desc&#x27; &#125;) =&gt; &#123;  const db = await getDB()    try &#123;    const tx = db.transaction(&#x27;users&#x27;, &#x27;readonly&#x27;)    const store = tx.objectStore(&#x27;users&#x27;)        let cursorRequest        // 根据筛选条件选择合适的索引    if (filters.email) &#123;      cursorRequest = store.index(&#x27;email&#x27;).openCursor(IDBKeyRange.only(filters.email))    &#125; else if (filters.age) &#123;      const ageRange = IDBKeyRange.bound(        filters.age.min || 0,        filters.age.max || 150      )      cursorRequest = store.index(&#x27;age&#x27;).openCursor(ageRange)    &#125; else if (filters.level) &#123;      cursorRequest = store.index(&#x27;level&#x27;).openCursor(IDBKeyRange.only(filters.level))    &#125; else &#123;      // 默认遍历所有数据      cursorRequest = store.openCursor()    &#125;        const users = []        await new Promise((resolve, reject) =&gt; &#123;      cursorRequest.onsuccess = (event) =&gt; &#123;        const cursor = event.target.result        if (cursor) &#123;          const user = cursor.value          let match = true                    // 应用额外的筛选条件          if (filters.name &amp;&amp; !user.name.toLowerCase().includes(filters.name.toLowerCase())) &#123;            match = false          &#125;                    if (filters.points &amp;&amp; user.points &lt; (filters.points.min || 0)) &#123;            match = false          &#125;                    if (match) &#123;            users.push(user)          &#125;                    cursor.continue()        &#125; else &#123;          // 遍历完成后进行排序          users.sort((a, b) =&gt; &#123;            if (a[sort.field] &lt; b[sort.field]) &#123;              return sort.order === &#x27;asc&#x27; ? -1 : 1            &#125;            if (a[sort.field] &gt; b[sort.field]) &#123;              return sort.order === &#x27;asc&#x27; ? 1 : -1            &#125;            return 0          &#125;)                    resolve()        &#125;      &#125;            cursorRequest.onerror = (event) =&gt; &#123;        reject(event.target.error)      &#125;    &#125;)        await tx.done        return &#123; success: true, data: users &#125;  &#125; catch (error) &#123;    console.error(&#x27;搜索用户失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\nVue 中的最佳实践\n创建 Vue Composition API 封装\n// src/composables/useIndexedDB.jsimport &#123; ref, reactive, toRefs &#125; from &#x27;vue&#x27;import &#123; getDB &#125; from &#x27;@/utils/indexedDB&#x27;export const useIndexedDB = (storeName) =&gt; &#123;  const state = reactive(&#123;    data: null,    loading: false,    error: null,    pagination: &#123;      page: 1,      pageSize: 20,      totalCount: 0,      totalPages: 0    &#125;  &#125;)  const resetState = () =&gt; &#123;    state.data = null    state.loading = false    state.error = null  &#125;  const getById = async (id) =&gt; &#123;    resetState()    state.loading = true    try &#123;      const db = await getDB()      const data = await db.get(storeName, id)      state.data = data      return &#123; success: true, data &#125;    &#125; catch (error) &#123;      state.error = error.message      console.error(`获取$&#123;storeName&#125;数据失败:`, error)      return &#123; success: false, error: error.message &#125;    &#125; finally &#123;      state.loading = false    &#125;  &#125;  const getAll = async () =&gt; &#123;    resetState()    state.loading = true    try &#123;      const db = await getDB()      const data = await db.getAll(storeName)      state.data = data      state.pagination.totalCount = data.length      state.pagination.totalPages = 1      return &#123; success: true, data &#125;    &#125; catch (error) &#123;      state.error = error.message      console.error(`获取所有$&#123;storeName&#125;数据失败:`, error)      return &#123; success: false, error: error.message &#125;    &#125; finally &#123;      state.loading = false    &#125;  &#125;  const getByPage = async (page = 1, pageSize = 20) =&gt; &#123;    resetState()    state.loading = true    try &#123;      const db = await getDB()      const tx = db.transaction(storeName, &#x27;readonly&#x27;)      const store = tx.objectStore(storeName)      const totalCount = await store.count()      const totalPages = Math.ceil(totalCount / pageSize)      const skip = (page - 1) * pageSize      const data = []      let count = 0      await new Promise((resolve, reject) =&gt; &#123;        const cursorRequest = store.openCursor()        cursorRequest.onsuccess = (event) =&gt; &#123;          const cursor = event.target.result          if (cursor) &#123;            if (count &gt;= skip &amp;&amp; count &lt; skip + pageSize) &#123;              data.push(cursor.value)            &#125;            count++            if (count &lt; skip + pageSize) &#123;              cursor.continue()            &#125; else &#123;              resolve()            &#125;          &#125; else &#123;            resolve()          &#125;        &#125;        cursorRequest.onerror = (event) =&gt; &#123;          reject(event.target.error)        &#125;      &#125;)      await tx.done      state.data = data      state.pagination = &#123;        page,        pageSize,        totalCount,        totalPages      &#125;      return &#123;        success: true,        data,        pagination: state.pagination      &#125;    &#125; catch (error) &#123;      state.error = error.message      console.error(`分页获取$&#123;storeName&#125;数据失败:`, error)      return &#123; success: false, error: error.message &#125;    &#125; finally &#123;      state.loading = false    &#125;  &#125;  const create = async (item) =&gt; &#123;    state.loading = true    try &#123;      const db = await getDB()      const id = await db.add(storeName, item)      return &#123; success: true, id &#125;    &#125; catch (error) &#123;      state.error = error.message      console.error(`创建$&#123;storeName&#125;数据失败:`, error)      return &#123; success: false, error: error.message &#125;    &#125; finally &#123;      state.loading = false    &#125;  &#125;  const update = async (id, item) =&gt; &#123;    state.loading = true    try &#123;      const db = await getDB()      await db.put(storeName, &#123; ...item, id &#125;)      return &#123; success: true &#125;    &#125; catch (error) &#123;      state.error = error.message      console.error(`更新$&#123;storeName&#125;数据失败:`, error)      return &#123; success: false, error: error.message &#125;    &#125; finally &#123;      state.loading = false    &#125;  &#125;  const remove = async (id) =&gt; &#123;    state.loading = true    try &#123;      const db = await getDB()      await db.delete(storeName, id)      return &#123; success: true &#125;    &#125; catch (error) &#123;      state.error = error.message      console.error(`删除$&#123;storeName&#125;数据失败:`, error)      return &#123; success: false, error: error.message &#125;    &#125; finally &#123;      state.loading = false    &#125;  &#125;  const clear = async () =&gt; &#123;    state.loading = true    try &#123;      const db = await getDB()      await db.clear(storeName)      state.data = null      state.pagination.totalCount = 0      state.pagination.totalPages = 0      return &#123; success: true &#125;    &#125; catch (error) &#123;      state.error = error.message      console.error(`清空$&#123;storeName&#125;数据失败:`, error)      return &#123; success: false, error: error.message &#125;    &#125; finally &#123;      state.loading = false    &#125;  &#125;  return &#123;    ...toRefs(state),    getById,    getAll,    getByPage,    create,    update,    remove,    clear,    resetState  &#125;&#125;\n在 Vue 组件中使用\n&lt;!-- src/components/UserManagement.vue --&gt;&lt;template&gt;  &lt;div class=&quot;user-management&quot;&gt;    &lt;div class=&quot;header&quot;&gt;      &lt;h2&gt;用户管理&lt;/h2&gt;      &lt;button @click=&quot;showCreateModal = true&quot; class=&quot;btn btn-primary&quot;&gt;        添加用户      &lt;/button&gt;    &lt;/div&gt;    &lt;!-- 搜索和筛选 --&gt;    &lt;div class=&quot;filters&quot;&gt;      &lt;input        v-model=&quot;searchName&quot;        placeholder=&quot;搜索用户名...&quot;        @input=&quot;handleSearch&quot;        class=&quot;search-input&quot;      /&gt;      &lt;select v-model=&quot;filterLevel&quot; @change=&quot;handleSearch&quot; class=&quot;filter-select&quot;&gt;        &lt;option value=&quot;&quot;&gt;所有等级&lt;/option&gt;        &lt;option value=&quot;1&quot;&gt;等级1&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;等级2&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;等级3&lt;/option&gt;      &lt;/select&gt;    &lt;/div&gt;    &lt;!-- 加载状态 --&gt;    &lt;div v-if=&quot;loading&quot; class=&quot;loading&quot;&gt;      &lt;span&gt;加载中...&lt;/span&gt;    &lt;/div&gt;    &lt;!-- 错误提示 --&gt;    &lt;div v-else-if=&quot;error&quot; class=&quot;error&quot;&gt;      &lt;span&gt;错误: &#123;&#123; error &#125;&#125;&lt;/span&gt;    &lt;/div&gt;    &lt;!-- 用户列表 --&gt;    &lt;div v-else class=&quot;user-list&quot;&gt;      &lt;table class=&quot;user-table&quot;&gt;        &lt;thead&gt;          &lt;tr&gt;            &lt;th&gt;ID&lt;/th&gt;            &lt;th&gt;用户名&lt;/th&gt;            &lt;th&gt;邮箱&lt;/th&gt;            &lt;th&gt;年龄&lt;/th&gt;            &lt;th&gt;等级&lt;/th&gt;            &lt;th&gt;积分&lt;/th&gt;            &lt;th&gt;操作&lt;/th&gt;          &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;          &lt;tr v-for=&quot;user in data&quot; :key=&quot;user.id&quot;&gt;            &lt;td&gt;&#123;&#123; user.id &#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123; user.name &#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123; user.email &#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123; user.age &#125;&#125;&lt;/td&gt;            &lt;td&gt;等级&#123;&#123; user.level &#125;&#125;&lt;/td&gt;            &lt;td&gt;&#123;&#123; user.points &#125;&#125;&lt;/td&gt;            &lt;td class=&quot;actions&quot;&gt;              &lt;button @click=&quot;handleEdit(user)&quot; class=&quot;btn btn-edit&quot;&gt;编辑&lt;/button&gt;              &lt;button @click=&quot;handleDelete(user.id)&quot; class=&quot;btn btn-delete&quot;&gt;删除&lt;/button&gt;            &lt;/td&gt;          &lt;/tr&gt;        &lt;/tbody&gt;      &lt;/table&gt;      &lt;!-- 分页 --&gt;      &lt;div class=&quot;pagination&quot; v-if=&quot;pagination.totalPages &gt; 1&quot;&gt;        &lt;button          @click=&quot;handlePageChange(pagination.page - 1)&quot;          :disabled=&quot;pagination.page === 1&quot;          class=&quot;page-btn&quot;        &gt;          上一页        &lt;/button&gt;        &lt;span class=&quot;page-info&quot;&gt;          第 &#123;&#123; pagination.page &#125;&#125; 页 / 共 &#123;&#123; pagination.totalPages &#125;&#125; 页        &lt;/span&gt;        &lt;button          @click=&quot;handlePageChange(pagination.page + 1)&quot;          :disabled=&quot;pagination.page === pagination.totalPages&quot;          class=&quot;page-btn&quot;        &gt;          下一页        &lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;!-- 创建/编辑用户模态框 --&gt;    &lt;div v-if=&quot;showCreateModal || showEditModal&quot; class=&quot;modal-overlay&quot;&gt;      &lt;div class=&quot;modal&quot;&gt;        &lt;div class=&quot;modal-header&quot;&gt;          &lt;h3&gt;&#123;&#123; showEditModal ? &#x27;编辑用户&#x27; : &#x27;创建用户&#x27; &#125;&#125;&lt;/h3&gt;          &lt;button @click=&quot;closeModal&quot; class=&quot;close-btn&quot;&gt;&amp;times;&lt;/button&gt;        &lt;/div&gt;        &lt;div class=&quot;modal-body&quot;&gt;          &lt;form @submit.prevent=&quot;handleSubmit&quot;&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;label&gt;用户名:&lt;/label&gt;              &lt;input                v-model=&quot;form.name&quot;                required                class=&quot;form-control&quot;              /&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;label&gt;邮箱:&lt;/label&gt;              &lt;input                v-model=&quot;form.email&quot;                type=&quot;email&quot;                required                class=&quot;form-control&quot;              /&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;label&gt;年龄:&lt;/label&gt;              &lt;input                v-model.number=&quot;form.age&quot;                type=&quot;number&quot;                min=&quot;1&quot;                max=&quot;150&quot;                required                class=&quot;form-control&quot;              /&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;label&gt;等级:&lt;/label&gt;              &lt;select v-model.number=&quot;form.level&quot; class=&quot;form-control&quot;&gt;                &lt;option value=&quot;1&quot;&gt;等级1&lt;/option&gt;                &lt;option value=&quot;2&quot;&gt;等级2&lt;/option&gt;                &lt;option value=&quot;3&quot;&gt;等级3&lt;/option&gt;              &lt;/select&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;label&gt;积分:&lt;/label&gt;              &lt;input                v-model.number=&quot;form.points&quot;                type=&quot;number&quot;                min=&quot;0&quot;                class=&quot;form-control&quot;              /&gt;            &lt;/div&gt;            &lt;div class=&quot;form-actions&quot;&gt;              &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;                &#123;&#123; showEditModal ? &#x27;更新&#x27; : &#x27;创建&#x27; &#125;&#125;              &lt;/button&gt;              &lt;button type=&quot;button&quot; @click=&quot;closeModal&quot; class=&quot;btn btn-secondary&quot;&gt;                取消              &lt;/button&gt;            &lt;/div&gt;          &lt;/form&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;import &#123; useIndexedDB &#125; from &#x27;@/composables/useIndexedDB&#x27;import &#123; searchUsers &#125; from &#x27;@/api/user&#x27;// 使用IndexedDB composableconst &#123;  data,  loading,  error,  pagination,  getByPage,  create,  update,  remove&#125; = useIndexedDB(&#x27;users&#x27;)// 组件状态const showCreateModal = ref(false)const showEditModal = ref(false)const searchName = ref(&#x27;&#x27;)const filterLevel = ref(&#x27;&#x27;)const currentEditId = ref(null)// 表单数据const form = reactive(&#123;  name: &#x27;&#x27;,  email: &#x27;&#x27;,  age: 18,  level: 1,  points: 0,  createdAt: new Date().toISOString(),  updatedAt: new Date().toISOString()&#125;)// 初始化const init = async () =&gt; &#123;  await getByPage(1, 20)&#125;// 搜索处理const handleSearch = async () =&gt; &#123;  const filters = &#123;&#125;  if (searchName.value) &#123;    filters.name = searchName.value  &#125;  if (filterLevel.value) &#123;    filters.level = parseInt(filterLevel.value)  &#125;  const result = await searchUsers(filters)  if (result.success) &#123;    data.value = result.data    pagination.value.totalCount = result.data.length    pagination.value.totalPages = 1  &#125;&#125;// 分页处理const handlePageChange = async (newPage) =&gt; &#123;  await getByPage(newPage, pagination.value.pageSize)&#125;// 编辑用户const handleEdit = async (user) =&gt; &#123;  currentEditId.value = user.id  form.name = user.name  form.email = user.email  form.age = user.age  form.level = user.level  form.points = user.points  showEditModal.value = true&#125;// 删除用户const handleDelete = async (userId) =&gt; &#123;  if (confirm(&#x27;确定要删除这个用户吗？&#x27;)) &#123;    const result = await remove(userId)    if (result.success) &#123;      await init() // 重新加载数据    &#125;  &#125;&#125;// 表单提交const handleSubmit = async () =&gt; &#123;  form.updatedAt = new Date().toISOString()  if (showEditModal.value) &#123;    // 更新用户    const result = await update(currentEditId.value, form)    if (result.success) &#123;      closeModal()      await init()    &#125;  &#125; else &#123;    // 创建用户    const result = await create(form)    if (result.success) &#123;      closeModal()      await init()    &#125;  &#125;&#125;// 关闭模态框const closeModal = () =&gt; &#123;  showCreateModal.value = false  showEditModal.value = false  currentEditId.value = null  // 重置表单  form.name = &#x27;&#x27;  form.email = &#x27;&#x27;  form.age = 18  form.level = 1  form.points = 0&#125;// 页面加载时初始化init()&lt;/script&gt;&lt;style scoped&gt;/* 组件样式 */.user-management &#123;  max-width: 1200px;  margin: 0 auto;  padding: 20px;&#125;.header &#123;  display: flex;  justify-content: space-between;  align-items: center;  margin-bottom: 20px;&#125;.filters &#123;  display: flex;  gap: 10px;  margin-bottom: 20px;&#125;.search-input, .filter-select &#123;  padding: 8px 12px;  border: 1px solid #ddd;  border-radius: 4px;  flex: 1;  max-width: 300px;&#125;.loading, .error &#123;  text-align: center;  padding: 20px;  color: #666;&#125;.error &#123;  color: #dc3545;&#125;.user-table &#123;  width: 100%;  border-collapse: collapse;  margin-bottom: 20px;&#125;.user-table th, .user-table td &#123;  padding: 12px 15px;  text-align: left;  border-bottom: 1px solid #ddd;&#125;.user-table th &#123;  background-color: #f8f9fa;  font-weight: bold;&#125;.actions &#123;  display: flex;  gap: 5px;&#125;.btn &#123;  padding: 6px 12px;  border: none;  border-radius: 4px;  cursor: pointer;  font-size: 14px;&#125;.btn-primary &#123;  background-color: #007bff;  color: white;&#125;.btn-edit &#123;  background-color: #28a745;  color: white;&#125;.btn-delete &#123;  background-color: #dc3545;  color: white;&#125;.pagination &#123;  display: flex;  justify-content: center;  align-items: center;  gap: 10px;  margin-top: 20px;&#125;.page-btn &#123;  padding: 6px 12px;  border: 1px solid #ddd;  background-color: white;  cursor: pointer;&#125;.page-btn:disabled &#123;  cursor: not-allowed;  opacity: 0.5;&#125;.modal-overlay &#123;  position: fixed;  top: 0;  left: 0;  right: 0;  bottom: 0;  background-color: rgba(0, 0, 0, 0.5);  display: flex;  justify-content: center;  align-items: center;  z-index: 1000;&#125;.modal &#123;  background-color: white;  border-radius: 4px;  width: 90%;  max-width: 500px;  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);&#125;.modal-header &#123;  display: flex;  justify-content: space-between;  align-items: center;  padding: 15px;  border-bottom: 1px solid #ddd;&#125;.close-btn &#123;  background: none;  border: none;  font-size: 20px;  cursor: pointer;&#125;.modal-body &#123;  padding: 15px;&#125;.form-group &#123;  margin-bottom: 15px;&#125;.form-control &#123;  width: 100%;  padding: 8px 12px;  border: 1px solid #ddd;  border-radius: 4px;&#125;.form-actions &#123;  display: flex;  gap: 10px;  margin-top: 20px;&#125;&lt;/style&gt;\nVuex/Pinia 集成\n// src/store/indexedDB.js (Pinia store)import &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; getDB &#125; from &#x27;@/utils/indexedDB&#x27;export const useIndexedDBStore = defineStore(&#x27;indexedDB&#x27;, &#123;  state: () =&gt; (&#123;    stores: &#123;&#125;,    loading: false,    error: null  &#125;),  actions: &#123;    async initStore(storeName) &#123;      if (!this.stores[storeName]) &#123;        this.stores[storeName] = &#123;          data: [],          pagination: &#123;            page: 1,            pageSize: 20,            totalCount: 0,            totalPages: 0          &#125;        &#125;      &#125;    &#125;,    async getById(storeName, id) &#123;      this.loading = true      this.error = null      try &#123;        await this.initStore(storeName)        const db = await getDB()        const data = await db.get(storeName, id)                this.stores[storeName].data = data ? [data] : []        return &#123; success: true, data &#125;      &#125; catch (error) &#123;        this.error = error.message        console.error(`获取$&#123;storeName&#125;数据失败:`, error)        return &#123; success: false, error: error.message &#125;      &#125; finally &#123;        this.loading = false      &#125;    &#125;,    async getAll(storeName) &#123;      this.loading = true      this.error = null      try &#123;        await this.initStore(storeName)        const db = await getDB()        const data = await db.getAll(storeName)                this.stores[storeName].data = data        this.stores[storeName].pagination.totalCount = data.length        this.stores[storeName].pagination.totalPages = 1                return &#123; success: true, data &#125;      &#125; catch (error) &#123;        this.error = error.message        console.error(`获取所有$&#123;storeName&#125;数据失败:`, error)        return &#123; success: false, error: error.message &#125;      &#125; finally &#123;        this.loading = false      &#125;    &#125;,    async create(storeName, item) &#123;      this.loading = true      this.error = null      try &#123;        const db = await getDB()        const id = await db.add(storeName, item)                // 重新加载数据        await this.getAll(storeName)                return &#123; success: true, id &#125;      &#125; catch (error) &#123;        this.error = error.message        console.error(`创建$&#123;storeName&#125;数据失败:`, error)        return &#123; success: false, error: error.message &#125;      &#125; finally &#123;        this.loading = false      &#125;    &#125;,    async update(storeName, id, item) &#123;      this.loading = true      this.error = null      try &#123;        const db = await getDB()        await db.put(storeName, &#123; ...item, id &#125;)                // 重新加载数据        await this.getAll(storeName)                return &#123; success: true &#125;      &#125; catch (error) &#123;        this.error = error.message        console.error(`更新$&#123;storeName&#125;数据失败:`, error)        return &#123; success: false, error: error.message &#125;      &#125; finally &#123;        this.loading = false      &#125;    &#125;,    async remove(storeName, id) &#123;      this.loading = true      this.error = null      try &#123;        const db = await getDB()        await db.delete(storeName, id)                // 重新加载数据        await this.getAll(storeName)                return &#123; success: true &#125;      &#125; catch (error) &#123;        this.error = error.message        console.error(`删除$&#123;storeName&#125;数据失败:`, error)        return &#123; success: false, error: error.message &#125;      &#125; finally &#123;        this.loading = false      &#125;    &#125;  &#125;,  getters: &#123;    getStoreData: (state) =&gt; (storeName) =&gt; &#123;      return state.stores[storeName]?.data || []    &#125;,    getStorePagination: (state) =&gt; (storeName) =&gt; &#123;      return state.stores[storeName]?.pagination || &#123;        page: 1,        pageSize: 20,        totalCount: 0,        totalPages: 0      &#125;    &#125;  &#125;&#125;)\n常见问题与解决方案\n1. 数据库连接问题\n问题：数据库连接被阻塞或无法打开\n解决方案：\n// 改进的连接管理let dbInstance = nulllet dbOpening = falselet dbQueue = []export const getDB = async () =&gt; &#123;  if (dbInstance) &#123;    return dbInstance  &#125;  // 如果正在打开连接，加入队列等待  if (dbOpening) &#123;    return new Promise((resolve) =&gt; &#123;      dbQueue.push(resolve)    &#125;)  &#125;  dbOpening = true  try &#123;    dbInstance = await initDB()        // 通知所有等待的连接    while (dbQueue.length &gt; 0) &#123;      dbQueue.shift()(dbInstance)    &#125;        return dbInstance  &#125; catch (error) &#123;    console.error(&#x27;数据库连接失败:&#x27;, error)        // 清空队列并返回错误    while (dbQueue.length &gt; 0) &#123;      dbQueue.shift()(null)    &#125;        throw error  &#125; finally &#123;    dbOpening = false  &#125;&#125;// 连接健康检查export const checkDBHealth = async () =&gt; &#123;  try &#123;    const db = await getDB()        // 尝试执行一个简单的操作来检查连接状态    const tx = db.transaction(db.objectStoreNames[0] || &#x27;settings&#x27;, &#x27;readonly&#x27;)    await tx.done        return true  &#125; catch (error) &#123;    console.error(&#x27;数据库连接不健康，尝试重新连接:&#x27;, error)        // 重置连接实例    dbInstance = null        // 尝试重新连接    try &#123;      dbInstance = await initDB()      return true    &#125; catch (reconnectError) &#123;      console.error(&#x27;重新连接数据库失败:&#x27;, reconnectError)      return false    &#125;  &#125;&#125;\n2. 数据迁移问题\n问题：版本升级时数据迁移失败\n解决方案：\n// 安全的数据迁移工具export const safeMigrate = async (migrationSteps) =&gt; &#123;  const currentVersion = await getCurrentDBVersion()  const targetVersion = Math.max(...Object.keys(migrationSteps).map(v =&gt; parseInt(v)))  if (currentVersion &gt;= targetVersion) &#123;    return &#123; success: true, message: &#x27;无需迁移&#x27; &#125;  &#125;  try &#123;    // 备份当前数据    await backupDatabase()    // 执行迁移步骤    for (let version = currentVersion + 1; version &lt;= targetVersion; version++) &#123;      if (migrationSteps[version]) &#123;        console.log(`执行迁移步骤: $&#123;version&#125;`)        await migrationSteps[version]()      &#125;    &#125;    return &#123; success: true, message: &#x27;迁移完成&#x27; &#125;  &#125; catch (error) &#123;    console.error(&#x27;迁移失败，尝试回滚:&#x27;, error)        // 尝试回滚到备份    await restoreDatabase()        return &#123; success: false, error: error.message &#125;  &#125;&#125;// 数据库备份export const backupDatabase = async () =&gt; &#123;  const db = await getDB()  const backup = &#123;&#125;  // 备份所有对象仓库的数据  for (const storeName of db.objectStoreNames) &#123;    const tx = db.transaction(storeName, &#x27;readonly&#x27;)    const store = tx.objectStore(storeName)    backup[storeName] = await store.getAll()    await tx.done  &#125;  // 保存备份到localStorage或服务器  localStorage.setItem(&#x27;db_backup&#x27;, JSON.stringify(&#123;    timestamp: new Date().toISOString(),    version: db.version,    data: backup  &#125;))  return backup&#125;// 数据库恢复export const restoreDatabase = async () =&gt; &#123;  const backupData = localStorage.getItem(&#x27;db_backup&#x27;)    if (!backupData) &#123;    throw new Error(&#x27;没有找到备份数据&#x27;)  &#125;  const &#123; data, version &#125; = JSON.parse(backupData)  const db = await openDB(DB_NAME, version, &#123;    upgrade(db) &#123;      // 重建对象仓库结构      for (const storeName in data) &#123;        if (!db.objectStoreNames.contains(storeName)) &#123;          db.createObjectStore(storeName)        &#125;      &#125;    &#125;  &#125;)  // 恢复数据  for (const storeName in data) &#123;    const tx = db.transaction(storeName, &#x27;readwrite&#x27;)    const store = tx.objectStore(storeName)        // 清空现有数据    await store.clear()        // 恢复备份数据    for (const item of data[storeName]) &#123;      await store.put(item)    &#125;        await tx.done  &#125;  return true&#125;\n3. 性能问题\n问题：大量数据操作时性能低下\n解决方案：\n// 批量操作优化export const batchOperations = async (storeName, operations) =&gt; &#123;  const db = await getDB()    try &#123;    const tx = db.transaction(storeName, &#x27;readwrite&#x27;)    const store = tx.objectStore(storeName)        const results = []        for (const op of operations) &#123;      let result            switch (op.type) &#123;        case &#x27;add&#x27;:          result = await store.add(op.data)          break        case &#x27;put&#x27;:          result = await store.put(op.data)          break        case &#x27;delete&#x27;:          result = await store.delete(op.key)          break        default:          throw new Error(`不支持的操作类型: $&#123;op.type&#125;`)      &#125;            results.push(&#123;        operation: op,        result,        success: true      &#125;)    &#125;        await tx.done    return &#123; success: true, results &#125;  &#125; catch (error) &#123;    console.error(&#x27;批量操作失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 大数据集分页查询优化export const optimizedPagination = async (storeName, page = 1, pageSize = 20, indexName = null, keyRange = null) =&gt; &#123;  const db = await getDB()    try &#123;    const tx = db.transaction(storeName, &#x27;readonly&#x27;)    const store = tx.objectStore(storeName)        let index = store    if (indexName &amp;&amp; store.indexNames.contains(indexName)) &#123;      index = store.index(indexName)    &#125;        // 获取总数（优化：如果有范围查询，先获取范围内的总数）    const totalCount = keyRange       ? await index.count(keyRange)      : await store.count()        const totalPages = Math.ceil(totalCount / pageSize)    const skip = (page - 1) * pageSize        const data = []        // 使用游标进行高效分页    await new Promise((resolve, reject) =&gt; &#123;      let count = 0      const cursorRequest = keyRange         ? index.openCursor(keyRange)        : index.openCursor()            cursorRequest.onsuccess = (event) =&gt; &#123;        const cursor = event.target.result        if (cursor) &#123;          if (count &gt;= skip &amp;&amp; count &lt; skip + pageSize) &#123;            data.push(cursor.value)          &#125;                    count++                    if (count &lt; skip + pageSize) &#123;            cursor.continue()          &#125; else &#123;            resolve()          &#125;        &#125; else &#123;          resolve()        &#125;      &#125;            cursorRequest.onerror = (event) =&gt; &#123;        reject(event.target.error)      &#125;    &#125;)        await tx.done        return &#123;      success: true,      data,      pagination: &#123;        page,        pageSize,        totalCount,        totalPages      &#125;    &#125;  &#125; catch (error) &#123;    console.error(&#x27;优化分页查询失败:&#x27;, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;\n4. 浏览器兼容性问题\n问题：某些浏览器不支持 IndexedDB 或 idb 库\n解决方案：\n// 兼容性检测和降级方案export const checkCompatibility = () =&gt; &#123;  try &#123;    // 检测IndexedDB支持    if (!window.indexedDB) &#123;      return &#123;        supported: false,        message: &#x27;您的浏览器不支持IndexedDB，请升级到现代浏览器&#x27;      &#125;    &#125;    // 检测Promise支持（idb需要Promise）    if (!window.Promise) &#123;      return &#123;        supported: false,        message: &#x27;您的浏览器不支持Promise，请升级到现代浏览器&#x27;      &#125;    &#125;    return &#123; supported: true &#125;  &#125; catch (error) &#123;    return &#123;      supported: false,      message: `兼容性检测失败: $&#123;error.message&#125;`    &#125;  &#125;&#125;// 降级到localStorage的适配器export const createFallbackStorage = () =&gt; &#123;  const STORAGE_KEY = &#x27;fallback_db_&#x27;  return &#123;    async get(storeName, key) &#123;      const data = localStorage.getItem(STORAGE_KEY + storeName)      if (!data) return null            const store = JSON.parse(data)      return store[key] || null    &#125;,    async getAll(storeName) &#123;      const data = localStorage.getItem(STORAGE_KEY + storeName)      if (!data) return []            const store = JSON.parse(data)      return Object.values(store)    &#125;,    async add(storeName, value, key) &#123;      const data = localStorage.getItem(STORAGE_KEY + storeName) || &#x27;&#123;&#125;&#x27;      const store = JSON.parse(data)            if (store[key]) &#123;        throw new Error(`主键 $&#123;key&#125; 已存在`)      &#125;            store[key] = value      localStorage.setItem(STORAGE_KEY + storeName, JSON.stringify(store))      return key    &#125;,    async put(storeName, value, key) &#123;      const data = localStorage.getItem(STORAGE_KEY + storeName) || &#x27;&#123;&#125;&#x27;      const store = JSON.parse(data)            store[key] = value      localStorage.setItem(STORAGE_KEY + storeName, JSON.stringify(store))      return key    &#125;,    async delete(storeName, key) &#123;      const data = localStorage.getItem(STORAGE_KEY + storeName)      if (!data) return            const store = JSON.parse(data)      delete store[key]      localStorage.setItem(STORAGE_KEY + storeName, JSON.stringify(store))    &#125;,    async clear(storeName) &#123;      localStorage.removeItem(STORAGE_KEY + storeName)    &#125;,    async count(storeName) &#123;      const data = localStorage.getItem(STORAGE_KEY + storeName)      if (!data) return 0            const store = JSON.parse(data)      return Object.keys(store).length    &#125;  &#125;&#125;// 创建统一的存储接口export const createStorage = async () =&gt; &#123;  const compatibility = checkCompatibility()    if (!compatibility.supported) &#123;    console.warn(&#x27;IndexedDB不支持，使用localStorage降级方案&#x27;)    return createFallbackStorage()  &#125;  try &#123;    // 尝试初始化IndexedDB    const db = await getDB()    return db  &#125; catch (error) &#123;    console.warn(&#x27;IndexedDB初始化失败，使用localStorage降级方案:&#x27;, error)    return createFallbackStorage()  &#125;&#125;\n性能优化\n1. 连接池管理\n// 数据库连接池class DBConnectionPool &#123;  constructor() &#123;    this.pool = []    this.maxConnections = 5    this.waiting = []    this.isClosed = false  &#125;  async getConnection() &#123;    if (this.isClosed) &#123;      throw new Error(&#x27;连接池已关闭&#x27;)    &#125;    // 如果有空闲连接，直接返回    if (this.pool.length &gt; 0) &#123;      return this.pool.shift()    &#125;    // 如果未达到最大连接数，创建新连接    if (this.pool.length + this.waiting.length &lt; this.maxConnections) &#123;      const db = await initDB()      return db    &#125;    // 否则等待空闲连接    return new Promise((resolve) =&gt; &#123;      this.waiting.push(resolve)    &#125;)  &#125;  releaseConnection(db) &#123;    if (this.isClosed) &#123;      db.close()      return    &#125;    // 如果有等待的请求，直接分配连接    if (this.waiting.length &gt; 0) &#123;      const resolve = this.waiting.shift()      resolve(db)      return    &#125;    // 否则放回连接池    this.pool.push(db)  &#125;  async close() &#123;    this.isClosed = true    // 关闭所有连接    for (const db of this.pool) &#123;      await db.close()    &#125;    // 拒绝所有等待的请求    for (const resolve of this.waiting) &#123;      resolve(null)    &#125;    this.pool = []    this.waiting = []  &#125;&#125;// 创建连接池实例export const connectionPool = new DBConnectionPool()// 使用连接池的数据库操作export const withConnection = async (operation) =&gt; &#123;  let db = null  try &#123;    db = await connectionPool.getConnection()        if (!db) &#123;      throw new Error(&#x27;无法获取数据库连接&#x27;)    &#125;    return await operation(db)  &#125; finally &#123;    if (db) &#123;      connectionPool.releaseConnection(db)    &#125;  &#125;&#125;// 使用连接池的示例export const getUserWithPool = async (userId) =&gt; &#123;  return withConnection(async (db) =&gt; &#123;    return db.get(&#x27;users&#x27;, userId)  &#125;)&#125;\n2. 缓存策略\n// 内存缓存管理器class CacheManager &#123;  constructor(options = &#123;&#125;) &#123;    this.cache = new Map()    this.ttl = options.ttl || 5 * 60 * 1000 // 默认5分钟    this.maxSize = options.maxSize || 1000  &#125;  set(key, value, ttl = this.ttl) &#123;    // 如果缓存已满，删除最旧的条目    if (this.cache.size &gt;= this.maxSize) &#123;      const firstKey = this.cache.keys().next().value      this.cache.delete(firstKey)    &#125;    const expireTime = Date.now() + ttl    this.cache.set(key, &#123; value, expireTime &#125;)  &#125;  get(key) &#123;    const item = this.cache.get(key)        if (!item) &#123;      return null    &#125;    // 检查是否过期    if (Date.now() &gt; item.expireTime) &#123;      this.cache.delete(key)      return null    &#125;    return item.value  &#125;  delete(key) &#123;    this.cache.delete(key)  &#125;  clear() &#123;    this.cache.clear()  &#125;  has(key) &#123;    return this.get(key) !== null  &#125;&#125;// 创建缓存实例export const cache = new CacheManager(&#123;  ttl: 10 * 60 * 1000, // 10分钟  maxSize: 500&#125;)// 带缓存的数据获取export const getCachedData = async (storeName, key, options = &#123;&#125;) =&gt; &#123;  const cacheKey = `$&#123;storeName&#125;:$&#123;key&#125;`    // 先检查缓存  const cachedData = cache.get(cacheKey)  if (cachedData &amp;&amp; !options.forceRefresh) &#123;    return &#123; success: true, data: cachedData, fromCache: true &#125;  &#125;  // 缓存未命中或需要强制刷新，从数据库获取  try &#123;    const result = await withConnection(async (db) =&gt; &#123;      return db.get(storeName, key)    &#125;)    if (result) &#123;      // 更新缓存      cache.set(cacheKey, result, options.ttl)      return &#123; success: true, data: result, fromCache: false &#125;    &#125;    return &#123; success: false, error: &#x27;数据不存在&#x27; &#125;  &#125; catch (error) &#123;    console.error(`获取$&#123;storeName&#125;数据失败:`, error)    return &#123; success: false, error: error.message &#125;  &#125;&#125;// 缓存失效机制export const invalidateCache = (storeName, key = null) =&gt; &#123;  if (key) &#123;    cache.delete(`$&#123;storeName&#125;:$&#123;key&#125;`)  &#125; else &#123;    // 清除整个store的缓存    for (const cacheKey of cache.cache.keys()) &#123;      if (cacheKey.startsWith(`$&#123;storeName&#125;:`)) &#123;        cache.delete(cacheKey)      &#125;    &#125;  &#125;&#125;// 更新数据时自动失效缓存export const updateWithCacheInvalidation = async (storeName, id, data) =&gt; &#123;  const result = await withConnection(async (db) =&gt; &#123;    return db.put(storeName, data, id)  &#125;)  if (result.success) &#123;    // 失效相关缓存    invalidateCache(storeName, id)    // 可以根据需要失效其他相关缓存  &#125;  return result&#125;\n3. 批量操作优化\n// 批量操作队列class BatchOperationQueue &#123;  constructor(options = &#123;&#125;) &#123;    this.queue = new Map()    this.batchSize = options.batchSize || 100    this.delay = options.delay || 100    this.timers = new Map()  &#125;  addOperation(storeName, operation) &#123;    if (!this.queue.has(storeName)) &#123;      this.queue.set(storeName, [])    &#125;    const storeQueue = this.queue.get(storeName)    storeQueue.push(operation)    // 如果达到批处理大小，立即执行    if (storeQueue.length &gt;= this.batchSize) &#123;      this.processBatch(storeName)    &#125; else if (!this.timers.has(storeName)) &#123;      // 否则设置延迟执行      this.timers.set(storeName, setTimeout(() =&gt; &#123;        this.processBatch(storeName)      &#125;, this.delay))    &#125;  &#125;  async processBatch(storeName) &#123;    // 清除定时器    if (this.timers.has(storeName)) &#123;      clearTimeout(this.timers.get(storeName))      this.timers.delete(storeName)    &#125;    const storeQueue = this.queue.get(storeName)    if (!storeQueue || storeQueue.length === 0) &#123;      return    &#125;    try &#123;      // 执行批处理操作      await batchOperations(storeName, storeQueue)            // 清空队列      this.queue.set(storeName, [])    &#125; catch (error) &#123;      console.error(`批处理操作失败 ($&#123;storeName&#125;):`, error)      // 可以选择重试或处理失败的操作    &#125;  &#125;  async flush() &#123;    // 立即执行所有队列中的操作    for (const storeName of this.queue.keys()) &#123;      await this.processBatch(storeName)    &#125;  &#125;&#125;// 创建批处理队列实例export const batchQueue = new BatchOperationQueue(&#123;  batchSize: 50,  delay: 50&#125;)// 使用批处理队列的操作export const queueUserUpdate = (userId, data) =&gt; &#123;  batchQueue.addOperation(&#x27;users&#x27;, &#123;    type: &#x27;put&#x27;,    data: &#123; id: userId, ...data &#125;  &#125;)&#125;export const queueProductAdd = (productData) =&gt; &#123;  batchQueue.addOperation(&#x27;products&#x27;, &#123;    type: &#x27;add&#x27;,    data: productData  &#125;)&#125;\n4. 索引优化\n// 索引使用建议和优化export const optimizeIndexes = async () =&gt; &#123;  const db = await getDB()    // 分析查询模式并建议索引  const indexRecommendations = []  // 检查用户表的查询模式  const userStore = db.transaction(&#x27;users&#x27;, &#x27;readonly&#x27;).objectStore(&#x27;users&#x27;)    // 检查常用查询字段是否有索引  const commonQueryFields = [&#x27;email&#x27;, &#x27;username&#x27;, &#x27;level&#x27;, &#x27;age&#x27;]  for (const field of commonQueryFields) &#123;    if (!userStore.indexNames.contains(field)) &#123;      indexRecommendations.push(&#123;        storeName: &#x27;users&#x27;,        field,        reason: &#x27;常用查询字段缺少索引&#x27;      &#125;)    &#125;  &#125;  return indexRecommendations&#125;// 索引使用性能监控export const monitorIndexPerformance = async () =&gt; &#123;  const db = await getDB()  const performanceData = &#123;&#125;  for (const storeName of db.objectStoreNames) &#123;    const tx = db.transaction(storeName, &#x27;readonly&#x27;)    const store = tx.objectStore(storeName)        performanceData[storeName] = &#123;      indexes: Array.from(store.indexNames),      recordCount: await store.count()    &#125;    await tx.done  &#125;  return performanceData&#125;\n总结\n本指南详细介绍了如何在 Vue 应用中使用 idb 库操作 IndexedDB，涵盖了从基础概念到高级应用的各个方面：\n核心要点\n\n\n环境搭建：安装 idb 库并创建数据库连接管理\n\n\n基础操作：掌握 CRUD 操作和事务处理\n\n\n版本管理：正确处理数据库版本升级和迁移\n\n\n索引优化：使用索引提高查询效率\n\n\n高级查询：掌握区间查找和游标操作\n\n\nVue 集成：使用 Composition API 和 Pinia/Vuex 管理数据\n\n\n性能优化：连接池、缓存、批处理等优化策略\n\n\n问题解决：常见问题的解决方案和最佳实践\n\n\n最佳实践建议\n\n\n连接管理：使用单例模式管理数据库连接，避免频繁打开和关闭\n\n\n错误处理：完善的错误处理和用户反馈机制\n\n\n性能优化：合理使用索引，避免全表扫描\n\n\n数据安全：敏感数据加密，定期备份\n\n\n兼容性考虑：提供降级方案，确保在不支持 IndexedDB 的浏览器中也能正常运行\n\n\n监控和调试：使用浏览器 DevTools 进行调试和性能监控\n\n\n通过本指南的学习，您应该能够在 Vue 应用中熟练使用 IndexedDB 进行本地数据存储，为用户提供更好的离线体验和数据持久化功能。\n进一步学习资源\n\n\nidb 官方文档\n\n\nMDN IndexedDB 文档\n\n\nVue.js 官方文档\n\n\n浏览器兼容性表\n\n\n","categories":["编程"],"tags":["Web"]},{"title":"零拷贝","url":"/2025/09/15/linux/%E9%9B%B6%E6%8B%B7%E8%B4%9D/","content":"如何利用零拷贝技术优化性能，减低负荷\n \n零拷贝\n零拷贝（Zero-Copy） 是一种通过减少数据在用户空间与内核空间之间的拷贝次数，来提升数据传输效率的关键技术。其核心思想是避免不必要的数据复制操作，让数据直接在内核空间中完成流转，从而降低 CPU 开销、减少内存带宽占用，特别适用于高吞吐量的场景（如大文件传输、高性能服务器等）。\n一、零拷贝的核心价值\n传统数据传输（如 “读取文件并发送到网络”）的流程通常包含 4 次拷贝和 2 次用户态 / 内核态切换：\n\n\n数据从磁盘拷贝到内核缓冲区（DMA 拷贝）；\n\n\n数据从内核缓冲区拷贝到用户缓冲区（CPU 拷贝）；\n\n\n数据从用户缓冲区拷贝到 Socket 内核缓冲区（CPU 拷贝）；\n\n\n数据从 Socket 内核缓冲区拷贝到网络接口（DMA 拷贝）。\n\n\n零拷贝技术通过省略步骤 2 和 3 中的 CPU 拷贝，显著提升效率。\n二、C++ 中常用的零拷贝函数及用法\n零拷贝的实现依赖于操作系统提供的系统调用，不同平台（Linux/Windows）函数不同，以下以 Linux 为主（最常用）：\n1. sendfile：文件到网络的直接传输\nsendfile 是 Linux 内核 2.1 版本后提供的零拷贝函数，专门用于将文件数据直接从文件描述符传输到 Socket 描述符，全程在内核空间完成，完全避免用户空间参与。\n函数原型：\n#include &lt;sys/sendfile.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n参数说明：\n\n\nout_fd：目标文件描述符（通常是 Socket 的 fd）；\n\n\nin_fd：源文件描述符（必须是支持mmap的文件，不能是 Socket）；\n\n\noffset：文件读取的起始偏移量（若为NULL，则从当前位置开始）；\n\n\ncount：要传输的字节数。\n\n\n返回值：\n\n\n成功：实际传输的字节数；\n\n\n失败：-1（需通过errno判断错误原因）。\n\n\n示例代码（用sendfile发送文件到网络）：\n#include &lt;sys/socket.h&gt;#include &lt;sys/sendfile.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;int main() &#123;    // 1. 创建Socket（假设已完成绑定、监听、 accept，得到client_fd）    int client_fd = ...;  // 已连接的客户端Socket    // 2. 打开要发送的文件    int file_fd = open(&quot;large_file.dat&quot;, O_RDONLY);    if (file_fd == -1) &#123;        perror(&quot;open failed&quot;);        return -1;    &#125;    // 3. 获取文件大小（简化示例）    off_t file_size = lseek(file_fd, 0, SEEK_END);    lseek(file_fd, 0, SEEK_SET);  // 回到文件开头    // 4. 使用sendfile传输文件    off_t offset = 0;    ssize_t total_sent = 0;    while (total_sent &lt; file_size) &#123;        ssize_t sent = sendfile(client_fd, file_fd, &amp;offset, file_size - total_sent);        if (sent == -1) &#123;            perror(&quot;sendfile failed&quot;);            close(file_fd);            close(client_fd);            return -1;        &#125;        total_sent += sent;    &#125;    std::cout &lt;&lt; &quot;File sent successfully, total: &quot; &lt;&lt; total_sent &lt;&lt; &quot; bytes\\n&quot;;    // 5. 关闭资源    close(file_fd);    close(client_fd);    return 0;&#125;\n2. mmap + write：内存映射的间接零拷贝\nmmap 将文件直接映射到用户空间的内存地址，此时用户空间可以直接访问内核缓冲区的数据（无需拷贝到用户缓冲区），再通过write将数据发送到 Socket。虽然仍有一次 “用户空间到 Socket 内核缓冲区” 的拷贝，但比传统方式少一次拷贝。\n函数原型：\n#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);int munmap(void *addr, size_t length);  // 解除映射\n参数说明：\n\n\naddr：映射的起始地址（通常为NULL，由系统自动分配）；\n\n\nlength：映射的字节数；\n\n\nprot：内存保护标志（如PROT_READ表示可读）；\n\n\nflags：映射属性（如MAP_SHARED表示修改会同步到文件）；\n\n\nfd：文件描述符；\n\n\noffset：文件映射的起始偏移量。\n\n\n示例代码：\n#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;int main() &#123;    int client_fd = ...;  // 已连接的客户端Socket    int file_fd = open(&quot;large_file.dat&quot;, O_RDONLY);    if (file_fd == -1) &#123; /* 错误处理 */ &#125;    // 获取文件大小    off_t file_size = lseek(file_fd, 0, SEEK_END);    // 映射文件到用户空间    void *addr = mmap(NULL, file_size, PROT_READ, MAP_SHARED, file_fd, 0);    if (addr == MAP_FAILED) &#123;        perror(&quot;mmap failed&quot;);        close(file_fd);        return -1;    &#125;    // 直接通过write发送映射的内存（内部仍有一次内核拷贝）    ssize_t sent = write(client_fd, addr, file_size);    if (sent == -1) &#123; /* 错误处理 */ &#125;    // 解除映射并关闭资源    munmap(addr, file_size);    close(file_fd);    close(client_fd);    return 0;&#125;\n3. splice：任意文件描述符间的零拷贝\nsplice 是 Linux 2.6.17 后提供的更灵活的零拷贝函数，支持在两个文件描述符（可以是管道、Socket、文件等）之间直接传输数据，全程在内核空间完成，且无需用户空间参与。\n函数原型：\n#include &lt;fcntl.h&gt;ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);\n参数说明：\n\n\nfd_in/fd_out：输入 / 输出文件描述符（至少有一个必须是管道）；\n\n\noff_in/off_out：输入 / 输出的偏移量（NULL表示使用当前位置）；\n\n\nlen：传输的字节数；\n\n\nflags：控制标志（如SPLICE_F_MOVE表示尽可能移动数据而非复制）。\n\n\n示例代码（用splice在两个 Socket 间转发数据）：\n#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;int main() &#123;    int sock1 = ...;  // 源Socket    int sock2 = ...;  // 目标Socket    // 创建管道（splice要求至少一个fd是管道）    int pipefd[2];    if (pipe(pipefd) == -1) &#123; /* 错误处理 */ &#125;    const size_t BUF_SIZE = 4096;    ssize_t n;    // 从sock1读取数据到管道，再从管道写入sock2    while ((n = splice(sock1, NULL, pipefd[1], NULL, BUF_SIZE, SPLICE_F_MOVE)) &gt; 0) &#123;        ssize_t written = splice(pipefd[0], NULL, sock2, NULL, n, SPLICE_F_MOVE);        if (written != n) &#123; /* 错误处理 */ &#125;    &#125;    close(pipefd[0]);    close(pipefd[1]);    close(sock1);    close(sock2);    return 0;&#125;\n控制标志\n\n\nSPLICE_F_MOVE\n\n\n\n\n作用：尝试以 “移动” 方式传输数据，而非复制。\n\n\n行为：告知内核尽可能重用页面（如将页面所有权从源文件描述符转移到目标），减少内存复制开销。\n\n\n注意：这只是一个 “建议”，内核可能因条件限制（如页面被其他进程引用）而退化为复制方式。\n\n\n\n\nSPLICE_F_NONBLOCK\n\n\n\n\n作用：使 splice() 操作非阻塞执行。\n\n\n行为：若操作无法立即完成（如数据未就绪），函数会立即返回 -1 并设置 errno 为 EAGAIN 或 EWOULDBLOCK，而非阻塞等待。\n\n\n注意：需确保相关文件描述符本身支持非阻塞操作（如通过 fcntl() 设置 O_NONBLOCK）。\n\n\n\n\nSPLICE_F_MORE\n\n\n\n\n作用：提示内核后续还有更多数据要传输。\n\n\n行为：内核可据此优化 I/O 调度（如延迟提交数据，合并成更大的 I/O 操作），提升效率。\n\n\n适用场景：连续多次调用 splice() 传输大量数据时使用。\n\n\n\n\nSPLICE_F_GIFT\n\n\n\n\n作用：表示传输的数据是给内核的 “礼物”，用户态不再需要访问这些数据。\n\n\n行为：内核可自由处理数据页面（如直接丢弃），通常用于管道写端向内核传递数据的场景。\n\n\n限制：仅适用于从用户态文件描述符（如匿名管道）向内核态传输数据的情况。\n\n\n4.Windows 平台：TransmitFile\nWindows 提供的TransmitFile函数类似 Linux 的sendfile，用于将文件数据直接发送到 Socket，实现零拷贝。\n函数原型：\n#include &lt;windows.h&gt;BOOL TransmitFile(  SOCKET hSocket,  HANDLE hFile,  DWORD nNumberOfBytesToWrite,  DWORD nNumberOfBytesPerSend,  LPOVERLAPPED lpOverlapped,  LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,  DWORD dwFlags);\n三、注意事项\n\n\n平台依赖性：零拷贝函数是操作系统相关的（如sendfile仅 Linux 有效，TransmitFile仅 Windows 有效），跨平台开发需封装适配层（如使用 Boost.Asio 等库抽象）。\n\n\n适用场景限制：\n\nsendfile早期版本仅支持 “文件到 Socket” 的传输（无法反向或 Socket 到 Socket）；\nsplice要求至少一个文件描述符是管道，灵活性受限；\n小数据传输可能因函数调用开销高于拷贝开销，反而效率更低。\n\n\n\n错误处理：零拷贝函数的错误码与普通 IO 函数不同（如sendfile失败时errno可能为EINVAL表示不支持的 fd 类型），需针对性处理。\n\n\n内存映射风险：mmap映射的内存若被意外修改（如MAP_SHARED模式），可能导致文件数据损坏；且映射大文件可能耗尽虚拟内存。\n\n\n偏移量管理：sendfile和mmap的offset参数需手动管理，多次调用时需确保偏移量正确递增，避免数据重复或丢失。\n\n\n四、典型使用场景\n\n\n静态文件服务器（如 Nginx）：用sendfile直接将磁盘文件发送到网络，避免用户空间拷贝，支撑高并发下载。\n\n\n大文件传输（如视频、备份数据）：数据量通常达 GB 级，零拷贝可减少 90% 以上的 CPU 开销，显著提升传输速度。\n\n\n代理服务器（如反向代理）：用splice在客户端与后端服务器间转发数据，全程内核态处理，提升转发吞吐量。\n\n\n高性能日志收集：用mmap映射日志文件，应用程序直接写入映射内存，避免频繁 IO 拷贝。\n\n\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"PyBind11使用指北(补充)","url":"/2025/09/09/C++/pybind11%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%20-%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9/","content":"\n如题，结合官方文档与网络帖子，利用AI整理\n\n\npybind11 使用指南 - 官方文档补充内容\n目录\n\n\n高级类特性\n\n\n构建系统详解\n\n\n返回值策略\n\n\n智能指针\n\n\n类型转换\n\n\n嵌入 Python 解释器\n\n\n多线程与 GIL 管理\n\n\n子解释器\n\n\n自定义类型转换\n\n\n其他高级特性\n\n\n高级类特性\n1. 动态属性\n默认情况下，C++ 类在 Python 中不支持动态添加属性。要启用此功能，需要使用py::dynamic_attr标签：\n#include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;class Pet &#123;public:    Pet(const std::string&amp; name) : name(name) &#123;&#125;        std::string get_name() const &#123; return name; &#125;    void set_name(const std::string&amp; new_name) &#123; name = new_name; &#125;private:    std::string name;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Pet&gt;(m, &quot;Pet&quot;, py::dynamic_attr())        .def(py::init&lt;const std::string&amp;&gt;())        .def(&quot;get_name&quot;, &amp;Pet::get_name)        .def(&quot;set_name&quot;, &amp;Pet::set_name)        .def_readwrite(&quot;name&quot;, &amp;Pet::name);&#125;\nPython 使用：\nimport examplep = example.Pet(&quot;小狗&quot;)p.age = 2  # 动态添加属性p.color = &quot;棕色&quot;  # 动态添加属性print(p.name)   # 输出：小狗print(p.age)    # 输出：2print(p.color)  # 输出：棕色\n2. 继承与自动向下转型\n对于多态类（含有虚函数），pybind11 会自动进行向下转型：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;namespace py = pybind11;class Animal &#123;public:    virtual ~Animal() = default;    virtual std::string speak() const = 0;&#125;;class Dog : public Animal &#123;public:    std::string speak() const override &#123;        return &quot;汪汪！&quot;;    &#125;&#125;;class Cat : public Animal &#123;public:    std::string speak() const override &#123;        return &quot;喵喵！&quot;;    &#125;&#125;;// 返回基类指针Animal* create_animal(const std::string&amp; type) &#123;    if (type == &quot;dog&quot;) return new Dog();    if (type == &quot;cat&quot;) return new Cat();    throw std::invalid_argument(&quot;未知动物类型&quot;);&#125;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Animal&gt;(m, &quot;Animal&quot;)        .def(&quot;speak&quot;, &amp;Animal::speak);        py::class_&lt;Dog, Animal&gt;(m, &quot;Dog&quot;)        .def(py::init&lt;&gt;());        py::class_&lt;Cat, Animal&gt;(m, &quot;Cat&quot;)        .def(py::init&lt;&gt;());        m.def(&quot;create_animal&quot;, &amp;create_animal,           py::return_value_policy::take_ownership);&#125;\nPython 使用：\nimport exampleanimal = example.create_animal(&quot;dog&quot;)print(type(animal))  # 输出：&lt;class &#x27;example.Dog&#x27;&gt;（自动向下转型）print(animal.speak())  # 输出：汪汪！\n3. 运算符重载\n使用pybind11/operators.h头文件支持运算符重载：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/operators.h&gt;namespace py = pybind11;class Vector2 &#123;public:    float x, y;        Vector2(float x = 0, float y = 0) : x(x), y(y) &#123;&#125;        Vector2 operator+(const Vector2&amp; other) const &#123;        return Vector2(x + other.x, y + other.y);    &#125;        Vector2 operator*(float scalar) const &#123;        return Vector2(x * scalar, y * scalar);    &#125;        bool operator==(const Vector2&amp; other) const &#123;        return x == other.x &amp;&amp; y == other.y;    &#125;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Vector2&gt;(m, &quot;Vector2&quot;)        .def(py::init&lt;float, float&gt;())        .def_readwrite(&quot;x&quot;, &amp;Vector2::x)        .def_readwrite(&quot;y&quot;, &amp;Vector2::y)                // 运算符重载        .def(py::self + py::self)          // + 运算符        .def(py::self * float())           // * 运算符（向量 * 标量）        .def(float() * py::self)           // * 运算符（标量 * 向量）        .def(py::self == py::self);        // == 运算符&#125;\n4. 枚举类型绑定\n使用py::native_enum绑定 C++ 枚举到 Python 原生枚举：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/native_enum.h&gt;namespace py = pybind11;class Pet &#123;public:    enum class Kind &#123;        Dog,        Cat,        Bird    &#125;;        enum Attributes &#123;        None = 0,        Friendly = 1 &lt;&lt; 0,        Playful = 1 &lt;&lt; 1,        Lazy = 1 &lt;&lt; 2    &#125;;        Pet(const std::string&amp; name, Kind kind)         : name(name), kind(kind), attributes(None) &#123;&#125;        std::string name;    Kind kind;    Attributes attributes;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)        .def(py::init&lt;const std::string&amp;, Pet::Kind&gt;())        .def_readwrite(&quot;name&quot;, &amp;Pet::name)        .def_readwrite(&quot;kind&quot;, &amp;Pet::kind)        .def_readwrite(&quot;attributes&quot;, &amp;Pet::attributes);        // 绑定枚举    py::native_enum&lt;Pet::Kind&gt;(m, &quot;Kind&quot;)        .value(&quot;Dog&quot;, Pet::Kind::Dog)        .value(&quot;Cat&quot;, Pet::Kind::Cat)        .value(&quot;Bird&quot;, Pet::Kind::Bird)        .export_values()        .finalize();        py::native_enum&lt;Pet::Attributes&gt;(m, &quot;Attributes&quot;)        .value(&quot;None&quot;, Pet::Attributes::None)        .value(&quot;Friendly&quot;, Pet::Attributes::Friendly)        .value(&quot;Playful&quot;, Pet::Attributes::Playful)        .value(&quot;Lazy&quot;, Pet::Attributes::Lazy)        .export_values()        .finalize();&#125;\n构建系统详解\n1. CMake 构建\n基础 CMakeLists.txt：\ncmake_minimum_required(VERSION 3.15...3.27)project(example LANGUAGES CXX)# 查找pybind11find_package(pybind11 CONFIG REQUIRED)# 创建Python扩展模块pybind11_add_module(example example.cpp)# 安装到当前目录install(TARGETS example DESTINATION .)\n高级 CMake 配置：\ncmake_minimum_required(VERSION 3.15...3.27)project(example LANGUAGES CXX)# 设置C++标准set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED ON)set(CMAKE_CXX_EXTENSIONS OFF)# 查找Pythonfind_package(Python COMPONENTS Interpreter Development REQUIRED)# 查找pybind11find_package(pybind11 CONFIG REQUIRED)# 创建扩展模块pybind11_add_module(example     src/bindings.cpp    src/algorithm.cpp    src/data_structures.cpp)# 设置编译选项target_compile_options(example PRIVATE    -O3    -Wall    -Wextra    -Wpedantic)# 设置链接选项target_link_libraries(example PRIVATE    pybind11::module    my_custom_library)# 设置安装路径install(TARGETS example     DESTINATION $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)\n2. pyproject.toml 构建\n使用 scikit-build-core：\n[build-system]requires = [&quot;scikit-build-core&gt;=0.5&quot;, &quot;pybind11&gt;=2.11&quot;]build-backend = &quot;scikit_build_core.build&quot;[project]name = &quot;example&quot;version = &quot;0.1.0&quot;authors = [    &#123; name = &quot;Your Name&quot;, email = &quot;your.email@example.com&quot; &#125;]description = &quot;pybind11示例项目&quot;long_description = file: &quot;README.md&quot;long_description_content_type = &quot;text/markdown&quot;requires-python = &quot;&gt;=3.8&quot;\n使用 meson-python：\n[build-system]requires = [&quot;meson-python&gt;=0.12&quot;, &quot;pybind11&gt;=2.11&quot;]build-backend = &quot;mesonpy&quot;[project]name = &quot;example&quot;version = &quot;0.1.0&quot;\n3. setuptools 构建高级配置\nfrom setuptools import setup, Extensionfrom pybind11.setup_helpers import Pybind11Extension, build_extfrom pybind11 import get_cmake_dirimport glob# 并行编译def parallel_compile_test_parallel_compile(self, sources, output_dir=None, macros=None,                                          include_dirs=None, debug=0, extra_preargs=None,                                          extra_postargs=None, depends=None):    import multiprocessing    from setuptools._distutils.ccompiler import CCompiler    from setuptools._distutils import log    # 复制原始实现    original_compile = CCompiler._compile    def _compile_single(source):        return original_compile(self, source, output_dir, macros, include_dirs,                               debug, extra_preargs, extra_postargs, depends)    # 使用多进程编译    if not sources:        return    num_jobs = multiprocessing.cpu_count()    log.info(f&quot;Using &#123;num_jobs&#125; parallel jobs for compilation&quot;)        import multiprocessing.pool    pool = multiprocessing.pool.ThreadPool(num_jobs)    try:        pool.map(_compile_single, sources)    finally:        pool.close()        pool.join()# 应用并行编译补丁import setuptools._distutils.ccompilersetuptools._distutils.ccompiler.CCompiler._compile = parallel_compile_test_parallel_compile# 扩展模块ext_modules = [    Pybind11Extension(        &quot;example.core&quot;,        sorted(glob.glob(&quot;src/core/*.cpp&quot;)),        include_dirs=[&quot;src/include&quot;],        libraries=[&quot;my_custom_lib&quot;],        library_dirs=[&quot;lib&quot;],        extra_compile_args=[&quot;-O3&quot;, &quot;-std=c++17&quot;, &quot;-Wall&quot;],        extra_link_args=[&quot;-Wl,-rpath,$ORIGIN/lib&quot;],    ),    Pybind11Extension(        &quot;example.utils&quot;,        sorted(glob.glob(&quot;src/utils/*.cpp&quot;)),        include_dirs=[&quot;src/include&quot;],        extra_compile_args=[&quot;-O3&quot;, &quot;-std=c++17&quot;],    ),]setup(    name=&quot;example&quot;,    version=&quot;1.0.0&quot;,    author=&quot;Your Name&quot;,    author_email=&quot;your.email@example.com&quot;,    description=&quot;pybind11示例项目&quot;,    long_description=open(&quot;README.md&quot;).read(),    long_description_content_type=&quot;text/markdown&quot;,    url=&quot;https://github.com/yourusername/example&quot;,    ext_modules=ext_modules,    cmdclass=&#123;&quot;build_ext&quot;: build_ext&#125;,    zip_safe=False,    packages=[&quot;example&quot;],    package_dir=&#123;&quot;example&quot;: &quot;python/example&quot;&#125;,    package_data=&#123;&quot;example&quot;: [&quot;py.typed&quot;]&#125;,    classifiers=[        &quot;Programming Language :: C++&quot;,        &quot;Programming Language :: Python :: 3&quot;,        &quot;License :: OSI Approved :: MIT License&quot;,        &quot;Operating System :: OS Independent&quot;,    ],    python_requires=&quot;&gt;=3.8&quot;,    install_requires=[&quot;numpy&gt;=1.21&quot;],    extras_require=&#123;        &quot;dev&quot;: [            &quot;pytest&gt;=6.0&quot;,            &quot;pytest-cov&gt;=2.0&quot;,            &quot;black&gt;=21.0&quot;,            &quot;flake8&gt;=3.9&quot;,        ]    &#125;,)\n返回值策略\n1. 策略概述\n\n\n\n策略\n描述\n\n\n\n\nreturn_value_policy::take_ownership\n接管现有对象的所有权，Python 会在引用计数为零时删除对象\n\n\nreturn_value_policy::copy\n创建返回对象的副本，由 Python 拥有\n\n\nreturn_value_policy::move\n使用 std::move 转移内容到新实例\n\n\nreturn_value_policy::reference\n引用现有对象但不接管所有权\n\n\nreturn_value_policy::reference_internal\n引用内部对象，确保父对象存活\n\n\nreturn_value_policy::automatic\n自动选择策略（默认）\n\n\nreturn_value_policy::automatic_reference\n类似 automatic，但对指针使用 reference 策略\n\n\n\n2. 使用示例\n#include &lt;pybind11/pybind11.h&gt;#include &lt;memory&gt;namespace py = pybind11;class MyClass &#123;public:    MyClass(int value) : value(value) &#123;&#125;    int get_value() const &#123; return value; &#125;    private:    int value;&#125;;// 静态对象 - 使用reference策略MyClass static_instance(42);MyClass&amp; get_static_instance() &#123;    return static_instance;&#125;// 动态分配 - 使用take_ownership策略MyClass* create_instance(int value) &#123;    return new MyClass(value);&#125;// 内部对象 - 使用reference_internal策略class Container &#123;public:    Container() : internal(100) &#123;&#125;    MyClass&amp; get_internal() &#123; return internal; &#125;    private:    MyClass internal;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;MyClass&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;int&gt;())        .def(&quot;get_value&quot;, &amp;MyClass::get_value);        py::class_&lt;Container&gt;(m, &quot;Container&quot;)        .def(py::init&lt;&gt;())        .def(&quot;get_internal&quot;, &amp;Container::get_internal,              py::return_value_policy::reference_internal);        // 静态对象 - 使用reference策略    m.def(&quot;get_static_instance&quot;, &amp;get_static_instance,           py::return_value_policy::reference);        // 动态对象 - 使用take_ownership策略    m.def(&quot;create_instance&quot;, &amp;create_instance,           py::return_value_policy::take_ownership);        // 智能指针 - 自动处理    m.def(&quot;create_shared&quot;, []() &#123;        return std::make_shared&lt;MyClass&gt;(200);    &#125;);&#125;\n3. 常见错误及解决方案\n错误示例：\n// 危险！静态对象使用默认策略会导致double freem.def(&quot;get_static&quot;, &amp;get_static_instance);  // 错误\n正确做法：\n// 正确：使用reference策略m.def(&quot;get_static&quot;, &amp;get_static_instance, py::return_value_policy::reference);\n智能指针\n1. py::smart_holder（推荐）\npybind11 v3 引入的智能持有者，支持双向转换：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;memory&gt;namespace py = pybind11;class MyClass &#123;public:    MyClass(int value) : value(value) &#123;&#125;    int get_value() const &#123; return value; &#125;    private:    int value;&#125;;PYBIND11_MODULE(example, m) &#123;    // 使用py::smart_holder    py::class_&lt;MyClass, py::smart_holder&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;int&gt;())        .def(&quot;get_value&quot;, &amp;MyClass::get_value);        // 支持unique_ptr和shared_ptr双向转换    m.def(&quot;create_unique&quot;, []() &#123;        return std::make_unique&lt;MyClass&gt;(10);    &#125;);        m.def(&quot;create_shared&quot;, []() &#123;        return std::make_shared&lt;MyClass&gt;(20);    &#125;);        m.def(&quot;process_unique&quot;, [](std::unique_ptr&lt;MyClass&gt; ptr) &#123;        return ptr-&gt;get_value() * 2;    &#125;);        m.def(&quot;process_shared&quot;, [](std::shared_ptr&lt;MyClass&gt; ptr) &#123;        return ptr-&gt;get_value() * 3;    &#125;);&#125;\nPython 使用：\nimport example# 从Python传递到C++obj = example.MyClass(5)print(example.process_unique(obj))  # 输出：10（obj不再有效）obj2 = example.MyClass(6)print(example.process_shared(obj2))  # 输出：18（obj2仍然有效）# 从C++返回unique_obj = example.create_unique()shared_obj = example.create_shared()\n2. std::unique_ptr\n#include &lt;pybind11/pybind11.h&gt;#include &lt;memory&gt;namespace py = pybind11;class MyClass &#123;public:    MyClass(int value) : value(value) &#123;&#125;    int get_value() const &#123; return value; &#125;    private:    int value;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;MyClass&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;int&gt;())        .def(&quot;get_value&quot;, &amp;MyClass::get_value);        // 返回unique_ptr    m.def(&quot;create&quot;, []() &#123;        return std::make_unique&lt;MyClass&gt;(10);    &#125;);        // 接受unique_ptr（会转移所有权）    m.def(&quot;take_ownership&quot;, [](std::unique_ptr&lt;MyClass&gt; ptr) &#123;        return ptr-&gt;get_value();    &#125;);&#125;\n3. std::shared_ptr\n#include &lt;pybind11/pybind11.h&gt;#include &lt;memory&gt;namespace py = pybind11;class MyClass &#123;public:    MyClass(int value) : value(value) &#123;&#125;    int get_value() const &#123; return value; &#125;    private:    int value;&#125;;PYBIND11_MODULE(example, m) &#123;    // 使用shared_ptr作为持有者    py::class_&lt;MyClass, std::shared_ptr&lt;MyClass&gt;&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;int&gt;())        .def(&quot;get_value&quot;, &amp;MyClass::get_value);        m.def(&quot;create&quot;, []() &#123;        return std::make_shared&lt;MyClass&gt;(10);    &#125;);        m.def(&quot;share&quot;, [](std::shared_ptr&lt;MyClass&gt; ptr) &#123;        return ptr;  // 共享所有权    &#125;);&#125;\n4. 自定义智能指针\n#include &lt;pybind11/pybind11.h&gt;#include &lt;memory&gt;namespace py = pybind11;// 自定义智能指针template &lt;typename T&gt;class MySmartPtr &#123;public:    MySmartPtr(T* ptr) : ptr(ptr) &#123;&#125;    ~MySmartPtr() &#123; delete ptr; &#125;        T* get() const &#123; return ptr; &#125;    T&amp; operator*() const &#123; return *ptr; &#125;    T* operator-&gt;() const &#123; return ptr; &#125;    private:    T* ptr;&#125;;class MyClass &#123;public:    MyClass(int value) : value(value) &#123;&#125;    int get_value() const &#123; return value; &#125;    private:    int value;&#125;;// 声明自定义持有者类型PYBIND11_DECLARE_HOLDER_TYPE(T, MySmartPtr&lt;T&gt;)// 特化holder_helper（如果需要）namespace pybind11 &#123; namespace detail &#123;    template &lt;typename T&gt;    struct holder_helper&lt;MySmartPtr&lt;T&gt;&gt; &#123;        static const T* get(const MySmartPtr&lt;T&gt;&amp; p) &#123; return p.get(); &#125;    &#125;;&#125;&#125;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;MyClass, MySmartPtr&lt;MyClass&gt;&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;int&gt;())        .def(&quot;get_value&quot;, &amp;MyClass::get_value);        m.def(&quot;create&quot;, []() &#123;        return MySmartPtr&lt;MyClass&gt;(new MyClass(10));    &#125;);&#125;\n类型转换\n1. 基础类型转换\npybind11 支持以下基础类型的自动转换：\n\n\n\nC++ 类型\nPython 类型\n\n\n\n\nbool\nbool\n\n\nchar\nstr (长度 1)\n\n\nsigned char\nint\n\n\nunsigned char\nint\n\n\nshort\nint\n\n\nunsigned short\nint\n\n\nint\nint\n\n\nunsigned int\nint\n\n\nlong\nint\n\n\nunsigned long\nint\n\n\nlong long\nint\n\n\nunsigned long long\nint\n\n\nfloat\nfloat\n\n\ndouble\nfloat\n\n\nlong double\nfloat\n\n\nconst char*\nstr\n\n\nstd::string\nstr\n\n\nstd::wstring\nstr (UTF-8)\n\n\n\n2. STL 容器转换\n需要包含pybind11/stl.h头文件：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/stl.h&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;namespace py = pybind11;// 向量转换std::vector&lt;int&gt; double_vector(const std::vector&lt;int&gt;&amp; v) &#123;    std::vector&lt;int&gt; result;    for (int x : v) &#123;        result.push_back(x * 2);    &#125;    return result;&#125;// 映射转换std::map&lt;std::string, int&gt; count_words(const std::vector&lt;std::string&gt;&amp; words) &#123;    std::map&lt;std::string, int&gt; counts;    for (const auto&amp; word : words) &#123;        counts[word]++;    &#125;    return counts;&#125;// 集合转换std::set&lt;int&gt; unique_elements(const std::vector&lt;int&gt;&amp; v) &#123;    return std::set&lt;int&gt;(v.begin(), v.end());&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;double_vector&quot;, &amp;double_vector);    m.def(&quot;count_words&quot;, &amp;count_words);    m.def(&quot;unique_elements&quot;, &amp;unique_elements);&#125;\nPython 使用：\nimport example# 向量转换print(example.double_vector([1, 2, 3, 4]))  # 输出：[2, 4, 6, 8]# 映射转换words = [&quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;]print(example.count_words(words))  # 输出：&#123;&#x27;apple&#x27;: 2, &#x27;banana&#x27;: 1, &#x27;orange&#x27;: 1&#125;# 集合转换print(example.unique_elements([1, 2, 2, 3, 3, 3]))  # 输出：&#123;1, 2, 3&#125;\n3. 字符串和字节转换\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;#include &lt;vector&gt;namespace py = pybind11;// 字符串处理std::string reverse_string(const std::string&amp; s) &#123;    return std::string(s.rbegin(), s.rend());&#125;// 字节处理std::vector&lt;uint8_t&gt; process_bytes(const std::vector&lt;uint8_t&gt;&amp; data) &#123;    std::vector&lt;uint8_t&gt; result;    for (uint8_t byte : data) &#123;        result.push_back(byte ^ 0xAA);  // 简单的XOR加密    &#125;    return result;&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;reverse_string&quot;, &amp;reverse_string);    m.def(&quot;process_bytes&quot;, &amp;process_bytes);&#125;\n4. 时间类型转换\n需要包含pybind11/chrono.h头文件：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/chrono.h&gt;#include &lt;chrono&gt;#include &lt;ctime&gt;namespace py = pybind11;using namespace std::chrono;// 时间点转换system_clock::time_point add_seconds(system_clock::time_point tp, int seconds) &#123;    return tp + seconds(seconds);&#125;// 时间段转换seconds time_difference(system_clock::time_point start, system_clock::time_point end) &#123;    return duration_cast&lt;seconds&gt;(end - start);&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;add_seconds&quot;, &amp;add_seconds);    m.def(&quot;time_difference&quot;, &amp;time_difference);&#125;\nPython 使用：\nimport exampleimport datetime# 时间点转换now = datetime.datetime.now()later = example.add_seconds(now, 3600)  # 加1小时print(later)# 时间段转换start = datetime.datetime(2023, 1, 1)end = datetime.datetime(2023, 1, 2)diff = example.time_difference(start, end)print(diff.total_seconds())  # 输出：86400.0\n嵌入 Python 解释器\n1. 基础嵌入\nCMake 配置：\ncmake_minimum_required(VERSION 3.15...3.27)project(embedded_example LANGUAGES CXX)find_package(pybind11 CONFIG REQUIRED)add_executable(embedded_example main.cpp)target_link_libraries(embedded_example PRIVATE pybind11::embed)\nC++ 代码：\n#include &lt;pybind11/embed.h&gt;#include &lt;iostream&gt;namespace py = pybind11;int main() &#123;    // 启动Python解释器    py::scoped_interpreter guard&#123;&#125;;        try &#123;        // 执行Python代码        py::print(&quot;Hello from embedded Python!&quot;);                // 使用Python标准库        py::module math = py::module::import(&quot;math&quot;);        double result = math.attr(&quot;sqrt&quot;)(25.0).cast&lt;double&gt;();        std::cout &lt;&lt; &quot;sqrt(25) = &quot; &lt;&lt; result &lt;&lt; std::endl;                // 执行多行Python代码        py::exec(R&quot;(            import sys            print(f&quot;Python version: &#123;sys.version&#125;&quot;)                        def add(a, b):                return a + b                        result = add(3, 4)            print(f&quot;3 + 4 = &#123;result&#125;&quot;)        )&quot;);                // 调用Python函数        auto add = py::eval(&quot;add&quot;).cast&lt;py::function&gt;();        int sum_result = add(5, 6).cast&lt;int&gt;();        std::cout &lt;&lt; &quot;5 + 6 = &quot; &lt;&lt; sum_result &lt;&lt; std::endl;            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Python error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        // 解释器会在guard析构时自动关闭    return 0;&#125;\n2. 嵌入模块\n#include &lt;pybind11/embed.h&gt;#include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;// 嵌入的C++模块PYBIND11_EMBEDDED_MODULE(embedded_module, m) &#123;    m.def(&quot;multiply&quot;, [](int a, int b) &#123;        return a * b;    &#125;);        m.def(&quot;greet&quot;, [](const std::string&amp; name) &#123;        return &quot;Hello, &quot; + name + &quot;!&quot;;    &#125;);&#125;int main() &#123;    py::scoped_interpreter guard&#123;&#125;;        try &#123;        // 导入嵌入的模块        py::module em = py::module::import(&quot;embedded_module&quot;);                // 调用嵌入模块的函数        int product = em.attr(&quot;multiply&quot;)(3, 4).cast&lt;int&gt;();        std::cout &lt;&lt; &quot;3 * 4 = &quot; &lt;&lt; product &lt;&lt; std::endl;                std::string greeting = em.attr(&quot;greet&quot;)(&quot;World&quot;).cast&lt;std::string&gt;();        std::cout &lt;&lt; greeting &lt;&lt; std::endl;                // 在Python中使用嵌入模块        py::exec(R&quot;(            result = embedded_module.multiply(5, 6)            print(f&quot;5 * 6 = &#123;result&#125;&quot;)                        message = embedded_module.greet(&quot;Python&quot;)            print(message)        )&quot;);            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        return 0;&#125;\n3. 导入本地 Python 文件\n#include &lt;pybind11/embed.h&gt;#include &lt;iostream&gt;#include &lt;filesystem&gt;namespace py = pybind11;namespace fs = std::filesystem;int main() &#123;    py::scoped_interpreter guard&#123;&#125;;        try &#123;        // 添加当前目录到Python路径        py::module sys = py::module::import(&quot;sys&quot;);        sys.attr(&quot;path&quot;).cast&lt;py::list&gt;().append(fs::current_path().string());                // 导入本地Python模块        py::module my_module = py::module::import(&quot;my_python_module&quot;);                // 调用Python函数        int result = my_module.attr(&quot;my_function&quot;)(10, 20).cast&lt;int&gt;();        std::cout &lt;&lt; &quot;Result from Python: &quot; &lt;&lt; result &lt;&lt; std::endl;            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        return 0;&#125;\n多线程与 GIL 管理\n1. GIL 释放与获取\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/functional.h&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;iostream&gt;namespace py = pybind11;// 长时间运行的C++函数 - 应该释放GILvoid long_running_task() &#123;    // 释放GIL    py::gil_scoped_release release;        std::cout &lt;&lt; &quot;Long running task started (thread: &quot;               &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;        // 模拟长时间计算    for (int i = 0; i &lt; 5; ++i) &#123;        std::this_thread::sleep_for(std::chrono::seconds(1));        std::cout &lt;&lt; &quot;Task progress: &quot; &lt;&lt; (i + 1) &lt;&lt; &quot;/5&quot; &lt;&lt; std::endl;    &#125;        std::cout &lt;&lt; &quot;Long running task completed&quot; &lt;&lt; std::endl;        // GIL会在release析构时自动重新获取&#125;// 使用call_guard自动管理GILvoid task_with_guard() &#123;    std::cout &lt;&lt; &quot;Task with guard started&quot; &lt;&lt; std::endl;    std::this_thread::sleep_for(std::chrono::seconds(3));    std::cout &lt;&lt; &quot;Task with guard completed&quot; &lt;&lt; std::endl;&#125;// 多线程函数void run_in_threads() &#123;    std::thread t1(long_running_task);    std::thread t2(long_running_task);        t1.join();    t2.join();&#125;PYBIND11_MODULE(example, m) &#123;    // 直接释放GIL    m.def(&quot;long_running_task&quot;, &amp;long_running_task);        // 使用call_guard释放GIL    m.def(&quot;task_with_guard&quot;, &amp;task_with_guard,           py::call_guard&lt;py::gil_scoped_release&gt;());        // 多线程示例    m.def(&quot;run_in_threads&quot;, &amp;run_in_threads);        // 线程安全的函数调用    m.def(&quot;thread_safe_function&quot;, [](int value) &#123;        // 在关键部分获取GIL        py::gil_scoped_acquire acquire;        py::print(&quot;Thread-safe function called with value:&quot;, value);    &#125;);&#125;\nPython 使用：\nimport exampleimport threadingimport time# 测试长时间任务print(&quot;Testing long running task...&quot;)thread1 = threading.Thread(target=example.long_running_task)thread2 = threading.Thread(target=example.long_running_task)thread1.start()thread2.start()# 主线程可以继续执行其他任务for i in range(3):    print(f&quot;Main thread working... &#123;i&#125;&quot;)    time.sleep(1)thread1.join()thread2.join()# 测试带guard的任务print(&quot;Testing task with guard...&quot;)example.task_with_guard()# 测试多线程函数print(&quot;Testing run in threads...&quot;)example.run_in_threads()\n2. 线程局部存储\n#include &lt;pybind11/pybind11.h&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;iostream&gt;namespace py = pybind11;// 线程局部存储thread_local int thread_counter = 0;std::mutex cout_mutex;void thread_function(int id) &#123;    // 释放GIL    py::gil_scoped_release release;        for (int i = 0; i &lt; 5; ++i) &#123;        thread_counter++;                // 安全的输出        std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot;: counter = &quot; &lt;&lt; thread_counter &lt;&lt; std::endl;                std::this_thread::sleep_for(std::chrono::milliseconds(100));    &#125;&#125;void start_threads() &#123;    std::thread t1(thread_function, 1);    std::thread t2(thread_function, 2);        t1.join();    t2.join();&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;start_threads&quot;, &amp;start_threads);&#125;\n3. 异步任务\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/functional.h&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;iostream&gt;namespace py = pybind11;// 异步执行函数std::future&lt;int&gt; async_task(int x, int y) &#123;    return std::async(std::launch::async, [x, y]() &#123;        // 释放GIL        py::gil_scoped_release release;                std::cout &lt;&lt; &quot;Async task started (thread: &quot;                   &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;                // 模拟计算        std::this_thread::sleep_for(std::chrono::seconds(2));        return x + y;    &#125;);&#125;// 异步回调void async_callback(py::function callback, int x, int y) &#123;    std::thread([callback, x, y]() &#123;        // 释放GIL        py::gil_scoped_release release;                std::cout &lt;&lt; &quot;Callback task started&quot; &lt;&lt; std::endl;        std::this_thread::sleep_for(std::chrono::seconds(2));                // 计算结果        int result = x * y;                // 调用回调函数时重新获取GIL        py::gil_scoped_acquire acquire;        callback(result);    &#125;).detach();&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;async_task&quot;, [](int x, int y) &#123;        auto future = async_task(x, y);        return future.get();    &#125;);        m.def(&quot;async_callback&quot;, &amp;async_callback);&#125;\nPython 使用：\nimport exampleimport time# 测试异步任务print(&quot;Testing async task...&quot;)result = example.async_task(3, 4)print(f&quot;Async result: &#123;result&#125;&quot;)# 测试异步回调def on_complete(result):    print(f&quot;Callback received: &#123;result&#125;&quot;)print(&quot;Testing async callback...&quot;)example.async_callback(on_complete, 5, 6)print(&quot;Callback task started (will complete in 2 seconds)&quot;)# 等待回调完成time.sleep(3)\n子解释器\n1. 基础子解释器使用\n#include &lt;pybind11/embed.h&gt;#include &lt;pybind11/subinterpreter.h&gt;#include &lt;iostream&gt;namespace py = pybind11;int main() &#123;    // 初始化主解释器    py::scoped_interpreter main_guard&#123;&#125;;        try &#123;        std::cout &lt;&lt; &quot;Main interpreter started&quot; &lt;&lt; std::endl;                // 创建子解释器        py::subinterpreter sub = py::subinterpreter::create();                &#123;            // 激活子解释器            py::subinterpreter_scoped_activate activate(sub);                        std::cout &lt;&lt; &quot;Sub-interpreter activated&quot; &lt;&lt; std::endl;                        // 在子解释器中执行代码            py::exec(R&quot;(                import sys                print(f&quot;Sub-interpreter Python version: &#123;sys.version&#125;&quot;)                counter = 42            )&quot;);                        // 获取变量值            int counter = py::eval(&quot;counter&quot;).cast&lt;int&gt;();            std::cout &lt;&lt; &quot;Sub-interpreter counter: &quot; &lt;&lt; counter &lt;&lt; std::endl;        &#125;                std::cout &lt;&lt; &quot;Sub-interpreter deactivated&quot; &lt;&lt; std::endl;                // 主解释器不受影响        py::exec(&quot;print(&#x27;Back to main interpreter&#x27;)&quot;);            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        return 0;&#125;\n2. 多线程子解释器\n#include &lt;pybind11/embed.h&gt;#include &lt;pybind11/subinterpreter.h&gt;#include &lt;thread&gt;#include &lt;iostream&gt;namespace py = pybind11;void run_in_subinterpreter(py::subinterpreter sub, int id) &#123;    try &#123;        // 激活子解释器        py::subinterpreter_scoped_activate activate(sub);                std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; started in sub-interpreter&quot; &lt;&lt; std::endl;                // 执行Python代码        py::exec(R&quot;(            import time            import threading                        def task():                for i in range(3):                    print(f&quot;Task &#123;id&#125; iteration &#123;i&#125; (thread: &#123;threading.get_ident()&#125;)&quot;)                    time.sleep(1)                        task()        )&quot;);                std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; completed&quot; &lt;&lt; std::endl;            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    py::scoped_interpreter main_guard&#123;&#125;;        try &#123;        // 创建多个子解释器        py::subinterpreter sub1 = py::subinterpreter::create();        py::subinterpreter sub2 = py::subinterpreter::create();                // 在不同线程中运行子解释器        std::thread t1(run_in_subinterpreter, std::move(sub1), 1);        std::thread t2(run_in_subinterpreter, std::move(sub2), 2);                t1.join();        t2.join();            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Main error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        return 0;&#125;\n3. 子解释器安全最佳实践\n#include &lt;pybind11/embed.h&gt;#include &lt;pybind11/subinterpreter.h&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;iostream&gt;namespace py = pybind11;// 线程安全的子解释器管理器class SubinterpreterManager &#123;public:    SubinterpreterManager() : main_guard_&#123;&#125; &#123;&#125;        py::subinterpreter create_subinterpreter() &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex_);        return py::subinterpreter::create();    &#125;    private:    py::scoped_interpreter main_guard_;    std::mutex mutex_;&#125;;// 安全的任务函数void safe_task(py::subinterpreter sub, const std::string&amp; name) &#123;    try &#123;        // 子解释器作用域        py::subinterpreter_scoped_activate activate(sub);                // 任务逻辑        py::exec(R&quot;(            import time                        def safe_operation(name):                result = []                for i in range(5):                    result.append(f&quot;&#123;name&#125;: &#123;i&#125;&quot;)                    time.sleep(0.1)                return result                        result = safe_operation(name)            print(f&quot;Task &#123;name&#125; completed with &#123;len(result)&#125; items&quot;)        )&quot;);            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Task &quot; &lt;&lt; name &lt;&lt; &quot; failed: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    SubinterpreterManager manager;        // 创建并运行多个子解释器任务    std::vector&lt;std::thread&gt; threads;    for (int i = 0; i &lt; 3; ++i) &#123;        py::subinterpreter sub = manager.create_subinterpreter();        threads.emplace_back(safe_task, std::move(sub), &quot;task_&quot; + std::to_string(i));    &#125;        // 等待所有线程完成    for (auto&amp; t : threads) &#123;        t.join();    &#125;        return 0;&#125;\n自定义类型转换\n1. 基础自定义转换器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;#include &lt;sstream&gt;namespace py = pybind11;// 自定义类型struct Point &#123;    int x;    int y;        Point(int x = 0, int y = 0) : x(x), y(y) &#123;&#125;        std::string to_string() const &#123;        std::stringstream ss;        ss &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot;;        return ss.str();    &#125;&#125;;// 自定义类型转换器namespace pybind11 &#123; namespace detail &#123;    template &lt;&gt; struct type_caster&lt;Point&gt; &#123;    public:        PYBIND11_TYPE_CASTER(Point, _(&quot;Point&quot;));                // 从Python对象转换到C++        bool load(handle src, bool) &#123;            if (!src.is_dict()) return false;                        py::dict obj = src.cast&lt;py::dict&gt;();            value.x = obj[&quot;x&quot;].cast&lt;int&gt;();            value.y = obj[&quot;y&quot;].cast&lt;int&gt;();            return true;        &#125;                // 从C++转换到Python对象        static handle cast(const Point&amp; p, return_value_policy /* policy */, handle /* parent */) &#123;            py::dict obj;            obj[&quot;x&quot;] = p.x;            obj[&quot;y&quot;] = p.y;            return obj.release();        &#125;    &#125;;&#125;&#125;PYBIND11_MODULE(example, m) &#123;    // 使用自定义转换器    m.def(&quot;add_points&quot;, [](const Point&amp; a, const Point&amp; b) &#123;        return Point(a.x + b.x, a.y + b.y);    &#125;);        m.def(&quot;print_point&quot;, [](const Point&amp; p) &#123;        py::print(p.to_string());    &#125;);&#125;\nPython 使用：\nimport example# 创建Point对象（通过字典）p1 = &#123;&quot;x&quot;: 1, &quot;y&quot;: 2&#125;p2 = &#123;&quot;x&quot;: 3, &quot;y&quot;: 4&#125;# 使用自定义转换result = example.add_points(p1, p2)print(result)  # 输出：&#123;&#x27;x&#x27;: 4, &#x27;y&#x27;: 6&#125;example.print_point(result)  # 输出：(4, 6)\n2. 支持多种 Python 类型的转换器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/stl.h&gt;#include &lt;string&gt;#include &lt;vector&gt;namespace py = pybind11;struct Rectangle &#123;    int x, y, width, height;        Rectangle(int x=0, int y=0, int w=0, int h=0)         : x(x), y(y), width(w), height(h) &#123;&#125;        int area() const &#123; return width * height; &#125;&#125;;namespace pybind11 &#123; namespace detail &#123;    template &lt;&gt; struct type_caster&lt;Rectangle&gt; &#123;    public:        PYBIND11_TYPE_CASTER(Rectangle, _(&quot;Rectangle&quot;));                bool load(handle src, bool) &#123;            // 支持字典            if (src.is_dict()) &#123;                py::dict obj = src.cast&lt;py::dict&gt;();                value.x = obj[&quot;x&quot;].cast&lt;int&gt;();                value.y = obj[&quot;y&quot;].cast&lt;int&gt;();                value.width = obj[&quot;width&quot;].cast&lt;int&gt;();                value.height = obj[&quot;height&quot;].cast&lt;int&gt;();                return true;            &#125;            // 支持元组            else if (src.is_tuple()) &#123;                py::tuple obj = src.cast&lt;py::tuple&gt;();                if (obj.size() != 4) return false;                value.x = obj[0].cast&lt;int&gt;();                value.y = obj[1].cast&lt;int&gt;();                value.width = obj[2].cast&lt;int&gt;();                value.height = obj[3].cast&lt;int&gt;();                return true;            &#125;            // 支持列表            else if (src.is_list()) &#123;                py::list obj = src.cast&lt;py::list&gt;();                if (obj.size() != 4) return false;                value.x = obj[0].cast&lt;int&gt;();                value.y = obj[1].cast&lt;int&gt;();                value.width = obj[2].cast&lt;int&gt;();                value.height = obj[3].cast&lt;int&gt;();                return true;            &#125;                        return false;        &#125;                static handle cast(const Rectangle&amp; r, return_value_policy /* policy */, handle /* parent */) &#123;            py::dict obj;            obj[&quot;x&quot;] = r.x;            obj[&quot;y&quot;] = r.y;            obj[&quot;width&quot;] = r.width;            obj[&quot;height&quot;] = r.height;            obj[&quot;area&quot;] = r.area();            return obj.release();        &#125;    &#125;;&#125;&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;rectangle_area&quot;, [](const Rectangle&amp; r) &#123;        return r.area();    &#125;);        m.def(&quot;expand_rectangle&quot;, [](const Rectangle&amp; r, int amount) &#123;        return Rectangle(            r.x - amount,            r.y - amount,            r.width + 2 * amount,            r.height + 2 * amount        );    &#125;);&#125;\nPython 使用：\nimport example# 支持多种输入类型rect1 = &#123;&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;width&quot;: 10, &quot;height&quot;: 20&#125;rect2 = (10, 10, 5, 5)rect3 = [20, 20, 8, 8]print(example.rectangle_area(rect1))  # 输出：200print(example.rectangle_area(rect2))  # 输出：25print(example.rectangle_area(rect3))  # 输出：64# 扩展矩形expanded = example.expand_rectangle(rect1, 2)print(expanded)# 输出：&#123;&#x27;x&#x27;: -2, &#x27;y&#x27;: -2, &#x27;width&#x27;: 14, &#x27;height&#x27;: 24, &#x27;area&#x27;: 336&#125;\n3. 继承类型的转换器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;#include &lt;memory&gt;namespace py = pybind11;// 基类struct Shape &#123;    virtual ~Shape() = default;    virtual std::string name() const = 0;    virtual double area() const = 0;&#125;;// 派生类struct Circle : public Shape &#123;    double radius;        Circle(double r) : radius(r) &#123;&#125;        std::string name() const override &#123; return &quot;Circle&quot;; &#125;    double area() const override &#123; return 3.14159 * radius * radius; &#125;&#125;;struct Square : public Shape &#123;    double side;        Square(double s) : side(s) &#123;&#125;        std::string name() const override &#123; return &quot;Square&quot;; &#125;    double area() const override &#123; return side * side; &#125;&#125;;// 基类转换器namespace pybind11 &#123; namespace detail &#123;    template &lt;&gt; struct type_caster&lt;std::shared_ptr&lt;Shape&gt;&gt; &#123;    public:        PYBIND11_TYPE_CASTER(std::shared_ptr&lt;Shape&gt;, _(&quot;Shape&quot;));                bool load(handle src, bool) &#123;            if (!src.is_dict()) return false;                        py::dict obj = src.cast&lt;py::dict&gt;();            std::string type = obj[&quot;type&quot;].cast&lt;std::string&gt;();                        if (type == &quot;circle&quot;) &#123;                double radius = obj[&quot;radius&quot;].cast&lt;double&gt;();                value = std::make_shared&lt;Circle&gt;(radius);            &#125; else if (type == &quot;square&quot;) &#123;                double side = obj[&quot;side&quot;].cast&lt;double&gt;();                value = std::make_shared&lt;Square&gt;(side);            &#125; else &#123;                return false;            &#125;                        return true;        &#125;                static handle cast(const std::shared_ptr&lt;Shape&gt;&amp; shape,                           return_value_policy /* policy */, handle /* parent */) &#123;            py::dict obj;                        if (auto circle = std::dynamic_pointer_cast&lt;Circle&gt;(shape)) &#123;                obj[&quot;type&quot;] = &quot;circle&quot;;                obj[&quot;radius&quot;] = circle-&gt;radius;            &#125; else if (auto square = std::dynamic_pointer_cast&lt;Square&gt;(shape)) &#123;                obj[&quot;type&quot;] = &quot;square&quot;;                obj[&quot;side&quot;] = square-&gt;side;            &#125;                        obj[&quot;name&quot;] = shape-&gt;name();            obj[&quot;area&quot;] = shape-&gt;area();                        return obj.release();        &#125;    &#125;;&#125;&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;shape_info&quot;, [](const std::shared_ptr&lt;Shape&gt;&amp; shape) &#123;        return py::make_tuple(shape-&gt;name(), shape-&gt;area());    &#125;);        m.def(&quot;create_shape&quot;, [](const std::string&amp; type, double param) &#123;        if (type == &quot;circle&quot;) &#123;            return std::make_shared&lt;Circle&gt;(param);        &#125; else if (type == &quot;square&quot;) &#123;            return std::make_shared&lt;Square&gt;(param);        &#125;        throw std::invalid_argument(&quot;Unknown shape type&quot;);    &#125;);&#125;\n其他高级特性\n1. 属性装饰器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;namespace py = pybind11;class Person &#123;public:    Person(const std::string&amp; name, int age)         : name(name), age(age) &#123;&#125;        std::string get_name() const &#123; return name; &#125;    void set_name(const std::string&amp; new_name) &#123; name = new_name; &#125;        int get_age() const &#123; return age; &#125;    void set_age(int new_age) &#123;         if (new_age &lt; 0) throw std::invalid_argument(&quot;年龄不能为负数&quot;);        age = new_age;    &#125;        std::string get_full_info() const &#123;        return name + &quot;, &quot; + std::to_string(age) + &quot;岁&quot;;    &#125;    private:    std::string name;    int age;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Person&gt;(m, &quot;Person&quot;)        .def(py::init&lt;const std::string&amp;, int&gt;())                // 可读可写属性        .def_property(&quot;name&quot;, &amp;Person::get_name, &amp;Person::set_name)                // 带验证的属性        .def_property(&quot;age&quot;, &amp;Person::get_age, &amp;Person::set_age)                // 只读属性        .def_property_readonly(&quot;full_info&quot;, &amp;Person::get_full_info)                // 静态属性        .def_readwrite_static(&quot;species&quot;, []() &#123; return &quot;人类&quot;; &#125;);&#125;\n2. 方法装饰器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/functional.h&gt;#include &lt;string&gt;#include &lt;chrono&gt;namespace py = pybind11;// 计时装饰器template &lt;typename Func&gt;auto timing_decorator(Func&amp;&amp; func) &#123;    return [func = std::forward&lt;Func&gt;(func)](auto&amp;&amp;... args) &#123;        auto start = std::chrono::high_resolution_clock::now();                auto result = func(std::forward&lt;decltype(args)&gt;(args)...);                auto end = std::chrono::high_resolution_clock::now();        auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(            end - start        );                py::print(&quot;函数执行时间:&quot;, duration.count(), &quot;微秒&quot;);        return result;    &#125;;&#125;// 缓存装饰器template &lt;typename Func&gt;auto cache_decorator(Func&amp;&amp; func) &#123;    std::unordered_map&lt;std::string, py::object&gt; cache;        return [func = std::forward&lt;Func&gt;(func), cache = std::move(cache)](        const std::string&amp; key, auto&amp;&amp;... args    ) mutable &#123;        if (cache.find(key) != cache.end()) &#123;            py::print(&quot;缓存命中:&quot;, key);            return cache[key];        &#125;                py::object result = func(key, std::forward&lt;decltype(args)&gt;(args)...);        cache[key] = result;        py::print(&quot;缓存未命中，计算结果:&quot;, key);        return result;    &#125;;&#125;PYBIND11_MODULE(example, m) &#123;    // 原始函数    auto expensive_function = [](const std::string&amp; data) &#123;        // 模拟耗时计算        std::this_thread::sleep_for(std::chrono::milliseconds(100));        return &quot;处理结果: &quot; + data;    &#125;;        // 使用装饰器    m.def(&quot;process_data&quot;, timing_decorator(expensive_function));    m.def(&quot;cached_process&quot;, cache_decorator(expensive_function));&#125;\n3. 自定义异常\n#include &lt;pybind11/pybind11.h&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;namespace py = pybind11;// 自定义异常类型class ValidationError : public std::runtime_error &#123;public:    ValidationError(const std::string&amp; message)         : std::runtime_error(message) &#123;&#125;&#125;;class DatabaseError : public std::runtime_error &#123;public:    DatabaseError(const std::string&amp; message, int code)         : std::runtime_error(message), error_code(code) &#123;&#125;        int get_code() const &#123; return error_code; &#125;    private:    int error_code;&#125;;PYBIND11_MODULE(example, m) &#123;    // 绑定自定义异常    auto validation_error = py::register_exception&lt;ValidationError&gt;(m, &quot;ValidationError&quot;);    auto db_error = py::register_exception&lt;DatabaseError&gt;(m, &quot;DatabaseError&quot;);        // 为异常添加额外方法    db_error.def(&quot;get_code&quot;, &amp;DatabaseError::get_code);        // 使用自定义异常的函数    m.def(&quot;validate_age&quot;, [](int age) &#123;        if (age &lt; 0) &#123;            throw ValidationError(&quot;年龄不能为负数&quot;);        &#125;        if (age &gt; 150) &#123;            throw ValidationError(&quot;年龄不能超过150&quot;);        &#125;    &#125;);        m.def(&quot;connect_to_db&quot;, [](const std::string&amp; host) &#123;        if (host.empty()) &#123;            throw DatabaseError(&quot;数据库主机不能为空&quot;, 1001);        &#125;        if (host != &quot;localhost&quot;) &#123;            throw DatabaseError(&quot;连接失败: 未知主机&quot;, 1002);        &#125;        return &quot;连接成功&quot;;    &#125;);&#125;\nPython 使用：\nimport exampletry:    example.validate_age(-5)except example.ValidationError as e:    print(f&quot;验证错误: &#123;e&#125;&quot;)try:    example.connect_to_db(&quot;invalid_host&quot;)except example.DatabaseError as e:    print(f&quot;数据库错误: &#123;e&#125;, 错误码: &#123;e.get_code()&#125;&quot;)\n4. 上下文管理器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/functional.h&gt;#include &lt;iostream&gt;#include &lt;chrono&gt;namespace py = pybind11;class Timer &#123;public:    Timer() : start_time(std::chrono::high_resolution_clock::now()) &#123;        std::cout &lt;&lt; &quot;计时器开始&quot; &lt;&lt; std::endl;    &#125;        ~Timer() &#123;        auto end_time = std::chrono::high_resolution_clock::now();        auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(            end_time - start_time        );        std::cout &lt;&lt; &quot;计时器结束，耗时: &quot; &lt;&lt; duration.count() &lt;&lt; &quot;毫秒&quot; &lt;&lt; std::endl;    &#125;        void reset() &#123;        start_time = std::chrono::high_resolution_clock::now();        std::cout &lt;&lt; &quot;计时器重置&quot; &lt;&lt; std::endl;    &#125;    private:    std::chrono::high_resolution_clock::time_point start_time;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Timer&gt;(m, &quot;Timer&quot;)        .def(py::init&lt;&gt;())        .def(&quot;reset&quot;, &amp;Timer::reset)                // 实现上下文管理器接口        .def(&quot;__enter__&quot;, [](Timer&amp; self) &#123;            return &amp;self;        &#125;)        .def(&quot;__exit__&quot;, [](Timer&amp; self, py::object type, py::object value, py::object traceback) &#123;            // __exit__方法的返回值表示是否处理异常            return py::none();        &#125;);&#125;\nPython 使用：\nimport exampleimport time# 使用上下文管理器with example.Timer() as timer:    time.sleep(1)    timer.reset()    time.sleep(0.5)# 输出：# 计时器开始# 计时器重置# 计时器结束，耗时: 500毫秒\n5. 迭代器支持\n#include &lt;pybind11/pybind11.h&gt;#include &lt;vector&gt;#include &lt;string&gt;namespace py = pybind11;class NumberSequence &#123;public:    NumberSequence(int start, int end)         : start_(start), end_(end), current_(start) &#123;&#125;        // 迭代器接口    int next() &#123;        if (current_ &gt; end_) &#123;            throw py::stop_iteration();        &#125;        return current_++;    &#125;        // 重置迭代器    void reset() &#123;        current_ = start_;    &#125;    private:    int start_;    int end_;    int current_;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;NumberSequence&gt;(m, &quot;NumberSequence&quot;)        .def(py::init&lt;int, int&gt;())        .def(&quot;reset&quot;, &amp;NumberSequence::reset)                // 实现迭代器协议        .def(&quot;__iter__&quot;, [](NumberSequence&amp; self) &#123;            self.reset();            return &amp;self;        &#125;)        .def(&quot;__next__&quot;, &amp;NumberSequence::next);        // 范围迭代器示例    m.def(&quot;range_generator&quot;, [](int n) &#123;        return py::make_iterator(range(0, n).begin(), range(0, n).end());    &#125;, py::keep_alive&lt;0, 1&gt;());&#125;\nPython 使用：\nimport example# 使用自定义迭代器seq = example.NumberSequence(1, 5)for num in seq:    print(num)  # 输出：1, 2, 3, 4, 5# 使用范围生成器for i in example.range_generator(3):    print(i)  # 输出：0, 1, 2\n总结\n本补充指南涵盖了 pybind11 官方文档中的所有重要高级特性：\n核心要点\n\n\n高级类特性：动态属性、继承与多态、运算符重载、枚举绑定\n\n\n构建系统：CMake、pyproject.toml、setuptools 的高级配置\n\n\n内存管理：返回值策略、智能指针（smart_holder、unique_ptr、shared_ptr）\n\n\n类型系统：基础类型转换、STL 容器、自定义类型转换器\n\n\n嵌入与扩展：Python 解释器嵌入、子解释器、多线程 GIL 管理\n\n\n高级功能：属性装饰器、方法装饰器、自定义异常、上下文管理器、迭代器\n\n\n最佳实践\n\n\n内存安全：正确使用返回值策略，优先使用 smart_holder\n\n\n性能优化：合理释放 GIL，使用多线程和异步任务\n\n\n类型安全：使用强类型转换，避免隐式转换错误\n\n\n代码组织：模块化设计，分离实现和绑定代码\n\n\n错误处理：使用自定义异常，提供详细的错误信息\n\n\n进阶学习\n\n\n性能调优：使用 LTO 优化、缓存机制、异步编程\n\n\n调试技巧：GDB 调试、Python 调试器集成\n\n\n测试策略：单元测试、集成测试、性能测试\n\n\n部署方案：wheel 打包、conda 包、Docker 容器化\n\n\npybind11 为 C++ 和 Python 的无缝集成提供了强大的支持，掌握这些高级特性将帮助您开发出更加高效、健壮的跨语言应用程序。\nDate: October 16, 2025\nCode: https://github.com/pybind/pybind11\n","categories":["编程"],"tags":["python","C++"]},{"title":"PyBind11使用指北","url":"/2025/09/09/C++/pybind11%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","content":"\n如题，结合官方文档与网络帖子，利用AI整理\n\n\npybind11 使用指南\n目录\n\n\n简介\n\n\n安装\n\n\n基础用法\n\n\n进阶用法\n\n\n高级特性\n\n\n实际案例\n\n\n最佳实践\n\n\n常见问题\n\n\n简介\npybind11 是一个轻量级的仅头文件 C++ 库，用于将 C++ 代码暴露给 Python 调用，或者在 C++ 中调用 Python 代码。它比传统的 Boost.Python 更简洁高效，适用于现代 C++（C++11 及以上）。\n核心特性\n\n\n函数绑定：将 C++ 函数暴露给 Python\n\n\n类绑定：将 C++ 类及其方法暴露给 Python\n\n\n数据类型转换：支持基本类型、STL 容器、NumPy 数组等\n\n\n异常处理：C++ 异常与 Python 异常的转换\n\n\n继承支持：支持 C++ 类继承和 Python 继承 C++ 类\n\n\n运算符重载：支持 C++ 运算符在 Python 中的使用\n\n\n优势\n\n\n仅头文件：无需链接额外库，编译简单\n\n\n现代 C++：充分利用 C++11/14/17 特性\n\n\n自动类型推断：减少样板代码\n\n\n高性能：接近原生 C++ 性能\n\n\n易于使用：简洁的 API 设计\n\n\n安装\n使用 pip 安装\npip install pybind11\n从源码安装（推荐）\ngit clone https://github.com/pybind/pybind11.gitcd pybind11mkdir build &amp;&amp; cd buildcmake ..make install\n验证安装\npython -m pybind11 --includes\n成功安装会显示头文件路径，例如：\n-I/usr/local/include/python3.8 -I/usr/local/include/pybind11\n基础用法\n1. 简单函数绑定\n创建一个简单的 C++ 函数并暴露给 Python。\n示例代码：example.cpp\n#include &lt;pybind11/pybind11.h&gt;// 简单的加法函数int add(int a, int b) &#123;    return a + b;&#125;// 模块定义PYBIND11_MODULE(example, m) &#123;    m.doc() = &quot;pybind11示例模块&quot;;  // 模块文档字符串        // 绑定函数    m.def(&quot;add&quot;, &amp;add, &quot;一个加法函数&quot;,           pybind11::arg(&quot;a&quot;), pybind11::arg(&quot;b&quot;));&#125;\n编译方法\nLinux/macOS：\nc++ -O3 -Wall -shared -std=c++11 -fPIC $(python3 -m pybind11 --includes) example.cpp -o example$(python3-config --extension-suffix)\nWindows（MSVC）：\ncl /EHsc /LD /I C:\\path\\to\\Python\\include /I C:\\path\\to\\pybind11\\include example.cpp /link /LIBPATH:C:\\path\\to\\Python\\libs\nPython 中使用\nimport exampleprint(example.add(3, 4))  # 输出：7print(example.add(a=5, b=6))  # 输出：11（关键字参数）\n2. 使用 setuptools 编译\n创建setup.py文件：\nfrom setuptools import setupfrom pybind11.setup_helpers import Pybind11Extensionext_modules = [    Pybind11Extension(        &quot;example&quot;,        [&quot;example.cpp&quot;],        extra_compile_args=[&quot;-O3&quot;, &quot;-std=c++11&quot;]    ),]setup(    name=&quot;example&quot;,    ext_modules=ext_modules,    zip_safe=False,)\n编译安装：\npython setup.py build_ext --inplace\n3. 带默认参数的函数\n#include &lt;pybind11/pybind11.h&gt;int add(int a, int b = 10) &#123;    return a + b;&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;add&quot;, &amp;add, &quot;带默认参数的加法函数&quot;,          pybind11::arg(&quot;a&quot;), pybind11::arg(&quot;b&quot;) = 10);&#125;\nPython 使用：\nimport exampleprint(example.add(5))      # 输出：15（使用默认参数b=10）print(example.add(5, 3))   # 输出：8\n4. 暴露变量\n#include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;PYBIND11_MODULE(example, m) &#123;    m.attr(&quot;the_answer&quot;) = 42;    m.attr(&quot;what&quot;) = &quot;World&quot;;        const char* version = &quot;1.0.0&quot;;    m.attr(&quot;version&quot;) = version;&#125;\nPython 使用：\nimport exampleprint(example.the_answer)  # 输出：42print(example.what)        # 输出：Worldprint(example.version)     # 输出：1.0.0\n进阶用法\n1. 类绑定\n将 C++ 类暴露给 Python。\n示例代码\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;namespace py = pybind11;// C++类class Pet &#123;public:    Pet(const std::string&amp; name) : name(name) &#123;&#125;        void set_name(const std::string&amp; new_name) &#123;        name = new_name;    &#125;        std::string get_name() const &#123;        return name;    &#125;        std::string speak() const &#123;        return &quot;Woof!&quot;;    &#125;private:    std::string name;&#125;;// 派生类class Dog : public Pet &#123;public:    Dog(const std::string&amp; name) : Pet(name) &#123;&#125;        std::string speak() const override &#123;        return &quot;汪汪！&quot;;    &#125;        void wag_tail() &#123;        // 摇尾巴的实现    &#125;&#125;;PYBIND11_MODULE(example, m) &#123;    // 绑定基类    py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)        .def(py::init&lt;const std::string&amp;&gt;(), &quot;宠物类构造函数&quot;)        .def(&quot;set_name&quot;, &amp;Pet::set_name, &quot;设置宠物名字&quot;)        .def(&quot;get_name&quot;, &amp;Pet::get_name, &quot;获取宠物名字&quot;)        .def(&quot;speak&quot;, &amp;Pet::speak, &quot;宠物叫声&quot;)        .def_readwrite(&quot;name&quot;, &amp;Pet::name, &quot;宠物名字属性&quot;);        // 绑定派生类    py::class_&lt;Dog, Pet&gt;(m, &quot;Dog&quot;)        .def(py::init&lt;const std::string&amp;&gt;(), &quot;狗类构造函数&quot;)        .def(&quot;speak&quot;, &amp;Dog::speak, &quot;狗叫声&quot;)        .def(&quot;wag_tail&quot;, &amp;Dog::wag_tail, &quot;摇尾巴&quot;);&#125;\nPython 使用\nimport example# 创建Pet对象pet = example.Pet(&quot;小猫&quot;)print(pet.get_name())  # 输出：小猫print(pet.speak())     # 输出：Woof!# 创建Dog对象（继承自Pet）dog = example.Dog(&quot;小狗&quot;)print(dog.get_name())  # 输出：小狗print(dog.speak())     # 输出：汪汪！（多态）dog.wag_tail()\n2. 函数重载\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;namespace py = pybind11;// 重载函数int add(int a, int b) &#123;    return a + b;&#125;double add(double a, double b) &#123;    return a + b;&#125;std::string add(const std::string&amp; a, const std::string&amp; b) &#123;    return a + b;&#125;PYBIND11_MODULE(example, m) &#123;    // 绑定重载函数    m.def(&quot;add&quot;, py::overload_cast&lt;int, int&gt;(&amp;add), &quot;整数加法&quot;);    m.def(&quot;add&quot;, py::overload_cast&lt;double, double&gt;(&amp;add), &quot;浮点数加法&quot;);    m.def(&quot;add&quot;, py::overload_cast&lt;const std::string&amp;, const std::string&amp;&gt;(&amp;add), &quot;字符串连接&quot;);&#125;\n3. 静态方法和属性\n#include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;class MathUtils &#123;public:    static int square(int x) &#123;        return x * x;    &#125;        static double pi;&#125;;double MathUtils::pi = 3.1415926535;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;MathUtils&gt;(m, &quot;MathUtils&quot;)        .def_static(&quot;square&quot;, &amp;MathUtils::square, &quot;计算平方&quot;)        .def_readwrite_static(&quot;pi&quot;, &amp;MathUtils::pi, &quot;圆周率&quot;);&#125;\nPython 使用：\nimport exampleprint(example.MathUtils.square(5))  # 输出：25print(example.MathUtils.pi)        # 输出：3.1415926535\n4. 异常处理\n#include &lt;pybind11/pybind11.h&gt;#include &lt;stdexcept&gt;namespace py = pybind11;int divide(int a, int b) &#123;    if (b == 0) &#123;        throw std::runtime_error(&quot;除零错误！&quot;);    &#125;    return a / b;&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;divide&quot;, &amp;divide, &quot;除法函数&quot;);&#125;\nPython 中捕获异常：\nimport exampletry:    result = example.divide(10, 0)except RuntimeError as e:    print(f&quot;捕获异常：&#123;e&#125;&quot;)  # 输出：捕获异常：除零错误！\n高级特性\n1. STL 容器支持\n需要包含额外的头文件：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/stl.h&gt;  // 支持STL容器#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;namespace py = pybind11;// 处理vectorstd::vector&lt;int&gt; double_list(const std::vector&lt;int&gt;&amp; lst) &#123;    std::vector&lt;int&gt; result;    for (int x : lst) &#123;        result.push_back(x * 2);    &#125;    return result;&#125;// 处理mapstd::map&lt;std::string, int&gt; count_words(const std::vector&lt;std::string&gt;&amp; words) &#123;    std::map&lt;std::string, int&gt; counts;    for (const auto&amp; word : words) &#123;        counts[word]++;    &#125;    return counts;&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;double_list&quot;, &amp;double_list, &quot;将列表中的每个元素翻倍&quot;);    m.def(&quot;count_words&quot;, &amp;count_words, &quot;统计单词出现次数&quot;);&#125;\nPython 使用：\nimport example# 测试vectorresult = example.double_list([1, 2, 3, 4])print(result)  # 输出：[2, 4, 6, 8]# 测试mapwords = [&quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;]counts = example.count_words(words)print(counts)  # 输出：&#123;&#x27;apple&#x27;: 3, &#x27;banana&#x27;: 2, &#x27;orange&#x27;: 1&#125;\n2. NumPy 数组支持\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/numpy.h&gt;namespace py = pybind11;// 矩阵加法py::array_t&lt;double&gt; add_matrices(py::array_t&lt;double&gt; a, py::array_t&lt;double&gt; b) &#123;    // 获取数组信息    py::buffer_info a_info = a.request();    py::buffer_info b_info = b.request();        // 检查维度和大小    if (a_info.ndim != 2 || b_info.ndim != 2) &#123;        throw std::runtime_error(&quot;数组必须是二维的&quot;);    &#125;        if (a_info.shape[0] != b_info.shape[0] || a_info.shape[1] != b_info.shape[1]) &#123;        throw std::runtime_error(&quot;数组形状不匹配&quot;);    &#125;        // 创建结果数组    auto result = py::array_t&lt;double&gt;(a_info.shape);    py::buffer_info res_info = result.request();        // 获取指针    double *a_ptr = static_cast&lt;double *&gt;(a_info.ptr);    double *b_ptr = static_cast&lt;double *&gt;(b_info.ptr);    double *res_ptr = static_cast&lt;double *&gt;(res_info.ptr);        // 执行加法    size_t size = a_info.shape[0] * a_info.shape[1];    for (size_t i = 0; i &lt; size; i++) &#123;        res_ptr[i] = a_ptr[i] + b_ptr[i];    &#125;        return result;&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;add_matrices&quot;, &amp;add_matrices, &quot;矩阵加法&quot;);&#125;\nPython 使用：\nimport exampleimport numpy as npa = np.array([[1.0, 2.0], [3.0, 4.0]])b = np.array([[5.0, 6.0], [7.0, 8.0]])result = example.add_matrices(a, b)print(result)# 输出：# [[ 6.  8.]#  [10. 12.]]\n3. 在 C++ 中调用 Python\n#include &lt;pybind11/embed.h&gt;  // 必须包含这个头文件#include &lt;iostream&gt;#include &lt;string&gt;namespace py = pybind11;int main() &#123;    // 启动Python解释器    py::scoped_interpreter guard&#123;&#125;;        try &#123;        // 导入Python模块        py::module sys = py::module::import(&quot;sys&quot;);        py::module math = py::module::import(&quot;math&quot;);        py::module json = py::module::import(&quot;json&quot;);                // 调用Python函数        double sqrt_result = math.attr(&quot;sqrt&quot;)(2.0).cast&lt;double&gt;();        std::cout &lt;&lt; &quot;sqrt(2) = &quot; &lt;&lt; sqrt_result &lt;&lt; std::endl;                // 创建Python字典        py::dict person;        person[&quot;name&quot;] = &quot;张三&quot;;        person[&quot;age&quot;] = 30;        person[&quot;city&quot;] = &quot;北京&quot;;                // 使用json模块序列化        std::string json_str = json.attr(&quot;dumps&quot;)(person).cast&lt;std::string&gt;();        std::cout &lt;&lt; &quot;JSON: &quot; &lt;&lt; json_str &lt;&lt; std::endl;                // 执行Python代码        py::exec(R&quot;(            print(&quot;Hello from Python!&quot;)            result = 1 + 2 + 3            print(f&quot;1 + 2 + 3 = &#123;result&#125;&quot;)        )&quot;);            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Python error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        return 0;&#125;\n4. 运算符重载\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/operators.h&gt;namespace py = pybind11;class Vector2 &#123;public:    float x, y;        Vector2(float x = 0, float y = 0) : x(x), y(y) &#123;&#125;        Vector2 operator+(const Vector2&amp; other) const &#123;        return Vector2(x + other.x, y + other.y);    &#125;        Vector2 operator*(float scalar) const &#123;        return Vector2(x * scalar, y * scalar);    &#125;        bool operator==(const Vector2&amp; other) const &#123;        return x == other.x &amp;&amp; y == other.y;    &#125;        std::string to_string() const &#123;        return &quot;(&quot; + std::to_string(x) + &quot;, &quot; + std::to_string(y) + &quot;)&quot;;    &#125;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Vector2&gt;(m, &quot;Vector2&quot;)        .def(py::init&lt;float, float&gt;(), &quot;二维向量&quot;)        .def_readwrite(&quot;x&quot;, &amp;Vector2::x)        .def_readwrite(&quot;y&quot;, &amp;Vector2::y)        .def(&quot;__str__&quot;, &amp;Vector2::to_string)                // 运算符重载        .def(py::self + py::self)          // + 运算符        .def(py::self * float())           // * 运算符（向量 * 标量）        .def(float() * py::self)           // * 运算符（标量 * 向量）        .def(py::self == py::self);        // == 运算符&#125;\nPython 使用：\nimport examplev1 = example.Vector2(1, 2)v2 = example.Vector2(3, 4)v3 = v1 + v2print(v3)  # 输出：(4.000000, 6.000000)v4 = v1 * 2print(v4)  # 输出：(2.000000, 4.000000)v5 = 3 * v2print(v5)  # 输出：(9.000000, 12.000000)print(v1 == v2)  # 输出：False\n实际案例\n案例 1：高性能数值计算\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/numpy.h&gt;#include &lt;vector&gt;namespace py = pybind11;// 计算数组的移动平均值py::array_t&lt;double&gt; moving_average(py::array_t&lt;double&gt; data, int window_size) &#123;    py::buffer_info buf = data.request();        if (buf.ndim != 1) &#123;        throw std::runtime_error(&quot;只支持一维数组&quot;);    &#125;        size_t n = buf.size;    if (window_size &gt; n) &#123;        throw std::runtime_error(&quot;窗口大小不能大于数组长度&quot;);    &#125;        auto result = py::array_t&lt;double&gt;(n - window_size + 1);    py::buffer_info res_buf = result.request();        double *data_ptr = static_cast&lt;double *&gt;(buf.ptr);    double *res_ptr = static_cast&lt;double *&gt;(res_buf.ptr);        // 计算初始窗口    double sum = 0;    for (int i = 0; i &lt; window_size; i++) &#123;        sum += data_ptr[i];    &#125;    res_ptr[0] = sum / window_size;        // 滑动窗口    for (size_t i = 1; i &lt;= n - window_size; i++) &#123;        sum = sum - data_ptr[i-1] + data_ptr[i + window_size - 1];        res_ptr[i] = sum / window_size;    &#125;        return result;&#125;PYBIND11_MODULE(performance, m) &#123;    m.def(&quot;moving_average&quot;, &amp;moving_average, &quot;计算移动平均值&quot;,          py::arg(&quot;data&quot;), py::arg(&quot;window_size&quot;));&#125;\n案例 2：图像处理算法\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/numpy.h&gt;#include &lt;algorithm&gt;namespace py = pybind11;// 图像灰度化py::array_t&lt;uint8_t&gt; rgb_to_gray(py::array_t&lt;uint8_t&gt; image) &#123;    py::buffer_info buf = image.request();        if (buf.ndim != 3 || buf.shape[2] != 3) &#123;        throw std::runtime_error(&quot;输入必须是RGB图像&quot;);    &#125;        size_t height = buf.shape[0];    size_t width = buf.shape[1];        auto gray = py::array_t&lt;uint8_t&gt;(&#123;height, width&#125;);    py::buffer_info gray_buf = gray.request();        uint8_t *img_ptr = static_cast&lt;uint8_t *&gt;(buf.ptr);    uint8_t *gray_ptr = static_cast&lt;uint8_t *&gt;(gray_buf.ptr);        for (size_t i = 0; i &lt; height; i++) &#123;        for (size_t j = 0; j &lt; width; j++) &#123;            size_t idx = i * width * 3 + j * 3;            uint8_t r = img_ptr[idx];            uint8_t g = img_ptr[idx + 1];            uint8_t b = img_ptr[idx + 2];                        // 灰度化公式            gray_ptr[i * width + j] = static_cast&lt;uint8_t&gt;(                0.299 * r + 0.587 * g + 0.114 * b            );        &#125;    &#125;        return gray;&#125;PYBIND11_MODULE(imageprocessing, m) &#123;    m.def(&quot;rgb_to_gray&quot;, &amp;rgb_to_gray, &quot;RGB图像转灰度图像&quot;);&#125;\n案例 3：数据结构包装\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/stl.h&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;unordered_map&gt;namespace py = pybind11;// 栈数据结构template &lt;typename T&gt;class Stack &#123;private:    std::stack&lt;T&gt; stack_;    public:    void push(const T&amp; value) &#123;        stack_.push(value);    &#125;        T pop() &#123;        if (stack_.empty()) &#123;            throw std::runtime_error(&quot;栈为空&quot;);        &#125;        T top = stack_.top();        stack_.pop();        return top;    &#125;        T top() const &#123;        if (stack_.empty()) &#123;            throw std::runtime_error(&quot;栈为空&quot;);        &#125;        return stack_.top();    &#125;        bool empty() const &#123;        return stack_.empty();    &#125;        size_t size() const &#123;        return stack_.size();    &#125;&#125;;// 队列数据结构template &lt;typename T&gt;class Queue &#123;private:    std::queue&lt;T&gt; queue_;    public:    void enqueue(const T&amp; value) &#123;        queue_.push(value);    &#125;        T dequeue() &#123;        if (queue_.empty()) &#123;            throw std::runtime_error(&quot;队列为空&quot;);        &#125;        T front = queue_.front();        queue_.pop();        return front;    &#125;        T front() const &#123;        if (queue_.empty()) &#123;            throw std::runtime_error(&quot;队列为空&quot;);        &#125;        return queue_.front();    &#125;        bool empty() const &#123;        return queue_.empty();    &#125;        size_t size() const &#123;        return queue_.size();    &#125;&#125;;PYBIND11_MODULE(datastructures, m) &#123;    // 绑定栈    py::class_&lt;Stack&lt;int&gt;&gt;(m, &quot;IntStack&quot;)        .def(py::init&lt;&gt;())        .def(&quot;push&quot;, &amp;Stack&lt;int&gt;::push)        .def(&quot;pop&quot;, &amp;Stack&lt;int&gt;::pop)        .def(&quot;top&quot;, &amp;Stack&lt;int&gt;::top)        .def(&quot;empty&quot;, &amp;Stack&lt;int&gt;::empty)        .def(&quot;size&quot;, &amp;Stack&lt;int&gt;::size);        // 绑定队列    py::class_&lt;Queue&lt;std::string&gt;&gt;(m, &quot;StringQueue&quot;)        .def(py::init&lt;&gt;())        .def(&quot;enqueue&quot;, &amp;Queue&lt;std::string&gt;::enqueue)        .def(&quot;dequeue&quot;, &amp;Queue&lt;std::string&gt;::dequeue)        .def(&quot;front&quot;, &amp;Queue&lt;std::string&gt;::front)        .def(&quot;empty&quot;, &amp;Queue&lt;std::string&gt;::empty)        .def(&quot;size&quot;, &amp;Queue&lt;std::string&gt;::size);&#125;\n最佳实践\n1. 代码组织\n推荐的项目结构：\nproject/├── src/│   ├── mymodule/│   │   ├── core/│   │   │   ├── algorithm.cpp│   │   │   ├── algorithm.h│   │   │   ├── data_structures.cpp│   │   │   └── data_structures.h│   │   └── bindings.cpp      # pybind11绑定代码│   └── CMakeLists.txt├── tests/│   ├── test_basic.py│   └── test_advanced.py├── setup.py├── CMakeLists.txt└── README.md\n2. 性能优化\n编译优化：\n# 使用最高优化级别c++ -O3 -Wall -shared -std=c++17 -fPIC ...# 使用链接时间优化（LTO）c++ -O3 -flto -Wall -shared -std=c++17 -fPIC ...\n内存管理：\n// 使用智能指针#include &lt;memory&gt;class MyClass &#123;    // ...&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;MyClass, std::shared_ptr&lt;MyClass&gt;&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;&gt;())        // ...        ;&#125;\n3. 错误处理\n#include &lt;pybind11/pybind11.h&gt;#include &lt;stdexcept&gt;namespace py = pybind11;void process_data(const std::vector&lt;int&gt;&amp; data) &#123;    if (data.empty()) &#123;        throw std::invalid_argument(&quot;数据不能为空&quot;);    &#125;        if (data.size() &gt; 1000000) &#123;        throw std::length_error(&quot;数据量过大&quot;);    &#125;        // 处理数据...&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;process_data&quot;, [](const std::vector&lt;int&gt;&amp; data) &#123;        try &#123;            process_data(data);        &#125; catch (const std::invalid_argument&amp; e) &#123;            throw py::value_error(e.what());        &#125; catch (const std::length_error&amp; e) &#123;            throw py::overflow_error(e.what());        &#125; catch (const std::exception&amp; e) &#123;            throw py::runtime_error(e.what());        &#125;    &#125;);&#125;\n4. 文档生成\n使用 doxygen 风格的注释：\n/** * @brief 计算两个数的和 *  * @param a 第一个整数 * @param b 第二个整数 * @return int 两数之和 *  * @note 这是一个简单的加法函数 * @throw std::invalid_argument 如果输入参数无效 */int add(int a, int b) &#123;    if (a &lt; 0 || b &lt; 0) &#123;        throw std::invalid_argument(&quot;输入必须是非负数&quot;);    &#125;    return a + b;&#125;\n5. 测试策略\nPython 测试示例：\nimport unittestimport exampleclass TestExampleModule(unittest.TestCase):    def test_add(self):        self.assertEqual(example.add(2, 3), 5)        self.assertEqual(example.add(-1, 1), 0)            def test_add_with_defaults(self):        self.assertEqual(example.add(5), 15)  # 5 + 10            def test_divide(self):        self.assertEqual(example.divide(10, 2), 5)                with self.assertRaises(RuntimeError):            example.divide(10, 0)if __name__ == &#x27;__main__&#x27;:    unittest.main()\n6. 版本控制\nsetup.py 版本管理：\nsetup(    name=&quot;mypackage&quot;,    version=&quot;1.2.3&quot;,    author=&quot;Your Name&quot;,    author_email=&quot;your.email@example.com&quot;,    description=&quot;A pybind11 example package&quot;,    long_description=open(&quot;README.md&quot;).read(),    long_description_content_type=&quot;text/markdown&quot;,    url=&quot;https://github.com/yourusername/mypackage&quot;,    ext_modules=ext_modules,    classifiers=[        &quot;Programming Language :: C++&quot;,        &quot;Programming Language :: Python :: 3&quot;,        &quot;License :: OSI Approved :: MIT License&quot;,        &quot;Operating System :: OS Independent&quot;,    ],    python_requires=&#x27;&gt;=3.6&#x27;,)\n常见问题\n1. 编译错误\n问题： fatal error: pybind11/pybind11.h: No such file or directory\n解决方案：\n# 检查pybind11是否正确安装python -m pybind11 --includes# 如果使用源码安装，指定头文件路径c++ -I/path/to/pybind11/include ...\n2. 链接错误\n问题： 找不到 Python 库\n解决方案：\n# Linux/macOSc++ ... $(python3-config --ldflags)# Windowscl ... /link /LIBPATH:C:\\Python\\libs python39.lib\n3. 类型转换问题\n问题： Python 和 C++ 之间的类型不匹配\n解决方案：\n// 使用显式类型转换py::object result = some_python_function();int value = result.cast&lt;int&gt;();// 或者使用安全转换if (py::isinstance&lt;py::int_&gt;(result)) &#123;    int value = result.cast&lt;int&gt;();&#125; else &#123;    throw std::runtime_error(&quot;类型不匹配&quot;);&#125;\n4. GIL 管理\n问题： 在多线程环境中的性能问题\n解决方案：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/functional.h&gt;#include &lt;thread&gt;namespace py = pybind11;void long_running_task() &#123;    // 释放GIL    py::gil_scoped_release release;        // 执行长时间任务    for (int i = 0; i &lt; 1000000000; i++) &#123;        // ...    &#125;        // GIL会在release对象析构时自动重新获取&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;long_running_task&quot;, &amp;long_running_task);&#125;\n5. 内存泄漏\n问题： Python 对象没有被正确释放\n解决方案：\n// 使用智能指针#include &lt;memory&gt;class MyClass &#123;    // ...&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;MyClass, std::shared_ptr&lt;MyClass&gt;&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;&gt;())        // ...        ;&#125;\npybind11 使用指南 - 官方文档补充内容\n目录\n\n\n高级类特性\n\n\n构建系统详解\n\n\n返回值策略\n\n\n智能指针\n\n\n类型转换\n\n\n嵌入 Python 解释器\n\n\n多线程与 GIL 管理\n\n\n子解释器\n\n\n自定义类型转换\n\n\n其他高级特性\n\n\n高级类特性\n1. 动态属性\n默认情况下，C++ 类在 Python 中不支持动态添加属性。要启用此功能，需要使用py::dynamic_attr标签：\n#include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;class Pet &#123;public:    Pet(const std::string&amp; name) : name(name) &#123;&#125;        std::string get_name() const &#123; return name; &#125;    void set_name(const std::string&amp; new_name) &#123; name = new_name; &#125;private:    std::string name;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Pet&gt;(m, &quot;Pet&quot;, py::dynamic_attr())        .def(py::init&lt;const std::string&amp;&gt;())        .def(&quot;get_name&quot;, &amp;Pet::get_name)        .def(&quot;set_name&quot;, &amp;Pet::set_name)        .def_readwrite(&quot;name&quot;, &amp;Pet::name);&#125;\nPython 使用：\nimport examplep = example.Pet(&quot;小狗&quot;)p.age = 2  # 动态添加属性p.color = &quot;棕色&quot;  # 动态添加属性print(p.name)   # 输出：小狗print(p.age)    # 输出：2print(p.color)  # 输出：棕色\n2. 继承与自动向下转型\n对于多态类（含有虚函数），pybind11 会自动进行向下转型：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;namespace py = pybind11;class Animal &#123;public:    virtual ~Animal() = default;    virtual std::string speak() const = 0;&#125;;class Dog : public Animal &#123;public:    std::string speak() const override &#123;        return &quot;汪汪！&quot;;    &#125;&#125;;class Cat : public Animal &#123;public:    std::string speak() const override &#123;        return &quot;喵喵！&quot;;    &#125;&#125;;// 返回基类指针Animal* create_animal(const std::string&amp; type) &#123;    if (type == &quot;dog&quot;) return new Dog();    if (type == &quot;cat&quot;) return new Cat();    throw std::invalid_argument(&quot;未知动物类型&quot;);&#125;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Animal&gt;(m, &quot;Animal&quot;)        .def(&quot;speak&quot;, &amp;Animal::speak);        py::class_&lt;Dog, Animal&gt;(m, &quot;Dog&quot;)        .def(py::init&lt;&gt;());        py::class_&lt;Cat, Animal&gt;(m, &quot;Cat&quot;)        .def(py::init&lt;&gt;());        m.def(&quot;create_animal&quot;, &amp;create_animal,           py::return_value_policy::take_ownership);&#125;\nPython 使用：\nimport exampleanimal = example.create_animal(&quot;dog&quot;)print(type(animal))  # 输出：&lt;class &#x27;example.Dog&#x27;&gt;（自动向下转型）print(animal.speak())  # 输出：汪汪！\n3. 运算符重载\n使用pybind11/operators.h头文件支持运算符重载：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/operators.h&gt;namespace py = pybind11;class Vector2 &#123;public:    float x, y;        Vector2(float x = 0, float y = 0) : x(x), y(y) &#123;&#125;        Vector2 operator+(const Vector2&amp; other) const &#123;        return Vector2(x + other.x, y + other.y);    &#125;        Vector2 operator*(float scalar) const &#123;        return Vector2(x * scalar, y * scalar);    &#125;        bool operator==(const Vector2&amp; other) const &#123;        return x == other.x &amp;&amp; y == other.y;    &#125;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Vector2&gt;(m, &quot;Vector2&quot;)        .def(py::init&lt;float, float&gt;())        .def_readwrite(&quot;x&quot;, &amp;Vector2::x)        .def_readwrite(&quot;y&quot;, &amp;Vector2::y)                // 运算符重载        .def(py::self + py::self)          // + 运算符        .def(py::self * float())           // * 运算符（向量 * 标量）        .def(float() * py::self)           // * 运算符（标量 * 向量）        .def(py::self == py::self);        // == 运算符&#125;\n4. 枚举类型绑定\n使用py::native_enum绑定 C++ 枚举到 Python 原生枚举：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/native_enum.h&gt;namespace py = pybind11;class Pet &#123;public:    enum class Kind &#123;        Dog,        Cat,        Bird    &#125;;        enum Attributes &#123;        None = 0,        Friendly = 1 &lt;&lt; 0,        Playful = 1 &lt;&lt; 1,        Lazy = 1 &lt;&lt; 2    &#125;;        Pet(const std::string&amp; name, Kind kind)         : name(name), kind(kind), attributes(None) &#123;&#125;        std::string name;    Kind kind;    Attributes attributes;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)        .def(py::init&lt;const std::string&amp;, Pet::Kind&gt;())        .def_readwrite(&quot;name&quot;, &amp;Pet::name)        .def_readwrite(&quot;kind&quot;, &amp;Pet::kind)        .def_readwrite(&quot;attributes&quot;, &amp;Pet::attributes);        // 绑定枚举    py::native_enum&lt;Pet::Kind&gt;(m, &quot;Kind&quot;)        .value(&quot;Dog&quot;, Pet::Kind::Dog)        .value(&quot;Cat&quot;, Pet::Kind::Cat)        .value(&quot;Bird&quot;, Pet::Kind::Bird)        .export_values()        .finalize();        py::native_enum&lt;Pet::Attributes&gt;(m, &quot;Attributes&quot;)        .value(&quot;None&quot;, Pet::Attributes::None)        .value(&quot;Friendly&quot;, Pet::Attributes::Friendly)        .value(&quot;Playful&quot;, Pet::Attributes::Playful)        .value(&quot;Lazy&quot;, Pet::Attributes::Lazy)        .export_values()        .finalize();&#125;\n构建系统详解\n1. CMake 构建\n基础 CMakeLists.txt：\ncmake_minimum_required(VERSION 3.15...3.27)project(example LANGUAGES CXX)# 查找pybind11find_package(pybind11 CONFIG REQUIRED)# 创建Python扩展模块pybind11_add_module(example example.cpp)# 安装到当前目录install(TARGETS example DESTINATION .)\n高级 CMake 配置：\ncmake_minimum_required(VERSION 3.15...3.27)project(example LANGUAGES CXX)# 设置C++标准set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED ON)set(CMAKE_CXX_EXTENSIONS OFF)# 查找Pythonfind_package(Python COMPONENTS Interpreter Development REQUIRED)# 查找pybind11find_package(pybind11 CONFIG REQUIRED)# 创建扩展模块pybind11_add_module(example     src/bindings.cpp    src/algorithm.cpp    src/data_structures.cpp)# 设置编译选项target_compile_options(example PRIVATE    -O3    -Wall    -Wextra    -Wpedantic)# 设置链接选项target_link_libraries(example PRIVATE    pybind11::module    my_custom_library)# 设置安装路径install(TARGETS example     DESTINATION $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)\n2. pyproject.toml 构建\n使用 scikit-build-core：\n[build-system]requires = [&quot;scikit-build-core&gt;=0.5&quot;, &quot;pybind11&gt;=2.11&quot;]build-backend = &quot;scikit_build_core.build&quot;[project]name = &quot;example&quot;version = &quot;0.1.0&quot;authors = [    &#123; name = &quot;Your Name&quot;, email = &quot;your.email@example.com&quot; &#125;]description = &quot;pybind11示例项目&quot;long_description = file: &quot;README.md&quot;long_description_content_type = &quot;text/markdown&quot;requires-python = &quot;&gt;=3.8&quot;\n使用 meson-python：\n[build-system]requires = [&quot;meson-python&gt;=0.12&quot;, &quot;pybind11&gt;=2.11&quot;]build-backend = &quot;mesonpy&quot;[project]name = &quot;example&quot;version = &quot;0.1.0&quot;\n3. setuptools 构建高级配置\nfrom setuptools import setup, Extensionfrom pybind11.setup_helpers import Pybind11Extension, build_extfrom pybind11 import get_cmake_dirimport glob# 并行编译def parallel_compile_test_parallel_compile(self, sources, output_dir=None, macros=None,                                          include_dirs=None, debug=0, extra_preargs=None,                                          extra_postargs=None, depends=None):    import multiprocessing    from setuptools._distutils.ccompiler import CCompiler    from setuptools._distutils import log    # 复制原始实现    original_compile = CCompiler._compile    def _compile_single(source):        return original_compile(self, source, output_dir, macros, include_dirs,                               debug, extra_preargs, extra_postargs, depends)    # 使用多进程编译    if not sources:        return    num_jobs = multiprocessing.cpu_count()    log.info(f&quot;Using &#123;num_jobs&#125; parallel jobs for compilation&quot;)        import multiprocessing.pool    pool = multiprocessing.pool.ThreadPool(num_jobs)    try:        pool.map(_compile_single, sources)    finally:        pool.close()        pool.join()# 应用并行编译补丁import setuptools._distutils.ccompilersetuptools._distutils.ccompiler.CCompiler._compile = parallel_compile_test_parallel_compile# 扩展模块ext_modules = [    Pybind11Extension(        &quot;example.core&quot;,        sorted(glob.glob(&quot;src/core/*.cpp&quot;)),        include_dirs=[&quot;src/include&quot;],        libraries=[&quot;my_custom_lib&quot;],        library_dirs=[&quot;lib&quot;],        extra_compile_args=[&quot;-O3&quot;, &quot;-std=c++17&quot;, &quot;-Wall&quot;],        extra_link_args=[&quot;-Wl,-rpath,$ORIGIN/lib&quot;],    ),    Pybind11Extension(        &quot;example.utils&quot;,        sorted(glob.glob(&quot;src/utils/*.cpp&quot;)),        include_dirs=[&quot;src/include&quot;],        extra_compile_args=[&quot;-O3&quot;, &quot;-std=c++17&quot;],    ),]setup(    name=&quot;example&quot;,    version=&quot;1.0.0&quot;,    author=&quot;Your Name&quot;,    author_email=&quot;your.email@example.com&quot;,    description=&quot;pybind11示例项目&quot;,    long_description=open(&quot;README.md&quot;).read(),    long_description_content_type=&quot;text/markdown&quot;,    url=&quot;https://github.com/yourusername/example&quot;,    ext_modules=ext_modules,    cmdclass=&#123;&quot;build_ext&quot;: build_ext&#125;,    zip_safe=False,    packages=[&quot;example&quot;],    package_dir=&#123;&quot;example&quot;: &quot;python/example&quot;&#125;,    package_data=&#123;&quot;example&quot;: [&quot;py.typed&quot;]&#125;,    classifiers=[        &quot;Programming Language :: C++&quot;,        &quot;Programming Language :: Python :: 3&quot;,        &quot;License :: OSI Approved :: MIT License&quot;,        &quot;Operating System :: OS Independent&quot;,    ],    python_requires=&quot;&gt;=3.8&quot;,    install_requires=[&quot;numpy&gt;=1.21&quot;],    extras_require=&#123;        &quot;dev&quot;: [            &quot;pytest&gt;=6.0&quot;,            &quot;pytest-cov&gt;=2.0&quot;,            &quot;black&gt;=21.0&quot;,            &quot;flake8&gt;=3.9&quot;,        ]    &#125;,)\n返回值策略\n1. 策略概述\n\n\n\n策略\n描述\n\n\n\n\nreturn_value_policy::take_ownership\n接管现有对象的所有权，Python 会在引用计数为零时删除对象\n\n\nreturn_value_policy::copy\n创建返回对象的副本，由 Python 拥有\n\n\nreturn_value_policy::move\n使用 std::move 转移内容到新实例\n\n\nreturn_value_policy::reference\n引用现有对象但不接管所有权\n\n\nreturn_value_policy::reference_internal\n引用内部对象，确保父对象存活\n\n\nreturn_value_policy::automatic\n自动选择策略（默认）\n\n\nreturn_value_policy::automatic_reference\n类似 automatic，但对指针使用 reference 策略\n\n\n\n2. 使用示例\n#include &lt;pybind11/pybind11.h&gt;#include &lt;memory&gt;namespace py = pybind11;class MyClass &#123;public:    MyClass(int value) : value(value) &#123;&#125;    int get_value() const &#123; return value; &#125;    private:    int value;&#125;;// 静态对象 - 使用reference策略MyClass static_instance(42);MyClass&amp; get_static_instance() &#123;    return static_instance;&#125;// 动态分配 - 使用take_ownership策略MyClass* create_instance(int value) &#123;    return new MyClass(value);&#125;// 内部对象 - 使用reference_internal策略class Container &#123;public:    Container() : internal(100) &#123;&#125;    MyClass&amp; get_internal() &#123; return internal; &#125;    private:    MyClass internal;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;MyClass&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;int&gt;())        .def(&quot;get_value&quot;, &amp;MyClass::get_value);        py::class_&lt;Container&gt;(m, &quot;Container&quot;)        .def(py::init&lt;&gt;())        .def(&quot;get_internal&quot;, &amp;Container::get_internal,              py::return_value_policy::reference_internal);        // 静态对象 - 使用reference策略    m.def(&quot;get_static_instance&quot;, &amp;get_static_instance,           py::return_value_policy::reference);        // 动态对象 - 使用take_ownership策略    m.def(&quot;create_instance&quot;, &amp;create_instance,           py::return_value_policy::take_ownership);        // 智能指针 - 自动处理    m.def(&quot;create_shared&quot;, []() &#123;        return std::make_shared&lt;MyClass&gt;(200);    &#125;);&#125;\n3. 常见错误及解决方案\n错误示例：\n// 危险！静态对象使用默认策略会导致double freem.def(&quot;get_static&quot;, &amp;get_static_instance);  // 错误\n正确做法：\n// 正确：使用reference策略m.def(&quot;get_static&quot;, &amp;get_static_instance, py::return_value_policy::reference);\n智能指针\n1. py::smart_holder（推荐）\npybind11 v3 引入的智能持有者，支持双向转换：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;memory&gt;namespace py = pybind11;class MyClass &#123;public:    MyClass(int value) : value(value) &#123;&#125;    int get_value() const &#123; return value; &#125;    private:    int value;&#125;;PYBIND11_MODULE(example, m) &#123;    // 使用py::smart_holder    py::class_&lt;MyClass, py::smart_holder&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;int&gt;())        .def(&quot;get_value&quot;, &amp;MyClass::get_value);        // 支持unique_ptr和shared_ptr双向转换    m.def(&quot;create_unique&quot;, []() &#123;        return std::make_unique&lt;MyClass&gt;(10);    &#125;);        m.def(&quot;create_shared&quot;, []() &#123;        return std::make_shared&lt;MyClass&gt;(20);    &#125;);        m.def(&quot;process_unique&quot;, [](std::unique_ptr&lt;MyClass&gt; ptr) &#123;        return ptr-&gt;get_value() * 2;    &#125;);        m.def(&quot;process_shared&quot;, [](std::shared_ptr&lt;MyClass&gt; ptr) &#123;        return ptr-&gt;get_value() * 3;    &#125;);&#125;\nPython 使用：\nimport example# 从Python传递到C++obj = example.MyClass(5)print(example.process_unique(obj))  # 输出：10（obj不再有效）obj2 = example.MyClass(6)print(example.process_shared(obj2))  # 输出：18（obj2仍然有效）# 从C++返回unique_obj = example.create_unique()shared_obj = example.create_shared()\n2. std::unique_ptr\n#include &lt;pybind11/pybind11.h&gt;#include &lt;memory&gt;namespace py = pybind11;class MyClass &#123;public:    MyClass(int value) : value(value) &#123;&#125;    int get_value() const &#123; return value; &#125;    private:    int value;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;MyClass&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;int&gt;())        .def(&quot;get_value&quot;, &amp;MyClass::get_value);        // 返回unique_ptr    m.def(&quot;create&quot;, []() &#123;        return std::make_unique&lt;MyClass&gt;(10);    &#125;);        // 接受unique_ptr（会转移所有权）    m.def(&quot;take_ownership&quot;, [](std::unique_ptr&lt;MyClass&gt; ptr) &#123;        return ptr-&gt;get_value();    &#125;);&#125;\n3. std::shared_ptr\n#include &lt;pybind11/pybind11.h&gt;#include &lt;memory&gt;namespace py = pybind11;class MyClass &#123;public:    MyClass(int value) : value(value) &#123;&#125;    int get_value() const &#123; return value; &#125;    private:    int value;&#125;;PYBIND11_MODULE(example, m) &#123;    // 使用shared_ptr作为持有者    py::class_&lt;MyClass, std::shared_ptr&lt;MyClass&gt;&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;int&gt;())        .def(&quot;get_value&quot;, &amp;MyClass::get_value);        m.def(&quot;create&quot;, []() &#123;        return std::make_shared&lt;MyClass&gt;(10);    &#125;);        m.def(&quot;share&quot;, [](std::shared_ptr&lt;MyClass&gt; ptr) &#123;        return ptr;  // 共享所有权    &#125;);&#125;\n4. 自定义智能指针\n#include &lt;pybind11/pybind11.h&gt;#include &lt;memory&gt;namespace py = pybind11;// 自定义智能指针template &lt;typename T&gt;class MySmartPtr &#123;public:    MySmartPtr(T* ptr) : ptr(ptr) &#123;&#125;    ~MySmartPtr() &#123; delete ptr; &#125;        T* get() const &#123; return ptr; &#125;    T&amp; operator*() const &#123; return *ptr; &#125;    T* operator-&gt;() const &#123; return ptr; &#125;    private:    T* ptr;&#125;;class MyClass &#123;public:    MyClass(int value) : value(value) &#123;&#125;    int get_value() const &#123; return value; &#125;    private:    int value;&#125;;// 声明自定义持有者类型PYBIND11_DECLARE_HOLDER_TYPE(T, MySmartPtr&lt;T&gt;)// 特化holder_helper（如果需要）namespace pybind11 &#123; namespace detail &#123;    template &lt;typename T&gt;    struct holder_helper&lt;MySmartPtr&lt;T&gt;&gt; &#123;        static const T* get(const MySmartPtr&lt;T&gt;&amp; p) &#123; return p.get(); &#125;    &#125;;&#125;&#125;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;MyClass, MySmartPtr&lt;MyClass&gt;&gt;(m, &quot;MyClass&quot;)        .def(py::init&lt;int&gt;())        .def(&quot;get_value&quot;, &amp;MyClass::get_value);        m.def(&quot;create&quot;, []() &#123;        return MySmartPtr&lt;MyClass&gt;(new MyClass(10));    &#125;);&#125;\n类型转换\n1. 基础类型转换\npybind11 支持以下基础类型的自动转换：\n\n\n\nC++ 类型\nPython 类型\n\n\n\n\nbool\nbool\n\n\nchar\nstr (长度 1)\n\n\nsigned char\nint\n\n\nunsigned char\nint\n\n\nshort\nint\n\n\nunsigned short\nint\n\n\nint\nint\n\n\nunsigned int\nint\n\n\nlong\nint\n\n\nunsigned long\nint\n\n\nlong long\nint\n\n\nunsigned long long\nint\n\n\nfloat\nfloat\n\n\ndouble\nfloat\n\n\nlong double\nfloat\n\n\nconst char*\nstr\n\n\nstd::string\nstr\n\n\nstd::wstring\nstr (UTF-8)\n\n\n\n2. STL 容器转换\n需要包含pybind11/stl.h头文件：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/stl.h&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;namespace py = pybind11;// 向量转换std::vector&lt;int&gt; double_vector(const std::vector&lt;int&gt;&amp; v) &#123;    std::vector&lt;int&gt; result;    for (int x : v) &#123;        result.push_back(x * 2);    &#125;    return result;&#125;// 映射转换std::map&lt;std::string, int&gt; count_words(const std::vector&lt;std::string&gt;&amp; words) &#123;    std::map&lt;std::string, int&gt; counts;    for (const auto&amp; word : words) &#123;        counts[word]++;    &#125;    return counts;&#125;// 集合转换std::set&lt;int&gt; unique_elements(const std::vector&lt;int&gt;&amp; v) &#123;    return std::set&lt;int&gt;(v.begin(), v.end());&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;double_vector&quot;, &amp;double_vector);    m.def(&quot;count_words&quot;, &amp;count_words);    m.def(&quot;unique_elements&quot;, &amp;unique_elements);&#125;\nPython 使用：\nimport example# 向量转换print(example.double_vector([1, 2, 3, 4]))  # 输出：[2, 4, 6, 8]# 映射转换words = [&quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;]print(example.count_words(words))  # 输出：&#123;&#x27;apple&#x27;: 2, &#x27;banana&#x27;: 1, &#x27;orange&#x27;: 1&#125;# 集合转换print(example.unique_elements([1, 2, 2, 3, 3, 3]))  # 输出：&#123;1, 2, 3&#125;\n3. 字符串和字节转换\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;#include &lt;vector&gt;namespace py = pybind11;// 字符串处理std::string reverse_string(const std::string&amp; s) &#123;    return std::string(s.rbegin(), s.rend());&#125;// 字节处理std::vector&lt;uint8_t&gt; process_bytes(const std::vector&lt;uint8_t&gt;&amp; data) &#123;    std::vector&lt;uint8_t&gt; result;    for (uint8_t byte : data) &#123;        result.push_back(byte ^ 0xAA);  // 简单的XOR加密    &#125;    return result;&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;reverse_string&quot;, &amp;reverse_string);    m.def(&quot;process_bytes&quot;, &amp;process_bytes);&#125;\n4. 时间类型转换\n需要包含pybind11/chrono.h头文件：\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/chrono.h&gt;#include &lt;chrono&gt;#include &lt;ctime&gt;namespace py = pybind11;using namespace std::chrono;// 时间点转换system_clock::time_point add_seconds(system_clock::time_point tp, int seconds) &#123;    return tp + seconds(seconds);&#125;// 时间段转换seconds time_difference(system_clock::time_point start, system_clock::time_point end) &#123;    return duration_cast&lt;seconds&gt;(end - start);&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;add_seconds&quot;, &amp;add_seconds);    m.def(&quot;time_difference&quot;, &amp;time_difference);&#125;\nPython 使用：\nimport exampleimport datetime# 时间点转换now = datetime.datetime.now()later = example.add_seconds(now, 3600)  # 加1小时print(later)# 时间段转换start = datetime.datetime(2023, 1, 1)end = datetime.datetime(2023, 1, 2)diff = example.time_difference(start, end)print(diff.total_seconds())  # 输出：86400.0\n嵌入 Python 解释器\n1. 基础嵌入\nCMake 配置：\ncmake_minimum_required(VERSION 3.15...3.27)project(embedded_example LANGUAGES CXX)find_package(pybind11 CONFIG REQUIRED)add_executable(embedded_example main.cpp)target_link_libraries(embedded_example PRIVATE pybind11::embed)\nC++ 代码：\n#include &lt;pybind11/embed.h&gt;#include &lt;iostream&gt;namespace py = pybind11;int main() &#123;    // 启动Python解释器    py::scoped_interpreter guard&#123;&#125;;        try &#123;        // 执行Python代码        py::print(&quot;Hello from embedded Python!&quot;);                // 使用Python标准库        py::module math = py::module::import(&quot;math&quot;);        double result = math.attr(&quot;sqrt&quot;)(25.0).cast&lt;double&gt;();        std::cout &lt;&lt; &quot;sqrt(25) = &quot; &lt;&lt; result &lt;&lt; std::endl;                // 执行多行Python代码        py::exec(R&quot;(            import sys            print(f&quot;Python version: &#123;sys.version&#125;&quot;)                        def add(a, b):                return a + b                        result = add(3, 4)            print(f&quot;3 + 4 = &#123;result&#125;&quot;)        )&quot;);                // 调用Python函数        auto add = py::eval(&quot;add&quot;).cast&lt;py::function&gt;();        int sum_result = add(5, 6).cast&lt;int&gt;();        std::cout &lt;&lt; &quot;5 + 6 = &quot; &lt;&lt; sum_result &lt;&lt; std::endl;            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Python error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        // 解释器会在guard析构时自动关闭    return 0;&#125;\n2. 嵌入模块\n#include &lt;pybind11/embed.h&gt;#include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;// 嵌入的C++模块PYBIND11_EMBEDDED_MODULE(embedded_module, m) &#123;    m.def(&quot;multiply&quot;, [](int a, int b) &#123;        return a * b;    &#125;);        m.def(&quot;greet&quot;, [](const std::string&amp; name) &#123;        return &quot;Hello, &quot; + name + &quot;!&quot;;    &#125;);&#125;int main() &#123;    py::scoped_interpreter guard&#123;&#125;;        try &#123;        // 导入嵌入的模块        py::module em = py::module::import(&quot;embedded_module&quot;);                // 调用嵌入模块的函数        int product = em.attr(&quot;multiply&quot;)(3, 4).cast&lt;int&gt;();        std::cout &lt;&lt; &quot;3 * 4 = &quot; &lt;&lt; product &lt;&lt; std::endl;                std::string greeting = em.attr(&quot;greet&quot;)(&quot;World&quot;).cast&lt;std::string&gt;();        std::cout &lt;&lt; greeting &lt;&lt; std::endl;                // 在Python中使用嵌入模块        py::exec(R&quot;(            result = embedded_module.multiply(5, 6)            print(f&quot;5 * 6 = &#123;result&#125;&quot;)                        message = embedded_module.greet(&quot;Python&quot;)            print(message)        )&quot;);            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        return 0;&#125;\n3. 导入本地 Python 文件\n#include &lt;pybind11/embed.h&gt;#include &lt;iostream&gt;#include &lt;filesystem&gt;namespace py = pybind11;namespace fs = std::filesystem;int main() &#123;    py::scoped_interpreter guard&#123;&#125;;        try &#123;        // 添加当前目录到Python路径        py::module sys = py::module::import(&quot;sys&quot;);        sys.attr(&quot;path&quot;).cast&lt;py::list&gt;().append(fs::current_path().string());                // 导入本地Python模块        py::module my_module = py::module::import(&quot;my_python_module&quot;);                // 调用Python函数        int result = my_module.attr(&quot;my_function&quot;)(10, 20).cast&lt;int&gt;();        std::cout &lt;&lt; &quot;Result from Python: &quot; &lt;&lt; result &lt;&lt; std::endl;            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        return 0;&#125;\n多线程与 GIL 管理\n1. GIL 释放与获取\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/functional.h&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;iostream&gt;namespace py = pybind11;// 长时间运行的C++函数 - 应该释放GILvoid long_running_task() &#123;    // 释放GIL    py::gil_scoped_release release;        std::cout &lt;&lt; &quot;Long running task started (thread: &quot;               &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;        // 模拟长时间计算    for (int i = 0; i &lt; 5; ++i) &#123;        std::this_thread::sleep_for(std::chrono::seconds(1));        std::cout &lt;&lt; &quot;Task progress: &quot; &lt;&lt; (i + 1) &lt;&lt; &quot;/5&quot; &lt;&lt; std::endl;    &#125;        std::cout &lt;&lt; &quot;Long running task completed&quot; &lt;&lt; std::endl;        // GIL会在release析构时自动重新获取&#125;// 使用call_guard自动管理GILvoid task_with_guard() &#123;    std::cout &lt;&lt; &quot;Task with guard started&quot; &lt;&lt; std::endl;    std::this_thread::sleep_for(std::chrono::seconds(3));    std::cout &lt;&lt; &quot;Task with guard completed&quot; &lt;&lt; std::endl;&#125;// 多线程函数void run_in_threads() &#123;    std::thread t1(long_running_task);    std::thread t2(long_running_task);        t1.join();    t2.join();&#125;PYBIND11_MODULE(example, m) &#123;    // 直接释放GIL    m.def(&quot;long_running_task&quot;, &amp;long_running_task);        // 使用call_guard释放GIL    m.def(&quot;task_with_guard&quot;, &amp;task_with_guard,           py::call_guard&lt;py::gil_scoped_release&gt;());        // 多线程示例    m.def(&quot;run_in_threads&quot;, &amp;run_in_threads);        // 线程安全的函数调用    m.def(&quot;thread_safe_function&quot;, [](int value) &#123;        // 在关键部分获取GIL        py::gil_scoped_acquire acquire;        py::print(&quot;Thread-safe function called with value:&quot;, value);    &#125;);&#125;\nPython 使用：\nimport exampleimport threadingimport time# 测试长时间任务print(&quot;Testing long running task...&quot;)thread1 = threading.Thread(target=example.long_running_task)thread2 = threading.Thread(target=example.long_running_task)thread1.start()thread2.start()# 主线程可以继续执行其他任务for i in range(3):    print(f&quot;Main thread working... &#123;i&#125;&quot;)    time.sleep(1)thread1.join()thread2.join()# 测试带guard的任务print(&quot;Testing task with guard...&quot;)example.task_with_guard()# 测试多线程函数print(&quot;Testing run in threads...&quot;)example.run_in_threads()\n2. 线程局部存储\n#include &lt;pybind11/pybind11.h&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;iostream&gt;namespace py = pybind11;// 线程局部存储thread_local int thread_counter = 0;std::mutex cout_mutex;void thread_function(int id) &#123;    // 释放GIL    py::gil_scoped_release release;        for (int i = 0; i &lt; 5; ++i) &#123;        thread_counter++;                // 安全的输出        std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot;: counter = &quot; &lt;&lt; thread_counter &lt;&lt; std::endl;                std::this_thread::sleep_for(std::chrono::milliseconds(100));    &#125;&#125;void start_threads() &#123;    std::thread t1(thread_function, 1);    std::thread t2(thread_function, 2);        t1.join();    t2.join();&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;start_threads&quot;, &amp;start_threads);&#125;\n3. 异步任务\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/functional.h&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;iostream&gt;namespace py = pybind11;// 异步执行函数std::future&lt;int&gt; async_task(int x, int y) &#123;    return std::async(std::launch::async, [x, y]() &#123;        // 释放GIL        py::gil_scoped_release release;                std::cout &lt;&lt; &quot;Async task started (thread: &quot;                   &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;                // 模拟计算        std::this_thread::sleep_for(std::chrono::seconds(2));        return x + y;    &#125;);&#125;// 异步回调void async_callback(py::function callback, int x, int y) &#123;    std::thread([callback, x, y]() &#123;        // 释放GIL        py::gil_scoped_release release;                std::cout &lt;&lt; &quot;Callback task started&quot; &lt;&lt; std::endl;        std::this_thread::sleep_for(std::chrono::seconds(2));                // 计算结果        int result = x * y;                // 调用回调函数时重新获取GIL        py::gil_scoped_acquire acquire;        callback(result);    &#125;).detach();&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;async_task&quot;, [](int x, int y) &#123;        auto future = async_task(x, y);        return future.get();    &#125;);        m.def(&quot;async_callback&quot;, &amp;async_callback);&#125;\nPython 使用：\nimport exampleimport time# 测试异步任务print(&quot;Testing async task...&quot;)result = example.async_task(3, 4)print(f&quot;Async result: &#123;result&#125;&quot;)# 测试异步回调def on_complete(result):    print(f&quot;Callback received: &#123;result&#125;&quot;)print(&quot;Testing async callback...&quot;)example.async_callback(on_complete, 5, 6)print(&quot;Callback task started (will complete in 2 seconds)&quot;)# 等待回调完成time.sleep(3)\n子解释器\n1. 基础子解释器使用\n#include &lt;pybind11/embed.h&gt;#include &lt;pybind11/subinterpreter.h&gt;#include &lt;iostream&gt;namespace py = pybind11;int main() &#123;    // 初始化主解释器    py::scoped_interpreter main_guard&#123;&#125;;        try &#123;        std::cout &lt;&lt; &quot;Main interpreter started&quot; &lt;&lt; std::endl;                // 创建子解释器        py::subinterpreter sub = py::subinterpreter::create();                &#123;            // 激活子解释器            py::subinterpreter_scoped_activate activate(sub);                        std::cout &lt;&lt; &quot;Sub-interpreter activated&quot; &lt;&lt; std::endl;                        // 在子解释器中执行代码            py::exec(R&quot;(                import sys                print(f&quot;Sub-interpreter Python version: &#123;sys.version&#125;&quot;)                counter = 42            )&quot;);                        // 获取变量值            int counter = py::eval(&quot;counter&quot;).cast&lt;int&gt;();            std::cout &lt;&lt; &quot;Sub-interpreter counter: &quot; &lt;&lt; counter &lt;&lt; std::endl;        &#125;                std::cout &lt;&lt; &quot;Sub-interpreter deactivated&quot; &lt;&lt; std::endl;                // 主解释器不受影响        py::exec(&quot;print(&#x27;Back to main interpreter&#x27;)&quot;);            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        return 0;&#125;\n2. 多线程子解释器\n#include &lt;pybind11/embed.h&gt;#include &lt;pybind11/subinterpreter.h&gt;#include &lt;thread&gt;#include &lt;iostream&gt;namespace py = pybind11;void run_in_subinterpreter(py::subinterpreter sub, int id) &#123;    try &#123;        // 激活子解释器        py::subinterpreter_scoped_activate activate(sub);                std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; started in sub-interpreter&quot; &lt;&lt; std::endl;                // 执行Python代码        py::exec(R&quot;(            import time            import threading                        def task():                for i in range(3):                    print(f&quot;Task &#123;id&#125; iteration &#123;i&#125; (thread: &#123;threading.get_ident()&#125;)&quot;)                    time.sleep(1)                        task()        )&quot;);                std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; completed&quot; &lt;&lt; std::endl;            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    py::scoped_interpreter main_guard&#123;&#125;;        try &#123;        // 创建多个子解释器        py::subinterpreter sub1 = py::subinterpreter::create();        py::subinterpreter sub2 = py::subinterpreter::create();                // 在不同线程中运行子解释器        std::thread t1(run_in_subinterpreter, std::move(sub1), 1);        std::thread t2(run_in_subinterpreter, std::move(sub2), 2);                t1.join();        t2.join();            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Main error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;        return 1;    &#125;        return 0;&#125;\n3. 子解释器安全最佳实践\n#include &lt;pybind11/embed.h&gt;#include &lt;pybind11/subinterpreter.h&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;iostream&gt;namespace py = pybind11;// 线程安全的子解释器管理器class SubinterpreterManager &#123;public:    SubinterpreterManager() : main_guard_&#123;&#125; &#123;&#125;        py::subinterpreter create_subinterpreter() &#123;        std::lock_guard&lt;std::mutex&gt; lock(mutex_);        return py::subinterpreter::create();    &#125;    private:    py::scoped_interpreter main_guard_;    std::mutex mutex_;&#125;;// 安全的任务函数void safe_task(py::subinterpreter sub, const std::string&amp; name) &#123;    try &#123;        // 子解释器作用域        py::subinterpreter_scoped_activate activate(sub);                // 任务逻辑        py::exec(R&quot;(            import time                        def safe_operation(name):                result = []                for i in range(5):                    result.append(f&quot;&#123;name&#125;: &#123;i&#125;&quot;)                    time.sleep(0.1)                return result                        result = safe_operation(name)            print(f&quot;Task &#123;name&#125; completed with &#123;len(result)&#125; items&quot;)        )&quot;);            &#125; catch (const py::error_already_set&amp; e) &#123;        std::cerr &lt;&lt; &quot;Task &quot; &lt;&lt; name &lt;&lt; &quot; failed: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;int main() &#123;    SubinterpreterManager manager;        // 创建并运行多个子解释器任务    std::vector&lt;std::thread&gt; threads;    for (int i = 0; i &lt; 3; ++i) &#123;        py::subinterpreter sub = manager.create_subinterpreter();        threads.emplace_back(safe_task, std::move(sub), &quot;task_&quot; + std::to_string(i));    &#125;        // 等待所有线程完成    for (auto&amp; t : threads) &#123;        t.join();    &#125;        return 0;&#125;\n自定义类型转换\n1. 基础自定义转换器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;#include &lt;sstream&gt;namespace py = pybind11;// 自定义类型struct Point &#123;    int x;    int y;        Point(int x = 0, int y = 0) : x(x), y(y) &#123;&#125;        std::string to_string() const &#123;        std::stringstream ss;        ss &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot;;        return ss.str();    &#125;&#125;;// 自定义类型转换器namespace pybind11 &#123; namespace detail &#123;    template &lt;&gt; struct type_caster&lt;Point&gt; &#123;    public:        PYBIND11_TYPE_CASTER(Point, _(&quot;Point&quot;));                // 从Python对象转换到C++        bool load(handle src, bool) &#123;            if (!src.is_dict()) return false;                        py::dict obj = src.cast&lt;py::dict&gt;();            value.x = obj[&quot;x&quot;].cast&lt;int&gt;();            value.y = obj[&quot;y&quot;].cast&lt;int&gt;();            return true;        &#125;                // 从C++转换到Python对象        static handle cast(const Point&amp; p, return_value_policy /* policy */, handle /* parent */) &#123;            py::dict obj;            obj[&quot;x&quot;] = p.x;            obj[&quot;y&quot;] = p.y;            return obj.release();        &#125;    &#125;;&#125;&#125;PYBIND11_MODULE(example, m) &#123;    // 使用自定义转换器    m.def(&quot;add_points&quot;, [](const Point&amp; a, const Point&amp; b) &#123;        return Point(a.x + b.x, a.y + b.y);    &#125;);        m.def(&quot;print_point&quot;, [](const Point&amp; p) &#123;        py::print(p.to_string());    &#125;);&#125;\nPython 使用：\nimport example# 创建Point对象（通过字典）p1 = &#123;&quot;x&quot;: 1, &quot;y&quot;: 2&#125;p2 = &#123;&quot;x&quot;: 3, &quot;y&quot;: 4&#125;# 使用自定义转换result = example.add_points(p1, p2)print(result)  # 输出：&#123;&#x27;x&#x27;: 4, &#x27;y&#x27;: 6&#125;example.print_point(result)  # 输出：(4, 6)\n2. 支持多种 Python 类型的转换器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/stl.h&gt;#include &lt;string&gt;#include &lt;vector&gt;namespace py = pybind11;struct Rectangle &#123;    int x, y, width, height;        Rectangle(int x=0, int y=0, int w=0, int h=0)         : x(x), y(y), width(w), height(h) &#123;&#125;        int area() const &#123; return width * height; &#125;&#125;;namespace pybind11 &#123; namespace detail &#123;    template &lt;&gt; struct type_caster&lt;Rectangle&gt; &#123;    public:        PYBIND11_TYPE_CASTER(Rectangle, _(&quot;Rectangle&quot;));                bool load(handle src, bool) &#123;            // 支持字典            if (src.is_dict()) &#123;                py::dict obj = src.cast&lt;py::dict&gt;();                value.x = obj[&quot;x&quot;].cast&lt;int&gt;();                value.y = obj[&quot;y&quot;].cast&lt;int&gt;();                value.width = obj[&quot;width&quot;].cast&lt;int&gt;();                value.height = obj[&quot;height&quot;].cast&lt;int&gt;();                return true;            &#125;            // 支持元组            else if (src.is_tuple()) &#123;                py::tuple obj = src.cast&lt;py::tuple&gt;();                if (obj.size() != 4) return false;                value.x = obj[0].cast&lt;int&gt;();                value.y = obj[1].cast&lt;int&gt;();                value.width = obj[2].cast&lt;int&gt;();                value.height = obj[3].cast&lt;int&gt;();                return true;            &#125;            // 支持列表            else if (src.is_list()) &#123;                py::list obj = src.cast&lt;py::list&gt;();                if (obj.size() != 4) return false;                value.x = obj[0].cast&lt;int&gt;();                value.y = obj[1].cast&lt;int&gt;();                value.width = obj[2].cast&lt;int&gt;();                value.height = obj[3].cast&lt;int&gt;();                return true;            &#125;                        return false;        &#125;                static handle cast(const Rectangle&amp; r, return_value_policy /* policy */, handle /* parent */) &#123;            py::dict obj;            obj[&quot;x&quot;] = r.x;            obj[&quot;y&quot;] = r.y;            obj[&quot;width&quot;] = r.width;            obj[&quot;height&quot;] = r.height;            obj[&quot;area&quot;] = r.area();            return obj.release();        &#125;    &#125;;&#125;&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;rectangle_area&quot;, [](const Rectangle&amp; r) &#123;        return r.area();    &#125;);        m.def(&quot;expand_rectangle&quot;, [](const Rectangle&amp; r, int amount) &#123;        return Rectangle(            r.x - amount,            r.y - amount,            r.width + 2 * amount,            r.height + 2 * amount        );    &#125;);&#125;\nPython 使用：\nimport example# 支持多种输入类型rect1 = &#123;&quot;x&quot;: 0, &quot;y&quot;: 0, &quot;width&quot;: 10, &quot;height&quot;: 20&#125;rect2 = (10, 10, 5, 5)rect3 = [20, 20, 8, 8]print(example.rectangle_area(rect1))  # 输出：200print(example.rectangle_area(rect2))  # 输出：25print(example.rectangle_area(rect3))  # 输出：64# 扩展矩形expanded = example.expand_rectangle(rect1, 2)print(expanded)# 输出：&#123;&#x27;x&#x27;: -2, &#x27;y&#x27;: -2, &#x27;width&#x27;: 14, &#x27;height&#x27;: 24, &#x27;area&#x27;: 336&#125;\n3. 继承类型的转换器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;#include &lt;memory&gt;namespace py = pybind11;// 基类struct Shape &#123;    virtual ~Shape() = default;    virtual std::string name() const = 0;    virtual double area() const = 0;&#125;;// 派生类struct Circle : public Shape &#123;    double radius;        Circle(double r) : radius(r) &#123;&#125;        std::string name() const override &#123; return &quot;Circle&quot;; &#125;    double area() const override &#123; return 3.14159 * radius * radius; &#125;&#125;;struct Square : public Shape &#123;    double side;        Square(double s) : side(s) &#123;&#125;        std::string name() const override &#123; return &quot;Square&quot;; &#125;    double area() const override &#123; return side * side; &#125;&#125;;// 基类转换器namespace pybind11 &#123; namespace detail &#123;    template &lt;&gt; struct type_caster&lt;std::shared_ptr&lt;Shape&gt;&gt; &#123;    public:        PYBIND11_TYPE_CASTER(std::shared_ptr&lt;Shape&gt;, _(&quot;Shape&quot;));                bool load(handle src, bool) &#123;            if (!src.is_dict()) return false;                        py::dict obj = src.cast&lt;py::dict&gt;();            std::string type = obj[&quot;type&quot;].cast&lt;std::string&gt;();                        if (type == &quot;circle&quot;) &#123;                double radius = obj[&quot;radius&quot;].cast&lt;double&gt;();                value = std::make_shared&lt;Circle&gt;(radius);            &#125; else if (type == &quot;square&quot;) &#123;                double side = obj[&quot;side&quot;].cast&lt;double&gt;();                value = std::make_shared&lt;Square&gt;(side);            &#125; else &#123;                return false;            &#125;                        return true;        &#125;                static handle cast(const std::shared_ptr&lt;Shape&gt;&amp; shape,                           return_value_policy /* policy */, handle /* parent */) &#123;            py::dict obj;                        if (auto circle = std::dynamic_pointer_cast&lt;Circle&gt;(shape)) &#123;                obj[&quot;type&quot;] = &quot;circle&quot;;                obj[&quot;radius&quot;] = circle-&gt;radius;            &#125; else if (auto square = std::dynamic_pointer_cast&lt;Square&gt;(shape)) &#123;                obj[&quot;type&quot;] = &quot;square&quot;;                obj[&quot;side&quot;] = square-&gt;side;            &#125;                        obj[&quot;name&quot;] = shape-&gt;name();            obj[&quot;area&quot;] = shape-&gt;area();                        return obj.release();        &#125;    &#125;;&#125;&#125;PYBIND11_MODULE(example, m) &#123;    m.def(&quot;shape_info&quot;, [](const std::shared_ptr&lt;Shape&gt;&amp; shape) &#123;        return py::make_tuple(shape-&gt;name(), shape-&gt;area());    &#125;);        m.def(&quot;create_shape&quot;, [](const std::string&amp; type, double param) &#123;        if (type == &quot;circle&quot;) &#123;            return std::make_shared&lt;Circle&gt;(param);        &#125; else if (type == &quot;square&quot;) &#123;            return std::make_shared&lt;Square&gt;(param);        &#125;        throw std::invalid_argument(&quot;Unknown shape type&quot;);    &#125;);&#125;\n其他高级特性\n1. 属性装饰器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;string&gt;namespace py = pybind11;class Person &#123;public:    Person(const std::string&amp; name, int age)         : name(name), age(age) &#123;&#125;        std::string get_name() const &#123; return name; &#125;    void set_name(const std::string&amp; new_name) &#123; name = new_name; &#125;        int get_age() const &#123; return age; &#125;    void set_age(int new_age) &#123;         if (new_age &lt; 0) throw std::invalid_argument(&quot;年龄不能为负数&quot;);        age = new_age;    &#125;        std::string get_full_info() const &#123;        return name + &quot;, &quot; + std::to_string(age) + &quot;岁&quot;;    &#125;    private:    std::string name;    int age;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Person&gt;(m, &quot;Person&quot;)        .def(py::init&lt;const std::string&amp;, int&gt;())                // 可读可写属性        .def_property(&quot;name&quot;, &amp;Person::get_name, &amp;Person::set_name)                // 带验证的属性        .def_property(&quot;age&quot;, &amp;Person::get_age, &amp;Person::set_age)                // 只读属性        .def_property_readonly(&quot;full_info&quot;, &amp;Person::get_full_info)                // 静态属性        .def_readwrite_static(&quot;species&quot;, []() &#123; return &quot;人类&quot;; &#125;);&#125;\n2. 方法装饰器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/functional.h&gt;#include &lt;string&gt;#include &lt;chrono&gt;namespace py = pybind11;// 计时装饰器template &lt;typename Func&gt;auto timing_decorator(Func&amp;&amp; func) &#123;    return [func = std::forward&lt;Func&gt;(func)](auto&amp;&amp;... args) &#123;        auto start = std::chrono::high_resolution_clock::now();                auto result = func(std::forward&lt;decltype(args)&gt;(args)...);                auto end = std::chrono::high_resolution_clock::now();        auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(            end - start        );                py::print(&quot;函数执行时间:&quot;, duration.count(), &quot;微秒&quot;);        return result;    &#125;;&#125;// 缓存装饰器template &lt;typename Func&gt;auto cache_decorator(Func&amp;&amp; func) &#123;    std::unordered_map&lt;std::string, py::object&gt; cache;        return [func = std::forward&lt;Func&gt;(func), cache = std::move(cache)](        const std::string&amp; key, auto&amp;&amp;... args    ) mutable &#123;        if (cache.find(key) != cache.end()) &#123;            py::print(&quot;缓存命中:&quot;, key);            return cache[key];        &#125;                py::object result = func(key, std::forward&lt;decltype(args)&gt;(args)...);        cache[key] = result;        py::print(&quot;缓存未命中，计算结果:&quot;, key);        return result;    &#125;;&#125;PYBIND11_MODULE(example, m) &#123;    // 原始函数    auto expensive_function = [](const std::string&amp; data) &#123;        // 模拟耗时计算        std::this_thread::sleep_for(std::chrono::milliseconds(100));        return &quot;处理结果: &quot; + data;    &#125;;        // 使用装饰器    m.def(&quot;process_data&quot;, timing_decorator(expensive_function));    m.def(&quot;cached_process&quot;, cache_decorator(expensive_function));&#125;\n3. 自定义异常\n#include &lt;pybind11/pybind11.h&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;namespace py = pybind11;// 自定义异常类型class ValidationError : public std::runtime_error &#123;public:    ValidationError(const std::string&amp; message)         : std::runtime_error(message) &#123;&#125;&#125;;class DatabaseError : public std::runtime_error &#123;public:    DatabaseError(const std::string&amp; message, int code)         : std::runtime_error(message), error_code(code) &#123;&#125;        int get_code() const &#123; return error_code; &#125;    private:    int error_code;&#125;;PYBIND11_MODULE(example, m) &#123;    // 绑定自定义异常    auto validation_error = py::register_exception&lt;ValidationError&gt;(m, &quot;ValidationError&quot;);    auto db_error = py::register_exception&lt;DatabaseError&gt;(m, &quot;DatabaseError&quot;);        // 为异常添加额外方法    db_error.def(&quot;get_code&quot;, &amp;DatabaseError::get_code);        // 使用自定义异常的函数    m.def(&quot;validate_age&quot;, [](int age) &#123;        if (age &lt; 0) &#123;            throw ValidationError(&quot;年龄不能为负数&quot;);        &#125;        if (age &gt; 150) &#123;            throw ValidationError(&quot;年龄不能超过150&quot;);        &#125;    &#125;);        m.def(&quot;connect_to_db&quot;, [](const std::string&amp; host) &#123;        if (host.empty()) &#123;            throw DatabaseError(&quot;数据库主机不能为空&quot;, 1001);        &#125;        if (host != &quot;localhost&quot;) &#123;            throw DatabaseError(&quot;连接失败: 未知主机&quot;, 1002);        &#125;        return &quot;连接成功&quot;;    &#125;);&#125;\nPython 使用：\nimport exampletry:    example.validate_age(-5)except example.ValidationError as e:    print(f&quot;验证错误: &#123;e&#125;&quot;)try:    example.connect_to_db(&quot;invalid_host&quot;)except example.DatabaseError as e:    print(f&quot;数据库错误: &#123;e&#125;, 错误码: &#123;e.get_code()&#125;&quot;)\n4. 上下文管理器\n#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/functional.h&gt;#include &lt;iostream&gt;#include &lt;chrono&gt;namespace py = pybind11;class Timer &#123;public:    Timer() : start_time(std::chrono::high_resolution_clock::now()) &#123;        std::cout &lt;&lt; &quot;计时器开始&quot; &lt;&lt; std::endl;    &#125;        ~Timer() &#123;        auto end_time = std::chrono::high_resolution_clock::now();        auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(            end_time - start_time        );        std::cout &lt;&lt; &quot;计时器结束，耗时: &quot; &lt;&lt; duration.count() &lt;&lt; &quot;毫秒&quot; &lt;&lt; std::endl;    &#125;        void reset() &#123;        start_time = std::chrono::high_resolution_clock::now();        std::cout &lt;&lt; &quot;计时器重置&quot; &lt;&lt; std::endl;    &#125;    private:    std::chrono::high_resolution_clock::time_point start_time;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;Timer&gt;(m, &quot;Timer&quot;)        .def(py::init&lt;&gt;())        .def(&quot;reset&quot;, &amp;Timer::reset)                // 实现上下文管理器接口        .def(&quot;__enter__&quot;, [](Timer&amp; self) &#123;            return &amp;self;        &#125;)        .def(&quot;__exit__&quot;, [](Timer&amp; self, py::object type, py::object value, py::object traceback) &#123;            // __exit__方法的返回值表示是否处理异常            return py::none();        &#125;);&#125;\nPython 使用：\nimport exampleimport time# 使用上下文管理器with example.Timer() as timer:    time.sleep(1)    timer.reset()    time.sleep(0.5)# 输出：# 计时器开始# 计时器重置# 计时器结束，耗时: 500毫秒\n5. 迭代器支持\n#include &lt;pybind11/pybind11.h&gt;#include &lt;vector&gt;#include &lt;string&gt;namespace py = pybind11;class NumberSequence &#123;public:    NumberSequence(int start, int end)         : start_(start), end_(end), current_(start) &#123;&#125;        // 迭代器接口    int next() &#123;        if (current_ &gt; end_) &#123;            throw py::stop_iteration();        &#125;        return current_++;    &#125;        // 重置迭代器    void reset() &#123;        current_ = start_;    &#125;    private:    int start_;    int end_;    int current_;&#125;;PYBIND11_MODULE(example, m) &#123;    py::class_&lt;NumberSequence&gt;(m, &quot;NumberSequence&quot;)        .def(py::init&lt;int, int&gt;())        .def(&quot;reset&quot;, &amp;NumberSequence::reset)                // 实现迭代器协议        .def(&quot;__iter__&quot;, [](NumberSequence&amp; self) &#123;            self.reset();            return &amp;self;        &#125;)        .def(&quot;__next__&quot;, &amp;NumberSequence::next);        // 范围迭代器示例    m.def(&quot;range_generator&quot;, [](int n) &#123;        return py::make_iterator(range(0, n).begin(), range(0, n).end());    &#125;, py::keep_alive&lt;0, 1&gt;());&#125;\nPython 使用：\nimport example# 使用自定义迭代器seq = example.NumberSequence(1, 5)for num in seq:    print(num)  # 输出：1, 2, 3, 4, 5# 使用范围生成器for i in example.range_generator(3):    print(i)  # 输出：0, 1, 2\n总结\n本补充指南涵盖了 pybind11 官方文档中的所有重要高级特性：\n核心要点\n\n\n高级类特性：动态属性、继承与多态、运算符重载、枚举绑定\n\n\n构建系统：CMake、pyproject.toml、setuptools 的高级配置\n\n\n内存管理：返回值策略、智能指针（smart_holder、unique_ptr、shared_ptr）\n\n\n类型系统：基础类型转换、STL 容器、自定义类型转换器\n\n\n嵌入与扩展：Python 解释器嵌入、子解释器、多线程 GIL 管理\n\n\n高级功能：属性装饰器、方法装饰器、自定义异常、上下文管理器、迭代器\n\n\n最佳实践\n\n\n内存安全：正确使用返回值策略，优先使用 smart_holder\n\n\n性能优化：合理释放 GIL，使用多线程和异步任务\n\n\n类型安全：使用强类型转换，避免隐式转换错误\n\n\n代码组织：模块化设计，分离实现和绑定代码\n\n\n错误处理：使用自定义异常，提供详细的错误信息\n\n\n进阶学习\n\n\n性能调优：使用 LTO 优化、缓存机制、异步编程\n\n\n调试技巧：GDB 调试、Python 调试器集成\n\n\n测试策略：单元测试、集成测试、性能测试\n\n\n部署方案：wheel 打包、conda 包、Docker 容器化\n\n\npybind11 为 C++ 和 Python 的无缝集成提供了强大的支持，掌握这些高级特性将帮助您开发出更加高效、健壮的跨语言应用程序。\nDate: October 16, 2025\nCode: https://github.com/pybind/pybind11\n总结\npybind11 是一个强大而灵活的工具，它让 C++ 和 Python 之间的互操作变得简单高效。通过本指南，你应该已经掌握了：\n\n\n基础概念：pybind11 的核心功能和优势\n\n\n安装配置：如何在不同平台上安装和配置 pybind11\n\n\n函数绑定：将 C++ 函数暴露给 Python 的各种方法\n\n\n类绑定：将 C++ 类及其方法、属性暴露给 Python\n\n\n高级特性：STL 容器支持、NumPy 集成、运算符重载等\n\n\n实际应用：性能优化、错误处理、测试策略等最佳实践\n\n\n进一步学习资源\n\n\n官方文档：https://pybind11.readthedocs.io/\n\n\nGitHub 仓库：https://github.com/pybind/pybind11\n\n\n示例项目：\n\n\nhttps://github.com/pybind/python_example\n\n\nhttps://github.com/pybind/cmake_example\n\n\n推荐书籍\n\n\n《Python Cookbook》（第 3 版）- David Beazley\n\n\n《C++ Concurrency in Action》- Anthony Williams\n\n\n《Effective Modern C++》- Scott Meyers\n\n\npybind11 为 C++ 和 Python 开发者提供了一个强大的桥梁，合理使用可以充分发挥两种语言的优势，开发出高性能、易维护的应用程序。\nDate: October 16, 2025\nCode: https://github.com/pybind/pybind11\n","categories":["编程"],"tags":["python","C++"]},{"title":"Vue基本组件","url":"/2025/09/09/web/Vue.js%20%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E6%95%B4%E7%90%86/","content":"\n如题，结合官方文档与网络帖子，利用AI整理\n\n\nVue.js 基本组件属性与方法讲解\n目录\n\n\n1. Button 按钮\n\n\n2. Input 输入框\n\n\n3. Form 表单\n\n\n4. Table 表格\n\n\n5. Checkbox 复选框\n\n\n6. Radio 单选框\n\n\n7. Select 下拉选择器\n\n\n8. 组件通信\n\n\n\n1. Button 按钮\n主要属性\n\n\n\n属性名\n类型\n默认值\n说明\n\n\n\n\ntype\nString\n‘button’\n按钮类型，可选值：‘button’、‘submit’、‘reset’\n\n\nvariant\nString\n‘primary’\n按钮样式变体，可选值：‘primary’、‘secondary’、‘danger’、‘success’\n\n\nsize\nString\n‘medium’\n按钮尺寸，可选值：‘small’、‘medium’、‘large’\n\n\ndisabled\nBoolean\nfalse\n是否禁用按钮\n\n\nloading\nBoolean\nfalse\n是否显示加载状态\n\n\ntext\nString\n‘按钮’\n按钮文本内容\n\n\nicon\nString\n-\n按钮图标\n\n\n\n主要方法\n\n\n\n方法名\n参数\n说明\n\n\n\n\nhandleClick\n-\n点击事件处理函数\n\n\nhandleSubmit\n-\n提交事件处理函数（仅当type为’submit’时有效）\n\n\n\n事件\n\n\nclick: 点击事件\n\n\nsubmit: 提交事件\n\n\n使用示例\n&lt;template&gt;  &lt;div&gt;    &lt;BaseButton       variant=&quot;primary&quot;      size=&quot;large&quot;      :loading=&quot;isLoading&quot;      @click=&quot;handleClick&quot;    &gt;      提交    &lt;/BaseButton&gt;        &lt;BaseButton       variant=&quot;danger&quot;      :disabled=&quot;!canDelete&quot;      @click=&quot;handleDelete&quot;    &gt;      删除    &lt;/BaseButton&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      isLoading: false,      canDelete: true    &#125;  &#125;,  methods: &#123;    handleClick() &#123;      this.isLoading = true      // 处理逻辑      setTimeout(() =&gt; &#123;        this.isLoading = false      &#125;, 2000)    &#125;,    handleDelete() &#123;      if (confirm(&#x27;确定要删除吗？&#x27;)) &#123;        // 删除逻辑      &#125;    &#125;  &#125;&#125;&lt;/script&gt;\n\n2. Input 输入框\n主要属性\n\n\n\n属性名\n类型\n默认值\n说明\n\n\n\n\nmodelValue\nString/Number\n‘’\n绑定值（v-model）\n\n\ntype\nString\n‘text’\n输入框类型\n\n\nlabel\nString\n‘’\n标签文本\n\n\nplaceholder\nString\n‘’\n占位文本\n\n\ndisabled\nBoolean\nfalse\n是否禁用\n\n\nreadonly\nBoolean\nfalse\n是否只读\n\n\nrequired\nBoolean\nfalse\n是否必填\n\n\nmaxlength\nNumber\n-\n最大输入长度\n\n\nminlength\nNumber\n-\n最小输入长度\n\n\npattern\nRegExp\n-\n正则表达式验证\n\n\nerrorMessage\nString\n‘’\n错误提示信息\n\n\n\n主要方法\n\n\n\n方法名\n参数\n说明\n\n\n\n\nhandleInput\nevent\n输入事件处理\n\n\nhandleFocus\n-\n获得焦点事件\n\n\nhandleBlur\n-\n失去焦点事件\n\n\nvalidate\n-\n验证输入内容\n\n\n\n事件\n\n\ninput: 输入事件\n\n\nfocus: 获得焦点事件\n\n\nblur: 失去焦点事件\n\n\nvalidate: 验证事件\n\n\n使用示例\n&lt;template&gt;  &lt;div&gt;    &lt;BaseInput      v-model=&quot;username&quot;      label=&quot;用户名&quot;      placeholder=&quot;请输入用户名&quot;      required      :pattern=&quot;/^[a-zA-Z0-9_]&#123;4,16&#125;$/&quot;      @validate=&quot;handleValidate&quot;    /&gt;        &lt;BaseInput      v-model=&quot;password&quot;      type=&quot;password&quot;      label=&quot;密码&quot;      placeholder=&quot;请输入密码&quot;      required      :errorMessage=&quot;passwordError&quot;    /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      username: &#x27;&#x27;,      password: &#x27;&#x27;,      passwordError: &#x27;&#x27;    &#125;  &#125;,  methods: &#123;    handleValidate(isValid) &#123;      console.log(&#x27;用户名验证结果:&#x27;, isValid)    &#125;  &#125;&#125;&lt;/script&gt;\n\n3. Form 表单\n主要属性\n\n\n\n属性名\n类型\n默认值\n说明\n\n\n\n\nmodel\nObject\n{}\n表单数据对象\n\n\nrules\nObject\n{}\n验证规则\n\n\nsubmitText\nString\n‘提交’\n提交按钮文本\n\n\nlabelWidth\nString/Number\n‘120px’\n标签宽度\n\n\ninline\nBoolean\nfalse\n是否行内表单\n\n\n\n主要方法\n\n\n\n方法名\n参数\n说明\n\n\n\n\nvalidate\n-\n验证表单\n\n\nhandleSubmit\n-\n提交表单\n\n\nhandleReset\n-\n重置表单\n\n\nclearError\nfield\n清除指定字段错误\n\n\n\n事件\n\n\nsubmit: 表单提交事件\n\n\nreset: 表单重置事件\n\n\ninvalid: 表单验证失败事件\n\n\n使用示例\n&lt;template&gt;  &lt;BaseForm    :model=&quot;form&quot;    :rules=&quot;rules&quot;    @submit=&quot;handleSubmit&quot;    @invalid=&quot;handleInvalid&quot;  &gt;    &lt;BaseInput      v-model=&quot;form.username&quot;      label=&quot;用户名&quot;      placeholder=&quot;请输入用户名&quot;    /&gt;        &lt;BaseInput      v-model=&quot;form.email&quot;      type=&quot;email&quot;      label=&quot;邮箱&quot;      placeholder=&quot;请输入邮箱&quot;    /&gt;        &lt;template #actions&gt;      &lt;BaseButton type=&quot;primary&quot; @click=&quot;$parent.handleSubmit&quot;&gt;        提交      &lt;/BaseButton&gt;      &lt;BaseButton type=&quot;secondary&quot; @click=&quot;$parent.handleReset&quot;&gt;        重置      &lt;/BaseButton&gt;    &lt;/template&gt;  &lt;/BaseForm&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      form: &#123;        username: &#x27;&#x27;,        email: &#x27;&#x27;      &#125;,      rules: &#123;        username: &#123;          required: true,          message: &#x27;请输入用户名&#x27;        &#125;,        email: &#123;          required: true,          pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,          message: &#x27;请输入正确的邮箱格式&#x27;        &#125;      &#125;    &#125;  &#125;,  methods: &#123;    handleSubmit(formData) &#123;      console.log(&#x27;表单提交:&#x27;, formData)    &#125;,    handleInvalid(errors) &#123;      console.log(&#x27;表单验证失败:&#x27;, errors)    &#125;  &#125;&#125;&lt;/script&gt;\n\n4. Table 表格\n主要属性\n\n\n\n属性名\n类型\n默认值\n说明\n\n\n\n\ndata\nArray\n[]\n表格数据\n\n\ncolumns\nArray\n[]\n列配置\n\n\nkeyField\nString\n‘id’\n数据唯一标识字段\n\n\nemptyText\nString\n‘暂无数据’\n空数据提示文本\n\n\nsortKey\nString\n‘’\n排序字段\n\n\nsortOrder\nString\n‘asc’\n排序方向\n\n\nborder\nBoolean\nfalse\n是否显示边框\n\n\nstriped\nBoolean\nfalse\n是否斑马纹\n\n\n\n主要方法\n\n\n\n方法名\n参数\n说明\n\n\n\n\nhandleSort\nkey, order\n处理排序\n\n\nhandleSelection\nrows\n处理选择\n\n\nhandleRowClick\nrow, index\n处理行点击\n\n\n\n事件\n\n\nsort: 排序事件\n\n\nselection-change: 选择变化事件\n\n\nrow-click: 行点击事件\n\n\n使用示例\n&lt;template&gt;  &lt;BaseTable    :data=&quot;users&quot;    :columns=&quot;columns&quot;    :sort-key=&quot;sortKey&quot;    :sort-order=&quot;sortOrder&quot;    @sort=&quot;handleSort&quot;  &gt;    &lt;template #status=&quot;&#123; row &#125;&quot;&gt;      &lt;span :class=&quot;row.status === &#x27;active&#x27; ? &#x27;status-active&#x27; : &#x27;status-inactive&#x27;&quot;&gt;        &#123;&#123; row.status === &#x27;active&#x27; ? &#x27;启用&#x27; : &#x27;禁用&#x27; &#125;&#125;      &lt;/span&gt;    &lt;/template&gt;        &lt;template #actions=&quot;&#123; row &#125;&quot;&gt;      &lt;div class=&quot;action-buttons&quot;&gt;        &lt;button @click=&quot;handleEdit(row)&quot;&gt;编辑&lt;/button&gt;        &lt;button @click=&quot;handleDelete(row)&quot;&gt;删除&lt;/button&gt;      &lt;/div&gt;    &lt;/template&gt;  &lt;/BaseTable&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      users: [        &#123; id: 1, name: &#x27;张三&#x27;, email: &#x27;zhangsan@example.com&#x27;, status: &#x27;active&#x27; &#125;,        &#123; id: 2, name: &#x27;李四&#x27;, email: &#x27;lisi@example.com&#x27;, status: &#x27;inactive&#x27; &#125;      ],      columns: [        &#123; key: &#x27;name&#x27;, title: &#x27;姓名&#x27;, sortable: true &#125;,        &#123; key: &#x27;email&#x27;, title: &#x27;邮箱&#x27;, sortable: true &#125;,        &#123; key: &#x27;status&#x27;, title: &#x27;状态&#x27; &#125;,        &#123; key: &#x27;actions&#x27;, title: &#x27;操作&#x27; &#125;      ],      sortKey: &#x27;&#x27;,      sortOrder: &#x27;asc&#x27;    &#125;  &#125;,  methods: &#123;    handleSort(key, order) &#123;      this.sortKey = key      this.sortOrder = order      // 处理排序逻辑    &#125;,    handleEdit(row) &#123;      console.log(&#x27;编辑:&#x27;, row)    &#125;,    handleDelete(row) &#123;      console.log(&#x27;删除:&#x27;, row)    &#125;  &#125;&#125;&lt;/script&gt;\n\n5. Checkbox 复选框\n主要属性\n\n\n\n属性名\n类型\n默认值\n说明\n\n\n\n\nmodelValue\nBoolean/Array\nfalse\n绑定值（v-model）\n\n\nlabel\nString\n‘’\n标签文本\n\n\ndisabled\nBoolean\nfalse\n是否禁用\n\n\nindeterminate\nBoolean\nfalse\n是否半选状态\n\n\nname\nString\n-\n表单名称\n\n\n\n主要方法\n\n\n\n方法名\n参数\n说明\n\n\n\n\nhandleChange\nvalue\n变化事件处理\n\n\n\n事件\n\n\nchange: 变化事件\n\n\n使用示例\n&lt;template&gt;  &lt;div&gt;    &lt;!-- 单个复选框 --&gt;    &lt;BaseCheckbox      v-model=&quot;agree&quot;      label=&quot;我同意用户协议&quot;      @change=&quot;handleAgreeChange&quot;    /&gt;        &lt;!-- 复选框组 --&gt;    &lt;div class=&quot;checkbox-group&quot;&gt;      &lt;BaseCheckbox        v-for=&quot;item in hobbies&quot;        :key=&quot;item.value&quot;        v-model=&quot;selectedHobbies&quot;        :label=&quot;item.label&quot;        :value=&quot;item.value&quot;      /&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      agree: false,      selectedHobbies: [],      hobbies: [        &#123; value: &#x27;reading&#x27;, label: &#x27;阅读&#x27; &#125;,        &#123; value: &#x27;sports&#x27;, label: &#x27;运动&#x27; &#125;,        &#123; value: &#x27;music&#x27;, label: &#x27;音乐&#x27; &#125;      ]    &#125;  &#125;,  methods: &#123;    handleAgreeChange(checked) &#123;      console.log(&#x27;同意状态:&#x27;, checked)    &#125;  &#125;&#125;&lt;/script&gt;\n\n6. Radio 单选框\n主要属性\n\n\n\n属性名\n类型\n默认值\n说明\n\n\n\n\nmodelValue\nString/Number/Boolean\n‘’\n绑定值（v-model）\n\n\nname\nString\n-\n表单名称\n\n\noptions\nArray\n[]\n选项数组\n\n\ndisabled\nBoolean\nfalse\n是否禁用\n\n\n\n主要方法\n\n\n\n方法名\n参数\n说明\n\n\n\n\nhandleChange\nvalue\n变化事件处理\n\n\n\n事件\n\n\nchange: 变化事件\n\n\n使用示例\n&lt;template&gt;  &lt;div&gt;    &lt;BaseRadio      v-model=&quot;gender&quot;      name=&quot;gender&quot;      :options=&quot;genderOptions&quot;      @change=&quot;handleGenderChange&quot;    /&gt;        &lt;BaseRadio      v-model=&quot;city&quot;      name=&quot;city&quot;      :options=&quot;cityOptions&quot;    /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      gender: &#x27;&#x27;,      city: &#x27;&#x27;,      genderOptions: [        &#123; value: &#x27;male&#x27;, label: &#x27;男&#x27; &#125;,        &#123; value: &#x27;female&#x27;, label: &#x27;女&#x27; &#125;      ],      cityOptions: [        &#123; value: &#x27;beijing&#x27;, label: &#x27;北京&#x27; &#125;,        &#123; value: &#x27;shanghai&#x27;, label: &#x27;上海&#x27; &#125;,        &#123; value: &#x27;guangzhou&#x27;, label: &#x27;广州&#x27; &#125;      ]    &#125;  &#125;,  methods: &#123;    handleGenderChange(value) &#123;      console.log(&#x27;性别选择:&#x27;, value)    &#125;  &#125;&#125;&lt;/script&gt;\n\n7. Select 下拉选择器\n主要属性\n\n\n\n属性名\n类型\n默认值\n说明\n\n\n\n\nmodelValue\nString/Number/Boolean\n‘’\n绑定值（v-model）\n\n\noptions\nArray\n[]\n选项数组\n\n\nplaceholder\nString\n‘请选择’\n占位文本\n\n\ndisabled\nBoolean\nfalse\n是否禁用\n\n\nfilterable\nBoolean\nfalse\n是否可搜索\n\n\nmultiple\nBoolean\nfalse\n是否多选\n\n\nclearable\nBoolean\nfalse\n是否可清空\n\n\nsize\nString\n‘medium’\n尺寸\n\n\n\n主要方法\n\n\n\n方法名\n参数\n说明\n\n\n\n\ntoggleDropdown\n-\n切换下拉框显示/隐藏\n\n\nselectOption\noption\n选择选项\n\n\nhandleSearch\nkeyword\n搜索处理\n\n\n\n事件\n\n\nchange: 变化事件\n\n\nopen: 下拉框打开事件\n\n\nclose: 下拉框关闭事件\n\n\nclear: 清空事件\n\n\n使用示例\n&lt;template&gt;  &lt;div&gt;    &lt;BaseSelect      v-model=&quot;selectedCity&quot;      :options=&quot;cityOptions&quot;      placeholder=&quot;请选择城市&quot;      filterable      @change=&quot;handleCityChange&quot;    /&gt;        &lt;BaseSelect      v-model=&quot;selectedTags&quot;      :options=&quot;tagOptions&quot;      placeholder=&quot;请选择标签&quot;      multiple      clearable    /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      selectedCity: &#x27;&#x27;,      selectedTags: [],      cityOptions: [        &#123; value: &#x27;beijing&#x27;, label: &#x27;北京&#x27; &#125;,        &#123; value: &#x27;shanghai&#x27;, label: &#x27;上海&#x27; &#125;,        &#123; value: &#x27;guangzhou&#x27;, label: &#x27;广州&#x27; &#125;,        &#123; value: &#x27;shenzhen&#x27;, label: &#x27;深圳&#x27; &#125;      ],      tagOptions: [        &#123; value: &#x27;vue&#x27;, label: &#x27;Vue.js&#x27; &#125;,        &#123; value: &#x27;react&#x27;, label: &#x27;React&#x27; &#125;,        &#123; value: &#x27;angular&#x27;, label: &#x27;Angular&#x27; &#125;      ]    &#125;  &#125;,  methods: &#123;    handleCityChange(value) &#123;      console.log(&#x27;城市选择:&#x27;, value)    &#125;  &#125;&#125;&lt;/script&gt;\n\n8. 组件通信\nProps 父传子\n&lt;!-- ParentComponent.vue --&gt;&lt;template&gt;  &lt;ChildComponent     :message=&quot;parentMessage&quot;    :user=&quot;currentUser&quot;    :is-visible=&quot;showChild&quot;  /&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      parentMessage: &#x27;来自父组件的消息&#x27;,      currentUser: &#123; name: &#x27;张三&#x27;, age: 25 &#125;,      showChild: true    &#125;  &#125;&#125;&lt;/script&gt;&lt;!-- ChildComponent.vue --&gt;&lt;template&gt;  &lt;div v-if=&quot;isVisible&quot;&gt;    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;    &lt;p&gt;用户名: &#123;&#123; user.name &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    message: String,    user: Object,    isVisible: Boolean  &#125;&#125;&lt;/script&gt;\nEmit 子传父\n&lt;!-- ChildComponent.vue --&gt;&lt;template&gt;  &lt;button @click=&quot;handleClick&quot;&gt;点击我&lt;/button&gt;  &lt;input v-model=&quot;inputValue&quot; @input=&quot;handleInput&quot; /&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      inputValue: &#x27;&#x27;    &#125;  &#125;,  methods: &#123;    handleClick() &#123;      this.$emit(&#x27;click&#x27;, &#x27;按钮被点击了&#x27;)    &#125;,    handleInput() &#123;      this.$emit(&#x27;input&#x27;, this.inputValue)    &#125;  &#125;&#125;&lt;/script&gt;&lt;!-- ParentComponent.vue --&gt;&lt;template&gt;  &lt;ChildComponent     @click=&quot;handleChildClick&quot;    @input=&quot;handleChildInput&quot;  /&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  methods: &#123;    handleChildClick(message) &#123;      console.log(&#x27;收到:&#x27;, message)    &#125;,    handleChildInput(value) &#123;      console.log(&#x27;输入:&#x27;, value)    &#125;  &#125;&#125;&lt;/script&gt;\nProvide/Inject\n&lt;!-- AncestorComponent.vue --&gt;&lt;template&gt;  &lt;div&gt;    &lt;DescendantComponent /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  provide() &#123;    return &#123;      theme: this.theme,      updateTheme: this.updateTheme    &#125;  &#125;,  data() &#123;    return &#123;      theme: &#x27;dark&#x27;    &#125;  &#125;,  methods: &#123;    updateTheme(newTheme) &#123;      this.theme = newTheme    &#125;  &#125;&#125;&lt;/script&gt;&lt;!-- DescendantComponent.vue --&gt;&lt;template&gt;  &lt;div :class=&quot;theme&quot;&gt;    &lt;button @click=&quot;updateTheme(&#x27;light&#x27;)&quot;&gt;      切换到亮色主题    &lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  inject: [&#x27;theme&#x27;, &#x27;updateTheme&#x27;]&#125;&lt;/script&gt;\n","categories":["编程"],"tags":["Web"]},{"title":"Linux 信号","url":"/2025/08/28/linux/linux%E4%BF%A1%E5%8F%B7/","content":"记录linux系统中信号的相关概念和用法\n \n一、信号的基本概念\n信号（Signal）是Linux系统中进程间异步通信的核心机制，用于通知进程发生特定事件（如用户输入、错误、进程状态变化等）。进程收到信号后会中断当前执行流程，转而去执行预设的处理逻辑。\n1. 信号本质与特性\n\n\n异步性：信号可在任意时刻触发，不受进程执行流程控制。\n\n\n不可靠性：标准信号（1-31）不支持排队，多次发送同一信号可能被合并；实时信号（34-64，SIGRTMIN~SIGRTMAX）支持排队和携带数据，更可靠。\n\n\n不可屏蔽性：SIGKILL（9）和SIGSTOP（19）无法被捕获、忽略或修改处理方式，用于强制终止/暂停进程。\n\n\n2. 信号来源\n\n\n硬件触发：如键盘输入（Ctrl+C产生SIGINT）、段错误（SIGSEGV）、算术错误（SIGFPE）。\n\n\n软件触发：如kill命令、kill()函数发送信号，子进程终止（SIGCHLD），定时器到期（SIGALRM），向关闭的套接字写数据（SIGPIPE）等。\n\n\n二、信号处理核心函数与结构体\nLinux提供了一系列信号处理函数，其中sigaction是POSIX标准推荐的接口（功能最全面），配合其他函数可实现灵活的信号控制。\n1. sigaction函数（推荐使用）\n功能：设置或获取信号的处理方式（替代旧的signal()函数，支持更多控制选项）。\n原型：\n#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction* act, struct sigaction* oldact);\n参数：\n\n\nsignum：目标信号编号（如SIGINT、SIGPIPE）。\n\n\nact：非空时，指定新的信号处理配置（struct sigaction类型）。\n\n\noldact：非空时，保存之前的处理配置（用于恢复）。\n返回值：成功返回0，失败返回-1（设置errno）。\n\n\n2. struct sigaction结构体\n用于描述信号的处理逻辑，定义如下：\nstruct sigaction &#123;    // 信号处理函数（二选一）    void (*sa_handler)(int);          // 简化版：仅接收信号编号    void (*sa_sigaction)(int, siginfo_t*, void*);  // 扩展版：需配合SA_SIGINFO标志        sigset_t sa_mask;                 // 处理信号时阻塞的其他信号    int sa_flags;                     // 控制信号处理行为的标志位    void (*sa_restorer)(void);        // 已废弃（无需使用）&#125;;\n成员详解：\n\n\nsa_handler：简化处理函数，参数为信号编号。可设为SIG_IGN（忽略信号）、SIG_DFL（默认行为）或自定义函数。\n\n\nsa_sigaction：扩展处理函数（需sa_flags设置SA_SIGINFO），可获取信号详细信息（siginfo_t）。\n\n\nsa_mask：信号集（sigset_t），表示处理当前信号时需阻塞的其他信号（避免嵌套处理）。\n\n\nsa_flags：标志位（可组合）：\n\nSA_RESTART：被信号中断的系统调用（如read、accept）自动重启（避免EINTR错误）。\nSA_SIGINFO：使用sa_sigaction作为处理函数。\nSA_NOCLDSTOP：SIGCHLD仅在子进程终止时通知（忽略暂停事件）。\n\n\n\n3. siginfo_t结构体（扩展信息载体）\n当使用sa_sigaction时，用于传递信号详细信息：\ntypedef struct &#123;    int      si_signo;   // 信号编号    int      si_code;    // 信号产生原因（如SI_USER表示用户发送）    pid_t    si_pid;     // 发送信号的进程ID    uid_t    si_uid;     // 发送进程的用户ID    void*    si_addr;    // 引发信号的地址（如SIGSEGV的错误地址）    int      si_status;  // 子进程退出状态（SIGCHLD专用）    union sigval si_value; // 附加数据（实时信号专用）&#125; siginfo_t;\n4. 信号集操作函数（sigset_t）\nsigset_t是表示“信号集”的位掩码类型，需通过以下函数操作：\n\n\nsigemptyset(sigset_t *set)：初始化信号集为空。\n\n\nsigfillset(sigset_t *set)：初始化信号集包含所有信号。\n\n\nsigaddset(sigset_t *set, int signum)：添加信号到集合。\n\n\nsigdelset(sigset_t *set, int signum)：从集合移除信号。\n\n\nsigismember(const sigset_t *set, int signum)：判断信号是否在集合中（返回1/0/-1）。\n\n\n5. 其他核心函数\n\n\n\n函数原型\n功能\n关键参数\n\n\n\n\nint sigprocmask(int how, const sigset_t *set, sigset_t *oldset)\n修改进程的信号掩码（全局阻塞信号）\nhow：SIG_BLOCK（添加阻塞）、SIG_UNBLOCK（解除阻塞）、SIG_SETMASK（替换掩码）\n\n\nint sigpending(sigset_t *set)\n获取当前进程中“已产生但未处理”的信号（pending集）\n-\n\n\nint kill(pid_t pid, int sig)\n向指定进程发送信号\npid：目标进程ID（pid&gt;0指定进程，pid=0同组进程）\n\n\nint raise(int sig)\n向当前进程发送信号（等价于kill(getpid(), sig)）\n-\n\n\nint sigwait(const sigset_t *set, int *sig)\n同步等待信号（将异步信号转为同步处理）\n需先通过sigprocmask阻塞目标信号\n\n\nint sigqueue(pid_t pid, int sig, const union sigval value)\n向进程发送带数据的实时信号\nvalue：附加数据（sival_int或sival_ptr）\n\n\n\n6. 兼容性函数signal()\n早期接口，功能简化但跨系统行为可能不一致：\nvoid (*signal(int signum, void (*handler)(int)))(int);\n局限性：不支持sa_mask和sa_flags，信号处理期间仅阻塞当前信号，部分系统会自动重置为默认行为。仅推荐用于简单演示，实际开发优先用sigaction。\n三、常用信号详解（网络编程高频场景）\n系统定义了64种信号，以下为网络编程中需重点关注的信号：\n\n\n\n编号\n信号名\n触发场景\n默认行为\n网络编程中的意义\n\n\n\n\n2\nSIGINT\nCtrl+C终端中断\n终止进程\n需捕获以优雅关闭连接（如释放socket）\n\n\n3\nSIGQUIT\nCtrl+\\终端退出\n终止+核心转储\n同上，可用于强制退出并生成调试信息\n\n\n6\nSIGABRT\n调用abort()\n终止+核心转储\n检测到严重错误（如内存破坏）时触发\n\n\n8\nSIGFPE\n算术错误（除零、溢出）\n终止+核心转储\n协议解析中的数值计算错误\n\n\n10\nSIGUSR1\n用户自定义\n终止\n自定义事件（如重新加载配置）\n\n\n12\nSIGUSR2\n用户自定义\n终止\n与SIGUSR1配合区分不同事件\n\n\n13\nSIGPIPE\n向已关闭的套接字写数据\n终止\n必须处理（忽略或捕获），避免程序意外退出\n\n\n14\nSIGALRM\n定时器到期\n终止\n实现网络超时（如connect超时控制）\n\n\n17\nSIGCHLD\n子进程终止/暂停\n忽略\n需捕获以回收子进程（避免僵尸进程）\n\n\n16\nSIGURG\n套接字收到紧急数据（OOB）\n忽略\n处理TCP带外数据（如紧急指针）\n\n\n20\nSIGTSTP\nCtrl+Z终端暂停\n暂停进程\n后台服务需忽略（避免意外暂停）\n\n\n\n关键信号深度解析：\n\n\nSIGPIPE（13）\n当TCP连接被对方关闭后，本地仍调用write()/send()时触发。默认终止进程，网络编程中必须处理：\n\n忽略信号：signal(SIGPIPE, SIG_IGN);，此时写操作返回-1并设置errno=EPIPE，便于程序捕获错误。\n捕获信号：在处理函数中记录连接异常日志。\n\n\n\nSIGCHLD（17）\n子进程终止时，父进程需回收资源（否则子进程变为僵尸进程）。处理方式：\nvoid handle_sigchld(int sig) &#123;    pid_t pid;    // 非阻塞回收所有终止的子进程    while ((pid = waitpid(-1, nullptr, WNOHANG)) &gt; 0) &#123;        // 处理子进程回收逻辑    &#125;&#125;\n\n\nSIGURG（16）\n套接字收到带外数据时触发，需结合socket选项SO_OOBINLINE使用，在处理函数中调用recv()读取紧急数据。\n\n\n四、实践注意事项\n\n\n信号处理函数的可重入性\n信号处理函数可能中断任意代码，需使用可重入函数（如write、_exit、sigprocmask），避免调用不可重入函数（printf、malloc、fopen等，可能导致资源竞争）。若需输出，可用write(STDOUT_FILENO, ...)替代printf。\n\n\n多线程信号处理\n信号默认随机投递到任意未阻塞该信号的线程，推荐做法：\n\n主线程通过pthread_sigmask阻塞所有信号。\n创建专门的信号处理线程，用sigwait()同步处理信号（避免中断业务逻辑）：sigset_t set;sigemptyset(&amp;set);sigaddset(&amp;set, SIGINT);pthread_sigmask(SIG_BLOCK, &amp;set, nullptr); // 阻塞SIGINTpthread_t tid;pthread_create(&amp;tid, nullptr, [](void* arg) &#123;    int sig;    while (sigwait((sigset_t*)arg, &amp;sig) == 0) &#123;        // 处理信号（如SIGINT）    &#125;    return nullptr;&#125;, &amp;set);\n\n\n\n\n系统调用中断与重启\n网络编程中的accept、recv、select等系统调用可能被信号中断，返回-1并设置errno=EINTR。解决方式：\n\n设置sa_flags = SA_RESTART，使系统调用自动重启（部分调用如select不支持，需手动重试）。\n手动判断并重试：ssize_t n;while ((n = recv(fd, buf, sizeof(buf), 0)) == -1 &amp;&amp; errno == EINTR);\n\n\n\n\n实时信号vs标准信号\n\n标准信号（1~31）：适合处理无需排队的事件（如中断、终止），多次发送可能合并。\n实时信号（34~64）：支持排队和带数据，适合需要可靠传递的场景（如多任务状态通知）。\n\n\n\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"Linux中孤儿进程的ppid","url":"/2025/08/21/linux/Linux%E4%B8%AD%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E7%9A%84ppid/","content":"记录蒋炎炎老师OS课上的孤儿进程问题\n \n\n\n孤儿进程的内核处理逻辑\n当父进程终止时，内核会触发do_exit()系统调用，其中包含对其子进程的 “领养” 处理逻辑。具体来说，内核会遍历该父进程的所有子进程（通过进程描述符task_struct的children链表），并为每个子进程重新设置父进程 ID（PPID）。这一过程由内核函数reparent_children()完成，其核心目标是确保每个进程始终有一个有效的父进程，以避免资源泄漏。\n\n\n为何通常指向 1 号进程？\n1 号进程（传统上是init，现代系统中多为systemd）是 Linux 用户态的第一个进程，由内核直接创建（start_kernel()阶段初始化）。其设计特性是：\n\n常驻内存（生命周期与系统一致）\n会主动调用wait()系列系统调用回收所有子进程资源因此，内核默认将孤儿进程的 PPID 重置为 1 号进程，利用其特性保证孤儿进程终止后能被及时回收，避免成为僵尸进程（Z状态）。\n\n\n\n非1号进程的特殊场景\n非 1 号进程成为领养者，本质上与 Linux 的进程命名空间（process namespace） 机制相关：\n\n每个命名空间（如容器环境、用户会话）都有独立的进程 ID 空间，其中也会存在一个 “命名空间内的 1 号进程”（即该命名空间的初始化进程）。\n当孤儿进程位于非初始命名空间时，内核会将其 PPID 重置为该命名空间内的 1 号进程，而非全局 1 号进程。例如：\n容器环境中，容器内的 1 号进程（如containerd-shim或容器内的init）会领养容器内的孤儿进程。\n用户会话中，systemd --user进程（可能是 1867 号）作为用户会话命名空间的初始化进程，会领养该会话内的孤儿进程。\n\n\n\n是否会指向其他进程？\n理论上，内核只会选择命名空间内的 1 号进程作为领养者，而非任意进程。这是因为：\n\n领养者必须具备 “不会主动退出” 且 “会处理子进程回收” 的特性，普通用户进程不满足这一要求。\n内核通过find_new_reaper()函数确定领养者，该函数的逻辑是：在当前命名空间中寻找 “最顶层” 的 init 类进程（即命名空间内的 1 号进程）。\n\n\n\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"fcntl函数","url":"/2025/08/18/linux/fcntl%E5%87%BD%E6%95%B0/","content":"使用场景和相关用法\n \nfcntl函数\n一、fcntl 函数基础\n#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* 可选参数 arg */ );\n\n\n返回值：成功时返回与 cmd 相关的值（如标志、文件描述符），失败返回 -1 并设置 errno。\n\n\n核心作用：通过 cmd 命令对 fd（文件描述符）执行控制操作，涵盖文件状态、I/O 模式、锁机制等。\n\n\n二、与 O_NONBLOCK 相关的操作（文件状态标志）\nO_NONBLOCK 是 非阻塞模式标志，用于设置文件描述符的 I/O 行为：\n\n\n阻塞模式（默认）：当执行 read/write 等操作时，若暂时无法完成（如无数据可读、缓冲区满），进程会进入睡眠等待。\n\n\n非阻塞模式（O_NONBLOCK）：操作无法立即完成时，函数会立即返回 -1 并设置 errno 为 EAGAIN 或 EWOULDBLOCK，不阻塞进程。\n\n\n相关 cmd 命令：\n\n\nF_GETFL：获取当前文件状态标志（包含是否设置 O_NONBLOCK）\nint flags = fcntl(fd, F_GETFL, 0);  // 0 表示无额外参数if (flags == -1) &#123;    perror(&quot;fcntl F_GETFL failed&quot;);&#125;\n\n\nF_SETFL：设置文件状态标志（用于开启 / 关闭 O_NONBLOCK）\n// 开启非阻塞模式（保留原有标志，添加 O_NONBLOCK）int new_flags = flags | O_NONBLOCK;if (fcntl(fd, F_SETFL, new_flags) == -1) &#123;    perror(&quot;fcntl F_SETFL failed&quot;);&#125;// 关闭非阻塞模式（清除 O_NONBLOCK 标志）new_flags = flags &amp; ~O_NONBLOCK;fcntl(fd, F_SETFL, new_flags);\n\n\n适用场景：\n\n\n网络套接字（socket）：避免 recv/send 阻塞导致进程卡死。\n\n\n管道（pipe）、FIFO：处理读写端不同步的情况。\n\n\n设备文件（如终端、串口）：实时响应 I/O 状态变化。\n\n\n三、文件锁操作（进程间同步）\nfcntl 支持对文件的部分或全部内容加锁，避免多进程竞争。相关 cmd 命令需配合 struct flock 结构体使用：\nstruct flock &#123;    short l_type;   // 锁类型：F_RDLCK（读锁）、F_WRLCK（写锁）、F_UNLCK（解锁）    short l_whence; // 偏移基准：SEEK_SET（文件头）、SEEK_CUR（当前位置）、SEEK_END（文件尾）    off_t l_start;  // 锁的起始偏移量    off_t l_len;    // 锁的长度（0 表示至文件末尾）    pid_t l_pid;    // 持有锁的进程 ID（仅 F_GETLK 时有效）&#125;;\n\n\nF_GETLK：检查锁冲突（获取当前阻塞当前锁请求的锁信息）\nstruct flock lock;lock.l_type = F_WRLCK;  // 尝试获取写锁lock.l_whence = SEEK_SET;lock.l_start = 0;lock.l_len = 0;         // 锁整个文件if (fcntl(fd, F_GETLK, &amp;lock) == -1) &#123;    perror(&quot;fcntl F_GETLK failed&quot;);&#125;if (lock.l_type != F_UNLCK) &#123;    // 存在冲突的锁，lock.l_pid 为持有锁的进程&#125;\n\n\nF_SETLK：设置或释放锁（非阻塞模式，失败立即返回）\n// 加写锁lock.l_type = F_WRLCK;if (fcntl(fd, F_SETLK, &amp;lock) == -1) &#123;    if (errno == EAGAIN || errno == EACCES) &#123;        // 锁被占用，无法获取    &#125;&#125;// 解锁lock.l_type = F_UNLCK;fcntl(fd, F_SETLK, &amp;lock);\n\n\nF_SETLKW：设置或释放锁（阻塞模式，若无法获取则等待）\n// 等待获取锁，直到成功或被信号中断if (fcntl(fd, F_SETLKW, &amp;lock) == -1) &#123;    perror(&quot;fcntl F_SETLKW failed&quot;);&#125;\n\n\n四、文件描述符管理\n\n\nF_DUPFD：复制文件描述符（类似 dup）\n// 生成一个 &gt;= min_fd 的新描述符，与原 fd 指向同一文件int new_fd = fcntl(old_fd, F_DUPFD, min_fd);\n\n\nF_DUPFD_CLOEXEC：复制描述符并设置 FD_CLOEXEC 标志\n// 新描述符在进程执行 exec 时自动关闭，避免资源泄漏int new_fd = fcntl(old_fd, F_DUPFD_CLOEXEC, min_fd);\n\n\nF_GETFD/F_SETFD：获取 / 设置文件描述符标志（仅 FD_CLOEXEC 有效）\n// 获取标志int fd_flags = fcntl(fd, F_GETFD);// 设置 FD_CLOEXEC（exec 时关闭）fcntl(fd, F_SETFD, fd_flags | FD_CLOEXEC);\n\n\n五、异步 I/O 与信号通知\n\n\nF_SETOWN：设置接收 SIGIO 和 SIGURG 信号的进程 / 进程组\n// 指定进程 ID 接收信号（负数表示进程组 ID）fcntl(fd, F_SETOWN, pid);\n\n\nF_GETOWN：获取当前接收信号的进程 / 进程组 ID\npid_t owner = fcntl(fd, F_GETOWN);\n\n\nF_SETFL 配合 O_ASYNC：开启异步 I/O 通知（数据可读 / 可写时触发 SIGIO）\nint flags = fcntl(fd, F_GETFL);fcntl(fd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);  // 同时开启异步和非阻塞\n\n\n六、其他系统相关命令\n\n\nF_GETPIPE_SZ/F_SETPIPE_SZ：获取 / 设置管道（pipe）的缓冲区大小\nint pipe_size = fcntl(fd, F_GETPIPE_SZ);  // 获取大小fcntl(fd, F_SETPIPE_SZ, new_size);        // 设置大小（需权限）\n\n\nF_ADD_SEALS/F_GET_SEALS：为文件添加 / 查询 “密封” 标志（限制修改）\n// 添加写密封（禁止后续写入）fcntl(fd, F_ADD_SEALS, F_SEAL_WRITE);// 查询当前密封标志int seals = fcntl(fd, F_GET_SEALS);\n\n\nF_GETLEASE/F_SETLEASE：获取 / 设置文件租约（协调进程间文件访问）\n// 设置读租约（其他进程写操作会触发通知）fcntl(fd, F_SETLEASE, F_RDLEASE);\n\n\nfcntl 是一个功能强大的多用途函数，核心能力包括：\n\n\n控制 I/O 模式（如 O_NONBLOCK 非阻塞）；\n\n\n进程间文件锁（读锁、写锁）；\n\n\n文件描述符管理（复制、标志设置）；\n\n\n异步 I/O 信号通知；\n\n\n系统特定扩展功能（管道大小、文件密封等）。\n\n\n使用时需注意：不同 Unix/Linux 系统对命令的支持可能有差异，建议通过 man 2 fcntl 查看本地系统的详细文档。非阻塞模式（O_NONBLOCK）常与 I/O 多路复用（select/poll/epoll）结合，是高性能网络编程的基础。\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"IO多路复用","url":"/2025/08/16/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","content":"\nLinux平台下的三种多路复用技术，结合AI进行整理\n\n\nIO多路复用\nIO 复用（IO Multiplexing） 是一种高效处理多 IO 事件的核心技术，其核心思想是通过单个进程 / 线程同时监视多个文件描述符（File Descriptor，如 Socket、文件、管道等），当某个描述符就绪（可读 / 可写 / 异常）时，主动通知程序进行处理。这种模式避免了传统 “一连接一线程” 模型的资源浪费（线程创建销毁开销、上下文切换成本），特别适合高并发场景（如百万级 TCP 连接的服务器）。\n一、IO 复用的核心价值\n在网络编程中，传统处理多客户端连接的方式是 “每连接创建一个线程”，但存在明显缺陷：\n\n\n线程数量有限（受系统资源限制，通常上限为几万），无法支撑高并发；\n\n\n线程上下文切换开销大，CPU 利用率低；\n\n\n内存消耗高（每个线程默认栈空间通常为 1MB）。\n\n\nIO 复用技术通过单线程 / 少量线程监视大量 IO 描述符，仅在描述符就绪时才进行处理，大幅降低资源消耗，可轻松支撑十万甚至百万级并发连接。\n二、常用 IO 复用函数及用法\nLinux 平台下常用的 IO 复用函数有select、poll、epoll（性能最优，最常用），Windows 平台对应有WSAEventSelect和IOCP（IO 完成端口）。以下以 Linux 为主展开讲解：\n1. select：最经典的 IO 复用函数\nselect是 POSIX 标准定义的 IO 复用函数，通过轮询方式监视多个文件描述符的可读、可写和异常事件。\n函数原型\n#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;int select(int nfds,            fd_set *readfds,   // 关注“可读”事件的描述符集合           fd_set *writefds,  // 关注“可写”事件的描述符集合           fd_set *exceptfds, // 关注“异常”事件的描述符集合           struct timeval *timeout); // 超时时间（NULL表示阻塞等待）\n核心参数说明\n\n\nnfds：需要监视的最大文件描述符值 + 1（因为描述符从 0 开始编号）；\n\n\nfd_set：描述符集合（本质是位图），需通过宏操作：\n\nFD_ZERO(fd_set *)：清空集合；\nFD_SET(int fd, fd_set *)：将 fd 加入集合；\nFD_CLR(int fd, fd_set *)：从集合中移除 fd；\nFD_ISSET(int fd, fd_set *)：检查 fd 是否在就绪集合中；\n\n\n\ntimeout：超时设置（struct timeval { long tv_sec; long tv_usec; }），NULL表示永久阻塞，tv_sec=0且tv_usec=0表示非阻塞。\n\n\n返回值\n\n\n成功：就绪的描述符总数；\n\n\n失败：-1（需通过errno判断错误，如EINTR表示被信号中断）；\n\n\n超时：0。\n\n\n示例代码（用 select 处理多客户端连接）\n#include &lt;sys/select.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;int main() &#123;    // 1. 创建监听Socket    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);    if (listen_fd == -1) &#123; perror(&quot;socket&quot;); return -1; &#125;    // 绑定地址和端口    struct sockaddr_in serv_addr;    memset(&amp;serv_addr, 0, sizeof(serv_addr));    serv_addr.sin_family = AF_INET;    serv_addr.sin_addr.s_addr = INADDR_ANY;    serv_addr.sin_port = htons(8080);    if (bind(listen_fd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)) == -1) &#123;        perror(&quot;bind&quot;); return -1;    &#125;    // 开始监听    listen(listen_fd, 1024);    std::cout &lt;&lt; &quot;Server listening on port 8080...\\n&quot;;    fd_set read_fds;       // 关注的可读事件集合    int max_fd = listen_fd; // 当前最大描述符    std::vector&lt;int&gt; client_fds; // 保存客户端连接    while (true) &#123;        // 每次调用select前需重置集合（因为select会修改集合）        FD_ZERO(&amp;read_fds);        FD_SET(listen_fd, &amp;read_fds); // 监听Socket加入可读集合        // 将所有客户端Socket加入可读集合        for (int fd : client_fds) &#123;            FD_SET(fd, &amp;read_fds);            if (fd &gt; max_fd) max_fd = fd;        &#125;        // 调用select，阻塞等待事件（超时设为NULL表示永久阻塞）        int ready = select(max_fd + 1, &amp;read_fds, NULL, NULL, NULL);        if (ready == -1) &#123;            perror(&quot;select&quot;);            continue;        &#125; else if (ready == 0) &#123;            continue; // 超时，继续等待        &#125;        // 处理监听Socket的可读事件（新客户端连接）        if (FD_ISSET(listen_fd, &amp;read_fds)) &#123;            struct sockaddr_in client_addr;            socklen_t addr_len = sizeof(client_addr);            int client_fd = accept(listen_fd, (struct sockaddr*)&amp;client_addr, &amp;addr_len);            if (client_fd == -1) &#123;                perror(&quot;accept&quot;);                continue;            &#125;            client_fds.push_back(client_fd);            std::cout &lt;&lt; &quot;New client connected, fd: &quot; &lt;&lt; client_fd &lt;&lt; &quot;\\n&quot;;            ready--; // 减少就绪计数，避免重复处理        &#125;        // 处理客户端Socket的可读事件（数据到来）        if (ready &gt; 0) &#123;            for (auto it = client_fds.begin(); it != client_fds.end();) &#123;                int fd = *it;                if (FD_ISSET(fd, &amp;read_fds)) &#123;                    char buf[1024] = &#123;0&#125;;                    ssize_t n = recv(fd, buf, sizeof(buf)-1, 0);                    if (n &lt;= 0) &#123; // 连接关闭或错误                        std::cout &lt;&lt; &quot;Client disconnected, fd: &quot; &lt;&lt; fd &lt;&lt; &quot;\\n&quot;;                        close(fd);                        it = client_fds.erase(it);                    &#125; else &#123; // 接收数据                        std::cout &lt;&lt; &quot;Received from fd &quot; &lt;&lt; fd &lt;&lt; &quot;: &quot; &lt;&lt; buf &lt;&lt; &quot;\\n&quot;;                        send(fd, &quot;Received&quot;, 8, 0); // 简单回显                        it++;                    &#125;                    ready--;                    if (ready == 0) break; // 所有就绪事件处理完毕                &#125; else &#123;                    it++;                &#125;            &#125;        &#125;    &#125;    close(listen_fd);    return 0;&#125;\n优缺点\n\n\n优点：跨平台（Linux/Windows/BSD 均支持），实现简单；\n\n\n缺点：\n\n描述符数量限制（默认上限为 1024，可通过修改内核参数FD_SETSIZE调整，但不推荐）；\n每次调用需重置fd_set，效率低；\n需遍历所有描述符检查就绪状态，随描述符增多性能下降。\n\n\n\n2. poll：select 的改进版\npoll解决了select的描述符数量限制问题，用结构体数组替代位图存储描述符，支持动态扩展。\n函数原型\n#include &lt;poll.h&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout);\n核心参数说明\n\n\nstruct pollfd：描述符及事件的结构体：\nstruct pollfd &#123;    int fd;         // 要监视的文件描述符（-1表示忽略）    short events;   // 关注的事件（输入参数）    short revents;  // 实际发生的事件（输出参数）&#125;;\n\n\n常用events：POLLIN（可读）、POLLOUT（可写）、POLLERR（错误）、POLLHUP（挂断）；\n\n\n\n\nnfds：fds数组的长度；\n\n\ntimeout：超时时间（毫秒，-1 表示永久阻塞，0 表示非阻塞）。\n\n\n返回值\n\n\n成功：就绪的描述符总数；\n\n\n失败：-1；\n\n\n超时：0。\n\n\n示例代码（用 poll 处理多客户端）\n#include &lt;poll.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;int main() &#123;    // 1. 创建监听Socket（同上，省略绑定/监听代码）    int listen_fd = ...;     std::vector&lt;struct pollfd&gt; fds;    // 添加监听Socket到poll集合    fds.push_back(&#123;listen_fd, POLLIN, 0&#125;);    while (true) &#123;        // 调用poll，阻塞等待事件        int ready = poll(fds.data(), fds.size(), -1);        if (ready == -1) &#123; perror(&quot;poll&quot;); continue; &#125;        // 遍历所有描述符检查就绪事件        for (size_t i = 0; i &lt; fds.size() &amp;&amp; ready &gt; 0; i++) &#123;            if (fds[i].revents == 0) continue;            // 处理监听Socket的可读事件（新连接）            if (fds[i].fd == listen_fd) &#123;                int client_fd = accept(listen_fd, NULL, NULL);                if (client_fd != -1) &#123;                    fds.push_back(&#123;client_fd, POLLIN, 0&#125;);                    std::cout &lt;&lt; &quot;New client, fd: &quot; &lt;&lt; client_fd &lt;&lt; &quot;\\n&quot;;                &#125;                ready--;            &#125;             // 处理客户端Socket的可读事件            else if (fds[i].revents &amp; POLLIN) &#123;                char buf[1024] = &#123;0&#125;;                ssize_t n = recv(fds[i].fd, buf, sizeof(buf)-1, 0);                if (n &lt;= 0) &#123; // 连接关闭                    close(fds[i].fd);                    // 用最后一个元素覆盖当前位置，减少vector移动开销                    fds[i] = fds.back();                    fds.pop_back();                &#125; else &#123; // 接收数据                    std::cout &lt;&lt; &quot;Received: &quot; &lt;&lt; buf &lt;&lt; &quot;\\n&quot;;                    send(fds[i].fd, &quot;OK&quot;, 2, 0);                &#125;                ready--;            &#125;        &#125;    &#125;    close(listen_fd);    return 0;&#125;\n优缺点\n\n\n优点：\n\n无描述符数量限制（仅受系统内存限制）；\n无需每次重置事件集合（revents由内核填充，events保持不变）；\n\n\n\n缺点：\n\n仍需遍历所有描述符检查就绪状态（大数量时效率低）；\n跨平台性略差（Windows 需模拟实现）。\n\n\n\n3. epoll：Linux 高性能 IO 复用（推荐）\nepoll是 Linux 2.6 内核后引入的高性能 IO 复用机制，采用内核事件表和回调通知模式，避免了select/poll的轮询开销，是高并发服务器的首选。\n核心函数\n\n\nepoll_create：创建 epoll 实例（内核事件表）\n#include &lt;sys/epoll.h&gt;int epoll_create(int size); // size：早期内核用于指定事件表大小，现在已忽略（传&gt;0即可）\n\n\nepoll_ctl：操作事件表（添加 / 修改 / 删除描述符及事件）\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n\n\nepfd：epoll_create返回的实例句柄；\n\n\nop：操作类型：EPOLL_CTL_ADD（添加）、EPOLL_CTL_MOD（修改）、EPOLL_CTL_DEL（删除）；\n\n\nfd：要操作的文件描述符；\n\n\nstruct epoll_event：事件结构：\nstruct epoll_event &#123;    uint32_t events;  // 关注的事件    epoll_data_t data; // 用户数据（通常存fd或自定义指针）&#125;;typedef union epoll_data &#123;    void *ptr;    int fd;    uint32_t u32;    uint64_t u64;&#125; epoll_data_t;\n常用events：EPOLLIN（可读）、EPOLLOUT（可写）、EPOLLET（边缘触发）、EPOLLONESHOT（只触发一次）。\n\n\n\n\nepoll_wait：等待事件就绪\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\n\n\nevents：输出参数，保存就绪的事件；\n\n\nmaxevents：最多处理的事件数（需≤epoll_create的 size）；\n\n\ntimeout：超时时间（毫秒，-1 表示阻塞，0 表示非阻塞）。\n\n\n返回值：就绪的事件数（0 表示超时，-1 表示错误）。\n\n\n\n\nepoll_create1 - 创建 epoll 实例\nint epoll_create1(int flags);\n\n\nflags：可以是 0（与epoll_create相同）或EPOLL_CLOEXEC（进程执行 exec 时自动关闭 epoll 实例）\n\n\n返回值：成功返回 epoll 文件描述符，失败返回 - 1\n\n\n\n\n关键特性：边缘触发（ET）与水平触发（LT）\n\n\n水平触发（LT，默认）：只要描述符有未处理的数据（如可读），epoll_wait就会持续通知；\n\n\n边缘触发（ET）：仅在描述符状态从 “未就绪” 变为 “就绪” 时通知一次（需一次性处理完所有数据，否则可能遗漏事件）。\n\n\nET 模式效率更高（减少通知次数），但编程复杂度高（需确保数据读完）。\n示例代码（epoll + ET 模式处理多客户端）\n#include &lt;sys/epoll.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;// 一次性读取所有数据（ET模式必需）ssize_t read_all(int fd, char *buf, size_t len) &#123;    ssize_t total = 0;    while (total &lt; len) &#123;        ssize_t n = recv(fd, buf + total, len - total, 0);        if (n &lt; 0) &#123;            if (errno == EAGAIN || errno == EWOULDBLOCK) break; // 数据已读完            return -1; // 错误        &#125; else if (n == 0) return total; // 连接关闭        total += n;    &#125;    return total;&#125;int main() &#123;    // 1. 创建监听Socket（同上，省略绑定/监听）    int listen_fd = ...;    // 2. 创建epoll实例    int epfd = epoll_create(1024); // 参数&gt;0即可    if (epfd == -1) &#123; perror(&quot;epoll_create&quot;); return -1; &#125;    // 3. 向epoll添加监听Socket（LT模式，默认）    struct epoll_event ev;    ev.events = EPOLLIN; // 关注可读事件    ev.data.fd = listen_fd;    if (epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &amp;ev) == -1) &#123;        perror(&quot;epoll_ctl&quot;); return -1;    &#125;    const int MAX_EVENTS = 1024;    struct epoll_event events[MAX_EVENTS]; // 存放就绪事件    while (true) &#123;        // 4. 等待事件就绪（阻塞）        int ready = epoll_wait(epfd, events, MAX_EVENTS, -1);        if (ready == -1) &#123; perror(&quot;epoll_wait&quot;); continue; &#125;        // 5. 处理就绪事件        for (int i = 0; i &lt; ready; i++) &#123;            int fd = events[i].data.fd;            // 新客户端连接            if (fd == listen_fd) &#123;                int client_fd = accept(listen_fd, NULL, NULL);                if (client_fd == -1) &#123; perror(&quot;accept&quot;); continue; &#125;                // 设为非阻塞（ET模式必须，避免读数据时阻塞）                int flags = fcntl(client_fd, F_GETFL);                fcntl(client_fd, F_SETFL, flags | O_NONBLOCK);                // 向epoll添加客户端Socket（ET模式）                ev.events = EPOLLIN | EPOLLET; // 可读 + 边缘触发                ev.data.fd = client_fd;                epoll_ctl(epfd, EPOLL_CTL_ADD, client_fd, &amp;ev);                std::cout &lt;&lt; &quot;New client, fd: &quot; &lt;&lt; client_fd &lt;&lt; &quot;\\n&quot;;            &#125;            // 客户端数据可读            else if (events[i].events &amp; EPOLLIN) &#123;                char buf[1024] = &#123;0&#125;;                ssize_t n = read_all(fd, buf, sizeof(buf)-1); // 一次性读完                if (n &lt;= 0) &#123; // 连接关闭或错误                    close(fd);                    epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL); // 从epoll移除                    std::cout &lt;&lt; &quot;Client disconnected, fd: &quot; &lt;&lt; fd &lt;&lt; &quot;\\n&quot;;                &#125; else &#123;                    std::cout &lt;&lt; &quot;Received: &quot; &lt;&lt; buf &lt;&lt; &quot;\\n&quot;;                    send(fd, &quot;OK&quot;, 2, 0);                &#125;            &#125;        &#125;    &#125;    close(epfd);    close(listen_fd);    return 0;&#125;\n优缺点\n\n\n优点：\n\n高效：内核通过回调直接通知就绪事件，无需轮询所有描述符；\n支持海量描述符（十万 / 百万级，仅受内存限制）；\n边缘触发模式减少冗余通知，适合高并发；\n\n\n\n缺点：\n\n仅支持 Linux 平台（不跨平台）；\nET 模式编程复杂（需处理非阻塞 IO 和数据完整性）。\n\n\n\n三、注意事项\n\n\n描述符管理：\n\nselect/poll需手动维护描述符集合，epoll通过epoll_ctl动态管理；\n关闭描述符前需从 IO 复用集合中移除（避免 “僵尸描述符” 导致错误）。\n\n\n\n非阻塞 IO 配合：\n\n边缘触发（ET）模式必须结合非阻塞 IO（O_NONBLOCK），否则可能因一次读 / 写未完成而阻塞；\n水平触发（LT）可配合阻塞 IO，但非阻塞 IO 更灵活。\n\n\n\n事件类型选择：\n\n避免过度关注EPOLLOUT（可写事件）：Socket 默认可写，会导致epoll_wait频繁触发，通常仅在发送数据时临时添加；\n用EPOLLONESHOT确保一个事件仅被一个线程处理（多线程场景）。\n\n\n\n跨平台兼容：\n\nselect是唯一跨所有平台的 IO 复用函数；\n跨平台开发可使用封装库（如 Boost.Asio、libuv），统一抽象不同系统的 IO 复用机制。\n\n\n\n性能误区：\n\n小并发场景（&lt;1000 连接），select/poll与epoll性能差异不大；\n避免在epoll中频繁添加 / 删除描述符（开销较高，可用EPOLLONESHOT替代）。\n\n\n\n四、典型使用场景\n\n\n高并发 TCP 服务器（如 Web 服务器、即时通讯服务器）：需同时处理数万至百万级客户端连接，epoll（Linux）或kqueue（BSD）是最优选择。\n\n\n多 IO 设备监控（如同时处理 Socket、管道、文件）：poll或epoll可统一管理不同类型的文件描述符。\n\n\n低资源环境（如嵌入式设备）：select实现简单，资源占用少，适合轻量级场景。\n\n\n非阻塞 IO 配合：与非阻塞 Socket 结合，实现 “非阻塞 + IO 复用” 的高效模型（如 Nginx 的事件驱动模型）。\n\n\n总结\nIO 复用是 C++ 高性能网络编程的基石，其核心是通过单线程 / 少量线程高效处理多 IO 事件。选择哪种函数需结合平台、并发量和复杂度：\n\n\n跨平台、轻量级场景→select；\n\n\n中等并发、需突破描述符限制→poll；\n\n\n高并发（Linux）、追求极致性能→epoll（推荐）。\n\n\n实际开发中，建议使用成熟的网络库（如 Boost.Asio、muduo），它们已封装 IO 复用细节，同时提供跨平台支持和更高层次的抽象，降低开发难度。\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"C++/Linux 创建daemon进程","url":"/2025/08/15/linux/C++Linux%20%E5%88%9B%E5%BB%BAdaemon%E8%BF%9B%E7%A8%8B/","content":"如何使用 C++ 在 Linux 环境下创建一个守护进程\n\n在 Linux 环境下，守护进程是一种在后台运行，不与任何终端关联，独立于控制终端并且周期性执行任务或等待处理某些事件的进程。以下是使用 C++ 编写将一个进程转换为守护进程的示例代码，并对关键步骤进行解释：\n#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;cstdlib&gt;#include &lt;cerrno&gt;// 函数用于将当前进程转换为守护进程bool daemonize() &#123;    // 第一步：创建子进程，父进程退出    pid_t pid = fork();    if (pid &lt; 0) &#123;        std::cerr &lt;&lt; &quot;fork error: &quot; &lt;&lt; errno &lt;&lt; std::endl;        return false;    &#125; else if (pid &gt; 0) &#123;        // 父进程直接退出，让子进程继续执行        exit(EXIT_SUCCESS);    &#125;    // 此时子进程成为新的会话组长和进程组长    // 第二步：创建新会话    pid = setsid();    if (pid &lt; 0) &#123;        std::cerr &lt;&lt; &quot;setsid error: &quot; &lt;&lt; errno &lt;&lt; std::endl;        return false;    &#125;    // 第三步：改变工作目录    if (chdir(&quot;/&quot;) &lt; 0) &#123;        std::cerr &lt;&lt; &quot;chdir error: &quot; &lt;&lt; errno &lt;&lt; std::endl;        return false;    &#125;    // 第四步：设置文件权限掩码    umask(0);    // 第五步：关闭标准输入、输出和错误输出，并重新定向到/dev/null    close(STDIN_FILENO);    int fd = open(&quot;/dev/null&quot;, O_RDWR);    if (fd != STDIN_FILENO) &#123;        return false;    &#125;    if (dup2(fd, STDOUT_FILENO) != STDOUT_FILENO) &#123;        return false;    &#125;    if (dup2(fd, STDERR_FILENO) != STDERR_FILENO) &#123;        return false;    &#125;    if (fd &gt; STDERR_FILENO) &#123;        close(fd);    &#125;    return true;&#125;int main() &#123;    if (daemonize()) &#123;        std::cout &lt;&lt; &quot;Process has been daemonized successfully.&quot; &lt;&lt; std::endl;        // 这里可以编写守护进程的具体任务逻辑，比如定时执行某些操作        while (true) &#123;            // 模拟守护进程执行任务，这里简单睡眠10秒            sleep(10);            std::cout &lt;&lt; &quot;Daemon is working...&quot; &lt;&lt; std::endl;        &#125;    &#125; else &#123;        std::cerr &lt;&lt; &quot;Failed to daemonize the process.&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;\n代码解释\n\n\n创建子进程并退出父进程：使用 fork() 函数创建一个子进程。父进程调用 exit(EXIT_SUCCESS) 退出，这样子进程就不再是控制终端的前台进程，并且可以避免在父进程退出时，子进程成为孤儿进程而被 init 进程收养并受到不必要的终端控制。\n\n\n创建新会话：调用 setsid() 函数，使子进程成为新会话的组长，同时也是新进程组的组长。这样做可以让守护进程脱离原会话的控制，并且不再有控制终端，从而实现后台独立运行。\n\n\n改变工作目录：使用 chdir(&quot;/&quot;) 将当前工作目录更改为根目录 / 。这是为了防止守护进程长时间运行时，其工作目录所在的文件系统被卸载而导致进程出现异常。也可以根据实际需求将工作目录设置为其他合适的目录。\n\n\n设置文件权限掩码：通过 umask(0) 将文件权限掩码设置为 0，这样守护进程在创建文件或目录时，可以完全按照指定的权限来创建，而不会受到默认掩码的影响。\n\n\n关闭并重新定向标准文件描述符：守护进程不应该与终端有交互，所以关闭标准输入（STDIN_FILENO）、标准输出（STDOUT_FILENO）和标准错误输出（STDERR_FILENO），并将它们重新定向到 /dev/null 。/dev/null 是一个特殊的设备文件，写入它的数据会被丢弃，读取它会立即返回文件结束标志。\n\n\nint daemon(int nochdir,int noclose)\nnochdir: 用于指定是否改变当前的工作目录, 如果 为0 则将工作目录设置为根目录（”/“), 否则依旧使用当前目录作为工作目录\nnoclose: 参数为0，则将标准输入输出和标准错误输出重定向至”/dev/null“文件\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"Git的使用","url":"/2025/08/15/linux/Git%20%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","content":"\n记录git的使用\n\n \nGit 命令大全\n\n本文基于知乎文章《Git 命令大全》（原文链接）整理，涵盖 Git 核心操作命令、常见问题解决方案，并补充实用扩展知识\n\n一、初始化与配置\n1. 核心命令整理（原文内容）\n# 初始化本地 Git 仓库（在当前目录创建 .git 文件夹）git init# 配置全局用户名（所有仓库生效）git config --global user.name &quot;你的用户名&quot;# 配置全局邮箱（与 Git 平台账号邮箱一致，用于身份识别）git config --global user.email &quot;你的邮箱@xxx.com&quot;# 开启命令自动着色（git status、git log 等输出更易读）git config --global color.ui truegit config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive auto# 移除全局 HTTP 代理配置（解决代理失效导致的连接问题）git config --global --unset http.proxy\n2. 补充知识与扩展\n\n\n配置作用域区别：\n\n--global：全局配置（保存在 ~/.gitconfig 或 C:\\Users\\用户名\\.gitconfig），对当前用户所有仓库生效；\n--local：仓库级配置（保存在当前仓库的 .git/config），仅对当前仓库生效，优先级高于 --global；\n--system：系统级配置（保存在 /etc/gitconfig 或 Git 安装目录/etc/gitconfig），对所有用户生效（需管理员权限）。\n示例：为当前仓库单独配置邮箱\n\ngit config --local user.email &quot;仓库专属邮箱@xxx.com&quot;\n\n\n查看配置：\ngit config --list  # 查看所有生效的配置（按优先级排序）git config user.name  # 查看指定配置项（如用户名）\n\n\n常用辅助配置：\n# 配置默认文本编辑器（解决 commit 时编辑器异常问题）git config --global core.editor &quot;code --wait&quot;  # VS Code 为例# 配置换行符自动转换（避免跨系统协作换行符冲突）git config --global core.autocrlf true  # Windows 下；Linux/macOS 下设为 input\n\n\n二、克隆、状态与提交\n1. 核心命令整理（原文内容）\n# 克隆远程仓库（SSH 地址示例，也可使用 HTTPS 地址）git clone git+ssh://git@192.168.53.168/VT.git# 查看当前仓库状态（显示修改未暂存、暂存未提交的文件）git status# 单个文件添加到暂存区（跟踪文件变更）git add xyz.txt# 当前目录所有修改/新增文件添加到暂存区（不含被忽略文件）git add .# 提交暂存区文件（-m 后为提交说明，需清晰描述变更内容）git commit -m &quot;feat: 新增登录功能&quot;# 修改上一次提交（仅适用于未推送到远程的提交，避免修改历史）git commit --amend -m &quot;feat: 新增登录功能（补充密码验证）&quot;# 跳过暂存区，直接提交已跟踪文件的修改（未跟踪文件需先 git add）git commit -am &quot;fix: 修复登录按钮点击无响应问题&quot;\n2. 补充知识与扩展\n\n\n克隆的扩展用法：\n# 克隆指定分支（避免克隆全部分支占用空间）git clone -b 分支名 远程仓库地址# 示例：克隆远程 develop 分支git clone -b develop https://github.com/xxx/xxx.git# 浅克隆（仅拉取最近 N 次提交，适合大型仓库提速）git clone --depth 1 远程仓库地址  # 仅拉取最近 1 次提交\n\n\n暂存区理解：\n暂存区（Index）是 Git 特有的“中间层”，用于临时存放待提交的变更。通过 git add 将变更存入暂存区，git commit 将暂存区内容提交到本地仓库。好处是可分批次提交不同文件的变更（例如：先提交功能代码，再提交文档）。\n\n\n提交信息规范：\n推荐遵循 Angular 提交规范，格式：类型(范围): 描述\n\n类型：feat（新功能）、fix（bug 修复）、docs（文档修改）、style（代码格式调整，无逻辑变更）、refactor（重构）、test（测试代码）、chore（构建/工具配置）；\n示例：fix(login): 修复手机号格式验证错误\n\n\n\n三、文件删除与重命名\n1. 核心命令整理（原文内容）\n# 从暂存区和工作区同时删除文件（需谨慎，删除后需 commit 生效）git rm xxx.txt# 递归删除目录（含子目录下所有文件）git rm -r docs/# 重命名文件（等价于 “mv 旧名 新名 + git add 新名 + git rm 旧名”）git mv README.md README_2.0.md\n2. 补充知识与扩展\n\n\n仅从暂存区删除（保留工作区文件）：\n若误将不需要跟踪的文件 git add，可从暂存区移除但保留本地文件：\ngit rm --cached 不需要跟踪的文件.txt\n\n\n删除已提交的文件（保留本地副本）：\n若文件已提交到仓库，想停止跟踪但保留本地文件：\ngit rm --cached 已提交文件.txtgit commit -m &quot;chore: 停止跟踪已提交文件.txt&quot;\n\n\n重命名的注意事项：\nGit 对文件名大小写不敏感（如 ReadMe.md 与 README.md 视为同一文件），若需修改文件名大小写，需先删除旧名再添加新名：\ngit rm ReadMe.mdmv ReadMe.md README.mdgit add README.md\n\n\n四、日志查看与显示\n1. 核心命令整理（原文内容）\n# 显示完整提交日志（按时间倒序，含作者、时间、提交 ID、说明）git log# 显示最近 1 次提交git log -1# 显示最近 5 次提交git log -5# 显示日志及每次提交的变更文件（含新增/删除/修改的文件数）git log --stat# 显示日志及每次提交的具体代码变更（-p 显示补丁，-m 显示合并提交的双方信息）git log -p -m# 图形化显示提交历史（含分支合并线，%h 显示短提交 ID，%s 显示提交说明）git log --pretty=format:&#x27;%h %s&#x27; --graph# 查看指定提交的完整内容（需输入完整提交 ID，或前 4-6 位即可）git show dfb02e6e4f2f7b573337763e5c0013802e392818git show dfb02  # 短 ID 示例# 查看当前 HEAD 指向的提交详情（HEAD 是当前分支的“指针”）git show HEAD# 查看上一个版本的提交（HEAD^ 等价于 HEAD~1）git show HEAD^# 查看上上上次版本的提交（HEAD~3 表示往前数 3 个版本）git show HEAD~3\n2. 补充知识与扩展\n\n\n常用日志过滤与格式化：\n# 按作者筛选日志（查找指定人提交的记录）git log --author=&quot;张三&quot;# 按时间筛选日志（查找近 3 天的提交）git log --since=&quot;3 days ago&quot;# 查找 2024-01-01 到 2024-05-01 之间的提交git log --since=&quot;2024-01-01&quot; --until=&quot;2024-05-01&quot;# 按提交说明筛选（查找含“登录”关键词的提交）git log --grep=&quot;登录&quot;# 简洁日志（一行显示一个提交，常用！）git log --oneline  # 等价于 --pretty=oneline --abbrev-commit# 图形化简洁日志（查看分支关系更直观）git log --oneline --graph --all  # --all 显示所有分支的日志\n\n\n查看特定文件的提交历史：\n跟踪单个文件的修改记录（适合排查“谁改了这个文件”）：\ngit log -p README.md  # 显示 README.md 的所有修改历史及代码变更git log --follow README.md  # 跟踪文件重命名后的历史（默认不跟踪）\n\n\n五、标签管理\n1. 核心命令整理（原文内容）\n# 查看本地所有标签（按字母顺序排列）git tag# 创建带注释的标签（-a 表示 annotated，含作者、时间、说明，推荐用于版本发布）git tag -a v2.0 -m &quot;版本 2.0：新增支付功能&quot;# 显示标签对应的提交详情（含标签说明、提交内容）git show v2.0# 查看标签 v2.0 对应的所有提交日志git log v2.0# 推送所有本地标签到远程仓库（标签不会随 git push 自动推送）git push --tags\n2. 补充知识与扩展\n\n\n标签的两种类型：\n\n带注释标签（Annotated）：git tag -a 创建，含完整元数据（作者、时间、说明），会被 Git 永久跟踪，适合正式版本（如 v1.0、v2.0）；\n轻量标签（Lightweight）：仅为提交 ID 的“别名”，无元数据，适合临时标记（如测试版本）：git tag v2.0-beta  # 创建轻量标签git tag -d v2.0-beta  # 删除轻量标签（与删除带注释标签命令一致）\n\n\n\n\n推送指定标签到远程：\n若不想推送所有标签，可指定单个标签：\ngit push origin v2.0  # 仅推送标签 v2.0 到远程\n\n\n删除远程标签：\n需先删除本地标签，再推送“删除指令”到远程：\ngit tag -d v2.0  # 删除本地标签git push origin :refs/tags/v2.0  # 删除远程标签\n\n\n检出标签（查看历史版本）：\n标签是“静态快照”，检出后会进入 detached HEAD 状态（无分支关联），若需修改，需创建新分支：\ngit checkout v2.0  # 检出标签 v2.0（进入 detached HEAD 状态）git checkout -b fix-v2.0 v2.0  # 基于标签创建新分支，用于修复旧版本问题\n\n\n六、差异比较（diff）\n1. 核心命令整理（原文内容）\n# 显示工作区与暂存区的差异（未 git add 的修改）git diff# 显示暂存区与本地仓库的差异（已 git add 但未 git commit 的修改）git diff --cached# 显示工作区与上一次提交（HEAD^）的差异git diff HEAD^# 显示工作区与 HEAD 版本中指定目录（lib/）的差异git diff HEAD -- ./lib# 显示远程 master 分支与本地 master 分支的差异（需先 git fetch）git diff origin/master..master# 仅显示差异文件列表（不显示具体代码变更，适合快速排查）git diff origin/master..master --stat\n2. 补充知识与扩展\n\n\n比较分支/提交的差异：\n# 比较两个分支的差异（如 feature/login 与 master）git diff feature/login..master# 比较两个提交之间的差异（需输入两个提交 ID）git diff dfb02..a8c3f  # 显示 dfb02 到 a8c3f 之间的变更# 比较指定文件在两个分支中的差异git diff feature/login master -- ./src/login.js\n\n\n忽略空白字符差异：\n若代码仅调整了空格/换行（无逻辑变更），可忽略空白差异：\ngit diff -w  # -w 忽略所有空白差异git diff --ignore-space-at-eol  # 仅忽略行尾空白差异\n\n\n使用工具可视化 diff：\n若觉得命令行 diff 不直观，可使用图形化工具（如 VS Code）：\ngit difftool  # 调用默认图形化工具显示差异git difftool --tool=vscode  # 指定 VS Code 为 diff 工具\n\n\n七、远程仓库操作\n1. 核心命令整理（原文内容）\n# 添加远程仓库（命名为 origin，通常为默认远程仓库名）git remote add origin git+ssh://git@192.168.53.168/VT.git# 获取远程仓库的所有更新（不合并到本地分支，仅更新本地缓存的远程分支）git fetch# 获取远程更新并清理本地缓存中已被远程删除的分支（避免无效分支残留）git fetch --prune# 拉取远程 master 分支并合并到当前本地分支（等价于 git fetch + git merge）git pull origin master# 推送当前本地分支到远程 master 分支（若远程无该分支则自动创建）git push origin master# 删除远程分支（hotfixes/BJVEP933，格式：origin:远程分支名）git push origin :hotfixes/BJVEP933\n2. 补充知识与扩展\n\n\n查看远程仓库信息：\ngit remote  # 查看所有远程仓库名（如 origin）git remote -v  # 查看远程仓库的详细地址（fetch 拉取地址、push 推送地址）git remote show origin  # 查看 origin 远程仓库的详细信息（含分支关联、提交状态）\n\n\n修改远程仓库地址：\n若远程仓库地址变更（如 Git 服务器迁移），无需删除重建，直接修改：\n# 方法 1：修改地址git remote set-url origin 新的远程地址# 方法 2：先删除旧地址，再添加新地址git remote remove origingit remote add origin 新的远程地址\n\n\nSSH 与 HTTPS 地址的区别：\n\n\n\n类型\n优势\n劣势\n适用场景\n\n\n\n\nSSH\n无需每次输入账号密码（配置 SSH 密钥后）\n需提前配置 SSH 密钥，首次 setup 稍复杂\n长期开发的个人/团队仓库\n\n\nHTTPS\n无需配置密钥，直接输入账号密码即可连接\n每次推送需输入账号密码（可配置凭据缓存）\n临时克隆、公共仓库访问\n\n\n\n\n\n安全推送替代 git push --force：\n原文提示慎用 git push --force（可能覆盖远程提交），推荐更安全的 --force-with-lease：\ngit push --force-with-lease origin master\n作用：仅当远程分支未被他人修改时才强制推送，若他人已提交，会提示冲突，避免误删他人代码。\n\n\n关联本地分支与远程分支：\n首次推送本地分支到远程时，建议关联分支（后续可直接 git pull/push，无需指定远程分支）：\ngit push -u origin 本地分支名  # -u 等价于 --set-upstream# 示例：推送本地 feature/pay 分支并关联远程同名分支git push -u origin feature/pay\n\n\n八、分支管理\n1. 核心命令整理（原文内容）\n# 查看本地所有分支（当前分支前带 * 标记）git branch# 查看包含指定提交（50089 为短提交 ID）的所有本地分支git branch --contains 50089# 查看所有分支（本地 + 远程，远程分支以 remotes/origin/ 开头）git branch -a# 仅查看所有远程分支git branch -r# 查看已合并到当前分支的所有本地分支（可安全删除）git branch --merged# 查看未合并到当前分支的所有本地分支（删除需谨慎）git branch --no-merged# 重命名本地分支（将 master 重命名为 master_copy，需在非目标分支下操作）git branch -m master master_copy# 删除本地分支（仅当分支已合并到其他分支时生效，避免误删未合并代码）git branch -d hotfixes/BJVEP933# 强制删除本地分支（无论是否合并，用于删除确定无用的分支）git branch -D hotfixes/BJVEP933\n2. 补充知识与扩展\n\n\nGit 2.23+ 新命令：git switch 与 git restore：\nGit 新增更直观的分支切换命令 git switch（替代 git checkout 的分支切换功能）：\ngit switch master  # 切换到已存在的 master 分支git switch -c feature/pay  # 创建并切换到 feature/pay 分支（-c 等价于 --create）git switch -c feature/pay origin/feature/pay  # 基于远程分支创建本地分支并切换\n\n\n查看分支关联状态：\n查看本地分支与远程分支的关联关系（是否已 --set-upstream）：\ngit branch -vv  # 显示每个分支的关联远程分支及提交差异\n\n\n清理本地无效分支：\n当远程分支被删除后，本地 git branch -a 仍会显示 remotes/origin/已删除分支，可通过以下命令清理：\ngit fetch --prune  # 清理本地缓存的远程已删除分支# 或手动删除本地跟踪的无效远程分支git branch -r | grep -v &#x27;origin/master&#x27; | xargs -I &#123;&#125; git branch --delete --remotes &#123;&#125;\n\n\n九、分支检出与合并\n1. 核心命令整理（原文内容）\n# 创建并切换到新分支（master_copy，等价于 git branch master_copy + git checkout master_copy）git checkout -b master_copy# 从远程 develop 分支创建本地 devel 分支并切换git checkout -b devel origin/develop# 检出已存在的分支（features/performance）git checkout features/performance# 跟踪远程分支（将本地 hotfixes/BJVEP933 与远程同名分支关联，后续可直接 git pull/push）git checkout --track hotfixes/BJVEP933# 切换到标签版本（v2.0，会进入 detached HEAD 状态）git checkout v2.0# 回退单个文件到上一次提交的状态（放弃工作区修改，需谨慎）git checkout -- README.md# 将远程 master 分支合并到当前本地分支git merge origin/master# 应用指定提交（ff44785404a8e 为提交 ID）到当前分支（常用于跨分支复用单个提交）git cherry-pick ff44785404a8e\n2. 补充知识与扩展\n\n\ngit merge 与 git rebase 的区别（核心扩展！）：\n两者均用于合并分支，但提交历史不同，适用场景不同：\n\n\n\n操作\n提交历史\n适用场景\n风险\n\n\n\n\ngit merge\n保留分支合并记录（生成一个“合并提交”），历史更完整\n团队协作的公共分支（如 master）合并功能分支\n无（不修改已有提交历史）\n\n\ngit rebase\n将当前分支的提交“移植”到目标分支末尾，历史更简洁（无合并提交）\n个人开发分支（如 feature/*）合并到 master 前整理历史\n有（修改已有提交历史，禁止对已推送到远程的公共分支使用）\n\n\n\n示例：将 feature/login 分支合并到 master\n# 方法 1：merge（保留合并记录）git checkout mastergit pull origin mastergit merge feature/logingit push origin master# 方法 2：rebase（整理历史，仅用于个人分支）git checkout feature/logingit rebase master  # 解决冲突后git checkout mastergit merge feature/login  # 此时为“快进合并”，无合并提交git push origin master\n\n\ngit cherry-pick 高级用法：\n# 应用多个连续提交（从 a8c3f 到 dfb02，左开右闭，即包含 dfb02 不包含 a8c3f）git cherry-pick a8c3f..dfb02# 应用提交时保留原作者信息git cherry-pick -x ff44785  # -x 会在提交说明中添加“(cherry picked from commit ...)”# 解决 cherry-pick 冲突后继续git cherry-pick --continue# 放弃 cherry-pickgit cherry-pick --abort\n\n\n合并冲突解决步骤（原文未详细说明，补充核心流程）：\n当 git merge 或 git rebase 出现冲突时，按以下步骤解决：\n\n查看冲突文件：冲突文件中会用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD（当前分支内容）、=======（目标分支内容）、&gt;&gt;&gt;&gt;&gt;&gt;&gt; 分支名 标记冲突区域；\n编辑冲突文件：删除冲突标记，保留正确的代码；\n标记冲突已解决：git add 冲突文件路径；\n继续合并/变基：\n\n若为 git merge：git commit -m &quot;merge: 解决与 master 分支的冲突&quot;（或 Git 自动提示提交）；\n若为 git rebase：git rebase --continue；\n\n\n（可选）放弃合并/变基：git merge --abort 或 git rebase --abort。\n\n\n\n十、版本控制操作（reset/rebase/revert）\n1. 核心命令整理（原文内容）\n# 重置当前分支到 HEAD 状态（--hard 会放弃工作区和暂存区的所有修改，需极度谨慎！）git reset --hard HEAD# 变基操作（整理提交历史，默认基于当前分支的上游分支，需结合 -i 使用）git rebase# 撤销指定提交（创建一个新提交抵消原提交的变更，不修改历史，适合已推送的提交）git revert dfb02e6e4f2f7b573337763e5c0013802e392818\n2. 补充知识与扩展\n\n\ngit reset 的三种模式（核心区别！）：\ngit reset 用于“回滚”版本，不同模式对工作区、暂存区的影响不同：\n\n\n\n模式\n工作区\n暂存区\n本地仓库\n适用场景\n\n\n\n\n--soft\n保留修改\n保留修改\n回滚到指定版本\n撤销 git commit，但保留已 git add 的内容（如提交信息写错）\n\n\n--mixed（默认）\n保留修改\n回滚\n回滚到指定版本\n撤销 git commit 和 git add，但保留工作区修改（如误 add 不需要的文件）\n\n\n--hard\n回滚（删除修改）\n回滚\n回滚到指定版本\n彻底放弃所有修改，回到指定版本（如代码完全错误，需从头开始）\n\n\n\n示例：\ngit reset --soft HEAD~1  # 撤销上一次 commit，保留暂存区（原文 FAQ 4 用到）git reset --mixed HEAD~1  # 撤销上一次 commit 和 add，保留工作区git reset --hard HEAD~1  # 撤销上一次 commit、add，且删除工作区修改（危险！）\n\n\ngit rebase -i（交互式变基，整理提交历史）：\n用于合并多个小提交、修改提交说明、删除无用提交，仅适用于未推送到远程的分支：\n# 整理最近 3 次提交（HEAD~3 表示往前数 3 个版本）git rebase -i HEAD~3\n执行后会进入编辑器，显示最近 3 次提交，每行开头为 pick（保留该提交），可修改为：\n\nreword（修改提交说明）；\nsquash（将当前提交合并到上一个提交）；\ndrop（删除当前提交）；\n保存后按提示完成变基，最终将多个小提交合并为一个清晰的提交。\n\n\n\ngit revert 与 git reset 的区别：\n\n\n\n操作\n对历史的影响\n适用场景\n风险\n\n\n\n\ngit revert\n创建新提交抵消原提交，不修改历史\n撤销已推送到远程的提交（避免影响他人）\n无\n\n\ngit reset\n直接修改分支指针，删除历史提交\n撤销未推送到远程的本地提交\n有（修改历史，远程已有的提交无法用 reset 撤销）\n\n\n\n示例：撤销已推送的提交 dfb02\ngit revert dfb02  # 会自动创建一个新提交，说明为“Revert &quot;原提交说明&quot;”git push origin master  # 推送新提交到远程，完成撤销\n\n\n十一、暂存与恢复（stash）\n1. 核心命令整理（原文内容）\n# 暂存当前工作区和暂存区的所有修改（未提交的内容），保存为一个“快照”git stash# 查看所有暂存的快照列表（按创建时间排序，stash@&#123;0&#125; 为最新）git stash list# 查看指定 stash 快照的具体内容（stash@&#123;0&#125; 为最新快照）git stash show -p stash@&#123;0&#125;# 应用指定 stash 快照到当前工作区（应用后快照仍保留）git stash apply stash@&#123;0&#125;\n2. 补充知识与扩展\n\n\nstash 的常用扩展命令：\n# 暂存时添加备注（方便后续识别快照内容，推荐！）git stash save &quot;开发到一半的登录功能&quot;# 应用最新快照并删除该快照（等价于 apply + drop，常用）git stash pop  # 应用 stash@&#123;0&#125; 并删除git stash pop stash@&#123;1&#125;  # 应用 stash@&#123;1&#125; 并删除# 删除指定快照（无需应用时）git stash drop stash@&#123;0&#125;# 删除所有快照（清理无用 stash）git stash clear# 基于 stash 快照创建新分支（适用于快照内容复杂，避免与当前分支冲突）git stash branch new-branch stash@&#123;0&#125;\n\n\nstash 的注意事项：\n\nstash 仅暂存已跟踪文件的修改和暂存区的变更，未跟踪的新文件不会被暂存；\n若需暂存未跟踪文件，需加 -u（–include-untracked）：git stash -u  # 暂存已跟踪文件修改 + 未跟踪文件\n\n若需暂存忽略文件（.gitignore 中的文件），需加 -a（–all）：git stash -a  # 暂存所有修改（已跟踪 + 未跟踪 + 忽略文件）\n\n\n\n\n十二、文件查找与日志辅助\n1. 核心命令整理（原文内容）\n# 在所有跟踪文件中查找含“delete from”关键词的内容（支持正则）git grep &quot;delete from&quot;# 查找同时包含“#define”和“SORT_DIRENT”的内容（--and 表示逻辑与）git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT# 列出当前暂存区（Index）中的所有文件（即已跟踪的文件）git ls-files# 显示最近修改过的文件历史（含每次修改的提交信息）git whatchanged# 查看所有引用的历史记录（包括已删除的分支、reset 回滚的提交，比 git log 更全面）git reflog# 查看 HEAD 引用历史中第 5 个状态的提交详情git show HEAD@&#123;5&#125;# 查看 master 分支昨天的状态对应的提交详情git show master@&#123;yesterday&#125;\n2. 补充知识与扩展\n\n\ngit grep 高级用法：\n# 仅显示匹配行的行号git grep -n &quot;delete from&quot;# 显示匹配文件的文件名，不显示具体行内容git grep -l &quot;delete from&quot;# 在指定分支（如 develop）中查找关键词git grep &quot;delete from&quot; develop# 在指定目录（如 src/）中查找关键词git grep &quot;delete from&quot; src/\n\n\ngit reflog 的关键作用：\ngit reflog 记录了 Git 仓库中所有引用（HEAD、分支、标签）的变更历史，是“救回误删内容”的核心工具：\n\n恢复误删的分支：通过 git reflog 找到分支删除前的最后一个提交 ID，再创建分支（原文 FAQ 6 用到）；\n恢复 git reset --hard 误删的工作区：找到 reset 前的提交 ID，用 git reset --hard 提交ID 恢复；\n示例：恢复误删的 feature/pay 分支\n\ngit reflog  # 找到 feature/pay 分支最后的提交 ID，如 a8c3fgit checkout -b feature/pay a8c3f  # 基于该提交重建分支\n\n\n十三、低层操作（了解即可）\n1. 核心命令整理（原文内容）\n# 以文本图示显示分支关系（含提交信息）git show-branch# 显示所有分支（本地 + 远程）的关系图示git show-branch --all# 查看 HEAD 指向的提交对象下的文件结构（含文件类型、SHA1 值、文件名）git ls-tree HEAD# 查看标签 v2.0 对应的提交对象的 SHA1 值（将引用转换为具体提交 ID）git rev-parse v2.0# 显示指定提交（2be7fcb476）的简化原始信息（不含代码变更，仅元数据）git show -s --pretty=raw 2be7fcb476# 垃圾回收（优化仓库，清理无用对象、合并松散对象，减小仓库体积）git gc# 仓库完整性检查（检测损坏的对象或引用，修复仓库问题）git fsck\n2. 补充知识与扩展\n\n\n低层操作的适用场景：\n这些命令主要用于 Git 内部原理学习或仓库故障排查，日常开发极少用到：\n\ngit gc：当仓库体积过大（如频繁提交大文件）时，手动执行可优化性能，Git 也会在后台自动执行；\ngit fsck：当仓库报错（如“corrupt object”）时，用于检测损坏的对象，若需修复，可能需要结合备份的 .git/objects 目录。\n\n\n\n十四、常见 Git 问题与解决方案（FAQ）\n1. 原文问题整理与补充\n1.1 fatal: not a git repository（不是 Git 仓库）\n\n\n错误原因：当前目录未初始化 Git 仓库（无 .git 文件夹），或切换到了非仓库目录。\n\n\n解决方案：\n# 方案 1：在当前目录初始化仓库（新建仓库）git init# 方案 2：切换到已存在的仓库目录（假设仓库在 ~/project 下）cd ~/project\n\n\n1.2 error: failed to push some refs to ...（推送失败）\n\n\n错误原因：远程分支有本地未同步的新提交（本地分支落后于远程），Git 防止覆盖远程代码而拒绝推送。\n\n\n解决方案（原文补充）：\n# 方案 1：拉取远程更新并合并（推荐，保留合并记录）git pull origin 分支名  # 如 git pull origin master# 解决合并冲突后，再推送git push origin 分支名# 方案 2：拉取远程更新并变基（整理历史，仅用于个人分支）git pull --rebase origin 分支名# 解决变基冲突后，再推送git push origin 分支名# 方案 3：强制推送（仅当远程分支无他人修改时使用，极度谨慎！）git push --force-with-lease origin 分支名  # 比 --force 更安全\n\n\n1.3 如何撤销 git add？（取消暂存）\n\n\n解决方案（原文 + 补充）：\n# 方案 1：适用于所有 Git 版本（原文方案）git reset HEAD 文件名  # 如 git reset HEAD login.jsgit reset HEAD .  # 撤销当前目录所有文件的暂存# 方案 2：适用于 Git 2.23+（更直观）git restore --staged 文件名  # 如 git restore --staged login.js\n\n\n1.4 如何撤销 git commit？（未推送）\n\n\n错误场景：提交信息写错，或漏加文件，且未推送到远程。\n\n\n解决方案（原文 + 补充）：\n# 方案 1：保留修改，回到 commit 前的暂存状态（原文方案）git reset --soft HEAD~1# 方案 2：保留修改，回到 commit 前的工作区状态（取消暂存）git reset --mixed HEAD~1  # 等价于 git reset HEAD~1（默认 --mixed）# 方案 3：直接修改上一次提交（推荐，避免多一次 reset 记录）git commit --amend -m &quot;修正后的提交说明&quot;# 若漏加文件，先 add 再 amendgit add 漏加的文件.txtgit commit --amend --no-edit  # --no-edit 保留原提交说明\n\n\n1.5 如何删除某次 commit？（未推送）\n\n\n错误场景：某次提交有误（如包含敏感信息），且未推送到远程。\n\n\n解决方案（原文 + 补充）：\n# 方案 1：交互式变基（原文方案，推荐）git rebase -i HEAD~N  # N 为“当前版本到目标提交”的距离（如删除最近第 3 次提交，N=3）# 编辑界面中，将目标提交前的“pick”改为“drop”，保存退出# 若出现冲突，解决后执行 git rebase --continue# 方案 2：reset 回滚（适用于删除最近的提交）git reset --hard 目标提交ID  # 回滚到目标提交，删除后续所有提交# 示例：删除最近 2 次提交，回滚到 HEAD~2 对应的提交git reset --hard HEAD~2\n\n\n警告：严禁对已推送到远程的提交使用此方法，会导致团队历史混乱！\n\n\n1.6 如何恢复被删除的分支？\n\n\n前提：被删除的分支曾有提交记录（可通过 git reflog 找到）。\n\n\n解决方案（原文 + 补充）：\n# 步骤 1：查看所有引用历史，找到被删除分支的最后一个提交 ID（如 a8c3f）git reflog# 步骤 2：基于该提交 ID 重建分支git checkout -b 被删除的分支名 提交ID  # 如 git checkout -b feature/pay a8c3f# 步骤 3：（若分支已推送到远程）重新推送分支git push -u origin 被删除的分支名\n\n\n1.7 Git 仓库突然很大，怎么排查？\n\n\n原因：仓库中存在大文件（如压缩包、日志），或历史提交中包含大文件。\n\n\n解决方案（原文 + 补充）：\n# 步骤 1：查看仓库中最大的 20 个文件（原文方案）git rev-list --objects --all | sort -k 2 | \\git cat-file --batch-check=&#x27;%(objecttype) %(objectname) %(objectsize) %(rest)&#x27; | \\grep ^blob | sort -k3 -n | tail -20# 步骤 2：删除大文件（若文件未提交，直接删除并添加到 .gitignore）rm 大文件路径echo &quot;大文件路径&quot; &gt;&gt; .gitignoregit add .gitignoregit commit -m &quot;chore: 忽略大文件并删除&quot;# 步骤 3：若大文件已提交到历史，需清理历史（需谨慎，会修改历史！）# 使用 BFG Repo-Cleaner 工具（比 git filter-branch 更快）# 1. 安装 BFG：https://rtyley.github.io/bfg-repo-cleaner/# 2. 清理历史中的大文件（如大于 100MB 的文件）bfg --strip-blobs-bigger-than 100M 仓库路径# 3. 优化仓库git gc --prune=now --aggressive# 4. 强制推送修改后的历史（仅在个人仓库或团队确认后执行）git push --force-with-lease origin master\n\n\n1.8 You have not concluded your merge（未完成合并）\n\n\n错误原因：上一次 git merge 出现冲突，未解决完就中断了操作。\n\n\n解决方案（原文 + 补充）：\n# 方案 1：放弃上一次合并，回到合并前状态（推荐，重新合并）git merge --abort# 方案 2：继续完成合并（若已解决冲突）git add 冲突文件路径  # 标记冲突已解决git commit -m &quot;merge: 完成与 master 分支的合并（解决冲突）&quot;\n\n\n1.9 detached HEAD（HEAD 脱离分支）\n\n\n含义：HEAD 直接指向某个提交 ID，而非分支指针（常见于检出标签、旧提交），此时修改无法直接提交到分支。\n\n\n解决方案（原文 + 补充）：\n# 方案 1：回到已存在的分支（如 master，丢弃 detached 状态的修改）git checkout master# 方案 2：基于当前 detached 状态创建新分支（保留修改，推荐）git checkout -b new-branch  # 新建分支并切换，修改会保留在新分支# 方案 3：若需将修改提交到已有分支（如 feature/pay）git stash  # 暂存当前修改git checkout feature/pay  # 切换到目标分支git stash pop  # 恢复修改git commit -m &quot;feat: 从 detached 状态恢复的修改&quot;\n\n\n1.10 忘记某次 commit ID 怎么办？\n\n\n解决方案（原文 + 补充）：\n# 方案 1：查看所有提交历史（含提交 ID、说明）git log --oneline  # 简洁显示，快速查找# 方案 2：查看所有引用历史（包括已删除的提交、reset 记录）git reflog  # 找到目标提交的 ID（如 a8c3f）# 方案 3：按作者/时间/关键词筛选（缩小范围）git log --author=&quot;张三&quot; --since=&quot;1 week ago&quot; --grep=&quot;登录&quot;\n\n\n2. 补充常见问题\n2.1 如何忽略已跟踪的文件？\n\n\n问题场景：已 git add 的文件（如配置文件 config.ini），后续想忽略但不删除本地文件。\n\n\n解决方案：\n# 步骤 1：从暂存区移除文件（保留本地文件）git rm --cached config.ini# 步骤 2：将文件添加到 .gitignoreecho &quot;config.ini&quot; &gt;&gt; .gitignore# 步骤 3：提交修改git add .gitignoregit commit -m &quot;chore: 忽略已跟踪的 config.ini 文件&quot;\n\n\n注意：.gitignore 仅对未跟踪文件生效，已跟踪文件需先 git rm --cached。\n\n\n2.2 如何恢复被 git checkout -- 文件 误删的修改？\n\n\n问题场景：执行 git checkout -- 文件名 后，工作区修改被删除，未提交也未 stash。\n\n\n解决方案：\n若修改未被 git add，Git 无法直接恢复，但可尝试通过编辑器的“本地历史”（如 VS Code 的“文件 &gt; 恢复文件”）恢复，或使用第三方数据恢复工具。\n\n\n预防：执行 git checkout -- 文件 前，先用 git status 确认修改是否需要保留，重要修改先 git stash。\n\n\n十五、实用提示与工作流建议\n1. 原文提示补充\n\n\n善用 git stash：切换分支前若有未提交的修改，用 git stash save &quot;备注&quot; 暂存，避免修改丢失；\n\n\n慎用 git push --force：优先使用 git push --force-with-lease，若必须 force，需先确认远程分支无他人修改；\n\n\n定期优化仓库：执行 git gc 清理无用对象，git fetch --prune 清理无效远程分支；\n\n\n可视化工具辅助：新手推荐使用 Sourcetree（免费）、GitKraken（付费），或 IDE 内置 Git 工具（VS Code、IntelliJ IDEA），降低命令行操作门槛。\n\n\n2. 补充：常用 Git 工作流\n\n\n1. GitHub Flow（简洁，适用于持续部署）：\n\n从 main 分支创建 feature/bugfix 分支；\n本地开发，频繁提交并推送到远程同名分支；\n开发完成后，提交 Pull Request（PR）；\n代码审核通过后，合并到 main 分支；\n合并后删除 feature/bugfix 分支，main 分支自动部署。\n\n\n\n2. Git Flow（规范，适用于版本化发布）：\n核心分支：\n\nmain：生产环境分支，仅存放稳定版本；\ndevelop：开发环境分支，集成各功能分支；\nfeature/*：功能开发分支（从 develop 创建，合并回 develop）；\nhotfix/*：生产环境紧急修复分支（从 main 创建，合并回 main 和 develop）；\nrelease/*：版本发布分支（从 develop 创建，合并回 main 和 develop，并打标签）。\n\n\n\n","categories":["编程"],"tags":["工具","Git"]},{"title":"Socket基础概念","url":"/2025/08/15/linux/Socket%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","content":"socket基础概念\n \n在网络编程中，Socket（套接字） 是进程间通信的抽象接口，用于实现不同主机或同一主机内不同进程之间的网络数据传输。它是 TCP/IP 协议栈的编程接口，现代 C++ 网络开发中依然是核心基础（尽管常被封装为更高层库如 Boost.Asio）。\n一、Socket 核心概念\n\n\n本质：Socket 是一个 “文件描述符”（Linux/Unix）或 “句柄”（Windows），代表一个网络通信端点，通过它可进行数据的发送 / 接收。\n\n\n分类：\n\n流式套接字（SOCK_STREAM）：基于 TCP 协议，提供可靠、有序、双向的字节流传输（无数据丢失 / 重复，适合文件传输、HTTP 等）。\n数据报套接字（SOCK_DGRAM）：基于 UDP 协议，提供无连接、不可靠的数据包传输（速度快，适合视频通话、DNS 等）。\n原始套接字（SOCK_RAW）：直接操作底层协议（如 IP），用于网络诊断或自定义协议（需管理员权限）。\n\n\n\n通信模型：\n\nTCP 采用 “客户端 - 服务器” 模型，需先建立连接（三次握手），再传输数据。\nUDP 无连接，直接发送数据包，无需提前建立连接。\n\n\n\n二、核心函数解析（基于 TCP，现代 C++ 视角）\n以下函数是 TCP 通信的核心，主要用于服务器端和客户端的连接建立过程。\n1. socket()：创建套接字\n作用：初始化一个套接字，返回其描述符（后续操作的句柄）。\n函数原型：\n#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);\n参数解析：\n\n\ndomain：地址族（协议族），指定网络层协议。常见值：\n\nAF_INET：IPv4 协议（最常用）。\nAF_INET6：IPv6 协议。\nAF_UNIX：本地进程间通信（Unix 域套接字）。\n\n\n\ntype：套接字类型，指定传输层协议特性：\n\nSOCK_STREAM：TCP 流式套接字。\nSOCK_DGRAM：UDP 数据报套接字。\n\n\n\nprotocol：具体协议（通常为 0，由系统根据前两个参数自动选择）。\n\n\n返回值：成功返回非负套接字描述符（sockfd），失败返回 - 1（需检查errno）。\n现代 C++ 实践：用智能指针（如std::unique_ptr）配合自定义删除器管理sockfd，避免资源泄漏：\n// 自定义删除器：关闭套接字auto socket_deleter = [](int fd) &#123;   if (fd != -1) ::close(fd); &#125;;using UniqueSocket = std::unique_ptr&lt;int, decltype(socket_deleter)&gt;;// 创建套接字UniqueSocket create_socket() &#123;  int sockfd = ::socket(AF_INET, SOCK_STREAM, 0);  if (sockfd == -1) &#123;    throw std::runtime_error(&quot;socket creation failed: &quot; + std::string(strerror(errno)));  &#125;  return UniqueSocket(new int(sockfd), socket_deleter);&#125;\n2. bind()：绑定地址与端口\n作用：将套接字与特定的 IP 地址和端口号绑定（主要用于服务器端，客户端通常不绑定，由系统自动分配端口）。\n函数原型：\nint bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);\n参数解析：\n\n\nsockfd：socket()返回的套接字描述符。\n\n\naddr：指向地址结构的指针（需根据domain选择对应类型，如 IPv4 用sockaddr_in）。\n\n\naddrlen：地址结构的大小（字节数）。\n\n\n地址结构处理（以 IPv4 为例）：sockaddr是通用地址结构，实际使用时需转换为具体协议的结构（如sockaddr_in）：\nstruct sockaddr_in &#123;  sa_family_t     sin_family;  // 地址族（必须为AF_INET）  uint16_t        sin_port;    // 端口号（需转换为网络字节序）  struct in_addr  sin_addr;    // IP地址（需转换为网络字节序）  char            sin_zero[8]; // 填充字段（通常为0）&#125;;\n字节序转换：网络协议使用大端字节序（网络字节序），而主机可能是小端 / 大端，需用函数转换：\n\n\nhtons()：主机字节序→网络字节序（16 位，用于端口）。\n\n\nhtonl()：主机字节序→网络字节序（32 位，用于 IPv4 地址）。\n\n\ninet_pton()：字符串 IP（如 “127.0.0.1”）→网络字节序的整数（现代 C++ 推荐，替代旧的inet_addr()）。\n\n\n示例：\n// 绑定到IPv4地址127.0.0.1:8080struct sockaddr_in server_addr;memset(&amp;server_addr, 0, sizeof(server_addr));server_addr.sin_family = AF_INET;server_addr.sin_port = htons(8080); // 端口转换为网络字节序// IP地址转换（&quot;0.0.0.0&quot;表示监听所有网络接口）if (inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;server_addr.sin_addr) &lt;= 0) &#123;  throw std::runtime_error(&quot;invalid IP address: &quot; + std::string(strerror(errno)));&#125;// 绑定if (::bind(sockfd, reinterpret_cast&lt;struct sockaddr*&gt;(&amp;server_addr), sizeof(server_addr)) == -1) &#123;  throw std::runtime_error(&quot;bind failed: &quot; + std::string(strerror(errno)));&#125;\n3. listen()：监听连接（服务器端）\n作用：将套接字转为 “监听状态”，允许接收客户端的连接请求（仅用于 TCP 服务器端的sockfd）。\n函数原型：\nint listen(int sockfd, int backlog);\n参数解析：\n\n\nsockfd：已绑定的套接字描述符（bind()之后）。\n\n\nbacklog：未完成连接队列（三次握手未完成）的最大长度（超过则客户端连接失败）。实际值受系统限制（如/proc/sys/net/core/somaxconn），现代系统通常建议设为 128 或更高。\n\n\n返回值：成功返回 0，失败返回 - 1。\n注意：listen()不阻塞，仅设置套接字状态。后续需通过accept()获取实际连接。\n4. accept()：接受连接（服务器端）\n作用：从listen()创建的连接队列中取出一个已完成的连接，返回一个新的套接字描述符（用于与该客户端通信）。\n函数原型：\nint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);\n参数解析：\n\n\nsockfd：处于监听状态的套接字（监听套接字）。\n\n\naddr：输出参数，用于存储客户端的地址信息（可设为nullptr忽略）。\n\n\naddrlen：输入输出参数，传入addr的大小，输出实际存储的地址长度（可设为nullptr）。\n\n\n返回值：成功返回新的套接字描述符（client_fd，用于与客户端通信），失败返回 - 1。\n特性：accept()默认是阻塞函数，直到有客户端连接到达才返回。现代 C++ 中可结合非阻塞 I/O 或多线程处理（如用std::thread为每个新连接创建线程）。\n示例：\nstruct sockaddr_in client_addr;socklen_t client_addr_len = sizeof(client_addr);// 阻塞等待客户端连接int client_fd = ::accept(listen_fd, reinterpret_cast&lt;struct sockaddr*&gt;(&amp;client_addr), &amp;client_addr_len);if (client_fd == -1) &#123;  throw std::runtime_error(&quot;accept failed: &quot; + std::string(strerror(errno)));&#125;// 打印客户端信息（将网络字节序转为字符串）char client_ip[INET_ADDRSTRLEN];inet_ntop(AF_INET, &amp;client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);uint16_t client_port = ntohs(client_addr.sin_port); // 网络字节序→主机字节序std::cout &lt;&lt; &quot;New connection from &quot; &lt;&lt; client_ip &lt;&lt; &quot;:&quot; &lt;&lt; client_port &lt;&lt; std::endl;\n5. connect()：发起连接（客户端）\n作用：客户端通过该函数向服务器发起 TCP 连接（三次握手的触发点）。\n函数原型：\nint connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);\n参数解析：\n\n\nsockfd：客户端的套接字描述符（socket()创建，通常不bind()）。\n\n\naddr：服务器的地址结构（包含服务器 IP 和端口）。\n\n\naddrlen：服务器地址结构的大小。\n\n\n返回值：成功返回 0（连接建立），失败返回 - 1（如服务器未监听、网络不可达等）。\n特性：默认是阻塞函数，直到连接建立或失败才返回。非阻塞模式下，可能返回EINPROGRESS（连接正在建立），需通过select()/poll()等检查状态。\n示例：\n// 客户端连接服务器（127.0.0.1:8080）struct sockaddr_in server_addr;memset(&amp;server_addr, 0, sizeof(server_addr));server_addr.sin_family = AF_INET;server_addr.sin_port = htons(8080);// 转换服务器IPif (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;server_addr.sin_addr) &lt;= 0) &#123;  throw std::runtime_error(&quot;invalid server IP&quot;);&#125;// 发起连接if (::connect(client_fd, reinterpret_cast&lt;struct sockaddr*&gt;(&amp;server_addr), sizeof(server_addr)) == -1) &#123;  throw std::runtime_error(&quot;connect failed: &quot; + std::string(strerror(errno)));&#125;\n三、现代 C++ 最佳实践\n\n\n资源管理：用 RAII（如智能指针、自定义封装类）管理sockfd，避免手动close()导致的泄漏。\n\n\n错误处理：用异常（std::runtime_error）替代传统的if-else检查，提高代码可读性。\n\n\n类型安全：用reinterpret_cast显式转换地址结构，避免隐式转换错误。\n\n\n异步操作：结合 Boost.Asio 或 C++20 的std::net（提案阶段）实现非阻塞 I/O，避免线程阻塞。\n\n\n跨平台：封装系统差异（如 Windows 的WSASend与 Linux 的send），用条件编译或跨平台库。\n\n\n四、总结\nsocket()/bind()/listen()/accept()/connect()是 TCP 通信的 “骨架”：服务器通过socket()创建套接字→bind()绑定地址→listen()监听→accept()接受连接；客户端通过socket()创建套接字→connect()连接服务器。理解这些函数的参数和交互流程，是掌握网络编程的基础。现代 C++ 通过封装和抽象（如智能指针、异常），可让这些底层操作更安全、易维护。\n附: socket 选项\n\n\n\n选项名\n数据类型\n功能描述\n可操作（get/set）\n备注\n\n\n\n\nSOL_SOCKET 级别（通用选项）\n\n\n\n\n\n\nSO_DEBUG\nint (0 / 非 0)\n启用调试模式，内核记录套接字调试信息\nget/set\n仅超级用户可设置\n\n\nSO_REUSEADDR\nint (0 / 非 0)\n允许重用本地地址和端口（如 TIME_WAIT 状态端口复用）\nget/set\n需在 bind 前设置，解决 “地址已被使用” 错误\n\n\nSO_REUSEPORT\nint (0 / 非 0)\n允许多个套接字绑定到同一端口（需同 UID，内核分发数据）\nget/set\n部分系统支持（如 Linux 3.9+），常用于多进程监听同一端口\n\n\nSO_KEEPALIVE\nint (0 / 非 0)\n启用 TCP 保活机制，定期检测对端是否存活\nget/set\n超时时间由系统配置（通常 2 小时无活动后触发）\n\n\nSO_DONTROUTE\nint (0 / 非 0)\n禁止路由，数据仅在本地子网传输\nget/set\n用于本地通信或诊断\n\n\nSO_BROADCAST\nint (0 / 非 0)\n允许发送广播报文\nget/set\n仅适用于 UDP，需在 sendto 前设置\n\n\nSO_SNDBUF\nint\n设置 / 获取发送缓冲区大小（字节）\nget/set\n内核可能调整实际大小（不超过系统上限）\n\n\nSO_RCVBUF\nint\n设置 / 获取接收缓冲区大小（字节）\nget/set\n影响接收性能和拥塞控制，建议在 connect/bind 前设置\n\n\nSO_SNDTIMEO\nstruct timeval\n设置发送操作（send/sendto）的超时时间\nget/set\n超时后返回 EAGAIN/EWOULDBLOCK\n\n\nSO_RCVTIMEO\nstruct timeval\n设置接收操作（recv/recvfrom）的超时时间\nget/set\n同 SO_SNDTIMEO\n\n\nSO_TYPE\nint\n获取套接字类型（如 SOCK_STREAM、SOCK_DGRAM）\nget（不可 set）\n用于判断套接字是 TCP 还是 UDP\n\n\nSO_ERROR\nint\n获取套接字上的待处理错误（如连接失败原因）\nget（不可 set）\n常用于非阻塞 connect 后的错误检查\n\n\nSO_LINGER\nstruct linger\n控制 close 时的延迟关闭行为（等待未发送数据）\nget/set\nstruct linger {int l_onoff; int l_linger;}，l_onoff=1 启用，l_linger 为等待秒数\n\n\nSO_PASSCRED\nint (0 / 非 0)\n允许接收辅助数据中的凭证信息（如 UID/GID）\nget/set\n用于 Unix 域套接字的权限验证\n\n\nSO_PEERCRED\nstruct ucred\n获取对端 Unix 域套接字的用户凭证（UID/GID/PID）\nget（不可 set）\n仅适用于已连接的 Unix 域套接字\n\n\nIPPROTO_IP 级别（IPv4 选项）\n\n\n\n\n\n\nIP_HDRINCL\nint (0 / 非 0)\n应用程序自行构造 IP 头部，不依赖内核\nget/set\n仅超级用户可设置，用于自定义 IP 报文\n\n\nIP_OPTIONS\nvoid *\n设置 / 获取 IP 选项（如源路由、记录路由）\nget/set\n选项数据需符合 IP 协议规范，长度有限制\n\n\nIP_TOS\nint\n设置 / 获取 IP 服务类型（TOS），控制路由优先级\nget/set\n值为 0~255，具体含义见 RFC 规范\n\n\nIP_TTL\nint\n设置 / 获取 IP 生存时间（TTL），限制报文转发跳数\nget/set\n通常设为 64、128 等，超过 TTL 则报文被丢弃\n\n\nIP_MULTICAST_TTL\nu_char\n设置多播报文的 TTL 值\nget/set\n控制多播范围（0 = 本地，1 = 同一子网，…，255 = 全局）\n\n\nIP_MULTICAST_LOOP\nu_char (0/1)\n启用多播报文回环（本地发送的多播自己能否接收）\nget/set\n默认 1（启用），多播应用需根据需求关闭\n\n\nIP_ADD_MEMBERSHIP\nstruct ip_mreq\n加入多播组\nset（不可 get）\nstruct ip_mreq 包含多播组 IP 和本地接口 IP\n\n\nIP_DROP_MEMBERSHIP\nstruct ip_mreq\n退出多播组\nset（不可 get）\n同 IP_ADD_MEMBERSHIP\n\n\nIPPROTO_TCP 级别（TCP 选项）\n\n\n\n\n\n\nTCP_NODELAY\nint (0 / 非 0)\n禁用 Nagle 算法（立即发送小数据包，不延迟合并）\nget/set\n适用于低延迟场景（如实时通信），可能增加网络拥塞\n\n\nTCP_MAXSEG\nint\n设置 / 获取 TCP 最大段大小（MSS）\nget/set\n通常由内核协商，手动设置需谨慎\n\n\nTCP_CORK\nint (0 / 非 0)\n启用 “塞子” 模式，累积数据后一次性发送（类似 Nagle 但更激进）\nget/set\n适用于批量数据发送，需在完成后关闭（避免延迟）\n\n\nTCP_KEEPIDLE\nint\n设置 TCP 保活探测的空闲时间（秒）\nget/set\n需 SO_KEEPALIVE 启用，默认 7200 秒（2 小时）\n\n\nTCP_KEEPINTVL\nint\n设置 TCP 保活探测的间隔时间（秒）\nget/set\n探测未响应时，间隔多久再次发送，默认 75 秒\n\n\nTCP_KEEPCNT\nint\n设置 TCP 保活探测的最大重试次数\nget/set\n超过次数则判定对端不可达，默认 9 次\n\n\n\n说明\n\n\n选项级别说明：SOL_SOCKET为通用选项，IPPROTO_IP为 IPv4 协议选项，IPPROTO_TCP为 TCP 协议选项，还有IPPROTO_UDP（UDP 选项，较少用）等。\n\n\n部分选项为系统特定（如SO_REUSEPORT在不同 OS 上行为可能不同），使用前需参考目标系统的man手册。\n\n\n多播相关选项（如IP_ADD_MEMBERSHIP）需结合多播地址（224.0.0.0~239.255.255.255）使用。\n\n\n","categories":["编程"],"tags":["C++","Linux","网络"]},{"title":"常用套接字函数原型及说明","url":"/2025/08/15/linux/%E5%B8%B8%E7%94%A8%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8F%8A%E8%AF%B4%E6%98%8E/","content":"正向和反向获取主机和服务信息的函数，以及套接字选项设置和获取的函数原型及说明。\n \n一、早期套接字函数原型及说明\n\n[!NOTE]\n以下仅支持解析IPv4 且 不是线程安全的\n\n\n\ngetsockname\n功能：获取套接字本地端的地址信息原型：\n#include &lt;sys/socket.h&gt;int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n说明：sockfd为套接字描述符，addr用于存储本地地址，addrlen传入地址结构体长度，传出实际长度。成功返回 0，失败返回 - 1（设置errno）。\n\n\ngetpeername\n功能：获取套接字对端的地址信息原型：\n#include &lt;sys/socket.h&gt;int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n说明：仅适用于已连接的 TCP 套接字（connect或accept后），参数含义同getsockname。\n\n\ngetsockopt\n功能：获取套接字的选项值原型：\n#include &lt;sys/socket.h&gt;int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);\n说明：level为选项级别（如SOL_SOCKET、IPPROTO_TCP），optname为选项名，optval存储结果，optlen传入缓冲区长度并传出实际使用长度。\n\n\nsetsockopt\n功能：设置套接字的选项值原型：\n#include &lt;sys/socket.h&gt;int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);\n说明：optval为待设置的值，optlen为值的长度，其他参数同getsockopt。部分选项需在bind/connect前设置。\n\n\ngethostbyname\n功能：通过主机名获取主机信息（IPv4）原型：\n#include &lt;netdb.h&gt;struct hostent *gethostbyname(const char *name);\n说明：已过时（仅支持 IPv4），推荐使用getaddrinfo。返回struct hostent指针，失败返回NULL（设置h_errno）。\n\n\ngethostbyaddr\n功能：通过 IP 地址获取主机名（IPv4）原型：\n#include &lt;netdb.h&gt;struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);\n说明：addr为网络字节序的 IP 地址，len为地址长度（如sizeof(struct in_addr)），type为地址族（如AF_INET）。已过时。\n\n\ngetservbyname\n功能：通过服务名和协议获取服务信息原型：\n#include &lt;netdb.h&gt;struct servent *getservbyname(const char *name, const char *proto);\n说明：name为服务名（如&quot;http&quot;），proto为协议（如&quot;tcp&quot;，可为NULL）。返回struct servent指针，包含端口号（网络字节序）。\n\n\ngetservbyport\n功能：通过端口号和协议获取服务信息原型：\n#include &lt;netdb.h&gt;struct servent *getservbyport(int port, const char *proto);\n说明：port为网络字节序的端口号（需用htons转换），其他参数同getservbyname。\nstruct hostent（主机信息结构体）\n用于存储主机的相关信息（如主机名、IP 地址列表等），定义在&lt;netdb.h&gt;中\nstruct hostent &#123;    char  *h_name;        // 主机的官方名称（规范名）    char **h_aliases;     // 主机的别名列表（以NULL结尾的字符串数组）    int    h_addrtype;    // 地址类型（如AF_INET表示IPv4，AF_INET6表示IPv6）    int    h_length;      // 每个地址的长度（字节），如IPv4为4，IPv6为16    char **h_addr_list;   // 主机的IP地址列表（网络字节序，以NULL结尾的指针数组）&#125;;\n字段说明：\n\n\nh_name：主机的正式名称（如www.example.com）。\n\n\nh_aliases：主机的其他别名（如example.com可能是www.example.com的别名），最后一个元素为NULL。\n\n\nh_addrtype：地址族类型，通常为AF_INET（IPv4），但现代系统也可能支持AF_INET6（IPv6）。\n\n\nh_length：每个 IP 地址的长度（IPv4 为 4 字节，IPv6 为 16 字节）。\n\n\nh_addr_list：存储主机的 IP 地址数组（网络字节序），每个元素是in_addr（IPv4）或in6_addr（IPv6）结构体的指针。为方便使用，通常用宏h_addr指代h_addr_list[0]（第一个 IP 地址）。\n\n\nstruct servent（服务信息结构体）\n用于存储网络服务的相关信息（如服务名、端口号、协议等），同样定义在&lt;netdb.h&gt;中。\nstruct servent &#123;    char  *s_name;        // 服务的官方名称（规范名）    char **s_aliases;     // 服务的别名列表（以NULL结尾的字符串数组）    int    s_port;        // 服务对应的端口号（网络字节序）    char  *s_proto;       // 服务使用的协议（如&quot;tcp&quot;或&quot;udp&quot;）&#125;;\n字段说明：\n\n\ns_name：服务的正式名称（如&quot;http&quot;、&quot;ftp&quot;）。\n\n\ns_aliases：服务的其他别名（如&quot;www&quot;可能是&quot;http&quot;的别名），最后一个元素为NULL。\n\n\ns_port：服务对应的端口号，以网络字节序（大端序）存储，使用时需通过ntohs转换为主机字节序。\n\n\ns_proto：服务使用的协议类型（如&quot;tcp&quot;用于面向连接的服务，&quot;udp&quot;用于无连接服务）。\n\n\n\n\n二、现代套接字函数原型及说明\ngetaddrinfo 函数：正向解析（主机名→IP 地址，服务名→端口号）\ngetaddrinfo的核心功能是将主机名（或 IP 字符串） 和服务名（或端口号字符串） 转换为一组用于创建套接字的struct sockaddr结构（套接字地址结构），方便后续的bind、connect等操作。\n1. 函数原型\n#include &lt;netdb.h&gt;int getaddrinfo(const char *node, const char *service,                const struct addrinfo *hints,                struct addrinfo **res);\n2. 参数详解\n\n\n\n参数名\n类型\n含义\n\n\n\n\nnode\nconst char*\n输入参数：主机名（如&quot;www.example.com&quot;）或 IP 地址字符串（如&quot;192.168.1.1&quot;）。若为NULL，结合hints.ai_flags的AI_PASSIVE可用于服务器绑定通配地址（INADDR_ANY）。\n\n\nservice\nconst char*\n输入参数：服务名（如&quot;http&quot;、&quot;ssh&quot;）或端口号字符串（如&quot;80&quot;、&quot;22&quot;）。若为NULL，则不指定端口号（需手动在返回的struct sockaddr中设置）。\n\n\nhints\nconst struct addrinfo*\n输入参数：用于过滤和指定返回结果的 “提示” 结构体。若为NULL，则默认返回所有可能的地址类型（IPv4/IPv6，TCP/UDP 等）。\n\n\nres\nstruct addrinfo**\n输出参数：指向struct addrinfo链表的指针，存储解析结果。需通过freeaddrinfo释放内存。\n\n\n\n3. 关键结构体：struct addrinfo\nhints和res均为struct addrinfo类型，其定义如下：\nstruct addrinfo &#123;    int ai_flags;           // 标志位（见下文）    int ai_family;          // 地址族（如AF_INET、AF_INET6、AF_UNSPEC）    int ai_socktype;        // 套接字类型（如SOCK_STREAM、SOCK_DGRAM）    int ai_protocol;        // 协议（如IPPROTO_TCP、IPPROTO_UDP，0表示任意）    socklen_t ai_addrlen;   // ai_addr指向的地址结构的长度    char *ai_canonname;     // 主机的规范名称（若指定AI_CANONNAME标志）    struct sockaddr *ai_addr; // 指向套接字地址结构（sockaddr_in或sockaddr_in6）    struct addrinfo *ai_next; // 链表下一个节点（可能有多个解析结果）&#125;;\n其中核心字段说明：\n\n\nai_family：指定地址族，AF_INET（仅 IPv4）、AF_INET6（仅 IPv6）、AF_UNSPEC（不限制，返回所有可能）。\n\n\nai_socktype：指定套接字类型，SOCK_STREAM（TCP）、SOCK_DGRAM（UDP）、0（任意类型）。\n\n\nai_protocol：指定协议，IPPROTO_TCP（TCP）、IPPROTO_UDP（UDP）、0（任意协议）。\n\n\nai_flags：常用标志（可组合使用，按位或）：\n\nAI_PASSIVE：用于服务器，node为NULL时，返回的地址将是通配地址（INADDR_ANY for IPv4，in6addr_any for IPv6），适合bind。\nAI_CANONNAME：要求返回主机的规范名称（存储在ai_canonname）。\nAI_NUMERICHOST：node必须是 IP 地址字符串（不进行域名解析），否则返回错误。\nAI_NUMERICSERV：service必须是端口号字符串（不解析服务名），否则返回错误。\n\n\n\n4. 返回值\n\n\n成功：返回0，res指向解析结果链表（可能有多个地址，需遍历处理）。\n\n\n失败：返回非 0 错误码（如EAI_NONAME表示主机名无效），可通过gai_strerror(err)获取错误信息字符串。\n\n\n5. 内存释放\n解析完成后，必须通过freeaddrinfo释放res指向的链表内存，避免泄漏：\nvoid freeaddrinfo(struct addrinfo *res);\n6. 使用场景\n\n\n客户端：将服务器主机名（如&quot;www.baidu.com&quot;）和服务名（如&quot;http&quot;）解析为struct sockaddr，用于connect。\n\n\n服务器：将NULL（主机名）和服务名（如&quot;8080&quot;）解析为通配地址（结合AI_PASSIVE），用于bind。\n\n\ngetnameinfo 函数：反向解析（IP 地址→主机名，端口号→服务名）\ngetnameinfo是getaddrinfo的反向操作：将struct sockaddr（套接字地址结构，包含 IP 和端口）转换为主机名和服务名。\n1. 函数原型\n#include &lt;netdb.h&gt;int getnameinfo(const struct sockaddr *addr, socklen_t addrlen,                char *host, socklen_t hostlen,                char *serv, socklen_t servlen,                int flags);\n2. 参数详解\n\n\n\n参数名\n类型\n含义\n\n\n\n\naddr\nconst struct sockaddr*\n输入参数：指向struct sockaddr（或sockaddr_in/sockaddr_in6）的指针，包含待解析的 IP 和端口。\n\n\naddrlen\nsocklen_t\n输入参数：addr指向的地址结构的长度（如sizeof(struct sockaddr_in)）。\n\n\nhost\nchar*\n输出参数：存储主机名的缓冲区（若为NULL，则不获取主机名）。\n\n\nhostlen\nsocklen_t\n输入参数：host缓冲区的大小（字节）。\n\n\nserv\nchar*\n输出参数：存储服务名的缓冲区（若为NULL，则不获取服务名）。\n\n\nservlen\nsocklen_t\n输入参数：serv缓冲区的大小（字节）。\n\n\nflags\nint\n输入参数：控制解析行为的标志（见下文）。\n\n\n\n3. 关键标志（flags）\n\n\nNI_NAMEREQD：若无法解析主机名（如无 DNS 记录），则返回错误（EAI_NONAME），不返回 IP 字符串。\n\n\nNI_NUMERICHOST：强制返回 IP 地址字符串（不解析为主机名）。\n\n\nNI_NUMERICSERV：强制返回端口号字符串（不解析为服务名）。\n\n\nNI_DGRAM：表示是 UDP 服务（默认假设是 TCP，某些服务名在 TCP 和 UDP 中可能不同）。\n\n\n4. 返回值\n\n\n成功：返回0，host和serv缓冲区分别存储主机名和服务名（若对应参数非NULL）。\n\n\n失败：返回非 0 错误码，可通过gai_strerror(err)获取错误信息。\n\n\n5. 使用场景\n\n\n服务器：获取客户端连接的 IP 对应的主机名（如日志记录）。\n\n\n网络工具：将套接字地址转换为人类可读的主机名和服务名（如netstat显示www.baidu.com:http而非180.101.50.242:80）。\n\n\n示例代码片段\n1. getaddrinfo 示例（解析主机名和服务名）\n#include &lt;iostream&gt;#include &lt;netdb.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123;    const char* host = &quot;www.baidu.com&quot;; // 主机名    const char* service = &quot;http&quot;;       // 服务名（对应80端口）        struct addrinfo hints, *res, *p;    memset(&amp;hints, 0, sizeof(hints));    hints.ai_family = AF_UNSPEC;    // 不限制IPv4/IPv6    hints.ai_socktype = SOCK_STREAM; // TCP        int status = getaddrinfo(host, service, &amp;hints, &amp;res);    if (status != 0) &#123;        std::cerr &lt;&lt; &quot;getaddrinfo error: &quot; &lt;&lt; gai_strerror(status) &lt;&lt; std::endl;        return 1;    &#125;        // 遍历解析结果    for (p = res; p != nullptr; p = p-&gt;ai_next) &#123;        char ipstr[INET6_ADDRSTRLEN]; // 足够存储IPv6地址的缓冲区        void* addr;                // 判断是IPv4还是IPv6        if (p-&gt;ai_family == AF_INET) &#123;            struct sockaddr_in* ipv4 = (struct sockaddr_in*)p-&gt;ai_addr;            addr = &amp;(ipv4-&gt;sin_addr);        &#125; else &#123;            struct sockaddr_in6* ipv6 = (struct sockaddr_in6*)p-&gt;ai_addr;            addr = &amp;(ipv6-&gt;sin6_addr);        &#125;                // 转换为字符串        inet_ntop(p-&gt;ai_family, addr, ipstr, sizeof(ipstr));        std::cout &lt;&lt; &quot;IP地址: &quot; &lt;&lt; ipstr &lt;&lt; std::endl;    &#125;        freeaddrinfo(res); // 释放内存    return 0;&#125;\n2. getnameinfo 示例（解析 IP 地址和端口）\n#include &lt;iostream&gt;#include &lt;netdb.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123;    struct sockaddr_in addr; // IPv4地址结构    memset(&amp;addr, 0, sizeof(addr));    addr.sin_family = AF_INET;    addr.sin_port = htons(80); // 端口80    inet_pton(AF_INET, &quot;180.101.50.242&quot;, &amp;addr.sin_addr); // 百度的一个IP        char host[NI_MAXHOST];   // 主机名缓冲区    char serv[NI_MAXSERV];   // 服务名缓冲区        // 解析：获取主机名和服务名    int status = getnameinfo((struct sockaddr*)&amp;addr, sizeof(addr),                             host, sizeof(host),                             serv, sizeof(serv),                             0); // 不使用特殊标志        if (status != 0) &#123;        std::cerr &lt;&lt; &quot;getnameinfo error: &quot; &lt;&lt; gai_strerror(status) &lt;&lt; std::endl;        return 1;    &#125;        std::cout &lt;&lt; &quot;主机名: &quot; &lt;&lt; host &lt;&lt; std::endl; // 可能输出&quot;www.baidu.com&quot;    std::cout &lt;&lt; &quot;服务名: &quot; &lt;&lt; serv &lt;&lt; std::endl; // 输出&quot;http&quot;    return 0;&#125;\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"IO复用+定时","url":"/2025/08/12/linux/IO%E5%A4%8D%E7%94%A8%20+%20%E5%AE%9A%E6%97%B6/","content":"\n学习IO复用和定时操作时，利用AI生成的示例\n\n\nIO复用 + 定时\n#include &lt;chrono&gt;#include &lt;cerrno&gt;#include &lt;cstdio&gt;#include &lt;sys/epoll.h&gt;// 定义超时时间常量（5秒）const std::chrono::steady_clock::duration TIMEOUT = std::chrono::milliseconds(5000);// 预计算超时毫秒数，避免重复转换const int TIMEOUT_MS = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(TIMEOUT).count();int main() &#123;    // 假设已初始化epfd、events和MAX_EVENTS_NUM    int epfd = -1;    struct epoll_event events[1024];  // 示例大小    const int MAX_EVENTS_NUM = 1024;    int timeout = TIMEOUT_MS;  // 初始超时时间    std::chrono::steady_clock::time_point start;    std::chrono::steady_clock::time_point end;    while (true) &#123;        start = std::chrono::steady_clock::now();        int event_count = epoll_wait(epfd, events, MAX_EVENTS_NUM, timeout);        // 处理epoll_wait错误        if (event_count &lt; 0) &#123;            if (errno != EINTR) &#123;  // 非信号中断的错误才退出                std::perror(&quot;epoll_wait failed&quot;);                break;            &#125;            // 信号中断则继续等待，不修改超时时间            continue;        &#125;        // 处理超时情况        else if (event_count == 0) &#123;            // 超时后重置超时时间            timeout = TIMEOUT_MS;            // 可以添加超时处理逻辑            continue;        &#125;        // 计算实际等待时间（毫秒）        end = std::chrono::steady_clock::now();        auto elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count();                // 更新剩余超时时间        timeout -= static_cast&lt;int&gt;(elapsed);        // 确保超时时间不会为负        if (timeout &lt; 0) &#123;            timeout = 0;        &#125;        // 处理事件（示例）        // handle_events(events, event_count);    &#125;    return 0;&#125;\n核心逻辑：用 epoll_wait 的“超时”实现定时\nepoll_wait 是 Linux 下 I/O 复用的核心系统调用，它有一个超时参数（代码里的 timeout）：\n\n\n如果在 timeout 时间内，没有 I/O 事件就绪，epoll_wait 会返回 0，表示“超时”。\n\n\n如果有 I/O 事件就绪，epoll_wait 会返回就绪的事件数量（大于 0），并提前返回。\n\n\n代码正是利用“epoll_wait 超时返回 0”这个特性，来实现定时触发。\n以下是这种 “IO 复用 + 定时” 模式的典型应用场景：\n\n\n高性能网络服务器\n\n\n\n\n场景描述：如 Web 服务器、游戏服务器等，需要同时处理大量客户端连接（I/O 事件），同时还需执行定时任务（如定时清理空闲连接、定时推送心跳包、定时统计服务器状态等）。\n\n\n示例：一个 Web 服务器，既需要处理客户端的 HTTP 请求（I/O 事件），又需要每 5 秒检查一次所有连接，关闭长时间无活动的连接（定时任务）。使用该模式可以在同一个线程中高效完成这两类操作，避免多线程开销。\n\n\n\n\n网络监控与管理系统\n\n\n\n\n场景描述：需要监控多个网络设备的状态（通过 I/O 读取设备数据），同时定时生成监控报告、定时发送告警信息。\n\n\n示例：一个服务器集群监控系统，需要实时监听各服务器的状态变化（I/O 事件），同时每 1 分钟生成一次性能统计报表（定时任务）\n\n\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"ASan的使用","url":"/2025/08/11/C++/ASan%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"如何使用ASan检测内存错误及其使用方法\n \nAddressSanitizer（ASan）详解：使用场景、注意事项及扩展知识\nAddressSanitizer（简称 ASan）是由 Google 开发的基于编译器的内存错误检测工具，集成于 GCC 4.8+、Clang 3.1 + 及 MSVC 2019 + 中。它能精准检测多种内存安全问题（如缓冲区溢出、使用已释放内存等），是 C/C++ 开发中排查内存错误的核心工具\n一、ASan 的核心功能\nASan 主要检测以下内存错误类型：\n\n\n栈 / 堆 / 全局缓冲区溢出（越界读写）；\n\n\n使用已释放内存（use-after-free）；\n\n\n双重释放（double-free）或释放无效指针；\n\n\n内存泄漏（需配合 LeakSanitizer，LSan）；\n\n\n部分未初始化内存的使用（更全面的检测需 MemorySanitizer，MSan）；\n\n\n栈 - use-after-return/scope（离开作用域后使用栈内存）。\n\n\n二、不同场景下的使用方法\n1. 基础编译场景（直接编译单个文件）\nASan 的使用依赖编译器插桩，需在编译和链接阶段同时添加选项。\n\n\n核心编译选项：-fsanitize=address：启用 ASan 检测；-g：生成调试信息（用于定位错误位置）；\n-O1/-O2：优化级别（-O0可使用但性能差，-O3可能因优化掩盖部分错误，推荐-O1）。\n\n\n示例（Clang/GCC）：假设有文件test.c（含堆缓冲区溢出）：\n#include &lt;stdlib.h&gt;int main() &#123;  int *arr = (int*)malloc(4 * sizeof(int)); // 分配4个int（16字节）  arr[4] = 0; // 越界写入（索引4超出范围）  free(arr);  return 0;&#125;\n编译并运行：\nclang -fsanitize=address -g -O1 test.c -o test  # 编译./test                                          # 运行\n输出将直接提示 “堆缓冲区溢出”，并显示错误位置（test.c:4）、调用栈及内存分配信息。\n\n\n2. 与构建工具集成（CMake/Makefile）\n在大型项目中，需通过构建工具统一配置 ASan 选项。\n\n\nCMake 集成：在CMakeLists.txt中添加：\n# 对C/C++均启用ASanset(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -fsanitize=address -g -O1&quot;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -fsanitize=address -g -O1&quot;)# 链接阶段同样需要ASan选项set(CMAKE_EXE_LINKER_FLAGS &quot;$&#123;CMAKE_EXE_LINKER_FLAGS&#125; -fsanitize=address&quot;)set(CMAKE_SHARED_LINKER_FLAGS &quot;$&#123;CMAKE_SHARED_LINKER_FLAGS&#125; -fsanitize=address&quot;)\n\n\nMakefile 集成：在Makefile中添加：\nCFLAGS += -fsanitize=address -g -O1   # C编译选项CXXFLAGS += -fsanitize=address -g -O1 # C++编译选项LDFLAGS += -fsanitize=address         # 链接选项\n\n\n3. 多线程程序检测\nASan 对多线程程序同样有效，可检测线程中的内存越界、use-after-free 等问题（但线程竞争需 ThreadSanitizer，TSan）。\n\n\n示例：多线程堆越界\n#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;int *arr;void *thread_func(void *arg) &#123;  arr[10] = 0; // 越界写入（假设仅分配8个int）  return NULL;&#125;int main() &#123;  arr = (int*)malloc(8 * sizeof(int));  pthread_t t;  pthread_create(&amp;t, NULL, thread_func, NULL);  pthread_join(t, NULL);  free(arr);  return 0;&#125;\ngcc -fsanitize=address -g -O1 -pthread test.c -o test\n运行后 ASan 会定位到线程函数中的越界位置。\n\n\n4. 与调试工具（GDB）结合\n当 ASan 检测到错误时，程序会崩溃，此时可通过 GDB 进一步调试。\n\n\n步骤：\n\n用 ASan 编译程序（保留-g选项）；\n用 GDB 启动程序：gdb ./test；\n在 GDB 中运行：(gdb) run；\n触发错误后，使用bt（查看调用栈）、frame N（切换到第 N 帧）定位代码细节。\n\n\n\n5. 平台差异（Linux/macOS/Windows）\n\n\nLinux：支持最完善，GCC/Clang 均无显著限制；\n\n\nmacOS：需使用 Clang（系统默认编译器），GCC 支持有限；\n\n\nWindows：\n\nClang：与 Linux 用法一致（需安装 LLVM）；\nMSVC 2019+：通过/fsanitize=address启用（选项格式与 GCC/Clang 不同，且部分功能有差异）。\n\n\n\n6. 内存泄漏检测（配合 LSan）\nASan 默认不检测内存泄漏，需手动启用 LeakSanitizer（LSan）。\n\n\n启用方法：\n\nClang：直接添加-fsanitize=address,leak；\nGCC：通过环境变量启用：export ASAN_OPTIONS=detect_leaks=1。\n\n\n\n示例：检测内存泄漏\n#include &lt;stdlib.h&gt;int main() &#123;  int *p = (int*)malloc(4); // 未释放  return 0;&#125;\nclang -fsanitize=address,leak -g test.c -o test./test\n输出会提示 “2 个字节的内存泄漏”，并显示分配位置。\n\n\n三、注意事项\n1. 性能开销不可忽视\n\n\n运行速度：程序会慢 2-5 倍（因插入大量检测代码）；\n\n\n内存占用：增加 2-3 倍（需维护 “影子内存”）；\n\n\n适用场景：仅用于开发 / 测试环境，禁止在生产环境启用。\n\n\n2. 编译选项必须完整\n\n\n编译（-c）和链接（-o）阶段均需添加-fsanitize=address，否则会出现链接错误（如 “undefined reference to `__asan_init’”）。\n\n\n3. 优化级别影响检测效果\n\n\n避免使用-O3：高优化可能导致编译器重排代码，掩盖内存错误（如合并相邻内存访问）；\n\n\n推荐-O1或-O2：平衡性能与检测精度。\n\n\n4. 符号表是定位错误的关键\n\n\n必须添加-g选项：否则 ASan 报告仅显示内存地址，无法关联到文件名和行号；\n\n\n若依赖第三方库，需确保其编译时也带-g（否则调用栈中库函数位置可能显示为 “unknown”）。\n\n\n5. 与其他工具的冲突与兼容\n\n\n冲突：不能与 TSan（-fsanitize=thread）同时使用（两者插桩逻辑冲突）；\n\n\n兼容：可与 UBSan（-fsanitize=undefined）同时使用（检测未定义行为，如整数溢出），例如：\nclang -fsanitize=address,undefined -g test.c -o test\n\n\n6. 环境变量配置（ASAN_OPTIONS）\nASan 通过环境变量ASAN_OPTIONS调整行为，常用参数：\n\n\ndetect_leaks=1：启用内存泄漏检测（默认 0）；\n\n\nmalloc_context_size=30：设置内存分配 / 释放的调用栈深度（默认 10，加深可更清晰定位来源）；\n\n\nfast_unwind_on_malloc=0：使用精确 unwind（而非快速），调用栈更准确但速度慢（默认 1）；\n\n\nquarantine_size_mb=1024：设置 “隔离区” 大小（已释放内存暂存区域，调大可检测更多 use-after-free）。\n\n\n示例：\nexport ASAN_OPTIONS=&quot;detect_leaks=1:malloc_context_size=20:fast_unwind_on_malloc=0&quot;\n7. 部分错误可能漏检\n\n\n微小越界（如 1 字节）：若未触及影子内存的 “红色区域”（标记为无效的内存），可能不被检测；\n\n\n复杂未初始化内存使用：需 MSan（-fsanitize=memory）补充检测（但需重新编译所有依赖库）。\n\n\n四、扩展知识\n1. ASan 工作原理（影子内存机制）\nASan 通过 “影子内存（shadow memory）” 跟踪用户内存状态：\n\n\n每 8 字节用户内存对应 1 字节影子内存（影子内存总大小为用户内存的 1/8）；\n\n\n影子内存标记内存状态：0（可访问）、1-7（部分可访问）、0xF1（已释放）、0xF2（越界区域）等；\n\n\n编译器在内存访问（读 / 写）处插入检测代码，检查对应影子内存状态，若非法则触发错误并输出报告。\n\n\n2. 与其他 Sanitizer 的区别\n\n\n\n工具\n检测目标\n与 ASan 兼容性\n特点\n\n\n\n\nLSan\n内存泄漏\n兼容（可联合使用）\n轻量，依赖 ASan 基础\n\n\nMSan\n使用未初始化内存\n不兼容\n需全链路重编译，精度高\n\n\nTSan\n线程竞争\n不兼容\n专用于多线程同步错误\n\n\nUBSan\n未定义行为（如整数溢出）\n兼容\n可与 ASan 联合使用，覆盖更广\n\n\n\n3. 最佳实践\n\n\n开发阶段：对核心模块启用 ASan，定期运行单元测试；\n\n\nCI/CD 流程：将 ASan 检测作为代码提交的 “门禁”，提前拦截内存错误；\n\n\n结合调试：用 GDB 解析 ASan 崩溃现场，定位错误根源；\n\n\n多工具协同：先用 ASan 检测基础内存错误，再用 TSan 检测线程问题，最后用 LSan 查漏内存泄漏。\n\n\n4. 局限性\n\n\n无法检测逻辑错误（如内存访问正确但值错误）；\n\n\n对自定义内存分配器（如jemalloc）支持有限，可能需要额外配置；\n\n\n性能开销大，无法用于生产环境的性能测试。\n\n\n","categories":["编程"],"tags":["C++","工具"]},{"title":"事件处理模式","url":"/2025/08/11/linux/%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/","content":"AI生成，未完全消化……\n \n一、Reactor 模式（反应器模式）\n核心思想：基于 “事件驱动”，通过一个集中式的事件循环等待事件发生，再将事件分发给对应的处理器处理。其核心是 “等待事件→分发处理” 的同步触发机制。\n1. 核心组件\n\n\n事件源（Event Source）：产生事件的实体，如网络套接字（socket）、文件描述符（fd）等。\n\n\n事件多路分发器（Event Multiplexer）：监听事件源，当事件就绪时通知反应器（如 Linux 的epoll、poll，Windows 的select）。\n\n\n事件处理器（EventHandler）：定义事件处理接口（如handleRead()、handleWrite()），由具体业务逻辑实现。\n\n\n反应器（Reactor）：协调事件多路分发器和事件处理器，负责注册 / 注销事件、分发就绪事件。\n\n\n2. 工作流程\n\n\n应用程序向 Reactor 注册事件（如 “读就绪”）及对应的处理器；\n\n\nReactor 通过事件多路分发器阻塞等待事件就绪；\n\n\n当事件就绪（如 socket 可读），事件多路分发器通知 Reactor；\n\n\nReactor 根据事件类型调用对应处理器的处理方法（如handleRead()）；\n\n\n处理器完成业务逻辑（如读取数据、解析协议）。\n\n\n3. 关键特性\n\n\n同步 I/O 模型：I/O 操作（如read()/write()）由应用程序主动发起，Reactor 仅负责 “通知事件就绪”，不参与实际 I/O。\n\n\n优势：实现简单，无操作系统异步 I/O 依赖，适合 I/O 密集型场景（如高并发网络服务器）。\n\n\n劣势：若处理器处理耗时任务（如复杂计算），会阻塞事件循环，导致其他事件延迟处理。\n\n\n4. C++ 应用示例\n\n\n知名网络库muduo（陈硕实现）基于 Reactor 模式，用epoll作为事件多路分发器，配合线程池处理耗时任务。\n\n\n代码框架示意：\n// 事件处理器接口class EventHandler &#123;public:    virtual void handleRead() = 0;    virtual void handleWrite() = 0;    virtual int getFd() = 0; // 获取事件源fd&#125;;// Reactor核心class Reactor &#123;public:    void registerHandler(EventHandler* handler, int events); // 注册事件    void removeHandler(EventHandler* handler); // 注销事件    void loop() &#123; // 事件循环        while (true) &#123;            // 调用epoll_wait等待事件就绪            int n = epoll_wait(epfd, events, MAX_EVENTS, -1);            for (int i = 0; i &lt; n; ++i) &#123;                EventHandler* handler = (EventHandler*)events[i].data.ptr;                if (events[i].events &amp; EPOLLIN) &#123;                    handler-&gt;handleRead(); // 分发读事件                &#125;                if (events[i].events &amp; EPOLLOUT) &#123;                    handler-&gt;handleWrite(); // 分发写事件                &#125;            &#125;        &#125;    &#125;&#125;;\n\n\n二、Proactor 模式（前摄器模式）\n核心思想：基于 “异步 I/O”，由操作系统完成实际 I/O 操作后，通知应用程序处理 I/O 结果。其核心是 “发起异步 I/O→等待完成→处理结果”。\n1. 核心组件\n\n\n异步操作处理器（Async Operation Processor）：由操作系统提供，负责执行异步 I/O（如读取数据到缓冲区）。\n\n\n完成事件队列（Completion Queue）：存储 I/O 操作完成的结果（如数据、错误码）。\n\n\n完成事件多路分发器：监听完成事件队列，通知 Proactor 有 I/O 完成。\n\n\nProactor：协调异步操作和结果处理，将完成事件分发给处理器。\n\n\n完成处理器（Completion Handler）：处理 I/O 完成后的业务逻辑（如解析数据）。\n\n\n2. 工作流程\n\n\n应用程序发起异步 I/O 请求（如aio_read），指定缓冲区、回调处理器，并注册到 Proactor；\n\n\n操作系统的异步操作处理器执行 I/O（如从 socket 读取数据到缓冲区）；\n\n\nI/O 完成后，操作系统将结果放入完成事件队列；\n\n\nProactor 通过完成事件多路分发器检测到完成事件，调用对应完成处理器；\n\n\n处理器处理 I/O 结果（如解析缓冲区数据）。\n\n\n3. 关键特性\n\n\n异步 I/O 模型：I/O 操作由操作系统完成，应用程序仅处理结果，避免 I/O 阻塞。\n\n\n优势：适合高并发场景，I/O 效率高（无应用程序轮询或阻塞等待）。\n\n\n劣势：依赖操作系统异步 I/O 支持（如 Windows 的 IOCP、Linux 的io_uring），实现复杂，移植性差。\n\n\n4. C++ 应用示例\n\n\nLinux 下可基于io_uring实现 Proactor，Windows 可基于 IOCP。\n\n\n代码框架示意（简化io_uring用法）：\n// 完成处理器class CompletionHandler &#123;public:    virtual void handleCompletion(ssize_t res) = 0; // 处理I/O结果&#125;;// Proactor核心class Proactor &#123;public:    // 发起异步读    void asyncRead(int fd, void* buf, size_t len, CompletionHandler* handler) &#123;        // 提交io_uring异步读请求        struct io_uring_sqe* sqe = io_uring_get_sqe(&amp;ring);        io_uring_prep_read(sqe, fd, buf, len, 0);        sqe-&gt;user_data = (uint64_t)handler; // 绑定处理器        io_uring_submit(&amp;ring);    &#125;    void loop() &#123; // 事件循环        while (true) &#123;            struct io_uring_cqe* cqe;            io_uring_wait_cqe(&amp;ring, &amp;cqe); // 等待I/O完成            CompletionHandler* handler = (CompletionHandler*)cqe-&gt;user_data;            handler-&gt;handleCompletion(cqe-&gt;res); // 处理结果            io_uring_cqe_seen(&amp;ring, cqe);        &#125;    &#125;&#125;;\n\n\n并发编程模式\n一、半同步 / 半异步模式（Half-Sync/Half-Async）\n核心思想：将系统分为 “异步层” 和 “同步层”，异步层处理 I/O 事件，同步层处理业务逻辑，通过队列连接两层，平衡效率与复杂度。\n1. 三层结构\n\n\n异步层：采用 Reactor 模式处理 I/O 事件（如接收连接、读写数据），不阻塞，高效响应事件。\n\n\n同步层：由线程池组成，同步执行业务逻辑（如协议解析、事务处理），避免异步层被耗时任务阻塞。\n\n\n任务队列：异步层将待处理的任务（如 “解析请求”）放入队列，同步层线程从队列取任务执行。\n\n\n2. 工作流程\n\n\n异步层（Reactor）接收网络事件（如客户端请求），将请求封装为任务；\n\n\n异步层将任务放入任务队列；\n\n\n同步层的线程池从队列中取任务，同步执行业务逻辑（如数据库操作）；\n\n\n业务处理完成后，结果通过队列返回给异步层，由异步层发送响应。\n\n\n3. 关键特性\n\n\n分离 I/O 与业务：异步层专注高效 I/O，同步层专注复杂业务，降低耦合。\n\n\n优势：兼顾高并发 I/O 和复杂业务处理，避免单一线程阻塞整个系统。\n\n\n劣势：任务队列可能成为瓶颈（需考虑线程安全和队列长度）；线程池管理增加复杂度。\n\n\n4. C++ 应用示例\n\n\n多数商业服务器框架采用此模式，如 Nginx（异步层处理连接，同步进程处理请求）。\n\n\n代码框架示意：\n// 异步层（Reactor）class AsyncLayer &#123;public:    void onRequest(Request* req) &#123;        taskQueue.push(req); // 请求放入队列        cond.notify_one(); // 唤醒同步层线程    &#125;&#125;;// 同步层（线程池）class SyncLayer &#123;public:    SyncLayer() &#123;        for (int i = 0; i &lt; 4; ++i) &#123; // 4个工作线程            threads.emplace_back([this]() &#123;                while (true) &#123;                    std::unique_lock&lt;std::mutex&gt; lock(mtx);                    cond.wait(lock, []&#123; return !taskQueue.empty(); &#125;);                    Request* req = taskQueue.front();                    taskQueue.pop();                    lock.unlock();                    processRequest(req); // 同步处理业务                &#125;            &#125;);        &#125;    &#125;&#125;;\n\n\n二、领导 / 追随者模式（Leader/Follower）\n核心思想：线程池中的线程轮流担任 “领导者”，领导者负责等待事件；事件到来后，领导者指定一个 “追随者” 成为新领导者，自己转为 “处理者” 处理事件；处理完成后回归追随者队列。\n1. 核心组件\n\n\n线程池：包含多个相同角色的线程（领导者 / 追随者 / 处理者）。\n\n\n事件多路分发器：仅由当前领导者持有，用于等待事件。\n\n\n事件队列：暂存待处理事件（可选，用于批量处理）。\n\n\n线程屏障（Barrier）：协调线程角色切换（如领导者选举）。\n\n\n2. 工作流程\n\n\n初始时，一个线程成为领导者，其他为追随者；\n\n\n领导者通过事件多路分发器等待事件；\n\n\n事件到来后，领导者从追随者中选一个线程作为新领导者（接管事件多路分发器）；\n\n\n原领导者转为处理者，处理当前事件；\n\n\n处理完成后，处理者变回追随者，等待下次选举。\n\n\n3. 关键特性\n\n\n无锁设计：线程角色切换通过屏障协调，避免锁竞争，减少开销。\n\n\n优势：适合短任务处理（如事件分发），线程切换效率高，适合高并发场景。\n\n\n劣势：不适合长任务（会阻塞领导者选举，导致事件处理延迟）；实现复杂（需精细控制线程状态）。\n\n\n4. C++ 应用示例\n\n\n常用于高性能事件驱动框架（如 ACE 库的ACE_Leader_Follower）。\n\n\n核心逻辑示意：\nclass LeaderFollower &#123;public:    void run() &#123;        while (true) &#123;            if (isLeader()) &#123;                // 领导者等待事件                Event* event = eventDemux.wait();                // 选新领导者                Thread* newLeader = selectFollower();                newLeader-&gt;becomeLeader();                // 处理事件                processEvent(event);                // 变回追随者                becomeFollower();            &#125; else &#123;                // 追随者等待成为领导者                barrier.wait();            &#125;        &#125;    &#125;&#125;;\n\n\n总结与对比\n\n\n\n模式\n核心机制\n适用场景\n典型依赖 / 库\n\n\n\n\nReactor\n同步事件驱动（等事件→处理）\n高并发 I/O、短任务\nepoll、muduo\n\n\nProactor\n异步 I/O（OS 完成 I/O→通知）\n超大规模并发、异步 I/O 支持\nIOCP、io_uring\n\n\n半同步 / 半异步\n异步 I/O + 同步业务 + 任务队列\n复杂业务 + 高并发 I/O\n线程池 + Reactor\n\n\n领导 / 追随者\n线程轮流领导 + 无锁处理\n高并发短任务、事件分发\nACE 库、自定义线程池\n\n\n\n在 C++ 网络编程中，Reactor 模式因实现简单且兼容性好，是最常用的基础模式；Proactor 适合对性能要求极高且依赖特定 OS 的场景；半同步 / 半异步是架构级设计，平衡了效率与业务复杂度；领导 / 追随者则适合追求极致性能的短任务处理场景\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"不从main开始执行C++程序","url":"/2025/08/09/C++/%E5%A6%82%E4%BD%95%E8%AE%A9C++%E7%A8%8B%E5%BA%8F%E4%B8%8D%E4%BB%8Emain%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C/","content":"\n在看蒋炎炎老师的OS课后一段时间记录下的操作，记得当时实现了另一种作法，但未及时记录，现在也忘了怎么复刻😅\n\n\n如何让C/C++程序不从main开始执行\n一、核心操作步骤（以 GCC/G++ 为例）\n以test.cpp为例，代码需手动定义_start（汇编级入口，需处理系统调用），而非main。\n1. 编写示例代码\n_start是 Linux 内核规定的程序入口（ELF 文件格式定义），需用汇编或内嵌汇编实现系统调用（如exit），否则程序会崩溃。\n// test.cppvoid _start() &#123;    // 内嵌汇编：调用Linux系统调用 exit(0)，避免程序异常退出    asm volatile (        &quot;mov $60, %rax;&quot;  // 系统调用号：60对应exit        &quot;mov $0, %rdi;&quot;   // 退出码：0（成功）        &quot;syscall;&quot;        // 触发系统调用    );&#125;\n2. 编译与链接参数\n关键参数用于禁用自动链接的初始化代码和指定入口点，分两步执行或合并为一条命令：\n\n\n分步执行：\n\n编译为目标文件（仅编译，不链接）：g++ -c test.cpp -o test.o\n链接为可执行文件（禁用 libc 和 crt0）：ld -o test test.o -nostdlib -e _start\n\n\n\n合并执行（更简洁）：\ng++ -o test test.cpp -nostdlib -e _start\n\n\ng++ test.cpp -nostartfiles -nostdlib -static -o test\n\n\n\n\n\n参数\n作用说明\n\n\n\n\n-nostdlib\n不链接 C 标准库（libc）和运行时初始化代码（crt0、crtbegin 等），这是核心\n\n\n-e _start\n显式指定程序入口点为_start（默认入口由 crt0 定义，最终调用main）\n\n\n\n二、必须注意的 3 个关键点\n\n\n不能使用任何 C++/C 标准库功能\n由于-nostdlib禁用了 libc，cout、printf、new、malloc、string等所有依赖标准库的代码都会编译失败，甚至return语句也无效（需手动调用系统调用退出）。\n\n\n必须手动处理程序退出\n内核要求程序通过系统调用（如exit）终止，若_start执行完直接返回，会触发内核异常（段错误）。示例中通过内嵌汇编调用exit(0)，是唯一正确的退出方式。\n\n\nC++ 的 “高级特性” 失效\n没有运行时初始化代码（crt0），C++ 的全局对象构造 / 析构、虚函数表初始化、异常处理（try/catch）等功能全部无法工作，代码本质退化为 “用 C++ 语法写的汇编级程序”。\n\n\n三、背后的底层原理\n核心是揭开 “main 函数是入口” 的假象，理解程序从内核加载到执行main的完整链路：\n\n\n内核加载程序时的入口是_start\nLinux 下可执行文件为 ELF 格式，ELF 头中会记录 “程序入口地址”。默认情况下，链接器会将入口地址设为crt0.o（C 运行时初始化文件）中的_start符号，这是内核执行的第一个函数，而非main。\n\n\nmain是被crt0调用的 “用户级入口”\n默认流程（未禁用 [1] 时）：内核加载→执行crt0的_start→初始化libc（堆、全局变量、I/O等）→调用main→main返回后调用exit→程序终止\n可见，main是 crt0 为用户代码提供的 “封装入口”，而非内核直接调用的入口。\n\n\n-nostdlib和-e _start的本质\n\n-nostdlib去掉了 crt0 这个 “中间层”，让程序直接对接内核；\n-e _start告诉链接器：“不用 crt0 的_start 了，用我自己定义的_start 作为 ELF 入口”。\n\n\n\n\n这种操作的本质是跳过 C/C++ 运行时的封装，直接与操作系统内核交互，它暴露了程序执行的底层真相：内核只认 ELF 头指定的入口（默认_start），main只是运行时库为开发者提供的便捷接口\n\n\n\n\ncrt0（C Runtime Zero）是C/C++ 程序运行时的 “初始化启动代码”，是连接操作系统内核与用户代码（如main函数）的关键中间层，默认由编译器工具链（如 GCC）自动链接，开发者通常感知不到它的存在。 ↩︎\n\n\n\n","categories":["编程"],"tags":["C++"]},{"title":"CMake用法","url":"/2025/08/07/C++/CMake%E6%93%8D%E4%BD%9C/","content":"\n关于CMake的基础概念和CMake项目构建流程\n\n\n一、CMake 基础语法\n1. 基础语法规则\n\n\n命令格式：不区分大小写（惯例用大写），格式为 COMMAND(参数1 参数2 ...)，参数含空格需用双引号包裹。\n例：PROJECT(MyApp) 与 project(myapp) 等效。\n\n\n变量：\n\n定义：set(变量名 值)，如 set(SRC main.cpp)。\n引用：${变量名}，如 add_executable(app ${SRC})。\n类型：\n\n普通变量：当前作用域有效（函数/目录内）。\n缓存变量：set(变量名 值 CACHE 类型 &quot;描述&quot;)，存入 CMakeCache.txt 跨构建保留（如 CMAKE_BUILD_TYPE）。\n环境变量：$ENV{变量名} 引用，set(ENV{变量名} 新值) 修改。\n\n\n预定义核心变量：\n\n\n\n变量名\n含义\n\n\n\n\nPROJECT_SOURCE_DIR\n项目根目录（根 CMakeLists.txt 路径）\n\n\nCMAKE_BINARY_DIR\n构建目录（执行 cmake 命令的目录）\n\n\nCMAKE_CXX_STANDARD\nC++ 标准版本（如 17、20）\n\n\n\n\n\n\n\n列表（List）：空格分隔的字符串集合，如 set(LIBS math utils)。\n常用操作：list(APPEND 列表 元素)（追加）、list(LENGTH 列表 变量)（长度）。\n\n\n注释：单行用 #，无多行注释（需每行加 #）。\n\n\n二、核心构建命令\n1. 项目配置基础\n\n\ncmake_minimum_required(VERSION 版本)：指定最低 CMake 版本（必须在 project 前），如 cmake_minimum_required(VERSION 3.10)。\n\n\nproject(项目名 [LANGUAGES C CXX ...])：定义项目名称及支持语言（默认 C/C++），自动生成 PROJECT_NAME、PROJECT_VERSION 等变量。\n\n\n2. 目标（Target）构建\n目标是 CMake 核心，代表可执行文件、库等产物。\n\n\n可执行文件：add_executable(目标名 源文件...)\n例：add_executable(app main.cpp src/func.cpp)。\n\n\n库文件：add_library(目标名 [STATIC|SHARED|MODULE] 源文件...)\n\nSTATIC：静态库（.a/.lib，编译时链接）。\nSHARED：动态库（.so/.dll，运行时加载）。\nMODULE：模块库（非链接用，运行时动态加载）。\n例：add_library(math STATIC src/math.cpp)。\n\n\n\n3. 目标属性与依赖配置\n现代 CMake（3.0+）推荐&quot;目标导向&quot;配置，替代全局命令（如 include_directories），明确作用域：\n\n\ntarget_include_directories(目标 作用域 目录...)：指定头文件目录\n\nPUBLIC：当前目标及依赖它的目标可见。\nPRIVATE：仅当前目标可见。\nINTERFACE：仅依赖它的目标可见。\n例：target_include_directories(app PUBLIC include)。\n\n\n\ntarget_link_libraries(目标 依赖...)：链接库（自定义库或系统库）\n例：target_link_libraries(app PUBLIC math pthread)（链接自定义库 math 和系统线程库）。\n\n\ntarget_compile_features(目标 作用域 cxx_std_17)：指定 C++ 标准（自动配置编译选项）。\n\n\ntarget_compile_options(目标 作用域 -Wall -O2)：添加编译选项（警告、优化等）。\n\n\n三、项目组织与模块化（多目录工程）\n1. 典型目录结构\nproject_root/├── CMakeLists.txt       # 根配置├── include/             # 全局头文件├── src/                 # 源码目录│   ├── math/            # 子模块（数学功能）│   │   ├── CMakeLists.txt│   │   ├── math.cpp│   │   └── math.h│   └── utils/           # 子模块（工具功能）│       ├── CMakeLists.txt│       └── utils.cpp└── apps/                # 可执行程序    ├── main.cpp    └── CMakeLists.txt\n2. 父子目录协作\n\n\n根目录 CMakeLists.txt：定义全局配置，通过 add_subdirectory 加载子目录。\ncmake_minimum_required(VERSION 3.15)project(MyProject LANGUAGES CXX)# 全局路径变量set(PROJECT_ROOT $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)# 加载子目录（自动解析子目录的 CMakeLists.txt）add_subdirectory(src/math)add_subdirectory(src/utils)add_subdirectory(apps)\n\n\n子目录 src/math/CMakeLists.txt：定义模块库，暴露头文件路径。\nadd_library(math STATIC math.cpp)# 头文件对依赖该库的目标可见（PUBLIC）target_include_directories(math PUBLIC $&#123;PROJECT_ROOT&#125;/include)\n\n\n应用目录 apps/CMakeLists.txt：链接子模块库。\nadd_executable(app main.cpp)target_link_libraries(app PUBLIC math utils)  # 依赖 math 和 utils 库\n\n\n3. 关键技巧\n\n\n输出路径控制：通过 set_target_properties 统一输出目录，避免污染源码。\nset_target_properties(app PROPERTIES RUNTIME_OUTPUT_DIRECTORY $&#123;PROJECT_ROOT&#125;/bin)set_target_properties(math PROPERTIES ARCHIVE_OUTPUT_DIRECTORY $&#123;PROJECT_ROOT&#125;/lib)\n\n\n变量作用域：子目录变量默认局部，修改父目录变量需加 PARENT_SCOPE：\nset(PARENT_VAR &quot;value&quot; PARENT_SCOPE)  # 子目录修改父目录变量\n\n\n四、流程控制（条件与循环）\n1. 条件判断（if-else-endif）\n根据平台、配置等动态调整构建规则：\nif(条件)  # 满足条件执行elseif(另一个条件)  # 满足另一条件执行else()  # 默认执行endif()\n常用条件：\n\n\n平台：if(WIN32)、if(UNIX)、if(APPLE)（macOS）。\n\n\n变量：if(DEFINED VAR)（是否定义）、if(VAR STREQUAL &quot;value&quot;)（字符串相等）。\n\n\n文件：if(EXISTS 路径)（路径存在）、if(IS_DIRECTORY 路径)（是否目录）。\n\n\n示例：平台差异化编译\nif(WIN32)  target_compile_definitions(app PRIVATE _WIN32)  # Windows 宏定义elseif(UNIX)  target_link_libraries(app pthread)  # Linux 链接线程库endif()\n2. 循环（foreach 与 while）\n\n\nforeach：遍历列表或范围\n# 遍历列表set(SRCS a.cpp b.cpp c.cpp)foreach(src IN LISTS SRCS)  message(STATUS &quot;Source: $&#123;src&#125;&quot;)endforeach()# 遍历数值范围（0到10，步长2）foreach(i RANGE 0 10 2)  message(STATUS &quot;Index: $&#123;i&#125;&quot;)endforeach()\n\n\nwhile：条件循环（适合动态计数场景）\nset(COUNT 0)while(COUNT LESS 5)  message(STATUS &quot;Count: $&#123;COUNT&#125;&quot;)  math(EXPR COUNT &quot;$&#123;COUNT&#125; + 1&quot;)  # 计数+1endwhile()\n\n\n五、依赖管理与外部库\n1. 查找系统库（find_package）\n用于引入外部库（如 Boost、OpenCV）：\nfind_package(库名 [版本] [REQUIRED])  # REQUIRED：找不到则报错\n找到库后：\n\n\n现代库会生成目标 库名::库名，直接链接：\nfind_package(OpenCV 4 REQUIRED)target_link_libraries(app PUBLIC OpenCV::OpenCV)  # 自动包含头文件和链接库\n\n\n传统库需手动处理变量：\nfind_package(Boost 1.70 REQUIRED COMPONENTS filesystem)target_include_directories(app PUBLIC $&#123;Boost_INCLUDE_DIRS&#125;)target_link_libraries(app PUBLIC $&#123;Boost_LIBRARIES&#125;)\n\n\n2. 自定义模块\n若外部库无默认查找模块，可自定义 FindXXX.cmake 并放入模块目录：\n# 添加自定义模块目录set(CMAKE_MODULE_PATH $&#123;CMAKE_MODULE_PATH&#125; &quot;$&#123;PROJECT_ROOT&#125;/cmake&quot;)find_package(MyLib REQUIRED)  # 查找 cmake/FindMyLib.cmake\n六、安装与打包\n1. 安装规则（install）\n定义目标、文件的安装路径（默认前缀：Unix 为 /usr/local，Windows 为 C:/Program Files）：\n# 安装可执行文件到 $&#123;CMAKE_INSTALL_PREFIX&#125;/bininstall(TARGETS app DESTINATION bin)# 安装静态库到 $&#123;CMAKE_INSTALL_PREFIX&#125;/libinstall(TARGETS math DESTINATION lib)# 安装头文件到 $&#123;CMAKE_INSTALL_PREFIX&#125;/includeinstall(FILES include/math.h DESTINATION include)\n修改安装前缀：\ncmake .. -DCMAKE_INSTALL_PREFIX=/path/to/install  # 生成时指定\n2. 生成安装包（CPack）\n在根 CMakeLists.txt 末尾添加：\ninclude(CPack)# 配置包信息set(CPACK_PACKAGE_NAME &quot;MyProject&quot;)set(CPACK_PACKAGE_VERSION &quot;1.0&quot;)set(CPACK_GENERATOR &quot;TGZ;DEB&quot;)  # 生成 .tar.gz 和 .deb 包\n生成包：\ncd build &amp;&amp; cpack  # 在构建目录执行\n七、最佳实践与避坑指南\n\n\n优先目标导向命令：用 target_include_directories 替代 include_directories，用 target_link_libraries 替代 link_libraries，明确依赖范围。\n\n\n分离构建目录：采用&quot;out-of-source&quot;构建，避免污染源码：\nmkdir build &amp;&amp; cd build &amp;&amp; cmake ..  # 构建目录与源码分离\n\n\n调试变量：用 message(STATUS &quot;VAR: ${VAR}&quot;) 打印变量值，排查配置问题。\n\n\n跨平台路径：用 PATH_EQUAL 比较路径（自动处理 / 与 \\ 差异）：\nif(&quot;/a/b&quot; PATH_EQUAL &quot;/a//b&quot;)  # 结果为真\n\n\n动态库查找：\n\nLinux：设置 LD_LIBRARY_PATH 或 CMAKE_INSTALL_RPATH。\nWindows：将 .dll 复制到可执行文件目录或添加到 PATH。\n\n\n\n八、完整构建流程\n\n\n编写 CMakeLists.txt：按模块拆分，定义目标与依赖。\n\n\n生成构建文件：\nmkdir build &amp;&amp; cd buildcmake .. -DCMAKE_BUILD_TYPE=Release  # Release 模式（默认 Debug）\n\n\n编译：\ncmake --build . -j8  # 8线程编译（通用）# 或针对 Makefile：make -j8\n\n\n安装（可选）：\ncmake --install .  # 安装到指定前缀\n\n\n","categories":["编程"],"tags":["C++","工具","CMake"]},{"title":"获取和设置socket选项","url":"/2025/07/31/linux/get%20setsockopt/","content":"如何使用 C++ 进行 TCP 和 UDP 数据读写的基础知识\n\nget/setsockopt\ngetsockopt 和 setsockopt 是套接字编程中用于获取和设置套接字选项的两个重要系统调用，它们允许开发者配置和查询套接字的各种参数，以控制网络通信的行为。\n函数原型\n#include &lt;sys/socket.h&gt;// 获取套接字选项int getsockopt(int sockfd, int level, int optname,                void *optval, socklen_t *optlen);// 设置套接字选项int setsockopt(int sockfd, int level, int optname,                const void *optval, socklen_t optlen);\n参数说明\n\n\nsockfd：套接字描述符，标识要操作的套接字。\n\n\nlevel：选项所在的协议层级，常见值包括：\n\nSOL_SOCKET：通用套接字选项（适用于所有协议）\nIPPROTO_TCP：TCP 协议特定选项\nIPPROTO_IP：IP 协议特定选项\n其他协议（如 IPPROTO_UDP、IPPROTO_IPV6 等）\n\n\n\noptname：要获取或设置的具体选项名称（与 level 对应）。\n\n\noptval：\n\n对于 setsockopt：指向要设置的选项值的缓冲区\n对于 getsockopt：指向存储获取结果的缓冲区\n\n\n\noptlen：\n\n对于 setsockopt：指定 optval 缓冲区的长度\n对于 getsockopt：输入时指定缓冲区长度，输出时返回实际读取的长度\n\n\n\n返回值\n\n\n成功：返回 0\n\n\n失败：返回 -1，并设置 errno\n\n\n常用选项示例\n1. SOL_SOCKET 层级（通用选项）\n\n\nSO_REUSEADDR：允许重用本地地址和端口\nint reuse = 1;setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse));\n\n\nSO_RCVBUF / SO_SNDBUF：获取 / 设置接收 / 发送缓冲区大小\nint bufsize;socklen_t len = sizeof(bufsize);getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &amp;bufsize, &amp;len);\n\n\nSO_KEEPALIVE：启用 TCP 保活机制\nint keepalive = 1;setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;keepalive, sizeof(keepalive));\n\n\n2. IPPROTO_TCP 层级（TCP 选项）\n\n\nTCP_NODELAY：禁用 Nagle 算法（减少延迟，可能增加带宽消耗）\nint nodelay = 1;setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;nodelay, sizeof(nodelay));\n\n\n3. IPPROTO_IP 层级（IP 选项）\n\n\nIP_TTL：设置 IP 数据包的生存时间（TTL）\nint ttl = 64;setsockopt(sockfd, IPPROTO_IP, IP_TTL, &amp;ttl, sizeof(ttl));\n\n\n使用场景\n\n\n网络性能优化：调整缓冲区大小、启用 / 禁用特定算法\n\n\n连接管理：设置超时、控制地址重用\n\n\n协议行为定制：如 TCP 保活、Nagle 算法等\n\n\n调试与监控：获取套接字当前状态信息\n\n\n注意事项\n\n\n选项的可用性取决于系统和协议栈实现\n\n\n某些选项只能在特定阶段设置（如 SO_REUSEADDR 通常在绑定前设置）\n\n\n对于数值型选项，通常使用 int 类型存储值\n\n\n错误处理很重要，需检查返回值并处理可能的错误\n\n\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"分散 / 聚集 IO","url":"/2025/07/29/linux/%E5%88%86%E6%95%A3%20%20%E8%81%9A%E9%9B%86%20IO/","content":"网络编程中常用的分散 / 聚集 IO 技术\n \n1. readv 与 writev：分散 / 聚集 I/O\nreadv（分散读）和 writev（聚集写）是用于处理分散缓冲区的 I/O 函数，核心作用是通过一次系统调用完成对多个不连续缓冲区的读写操作，减少系统调用次数（系统调用存在上下文切换开销）。\n函数原型\n#include &lt;sys/uio.h&gt;// 从fd读取数据，分散存储到iov指向的多个缓冲区ssize_t readv(int fd, const struct iovec *iov, int iovcnt);// 将iov指向的多个缓冲区数据聚集后写入fdssize_t writev(int fd, const struct iovec *iov, int iovcnt);\n关键参数\n\n\nstruct iovec描述一个缓冲区的结构，定义为：\nstruct iovec &#123;    void  *iov_base;  // 缓冲区起始地址    size_t iov_len;   // 缓冲区长度（字节数）&#125;;\n\n\niovcnt：缓冲区数量，上限由系统限制（通常IOV_MAX，如 Linux 为 1024）。\n\n\n功能与适用场景\n\n\nreadv：从文件描述符fd读取数据，按顺序填充iov数组中的缓冲区（前一个填满后再填下一个），返回实际读取的字节数。\n\n\nwritev：将iov数组中所有缓冲区的数据按顺序拼接后写入fd，返回实际写入的字节数。\n\n\n网络编程场景：在构造协议报文时（如 HTTP 响应包含状态行、头部字段、正文等多个独立部分），可通过writev一次发送所有部分，避免多次write调用的开销；同理，接收报文时若需拆分到不同缓冲区（如头部和正文分离），可使用readv。\n注意事项\n\n\n若读取 / 写入中途发生错误，仍会返回已成功处理的字节数（部分成功）。\n\n\n对于非阻塞fd，行为与read/write一致（可能返回EAGAIN或EWOULDBLOCK）。\n\n\n2. dup 与 dup2：文件描述符复制\ndup 和 dup2 用于复制文件描述符，使新的描述符与原描述符指向同一个文件表项（共享文件偏移量、文件状态标志等），核心作用是实现 I/O 重定向。\n函数原型\n#include &lt;unistd.h&gt;// 复制oldfd，返回最小的未使用描述符int dup(int oldfd);// 将newfd重定向为oldfd的副本（若newfd已打开则先关闭）int dup2(int oldfd, int newfd);\n功能差异\n\n\ndup：自动选择一个最小的未被使用的描述符作为新描述符，与oldfd指向同一文件。\n\n\ndup2：显式指定新描述符newfd，若newfd已打开，则先关闭它（若newfd == oldfd，则直接返回newfd，不关闭）。\n\n\n网络编程场景\n\n\n重定向标准 I/O：例如在网络服务中，将客户端socket的描述符通过dup2(client_fd, STDOUT_FILENO)重定向为标准输出，此时printf的内容会直接发送给客户端。\n\n\n简化接口适配：某些库函数仅支持固定描述符（如标准输出），通过dup2可将其适配到 socket 描述符。\n\n\n注意事项\n\n\n若oldfd无效（未打开），两函数均返回-1并设置errno为EBADF。\n\n\ndup2关闭newfd时若失败（如权限问题），会返回-1，但此时newfd可能已处于关闭状态，需注意错误处理。\n\n\n3. sendfile：零拷贝文件传输\nsendfile 用于在两个文件描述符之间直接传输数据，数据无需经过用户空间，全程在内核空间处理，属于零拷贝（zero-copy） 技术，可大幅提升大文件传输效率。\n函数原型（Linux）\n#include &lt;sys/sendfile.h&gt;// 将in_fd的数据传输到out_fd，返回实际传输的字节数ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n关键参数与限制\n\n\nin_fd：源文件描述符，必须是支持mmap的常规文件（不能是 socket 或管道）。\n\n\nout_fd：目标文件描述符，在 Linux 中必须是 socket（其他系统可能支持更多类型）。\n\n\noffset：指定in_fd的起始读取位置，若不为NULL，传输后会更新为实际结束位置（原子操作，避免多线程竞争）。\n\n\ncount：计划传输的字节数。\n\n\n功能与优势\n传统文件传输流程（read + write）需要 4 次数据拷贝（磁盘→内核缓冲区→用户缓冲区→socket 缓冲区→网卡）和 2 次系统调用；而sendfile通过内核直接将文件数据从页缓存传输到 socket 缓冲区，仅需 2 次拷贝（磁盘→内核缓冲区→socket 缓冲区）和 1 次系统调用，显著减少开销。\n网络编程场景：在文件服务器中（如 HTTP 服务器传输静态资源），sendfile是高效传输文件的首选方式，比read + write组合性能提升明显。\n注意事项\n\n\n跨平台差异大：Linux 的sendfile与 BSD 的sendfile参数和行为不同，移植时需注意。\n\n\n不支持非阻塞 I/O：若out_fd为非阻塞 socket 且暂时无法写入，sendfile可能返回-1并设置errno为EAGAIN，但部分实现可能不支持。\n\n\nin_fd必须是常规文件：不能用于 socket 之间的数据转发（需用splice等其他函数）。\n\n\n总结\n\n\nreadv/writev：优化多缓冲区 I/O，减少系统调用次数，适合协议报文的拼接 / 拆分。\n\n\ndup/dup2：实现文件描述符重定向，简化 I/O 接口适配。\n\n\nsendfile：利用零拷贝技术高效传输文件，是大文件网络传输的核心优化手段。\n\n\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"SSH的生成与配置","url":"/2025/07/28/linux/SSH%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E9%85%8D%E7%BD%AE/","content":"记录SSH的用法\n \nSSH的生成与配置\n生成\n1.检查Linux中是否有ssh\n#检查是否安装ssh -V#检查是否正在运行sudo systemctl status sshd #启动sshsudo systemctl start sshd#设置为开机自启sudo systemctl enable sshd\n2.生成密钥对\n#该算法更安全高效ssh-keygen -t ed25519#若不支持et25519ssh-keygen -t rsa -b 4096\n之后一直按回车即可,生成的公钥和私钥会默认保存至~/.ssh目录下\n配置\n\n将本机公钥部署到服务器,实现无密码登录\n\n法一:ssh-copy-id\nssh-copy-id -i ~/.ssh/id_ed25519.pub 用户名@服务器IP\n\n\n无参数 i 会默认尝试复制当前用户目录下的默认公钥文件（通常是 ~/.ssh/id_rsa.pub，如果存在的话）\n\n\n**法二:**手动上传\n# 将本地公钥内容传到服务器的authorized_keyscat ~/.ssh/id_ed25519.pub | ssh 用户名@服务器IP &quot;cat &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;\n**法三:**使用scp\nscp ~/.ssh/本地公钥文件名 远程用户名@远程服务器IP:~/目标路径\n之后再把传输过去的公钥写入authorized_keys文件中\n常见问题解决\n\n\n权限错误：若提示 “Permission denied”，检查服务器~/.ssh和authorized_keys的权限是否为 700 和 600。\n\n\n端口问题：服务器 SSH 端口非默认时，连接需指定端口：ssh -p 2222 用户名@IP，或在config中配置Port。\n\n\n密钥未生效：重启服务器 SSH 服务：sudo systemctl restart sshd（Linux）。\n\n\n","categories":["编程"],"tags":["工具","SSH"]},{"title":"TCP、UDP数据读写基础","url":"/2025/07/28/linux/TCP,UDP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E5%9F%BA%E7%A1%80/","content":"如何使用 C++ 进行 TCP 和 UDP 数据读写的基础知识\n \n一、通用数据读写基础（TCP/UDP 均需掌握）\n无论使用何种协议，网络数据读写都需处理字节序转换、数据序列化和错误处理，这是跨平台通信的基础。\n1. 字节序转换（解决主机与网络字节序差异）\n网络协议规定使用大端字节序（网络字节序），主机字节序可能为大端或小端（如 x86 为小端），需通过以下函数转换：\n\n\nuint16_t htons(uint16_t hostshort)：主机→网络字节序（16 位，如端口号）\n\n\nuint32_t htonl(uint32_t hostlong)：主机→网络字节序（32 位，如 IPv4 地址）\n\n\nuint16_t ntohs(uint16_t netshort)：网络→主机字节序（16 位）\n\n\nuint32_t ntohl(uint32_t netlong)：网络→主机字节序（32 位）\n\n\n进阶场景：\n\n\n64 位数据：POSIX 提供htobe64/be64toh（大端）、htole64/le64toh（小端），Windows 需手动实现。\n\n\n浮点数：无标准转换函数，需通过指针转换为字节数组传输（依赖 IEEE 754 兼容）。\n\n\n示例：\nint port = 8080;sockaddr_in addr;addr.sin_port = htons(port);  // 端口必须用网络字节序\n2. 数据序列化与缓冲区管理\n网络传输的是字节流，需通过缓冲区处理，结构化数据需序列化以避免对齐和字节序问题。\n核心函数：\n\n\nmemcpy(void *dest, const void *src, size_t n)：拷贝字节（用于序列化）\n\n\nmemset(void *s, int c, size_t n)：初始化缓冲区（如清空接收缓冲区）\n\n\nstrlen(const char *s)：计算字符串长度（用于发送字符串）\n\n\n序列化方案：\n\n\n手动序列化：拆分结构体成员，转换字节序后写入缓冲区：\nstruct Msg &#123; int len; short type; &#125;;char buf[6];int net_len = htonl(msg.len);short net_type = htons(msg.type);memcpy(buf, &amp;net_len, 4);memcpy(buf+4, &amp;net_type, 2);\n\n\n协议库：Protobuf、FlatBuffers 等自动处理对齐和字节序。\n\n\n缓冲区策略：\n\n\n动态缓冲区：使用vector&lt;char&gt;避免栈溢出，适合接收未知长度数据。\n\n\n分散 - 聚集 IO：通过iovec和sendmsg/recvmsg减少内存拷贝：\nstruct iovec iov[2];  // 分散发送消息头和消息体iov[0].iov_base = &amp;header;iov[0].iov_len = sizeof(header);iov[1].iov_base = data;iov[1].iov_len = data_len;struct msghdr msg;msg.msg_iov = iov;msg.msg_iovlen = 2;sendmsg(sockfd, &amp;msg, 0);\n\n\n3. 通用错误处理\n网络函数失败时返回 - 1，需通过错误码定位问题：\n\n\nLinux：errno（如EINTR、ECONNRESET）\n\n\nWindows：WSAGetLastError()（如WSAECONNRESET）\n\n\n常见错误：\n\n\nEINTR：操作被信号中断（需重试）\n\n\nEWOULDBLOCK：非阻塞模式下无数据（需等待）\n\n\nECONNRESET：连接被对方重置\n\n\nENOTCONN：TCP 未连接或 UDP 未指定目标\n\n\n二、TCP 数据读写（面向连接的字节流）\nTCP 是可靠的面向连接协议，数据无边界，需通过应用层协议界定消息边界。\n1. 核心读写函数\n\n\n发送：ssize_t send(int sockfd, const void *buf, size_t len, int flags)\n\n参数：sockfd（已连接的 TCP socket）、缓冲区、长度、标志（通常 0）。\n返回值：实际发送字节数（可能小于len）；失败返回 - 1。\n标志：MSG_NOSIGNAL（Linux）：避免对方关闭时触发 SIGPIPE。\n\n\n\n接收：ssize_t recv(int sockfd, void *buf, size_t len, int flags)\n\n参数：sockfd、接收缓冲区、长度、标志（通常 0）。\n返回值：实际接收字节数；0 表示对方正常关闭；-1 表示错误。\n标志：MSG_PEEK（预览数据不移除）。\n\n\n\nMSG_OOB\n\n\n发送 / 接收带外数据（Out-of-Band data），用于传输紧急数据。带外数据具有更高的优先级，可绕过常规数据流的排队机制。\n\n\nMSG_PEEK\n\n\n仅适用于 recv()：查看缓冲区中的数据，但不会将其从缓冲区中移除（即数据仍然可以被后续的 recv() 调用读取）。\n\n\n对 send() 无效。\n\n\nMSG_WAITALL\n\n\n仅适用于 recv()：要求函数阻塞直到接收到 len 参数指定的全部数据（除非发生错误或连接关闭）。\n\n\n注意：即使设置了此标志，也可能因信号中断、连接关闭等原因导致实际接收的数据少于 len。\n\n\n仅适用于 send() 的标志\nMSG_DONTROUTE\n\n\n告知内核不使用路由表，直接将数据发送到本地网络上的主机（仅适用于 UDP 或原始套接字）。\n\n\nMSG_NOSIGNAL\n\n\n当连接已关闭时，发送数据不会产生 SIGPIPE 信号（默认情况下会产生该信号导致程序终止）。\n\n\n2. 关键特性与实现\n\n\n字节流无边界：需应用层定义消息格式，常见方案：\n\n\n**固定长度:**累计读取到指定长度后处理：\nssize_t recv_fixed(int sockfd, char *buf, size_t fixed_len) &#123;    size_t total = 0;    while (total &lt; fixed_len) &#123;        ssize_t n = recv(sockfd, buf + total, fixed_len - total, 0);        if (n &lt;= 0) return n;  // 错误或连接关闭        total += n;    &#125;    return total;&#125;\n\n\n**长度前缀:**先读长度字段，再读对应数据：\nstd::vector&lt;char&gt; recv_with_header(int sockfd) &#123;    uint32_t net_len;    if (recv_fixed(sockfd, (char*)&amp;net_len, 4) != 4) return &#123;&#125;;    size_t len = ntohl(net_len);    std::vector&lt;char&gt; data(len);    recv_fixed(sockfd, data.data(), len);    return data;&#125;\n\n\n分隔符：如\\r\\n（HTTP 头部方式）。\n\n\n\n\n循环读写：send/recv可能不一次性处理全部数据，需循环调用：\nssize_t send_all(int sockfd, const void *buf, size_t len) &#123;    size_t total_sent = 0;    while (total_sent &lt; len) &#123;        ssize_t sent = send(sockfd, (char*)buf + total_sent, len - total_sent, 0);        if (sent == -1) return -1;        total_sent += sent;    &#125;    return total_sent;&#125;\n\n\n3. 连接异常处理\n\n\n半关闭：对方shutdown(SHUT_WR)后，recv返回 0（可继续发送数据）。\n\n\n重置连接：recv返回 - 1 且errno=ECONNRESET，需关闭 socket 并重连。\n\n\n超时设置:  通过SO_RCVTIMEO/SO_SNDTIMEO设置读写超时：\nstruct timeval timeout = &#123;5, 0&#125;;  // 5秒超时setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, sizeof(timeout));\n\n\n三、UDP 数据读写（无连接的数据包）\nUDP 是不可靠的无连接协议，数据有边界（一次发送对应一次接收），无需建立连接。\n1. 核心读写函数\n\n\n发送：ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)\n\n参数：sockfd（UDP socket）、缓冲区、长度、标志、目标地址及长度。\n返回值：成功返回发送字节数（等于len）；失败返回 - 1。\n\n\n\n接收：ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)\n\n参数：sockfd、接收缓冲区、长度、标志、发送方地址（输出）及长度（输入输出）。\n返回值：接收字节数（≤len）；失败返回 - 1。\n\n\n\n2. 关键特性与实现\n\n\n数据报边界：一次sendto的数据可被recvfrom完整接收（缓冲区足够时）。\n\n\n长度限制：超过 MTU（通常 1500 字节）会分片，建议单包≤1472 字节（1500-20IP 头 - 8UDP 头）。\n\n\n截断检测：MSG_TRUNC标志可检测数据是否被截断：\nsocklen_t addrlen = sizeof(addr);ssize_t n = recvfrom(sockfd, buf, len, MSG_TRUNC, &amp;addr, &amp;addrlen);if (n == len &amp;&amp; (flags &amp; MSG_TRUNC)) &#123; /* 数据被截断 */ &#125;\n\n\n3. 连接化 UDP（Connected UDP）\n通过connect绑定固定目标地址后，可使用send/recv简化操作（仍为 UDP 特性）：\nstruct sockaddr_in dest_addr;// 初始化目标地址...connect(udp_sockfd, (struct sockaddr*)&amp;dest_addr, sizeof(dest_addr));send(udp_sockfd, buf, len, 0);  // 无需重复指定地址\n4. 可靠性增强\nUDP 本身不可靠，需应用层补充机制：\n\n\n序号与确认（重传超时未确认的包）\n\n\n校验和（检测数据损坏）\n\n\n流量控制（避免接收方溢出）\n\n\n四、高级函数与性能优化\n\n\nssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)：支持分散发送（多个缓冲区数据合并发送），适合发送复杂数据结构。\n\n\nssize_t recvmsg(int sockfd, struct msghdr *msg, int flags)：支持聚集接收（将数据分散到多个缓冲区），常用于接收带辅助数据（如控制信息）的数据包。\n\n\nssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)（Linux）：零拷贝发送文件，直接从文件描述符in_fd发送到socket（out_fd），减少用户态与内核态拷贝，效率极高。\n\n\n性能优化：\n\n\nTCP：禁用 Nagle 算法（TCP_NODELAY）减少延迟；增大缓冲区（SO_SNDBUF/SO_RCVBUF）提高吞吐量。\n\n\nUDP：避免碎片化；批量发送减少系统调用。\n\n\nIO 模型：高并发场景使用非阻塞 IO+epoll（Linux）/kqueue（BSD）。\n\n\n五、跨平台兼容性\n\n\nWindows 需初始化套接字库（WSAStartup），Linux 无需。\n\n\n错误处理：Windows 用WSAGetLastError()，Linux 用errno。\n\n\n关闭 socket：Windows 用closesocket，Linux 用close。\n\n\n兼容代码示例：\n#ifdef _WIN32#include &lt;winsock2.h&gt;#define close closesocket#else#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#endifint get_last_error() &#123;#ifdef _WIN32    return WSAGetLastError();#else    return errno;#endif&#125;\n\n\nTCP：用send/recv，面向连接，需处理字节流无边界问题，适合可靠传输（如 HTTP）。\n\n\nUDP：用sendto/recvfrom，无连接，保留数据报边界，适合实时场景（如视频流）。\n\n\n通用基础：字节序转换、序列化、缓冲区管理和错误处理是核心前提。\n\n\n","categories":["编程"],"tags":["C++","Linux","网络"]},{"title":"linux管道(pipe)系统调用","url":"/2025/07/12/linux/pipe()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","content":"如何使用 C++ 在 Linux 环境下进行管道(pipe)系统调用\n \npipe() 系统调用\n在 Linux 系统编程中，pipe() 是一个系统调用，用于创建一个匿名管道，实现同一进程或父子进程间的单向通信。管道有两个文件描述符：一个用于读取（读端），一个用于写入（写端）。\npipe() 函数原型\n#include &lt;unistd.h&gt;int pipe(int pipefd[2]);\n\n\npipefd是一个包含两个整数的数组，用于存储管道的文件描述符\n\npipefd[0]：管道的读端，用于读取数据\npipefd[1]：管道的写端，用于写入数据\n\n\n\n返回值：成功返回 0，失败返回 -1 并设置 errno\n\n\n使用步骤\n\n\n创建管道：调用 pipe() 函数\n\n\n创建子进程：使用 fork() 创建子进程（管道通常用于父子进程间通信）\n\n\n关闭不需要的端：\n\n父进程关闭读端（pipefd[0]），只写\n子进程关闭写端（pipefd[1]），只读（或根据需求调整，如父进程读、子进程写）\n\n\n\n通信：通过 write() 写入数据，read() 读取数据\n\n\n关闭管道：通信完成后关闭所有文件描述符\n\n\n示例代码\n#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#include &lt;sys/wait.h&gt;#include &lt;string&gt;int main() &#123;    int pipefd[2];    pid_t pid;    char buf[1024];    // 1. 创建管道    if (pipe(pipefd) == -1) &#123;        std::cerr &lt;&lt; &quot;管道创建失败: &quot; &lt;&lt; std::strerror(errno) &lt;&lt; std::endl;        std::exit(EXIT_FAILURE);    &#125;    // 2. 创建子进程    pid = fork();    if (pid == -1) &#123;        std::cerr &lt;&lt; &quot;进程创建失败: &quot; &lt;&lt; std::strerror(errno) &lt;&lt; std::endl;        std::exit(EXIT_FAILURE);    &#125;    if (pid == 0) &#123;  // 子进程：读数据        // 3. 关闭子进程不需要的写端        close(pipefd[1]);        // 4. 从管道读取数据        ssize_t n = read(pipefd[0], buf, sizeof(buf) - 1);        if (n == -1) &#123;            std::cerr &lt;&lt; &quot;读取失败: &quot; &lt;&lt; std::strerror(errno) &lt;&lt; std::endl;            std::exit(EXIT_FAILURE);        &#125;        buf[n] = &#x27;\\0&#x27;;  // 添加字符串结束符        std::cout &lt;&lt; &quot;子进程收到: &quot; &lt;&lt; buf &lt;&lt; std::endl;        // 5. 关闭读端        close(pipefd[0]);        std::exit(EXIT_SUCCESS);    &#125; else &#123;  // 父进程：写数据        // 3. 关闭父进程不需要的读端        close(pipefd[0]);        // 4. 向管道写入数据        std::string msg = &quot;Hello from parent!&quot;;        if (write(pipefd[1], msg.c_str(), msg.length()) == -1) &#123;            std::cerr &lt;&lt; &quot;写入失败: &quot; &lt;&lt; std::strerror(errno) &lt;&lt; std::endl;            std::exit(EXIT_FAILURE);        &#125;        // 5. 关闭写端（触发子进程的read()返回0）        close(pipefd[1]);        // 等待子进程结束        wait(NULL);        std::exit(EXIT_SUCCESS);    &#125;&#125;\n代码说明\n\n\n管道创建：pipe(pipefd) 成功后，pipefd[0] 和 pipefd[1] 分别代表读端和写端\n\n\n进程通信\n\n父进程通过 write(pipefd[1], ...) 向管道写入数据\n子进程通过 read(pipefd[0], ...) 从管道读取数据\n\n\n\n关闭端的重要性\n\n不使用的端必须关闭，否则可能导致 read() 阻塞（等待数据）\n所有写端关闭后，read() 会返回 0（表示数据结束）\n\n\n\n单向性：管道是单向的，数据只能从写端流向读端\n\n\n核心原则：按需保留，及时关闭，全量清理\n\n\n“先关闭，后通信” 的原则：进程创建后（如 fork() 后），应立即关闭不需要的端，再进行读写操作。例如：\n\n父进程若负责写数据，应先关闭读端（pipefd[0]），仅保留写端（pipefd[1]）；\n子进程若负责读数据，应先关闭写端（pipefd[1]），仅保留读端（pipefd[0]）。避免因 “未及时关闭” 导致的意外数据交互（如子进程误写数据到本应关闭的写端）。\n\n\n\n写端关闭的 “触发信号” 作用：写端完成数据发送后，必须主动关闭写端，这是告知读端 “数据已发送完毕” 的唯一方式。读端通过 read() 返回 0 感知 “所有写端已关闭”，从而正常退出读取逻辑。\n\n反例：若父进程写完数据后未关闭写端，子进程的 read() 会一直阻塞（等待更多数据），导致子进程无法退出。\n\n\n\n多进程协作时的 “全关闭” 检查：若多个进程共享同一管道的写端（如父进程和多个子进程都向管道写数据），必须确保所有写端都关闭后，读端才能收到 EOF（read() 返回 0）。\n\n需通过进程同步（如 waitpid）确保所有写进程都已关闭写端，避免读端提前退出或阻塞。\n\n\n\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"linux文件操作","url":"/2025/07/12/linux/open()%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","content":"如何使用 C++ 在 Linux 环境下进行文件操作\n\n一、open() 系统调用（Unix/Linux）\n1. 核心知识点回顾\n\n\n函数原型\n#include &lt;fcntl.h&gt;    // 定义 O_RDONLY、O_WRONLY 等标志#include &lt;sys/types.h&gt;  // 定义 mode_t 类型#include &lt;sys/stat.h&gt;   // 定义文件权限宏int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);\n\n\n参数\n\npathname：要打开或创建的文件路径（绝对或相对路径）\nflags：必选标志，只能选其一（O_RDONLY/O_WRONLY/O_RDWR）和可选标志（O_CREAT、O_EXCL、O_APPEND、O_TRUNC 等）。\nmode：当使用 O_CREAT 标志时需指定权限。创建文件时的权限（如 0644）。\n\n\n\n返回值：文件描述符（整数）或 -1（失败）。\n\n\n特点：无缓冲的底层操作，适合设备驱动、非阻塞 I/O 等场景。\n\n\n2. 关键标志位\n\n\n\n标志\n功能描述\n\n\n\n\nO_CREAT\n文件不存在时创建\n\n\nO_EXCL\n与 O_CREAT 联用，文件存在则报错\n\n\nO_TRUNC\n打开时截断文件\n\n\nO_APPEND\n追加模式\n\n\nO_NONBLOCK\n非阻塞模式\n\n\n\n3. 错误处理\nopen() 失败时会设置 errno，常见错误码：\n\n\nENOENT：路径不存在（无 O_CREAT 标志时）。\n\n\nEACCES：权限不足（如尝试写入只读文件）。\n\n\nEEXIST：文件已存在（使用 O_CREAT | O_EXCL 时）。\n\n\nEISDIR：路径是目录而非文件。\n\n\n4. 相关系统调用\n\n\nclose(int fd)：关闭文件描述符。\n\n\nread(int fd, void *buf, size_t count)：从文件读取数据。\n\n\nwrite(int fd, const void *buf, size_t count)：向文件写入数据。\n\n\nlseek(int fd, off_t offset, int whence)：移动文件读写位置。\n\n\ncreat(const char *pathname, mode_t mode)：等价于 open(pathname, O_CREAT | O_WRONLY | O_TRUNC, mode)。\n\n\n#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;    // 打开文件（不存在则创建，存在则截断）    int fd = open(&quot;test.txt&quot;, O_RDWR | O_CREAT | O_TRUNC, 0644);    if (fd == -1) &#123;        perror(&quot;open failed&quot;);        return EXIT_FAILURE;    &#125;    // 写入数据    const char *data = &quot;Hello, open()!\\n&quot;;    ssize_t bytes_written = write(fd, data, strlen(data));    if (bytes_written == -1) &#123;        perror(&quot;write failed&quot;);        close(fd);        return EXIT_FAILURE;    &#125;    // 移动文件指针到开头    if (lseek(fd, 0, SEEK_SET) == -1) &#123;        perror(&quot;lseek failed&quot;);        close(fd);        return EXIT_FAILURE;    &#125;    // 读取数据    char buffer[100];    ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1);    if (bytes_read == -1) &#123;        perror(&quot;read failed&quot;);        close(fd);        return EXIT_FAILURE;    &#125;    buffer[bytes_read] = &#x27;\\0&#x27;;  // 确保字符串以 &#x27;\\0&#x27; 结尾    printf(&quot;Read: %s&quot;, buffer);    close(fd);  // 关闭文件描述符    return 0;&#125;\n二、C++ 标准库中的文件操作\nC++ 提供了更高级的文件流类，基于对象和异常处理，避免了直接使用系统调用的复杂性。\n1. &lt;fstream&gt; 库（推荐方案）\n\n\n主要类\n\nstd::ifstream：输入文件流（只读）。\nstd::ofstream：输出文件流（只写）。\nstd::fstream：输入 / 输出文件流（读写）。\n\n\n\n示例：打开文件并读写\n#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123;    // 打开文件（不存在则创建，存在则截断）    std::ofstream outfile(&quot;test.txt&quot;, std::ios::out | std::ios::trunc);    if (!outfile.is_open()) &#123;        std::cerr &lt;&lt; &quot;Failed to open file!&quot; &lt;&lt; std::endl;        return 1;    &#125;    // 写入数据    outfile &lt;&lt; &quot;Hello, C++ file stream!&quot; &lt;&lt; std::endl;    outfile.close();    // 读取文件    std::ifstream infile(&quot;test.txt&quot;);    std::string line;    if (infile.is_open()) &#123;        while (std::getline(infile, line)) &#123;            std::cout &lt;&lt; &quot;Read: &quot; &lt;&lt; line &lt;&lt; std::endl;        &#125;        infile.close();    &#125;    return 0;&#125;\n2. 文件打开模式（std::ios_base::openmode）\n\n\n\n模式\n功能描述\n\n\n\n\nstd::ios::in\n输入模式（读取）\n\n\nstd::ios::out\n输出模式（写入，默认截断文件）\n\n\nstd::ios::app\n追加模式（写入到文件末尾）\n\n\nstd::ios::ate\n打开后定位到文件末尾\n\n\nstd::ios::trunc\n打开时截断文件（若已存在）\n\n\nstd::ios::binary\n二进制模式（避免文本模式转换）\n\n\n\n三、C++17 及以后的文件系统库（&lt;filesystem&gt;）\nC++17 引入了更现代化的文件系统操作 API，提供路径处理、文件状态检查等功能。\n1. 文件操作示例\n#include &lt;filesystem&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;namespace fs = std::filesystem;int main() &#123;    fs::path filePath = &quot;test.txt&quot;;    // 创建文件并写入    if (std::ofstream file(filePath); file.is_open()) &#123;        file &lt;&lt; &quot;Hello, C++17 filesystem!&quot;;        file.close();    &#125;    // 检查文件状态    if (fs::exists(filePath)) &#123;        std::cout &lt;&lt; &quot;File size: &quot; &lt;&lt; fs::file_size(filePath) &lt;&lt; &quot; bytes&quot; &lt;&lt; std::endl;        fs::remove(filePath);  // 删除文件    &#125;    return 0;&#125;\n2. 优势\n\n\n跨平台：自动处理不同操作系统的路径分隔符（如 / 和 \\）。\n\n\n异常安全：使用 RAII 管理资源，避免手动关闭文件。\n\n\n功能丰富：支持文件遍历、权限管理、硬链接操作等。\n\n\n","categories":["编程"],"tags":["C++","Linux"]},{"title":"GDB的使用及常用命令","url":"/2025/07/12/linux/GDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"如何使用 GDB 调试 C/C++ 程序及常用命令详解\n \n一、GDB 在不同场景下的使用方法及常用命令\n场景 1：基础程序调试（单进程、无复杂逻辑）\n适用于调试简单的单文件程序，定位语法外的逻辑错误（如变量计算错误、循环异常等）。\n核心流程与命令：\n\n\n编译带调试信息的程序\n必须在编译时添加-g选项（生成调试符号，包含变量名、行号等信息），否则 GDB 无法正常调试。示例：gcc -g -o test test.c（C 程序）；g++ -g -o test test.cpp（C++ 程序）。\n\n\n启动 GDB\n\n命令：gdb ./test（直接启动调试）；或gdb -q ./test（安静模式，不显示 GDB 版本信息）。\n退出 GDB：quit（缩写q）。\n查看命令帮助：help &lt;命令&gt;（缩写h），如help break可查看断点命令说明。\n\n\n\n查看源代码\n\nlist &lt;位置&gt;（缩写l）：显示指定位置的源代码，如l 10显示第 10 行附近代码，l main显示 main 函数代码，默认每次显示 10 行。\nlist &lt;start&gt;,&lt;end&gt;：显示从 start 到 end 的源代码，如l 5,20显示 5-20 行。\nshow listsize：查看list命令每次显示的行数（默认 10 行）；set listsize &lt;N&gt;：设置每次显示 N 行，如set listsize 20。\n\n\n\n设置断点\n断点是调试的核心，用于在指定位置暂停程序执行。\n\n\n基础断点：break 位置（缩写b），位置支持行号（b 10）、文件名 + 行号（b test.c:20）、函数名（b main）、地址（b *0x400520）。\n\n\n临时断点：tbreak 位置（缩写tb），触发一次后自动删除。\n\n\n条件断点：break 位置 if 条件，仅当条件满足时中断，如break test.c:20 if i == 10。\n\n\n断点触发后自动执行命令：break 位置 command &lt;命令序列&gt; end, 如在 test.c:10 设置断点后，自动打印 i 和调用栈：\nb test.c:10commandp ibtend\n\n\n\n\n断点管理\n\n查看断点：info breakpoints（缩写info b），显示所有断点编号、状态、命中次数等。\n删除断点：delete 断点编号（缩写d），如d 1删除编号 1 的断点；d不带参数删除所有。\n禁用 / 启用断点：disable 断点编号（缩写dis）、enable 断点编号（缩写en）；enable once 断点编号仅生效一次。\n清除指定位置断点：clear &lt;位置&gt;，如clear main删除 main 函数入口的断点。\n\n\n\n运行程序\n\n启动程序：run [参数]（缩写r），如run 10 20传递命令行参数。\n启动并在 main 函数第一行中断：start。\n程序中断后继续执行：continue（缩写c），执行到下一个断点。\n\n\n\n单步执行\n\nnext（缩写n）：执行当前行，不进入函数调用。\nstep（缩写s）：执行当前行，进入函数调用。\n按汇编指令单步：nexti（ni）、stepi（si），分别对应不进入和进入函数的汇编级执行。\n跳出当前函数：finish，执行完当前函数并返回到调用处。\n执行到指定行：until &lt;行号&gt;（缩写u），适合快速跳过循环。\n\n\n\n查看 / 修改变量\n\n查看变量 / 表达式：print 变量/表达式（缩写p），如p a + b；按格式打印（x十六进制、d十进制等）：p /x num。\n打印数组：print *数组名@长度，如p *arr@5打印数组前 5 个元素。\n修改变量：set variable 变量名=值（缩写set var），如set var i=5。\n自动显示变量：display 变量名（缩写disp），程序每次中断时自动打印；undisplay 编号取消。\n查看局部变量：info locals；查看函数参数：info args。\n查看变量类型：whatis 变量（如whatis ptr）；查看详细类型定义：ptype 变量/类型（如ptype struct Student）。\n\n\n\n查看调用栈\n\nbacktrace（缩写bt）：查看函数调用链；bt N显示前 N 层，bt -N显示后 N 层。\n切换栈帧：frame N（缩写f N），查看第 N 层栈的局部变量；up &lt;N&gt;、down &lt;N&gt;上下移动栈帧。\n查看当前栈帧详情：info frame（缩写info f）。\n\n\n\n场景 2：多线程程序调试\n多线程程序易出现竞态条件、死锁等问题，GDB 提供专门的多线程调试命令。\n核心命令：\n\n\n查看线程信息：info threads，显示所有线程编号、状态、当前执行位置（*标记当前线程）。\n\n\n切换线程：thread 线程编号，如thread 2切换到线程 2。\n\n\n对线程执行命令：thread apply &lt;线程号&gt; &lt;命令&gt;，如thread apply 2 bt打印线程 2 的调用栈；thread apply all bt打印所有线程栈。\n\n\n控制线程调度：set scheduler-locking [on|off|step]\n\non：仅当前线程执行，其他线程暂停（避免干扰）；\noff：所有线程正常调度（默认）；\nstep：单步执行时仅当前线程移动。\n\n\n\n场景 3：程序崩溃定位（Core Dump 调试）\n当程序因内存错误（如段错误）崩溃时，可生成core文件（内存转储），通过 GDB 分析崩溃原因。\n核心流程：\n\n\n开启 Core Dump 功能\n\n临时开启：ulimit -c unlimited（当前终端有效）；\n永久开启：修改/etc/security/limits.conf，添加* soft core unlimited（需重启）。\n\n\n\n生成并分析 core 文件\n程序崩溃后生成core.PID文件，用 GDB 加载：gdb ./程序名 core文件（如gdb ./test core.12345）。加载后执行backtrace（bt），查看崩溃时的调用栈，定位崩溃位置。\n\n补充命令：core-file &lt;core文件&gt;，在 GDB 交互界面中加载 core 文件。\n\n\n\n在使用 systemd 作为初始化系统的 Linux 发行版使用coredumpctl来处理程序崩溃\ncoredumpctl list  #列出所有core dump记录coredumpctl list program_name #按程序名筛选coredumpctl list --since &quot;1 hour ago&quot; #按时间coredumpctl gdb program_name pid  #通过gdb进行调试\n场景 4：远程调试（如嵌入式设备、服务器程序）\n适用于调试运行在远程设备上的程序，本地通过 GDB 连接远程进程。\n核心流程：\n\n\n远程端启动 GDB Server\n远程设备安装gdbserver，启动命令：gdbserver 远程IP:端口 程序名（如gdbserver 192.168.1.100:1234 ./test）。\n\n\n本地 GDB 连接远程\n本地启动 GDB：gdb ./test，执行target remote 远程IP:端口（如target remote 192.168.1.100:1234），连接后即可像调试本地程序一样操作。\n\n\n场景 5：内存与寄存器调试\n用于直接检查内存数据或 CPU 寄存器状态，适合调试内存错误（如越界、野指针）。\n核心命令：\n\n\n查看内存：x/&lt;n&gt;&lt;f&gt;&lt;u&gt; 地址（x即 examine）\n\nn：单元数；f：格式（x/d/u/o/t/c/f）；u：单元大小（b/h/w/g）。\n示例：x/10xw 0x7fffffffde40（以 16 进制显示 10 个 4 字节单元）；x/s 地址以字符串格式查看。\n\n\n\n查看寄存器\n\ninfo registers：显示所有通用寄存器；info registers &lt;寄存器名&gt;：显示指定寄存器（如info registers rip）。\n修改寄存器：set $&lt;寄存器&gt;=&lt;值&gt;，如set $rip=0x400520（谨慎使用）。\n\n\n\n场景 6：多进程调试\n针对fork()创建的多进程程序，控制跟踪父进程或子进程。\n核心命令：\n\n\nset follow-fork-mode [parent|child]：设置fork()后跟踪的进程（默认跟踪父进程）。\n\n\nset detach-on-fork [on|off]：设置是否分离未跟踪的进程（默认分离，未跟踪进程继续运行）。\n\n\ninfo inferiors：显示所有进程信息；inferior &lt;进程号&gt;：切换到指定进程。\n\n\n二、GDB 使用注意事项\n\n\n编译必须带-g选项\n若未加-g，GDB 无法识别行号、变量名等调试信息，只能看到汇编代码，失去调试意义。\n\n\n避免高优化级别编译\n用-O2、-O3等优化选项编译时，编译器可能删除变量、重排代码，导致 GDB 无法查看变量或单步混乱。调试时建议用-O0（无优化）。\n\n\n处理信号时需谨慎\n程序可能收到信号（如SIGINT、SIGSEGV），默认 GDB 会捕获并中断。可通过handle 信号 动作设置：\n\n如handle SIGINT nostop（收到Ctrl+C时不中断）；handle SIGSEGV stop print（段错误时中断并打印）。\n\n\n\n区分next与step\n\nnext：不进入函数，适合快速跳过；step：进入函数，适合调试函数内部逻辑。新手易混淆导致效率低。\n\n\n\nCore 文件的存储与清理\ncore 文件可能很大（与程序内存占用一致），生产环境需限制大小（如ulimit -c 1024），并及时清理无用文件。\n\n\n远程调试需保持程序一致性\n本地与远程程序需为同一源码、同一编译选项编译，否则调试信息不匹配。\n\n\n三、GDB 扩展知识点\n1. 监视点（高级断点）\n\n\nwatch 变量：变量被修改时中断；\n\n\nrwatch 变量：变量被读取时中断；\n\n\nawatch 变量：变量被读取或修改时中断。示例：watch count，当count值变化时自动中断，无需手动设置断点。\n\n\n2. GDB 脚本与自动化\n\n\n.gdbinit配置文件：启动 GDB 时自动加载，可定义别名或自动执行命令。示例：在~/.gdbinit中添加alias ll = info locals（用ll快速查看局部变量）。\n\n\n自定义命令：通过 define 命令名\n定义批量操作，如：\ndefine dbg  bt          # 打印调用栈  info locals # 打印局部变量  print i     # 打印变量iend\n执行dbg即可一次性执行上述命令。\n\n\n3. 宏调试\nC/C++ 宏在预处理阶段展开，默认 GDB 无法调试。需编译时添加-ggdb3（更详细调试信息）和-fmacro-prefix-map=.=（保留宏路径），然后：\n\n\ninfo macro 宏名：查看宏定义；\n\n\nmacro expand 宏调用：查看宏展开结果。\n\n\n4. 断点保存与恢复\n\n\nsave breakpoints &lt;文件&gt;：将当前断点保存到文件（如save breakpoints bps.txt）；\n\n\nsource &lt;文件&gt;：恢复断点（如source bps.txt）。\n\n\n5. 与 IDE 集成\nGDB 可与 VS Code、Clion 等 IDE 集成，通过图形界面操作（点击设置断点、单步），底层依赖 GDB 核心功能。以 VS Code 为例，需在.vscode/launch.json中配置miDebuggerPath为 GDB 路径。\n","categories":["编程"],"tags":["C++","工具","GDB"]},{"title":"VScode中配置MSVC","url":"/2025/06/07/C++/vscode%E4%B8%AD%E9%85%8D%E7%BD%AEMSVC/","content":"\n觉得VS2022有点重，便在vscode中写C++项目，收集资料，结合ai整理出记录\n\n\nvscode中配置MSVC\n一、前置知识（理解环境配置的基础）\n\n\nC/C++编译器与IDE的区别\n\n编译器：负责将代码编译为可执行文件，常用类型包括GCC、MinGW、MSVC（本文核心使用MSVC）；\nIDE：集成开发环境（如Codeblocks、VS Code、Dev C++），仅提供编辑、调试界面，需依赖编译器才能运行代码；\n兼容性：仅使用标准库的代码可跨编译器运行，使用特定编译器独有库的代码需对应编译器（甚至版本）。\n\n\n\nWindows环境变量详解\n\n定义：操作系统中存储应用程序所需信息的对象，可理解为“路径指针”；\n分类：\n\n用户变量：仅对当前登录用户生效，优先级高于系统变量；\n系统变量：对所有用户生效；\n\n\n核心作用：简化路径调用（如将exe所在目录加入Path变量后，无需输入完整路径即可调用exe）；\n关键操作：\n\n查看变量：命令行输入echo %变量名%（如echo %SystemRoot%，输出C:\\WINDOWS）；\n重要变量：Path（存储二进制可执行文件目录，多以“bin”结尾）、自定义变量（如JAVA_HOME，用于统一路径引用）。\n\n\n\n\n\n二、安装步骤（环境配置的前提）\n\n\n安装VS Code\n\n操作：自行下载安装，安装后自动添加环境变量，需重启电脑生效。\n\n\n\n安装Visual Studio（核心依赖）\n\n版本选择：下载Visual Studio Installer，选择Visual Studio Community 2022（17.7.4版）（免费，适用于学生、开源参与者）；\n必选组件：勾选**“使用C的桌面开发”**（该组件包含MSVC工具链和Windows SDK，是编译C代码的核心）；\n系统适配（Windows 10用户）：在“安装详细信息”中，取消勾选“Windows 11 SDK”，并勾选“Windows 10 SDK”（如版本10.0.20348.0）；\n安装路径：\n\n2022版默认路径：C:\\Program Files\\Microsoft Visual Studio\\2022\\Community；\n2019及以下版路径：C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community（路径含“(x86)”）；\n\n\n\n\n\n三、配置系统环境变量（VS Code编译的关键）\n\n添加MSVC编译器(cl.exe)所在的目录,MSVC,win sdk的头文件和库文件所在目录\n\n需添加7条系统环境变量，其中前4条为基础变量（需按实际安装路径修改），后3条依赖前4条的路径，具体如下表：\n\n\n\n变量类别\n变量名\n变量值（以2022版为例）\n\n\n\n\n基础变量\nVCTools(Visual Studio的VC工具目录)\nC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\n\n\n基础变量\nWIN10KITS\nC:\\Program Files (x86)\\Windows Kits\\10\n\n\n基础变量\nMSVC_VERSION\n14.37.32822\n\n\n基础变量\nWIN_SDK_VERSION\n10.0.20348.0\n\n\n核心变量\nINCLUDE\n%VCTools%\\MSVC%MSVC_VERSION%\\include;%WIN10KITS%\\Include%WIN_SDK_VERSION%\\ucrt;%WIN10KITS%\\Include%WIN_SDK_VERSION%\\um;%WIN10KITS%\\Include%WIN_SDK_VERSION%\\shared;\n\n\n核心变量\nLIB\n%WIN10KITS%\\Lib%WIN_SDK_VERSION%\\um\\x64;%WIN10KITS%\\Lib%WIN_SDK_VERSION%\\ucrt\\x64;%VCTools%\\MSVC%MSVC_VERSION%\\lib\\x64;\n\n\nPath新增\nPath\n%VCTools%\\MSVC%MSVC_VERSION%\\bin\\Hostx64\\x64\n\n\n\n四、验证环境变量（确保配置有效）\n打开Windows命令提示符，执行以下命令验证配置是否成功，输出结果需与预期一致：\n\n\n输入cl：输出“用于x64的Microsoft ® C/C++优化编译器19.37.32824版 版权所有© Microsoft Corporation”，说明编译器可正常调用；\n\n\n输入echo %MSVC_VERSION%：输出设定的MSVC版本（如14.37.32822）；\n\n\n输入echo %WIN_SDK_VERSION%：输出设定的SDK版本（如10.0.20348.0）；\n\n\n输入echo %INCLUDE%：输出完整的头文件目录列表，且路径与配置的一致。\n\n\n五、VS Code配置（生成编译所需文件）\n\n\n创建项目目录与文件\n\n打开命令提示符，依次执行以下命令：\n\nmkdir CppTest：创建名为“CppTest”的项目文件夹；\ncd CppTest：进入该文件夹；\ntype nul &gt; hello.cpp：创建空的C++文件“hello.cpp”；\ncode .：用VS Code打开当前目录（弹出“信任文件夹”弹窗时，选择“信任”）。\n\n\n\n\n\n安装必要插件\n\n在VS Code扩展市场搜索并安装C/C++ Extension Pack\n\n\n\n生成配置文件\n\n\n生成c_cpp_properties.json：\n\n在VS Code顶部搜索框输入&gt; Edit Configurations (UI)（需先打开hello.cpp文件）；\n点击高亮选项，弹出配置界面后直接关闭，VS Code会在项目目录下生成隐藏文件夹.vscode，并自动创建c_cpp_properties.json（默认配置compilerPath为cl.exe，cppStandard为c++11）；\n\n\n\n生成tasks.json：\n\n在搜索框输入&gt; Default Build Task；\n选择C/C++ cl.exe 生成活动文件，VS Code会在.vscode文件夹中自动生成tasks.json（包含编译命令cl.exe及参数，如/zi（生成调试信息）、/EHsc（启用C++异常处理））\n\n&#123;\t&quot;version&quot;: &quot;2.0.0&quot;,\t&quot;tasks&quot;: [\t\t&#123;\t\t\t&quot;type&quot;: &quot;cppbuild&quot;,\t\t\t&quot;label&quot;: &quot;C/C++: cl.exe build active file&quot;,     #用来标识tasks.json文件\t\t\t&quot;command&quot;: &quot;cl.exe&quot;,\t\t\t&quot;args&quot;: [\t\t\t\t&quot;/Zi&quot;,\t\t\t\t&quot;/EHsc&quot;,\t\t\t\t&quot;/nologo&quot;,\t\t\t\t&quot;/Fe$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,\t\t\t\t&quot;$&#123;file&#125;&quot;\t\t\t],\t\t\t&quot;options&quot;: &#123;\t\t\t\t&quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;\t\t\t&#125;,\t\t\t&quot;problemMatcher&quot;: [\t\t\t\t&quot;$msCompile&quot;\t\t\t],\t\t\t&quot;group&quot;: &#123;\t\t\t\t&quot;kind&quot;: &quot;build&quot;,\t\t\t\t&quot;isDefault&quot;: true\t\t\t&#125;,\t\t\t&quot;detail&quot;: &quot;compiler: cl.exe&quot;\t\t&#125;\t]&#125;\n\n\n生成launch.json\n\n\n&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;(Windows) Launch&quot;,            &quot;type&quot;: &quot;cppvsdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,            &quot;environment&quot;: [],            &quot;console&quot;: &quot;externalTerminal&quot;,            &quot;preLaunchTask&quot;: &quot;C/C++: cl.exe build active file&quot;        &#125;    ]&#125;这是用来启动 tasks.json生成的exe文件其中preLaunchTask参数是指在启动launch.json文件里的工具,先启动对应tasks.json里的工具\n\n\n六、运行测试（验证环境是否可用）\n\n\n编写测试代码：在hello.cpp中写入以下Hello World程序：\n#include &lt;iostream&gt;using namespace std;void main()&#123;    cout&lt;&lt;&quot;Hello World&quot;&lt;&lt;endl;&#125;\n\n\n执行程序：\n\n点击VS Code菜单栏“运行”→“以非调试模式运行”；\n弹出调试器选择框，选择“C/C++ (Windows)”；\n结果：控制台输出“Hello World”，说明环境配置成功。\n\n\n\n七、常见疑问\n\n\n为何Visual Studio无需手动配置即可运行C++程序？\n\n答：Visual Studio在创建项目时，会自动配置头文件目录、库目录等（如“VC++目录”中的$(VC_LibraryPath_x64)、$(WindowsSDK_IncludePath)等内部变量），而VS Code需手动定义这些路径。\n\n\n\n\n关键问题\n问题1：在Windows 10系统中安装Visual Studio以配置VS Code的C++（MSVC）环境时，需注意哪些关键选项，避免后续编译出错？\n答：需注意3个关键选项：\n\n\n版本选择：选择Visual Studio Community 2022（17.7.4版，免费且功能满足需求），避免安装付费的Enterprise或Professional版；\n\n\n组件勾选：必须勾选**“使用C的桌面开发”**（该组件包含MSVC工具链和Windows SDK，是编译C代码的核心依赖，若不勾选则缺少编译器和库文件）；\n\n\nSDK适配：在“安装详细信息”中，取消勾选“Windows 11 SDK”，并勾选Windows 10 SDK（如版本10.0.20348.0）（Windows 11 SDK在Windows 10系统中兼容性未知，可能导致编译失败）。\n\n\n问题2：配置VS Code的C++（MSVC）环境时，为何必须添加INCLUDE和LIB这两个系统环境变量？它们的路径由哪些部分构成（以2022版为例）？\n答：（1）添加原因：\nINCLUDE和LIB是MSVC编译器和链接器的核心依赖变量——INCLUDE用于告诉编译器头文件（.h）的查找路径，确保代码中#include &lt;iostream&gt;等指令能找到对应文件；LIB用于告诉链接器库文件（.lib）的查找路径，确保编译后的目标文件能正确链接系统或第三方库，避免“无法解析的外部符号”等错误。\n（2）路径构成（以2022版、MSVC版本14.37.32822、SDK版本10.0.20348.0为例）：\n\n\nINCLUDE路径：%VCTools%\\MSVC\\%MSVC_VERSION%\\include（MSVC自带头文件） + %WIN10KITS%\\Include\\%WIN_SDK_VERSION%\\ucrt（SDK通用CRT头文件） + %WIN10KITS%\\Include\\%WIN_SDK_VERSION%\\um（SDK用户模式头文件） + %WIN10KITS%\\Include\\%WIN_SDK_VERSION%\\shared（SDK共享头文件）；\n\n\nLIB路径：%WIN10KITS%\\Lib\\%WIN_SDK_VERSION%\\um\\x64（SDK用户模式库文件，x64架构） + %WIN10KITS%\\Lib\\%WIN_SDK_VERSION%\\ucrt\\x64（SDK通用CRT库文件，x64架构） + %VCTools%\\MSVC\\%MSVC_VERSION%\\lib\\x64（MSVC自带库文件，x64架构）。\n\n\n问题3：在VS Code中完成系统环境变量配置后，如何通过具体操作生成编译所需的配置文件，并成功运行第一个C++程序？\n答：具体步骤分3步：\n\n\n生成配置文件：\n\n生成c_cpp_properties.json：打开项目中的hello.cpp文件，在VS Code顶部搜索框输入&gt; Edit Configurations (UI)，点击高亮选项后直接关闭，系统会自动在.vscode文件夹中生成该文件（默认配置编译器路径为cl.exe，适配MSVC）；\n生成tasks.json：在搜索框输入&gt; Default Build Task，选择C/C++ cl.exe 生成活动文件，系统会自动生成该文件（包含cl.exe的编译参数，如/Fe${fileDirname}\\\\${fileBasenameNoExtension}.exe，指定输出exe路径）；\n\n\n\n编写测试代码：在hello.cpp中写入Hello World程序（需包含&lt;iostream&gt;头文件，使用cout输出）；\n\n\n运行程序：\n\n点击VS Code菜单栏“运行”→“以非调试模式运行”；\n在弹出的调试器选择框中，选择“C/C++ (Windows)”；\n查看结果：控制台输出“Hello World”，说明程序运行成功，环境配置完成。\n\n\n\n","categories":["编程"],"tags":["工具"]},{"title":"MSVC,g++的简单使用","url":"/2025/06/07/C++/MSVC,g++%20%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0/","content":"\nmsvc和g++的常用参数\n\n\nMSVC,g++ 使用参数\nMSVC（Microsoft Visual C++）编译器核心为cl.exe（编译）和link.exe（链接），以下是常用参数精简说明：\n一、编译参数（cl.exe）\n\n\n基础控制\n\n/c：仅编译生成.obj，不链接\n/Fo&lt;路径&gt;：指定.obj输出路径（如/Foobj/）\n/Fe&lt;路径&gt;：指定最终可执行文件路径\n\n\n\n语言标准\n\n/std:c++11/c++17/c++20：指定C++标准\n/std:c11：指定C语言标准\n\n\n\n宏与路径\n\n/D&lt;宏&gt;：定义宏（如/DDEBUG）\n/I&lt;目录&gt;：添加头文件搜索目录\n\n\n\n警告与调试\n\n/W4：最高警告级别；/WX：警告视为错误\n/Zi：生成调试符号（.pdb）\n\n\n\n优化\n\n/Od：禁用优化（Debug用）\n/O2：优化执行速度（Release默认）\n/GL：启用全程序优化（需配合链接/LTCG）\n\n\n\n二、链接参数（link.exe）\n\n\n输出控制\n\n/OUT:&lt;路径&gt;：指定输出文件（.exe/.dll）\n/DLL：生成动态库（.dll）\n/SUBSYSTEM:CONSOLE：控制台程序（默认）；WINDOWS：窗口程序\n\n\n\n库与符号\n\n/LIBPATH:&lt;目录&gt;：添加库文件搜索目录\n&lt;库名.lib&gt;：指定依赖库（如kernel32.lib）\n/DEBUG：生成调试符号（配合编译/Zi）\n\n\n\n优化\n\n/LTCG：链接时优化（配合编译/GL）\n/OPT:REF：移除未使用代码\n\n\n\n三、示例\n\n\nDebug模式：\ncl /c /Od /Zi /W4 main.cpp /Foobj/\nlink /DEBUG obj/main.obj /OUT:app.exe\n\n\nRelease模式：\ncl /c /O2 /GL /W4 /DRELEASE main.cpp\nlink /LTCG main.obj /OUT:app.exe\n\n\n通过VS项目属性（右键项目→属性）可图形化配置所有参数。\ng++常用参数（简洁版）\ng是GNU C编译器，常用参数如下：\n\n\n基础控制\n\n-c：仅编译生成.o目标文件，不链接\n-o &lt;文件名&gt;：指定输出文件（如-o app.exe）\n-I&lt;目录&gt;：添加头文件搜索路径\n\n\n\n语言标准\n\n-std=c++11/c++17/c++20：指定C++标准\n-std=c11：指定C语言标准\n\n\n\n宏与警告\n\n-D&lt;宏&gt;：定义宏（如-DDEBUG）\n-Wall：开启大部分警告；-Werror：警告视为错误\n\n\n\n调试与优化\n\n-g：生成调试信息（供gdb使用）\n-O0：无优化（Debug）；-O2：中度优化（常用）；-O3：最高优化\n\n\n\n链接控制\n\n-L&lt;目录&gt;：添加库文件搜索路径\n-l&lt;库名&gt;：链接指定库（如-lpthread链接线程库）\n-shared：生成动态库（.so）\n\n\n\ng++与MSVC参数对比整合表\n\n\n\n功能类别\ng++参数\nMSVC参数（cl.exe/link.exe）\n说明\n\n\n\n\n输出指定\n-o &lt;文件&gt;\n/Fe&lt;文件&gt;（cl）//OUT:&lt;文件&gt;（link）\n指定最终输出文件\n\n\n仅编译\n-c\n/c（cl）\n只生成目标文件，不链接\n\n\n头文件路径\n-I&lt;目录&gt;\n/I&lt;目录&gt;（cl）\n添加头文件搜索目录\n\n\nC++标准\n-std=c++20\n/std:c++20（cl）\n指定C++标准版本\n\n\n宏定义\n-DDEBUG\n/DDEBUG（cl）\n定义预处理宏\n\n\n警告控制\n-Wall -Werror\n/W4 /WX（cl）\n开启警告并视为错误\n\n\n调试信息\n-g\n/Zi（cl）+/DEBUG（link）\n生成调试符号\n\n\n优化级别\n-O0（无）/ -O2（中）\n/Od（无）/ /O2（中）（cl）\n控制代码优化程度\n\n\n库路径\n-L&lt;目录&gt;\n/LIBPATH:&lt;目录&gt;（link）\n添加库文件搜索目录\n\n\n链接库\n-l&lt;库名&gt;（如-lm）\n&lt;库名.lib&gt;（如math.lib）（link）\n链接指定库文件\n\n\n生成动态库\n-shared\n/DLL（link）\n生成动态链接库\n\n\n\n示例对比：\n\n\ng++编译Debug版本：\ng++ -c -g -O0 -Wall main.cpp -o obj/main.o\ng++ obj/main.o -o app.exe\n\n\nMSVC编译Debug版本：\ncl /c /Zi /Od /W4 main.cpp /Foobj/main.obj\nlink obj/main.obj /DEBUG /OUT:app.exe\n\n\n","categories":["编程"],"tags":["C++","工具","MSVC","g++"]},{"title":"Vim的相关用法","url":"/2025/05/15/linux/Vim%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/","content":"\nvim的用法\n\n \n一、Vim 基础认知与核心模式\n1. Vim 简介与学习资源\n\n\n定位：Linux 系统上的高效文本编辑器，支持多模式操作，且多数主流 IDE 可安装 Vim 插件实现兼容。\n\n\n权威学习资料：Vim 内置帮助文档，启动 Vim 后输入:help即可查看（英文）；也可通过科学上网获取更多演变历史与学习资源。\n\n\n核心配置文件：Linux 系统中为~/.vimrc（家目录下的隐藏文件，不存在可手动创建），可配置显示行号、快捷键映射、插件等，例如将ESC键映射为连续两次j键：inoremap jj &lt;Esc&gt;。\n\n\n2. Vim 四大核心模式\n\n\n\n模式名称\n进入方式\n核心功能\n退出方式\n\n\n\n\n正常模式\nVim 启动默认进入；其他模式按ESC（或jj）\n浏览文件、光标移动、复制 / 粘贴 / 删除等操作\n按i/I/a/A/o/O等进入插入模式；按:或/进入命令模式\n\n\n插入模式\n正常模式下按i/I/a/A/o/O/s/S\n输入、编辑文本\n按ESC返回正常模式\n\n\n命令模式\n正常模式下按:（冒号）或/（斜杠）\n执行文件操作、环境设置、查找替换等指令\n执行指令后自动返回正常模式；未执行指令按ESC返回\n\n\n可视模式\n正常模式下按v（字符可视）、V（行可视）、Ctrl+v（块状可视）\n选中文本（类似鼠标选择），便于批量操作\n按ESC（或jj）返回正常模式；再次按对应模式键退出\n\n\n\n二、Vim 文件操作：打开、切换与分屏\n1. 打开文件\n\n\n打开单个文件：终端输入vim 文件名，示例：vim file1（打开名为file1的文件）。\n\n\n打开多个文件：终端输入vim 文件名1 文件名2 ...，示例：vim file1 file2（打开file1和file2，默认显示第一个文件）。\n\n\n2. 多文件切换与管理\n\n\n查看已打开文件列表：正常模式下按:进入命令模式，输入:ls，会显示所有打开文件的序号与文件名。\n\n\n切换文件：命令模式下输入:b序号（b即buffer），示例：:b2（切换到序号为 2 的文件）；也可输入:bn（切换到下一个文件）、:bp（切换到上一个文件）。\n\n\n3. 分屏操作\n（1）终端启动时直接分屏\n\n\n左右分屏：终端输入vim -On 文件名1 文件名2 ...（O为大写，n为文件数量），示例：vim -O2 file1 file2（左右分屏显示file1和file2）。\n\n\n上下分屏：终端输入vim -on 文件名1 文件名2 ...（o为小写，n为文件数量），示例：vim -o2 file1 file2（上下分屏显示file1和file2）。\n\n\n（2）Vim 内部分屏\n\n\n\n分屏类型\n操作命令\n示例\n\n\n\n\n上下分割当前文件\n正常模式下按Ctrl + w s\n按Ctrl + w后松开，再按s，当前文件上下分屏\n\n\n上下分割并打开新文件\n命令模式输入:sp 文件名\n:sp file3（当前文件与file3上下分屏）\n\n\n左右分割当前文件\n正常模式下按Ctrl + w v\n按Ctrl + w后松开，再按v，当前文件左右分屏\n\n\n左右分割并打开新文件\n命令模式输入:vsp 文件名\n:vsp file3（当前文件与file3左右分屏）\n\n\n\n（3）分屏切换与关闭\n\n\n光标切换：正常模式下按Ctrl + w后，按h（左屏）、l（右屏）、j（下屏）、k（上屏），示例：Ctrl + w h（光标移到左侧分屏）。\n\n\n分屏移动：正常模式下按Ctrl + w后，按H（当前分屏移到最左）、L（当前分屏移到最右）、J（当前分屏移到最下）、K（当前分屏移到最上），示例：Ctrl + w H（当前分屏移到左侧）。\n\n\n关闭分屏：正常模式下按Ctrl + w c（关闭当前分屏）；按Ctrl + w q（关闭当前分屏，若为最后一个分屏则退出 Vim）。\n\n\n三、Vim 退出与文件保存命令\n\n\n\n命令\n功能描述\n\n\n\n\n:w\n保存当前文件修改，不退出\n\n\n:w!\n强制保存当前文件修改，不退出（适用于只读文件等场景）\n\n\n:w 文件名\n将当前文件修改保存为新文件（另存为）\n\n\n:q\n退出 Vim，仅适用于未修改的文件\n\n\n:q!\n强制退出 Vim，不保存任何修改\n\n\n:qa!\n强制退出所有打开的文件，不保存任何修改\n\n\n:wq\n保存当前文件修改并退出 Vim\n\n\n:x\n保存当前文件修改并退出 Vim（与:wq功能类似，仅文件有修改时才保存）\n\n\n:e 文件名\n在当前 Vim 窗口打开新文件\n\n\n:e!\n放弃当前文件所有修改，恢复到上次保存状态\n\n\n:saveas 文件名\n将当前文件另存为指定文件名，保留原文件\n\n\nZZ\n正常模式下连续按两次大写Z，保存修改并退出（快捷操作）\n\n\n\n四、Vim 插入模式：文本编辑与快捷进入\n1. 从正常模式进入插入模式的命令\n\n\n\n命令\n功能描述\n\n\n\n\ni\n在光标所在字符前插入文本\n\n\nI\n在光标所在行的行首插入文本\n\n\na\n在光标所在字符后插入文本\n\n\nA\n在光标所在行的行尾插入文本\n\n\no\n在光标所在行下方新建一行，在行首插入文本\n\n\nO\n在光标所在行上方新建一行，在行首插入文本\n\n\ns\n删除光标所在字符，然后插入文本\n\n\nS\n删除光标所在整行，然后在该行首插入文本\n\n\ncw\n删除光标处到当前单词结尾的字符，然后插入文本\n\n\n\n五、Vim 命令模式：环境设置、查找替换与 Linux 命令调用\n1. 文本显示与行号设置\n\n\n\n命令\n功能描述\n\n\n\n\n:set nu\n显示文本行号\n\n\n:set nonu\n取消显示行号\n\n\n:n\n快速定位到第n行（n为数字）\n\n\n\n2. 文本查找与大小写设置\n若需 精准匹配独立单词（仅匹配 test 本身，不包含前后字符），需用单词边界标记 \\&lt; 和 \\&gt;    输入 /（正向查找）或 ?（反向查找）\n\n\n\n命令\n功能描述\n示例\n\n\n\n\n/目标字符串\n从光标位置向后查找目标字符串，匹配结果高亮\n/Vim（查找所有 “Vim”，按n跳转到下一个，N跳转到上一个）\n\n\n:set ic\n查找时忽略大小写\n输入:set ic后，查找 “vim” 会匹配 “Vim”“VIM” 等\n\n\n:set noic\n查找时区分大小写\n输入:set noic后，查找 “vim” 仅匹配 “vim”\n\n\n\n3. 文本删除与替换\n（1）多行删除\n\n\n命令格式：:n1,n2d（n1为起始行号，n2为结束行号，d为删除关键字）\n\n\n示例：:3,5d（删除第 3 行到第 5 行的文本）\n\n\n（2）文本替换\n\n\n命令格式：:{作用范围}s/{目标字符串}/{替换字符串}/{替换标志}\n\n\n详细示例：\n\n\n\n\n\n命令\n作用范围\n替换标志含义\n功能描述\n\n\n\n\n:s/zempty/handsome/g\n当前行\ng（全局替换）\n将当前行所有 “zempty” 替换为 “handsome”\n\n\n:%s/zempty/handsome/g\n全文（%表示）\ng（全局替换）\n将全文所有 “zempty” 替换为 “handsome”\n\n\n:2,4s/zempty/handsome/g\n第 2-4 行\ng（全局替换）\n将第 2-4 行所有 “zempty” 替换为 “handsome”\n\n\n:'&lt;,'&gt;s/zempty/handsome/g\n可视模式选区\ng（全局替换）\n可视模式选中文本后，输入:, 自动补全:'&lt;,'&gt;, 再输入命令，替换选区内 “zempty” 为 “handsome”\n\n\n:s/zempty/handsome\n当前行\n无（仅替换第一次匹配）\n将当前行第一个 “zempty” 替换为 “handsome”\n\n\n:%s/zempty/handsome/i\n全文\ni（忽略大小写）\n全文替换 “zempty” 为 “handsome”，忽略大小写\n\n\n:%s/zempty/handsome/gi\n全文\ng+i（全局 + 忽略大小写）\n全文替换所有 “zempty”（忽略大小写）为 “handsome”\n\n\n:%s/zempty/handsome/gc\n全文\ng+c（全局 + 确认）\n全文替换 “zempty” 为 “handsome”，每处匹配需确认（按y确认，n跳过，a全替换，q退出）\n\n\n\n4. Vim 中调用 Linux 命令\n（1）执行 Linux 命令并查看结果（不插入文本）\n\n\n命令格式：:!Linux命令（!为调用外部命令的标志）\n\n\n示例：\n\n:!date：执行date命令，显示当前系统时间，按Enter返回 Vim 编辑界面。\n:!ls：执行ls命令，显示当前目录下的文件列表，按Enter返回 Vim。\n:!pwd：执行pwd命令，显示当前工作目录路径，按Enter返回 Vim。\n\n\n\n（2）执行 Linux 命令并将结果插入文本\n\n\n命令格式：:r !Linux命令（r为 “读取” 标志，将命令结果读取到文本中）\n\n\n示例：\n\n:r !date：执行date命令，将当前时间插入到光标所在位置（如光标在第 5 行，时间会插入到第 5 行之后）。\n:r !cat file2：执行cat file2命令，将file2的内容插入到光标所在位置。\n:r !ls -l：执行ls -l命令，将目录下文件的详细信息（权限、大小等）插入到文本中。\n\n\n\n5. 自定义快捷键与文本缩写\n（1）自定义快捷键（map命令）\n\n\n命令格式：:map 快捷键 操作序列（快捷键需用Ctrl + v + 按键生成，如Ctrl + m需按Ctrl + v + m显示为^M）\n\n\n示例：\n\n:map ^M I#&lt;ESC&gt;：^M代表Ctrl + m，按该快捷键可在光标所在行首插入#（注释符号），并返回正常模式。\n:map ^D Ahelloworld&lt;ESC&gt;：^D代表Ctrl + d，按该快捷键可在光标所在行尾添加 “helloworld”，并返回正常模式。\n\n\n\n（2）文本缩写（ab命令）\n\n\n命令格式：:ab 缩写 完整文本（插入模式下输入缩写，会自动替换为完整文本）\n\n\n示例：\n\n:ab email xxx@gmail.com：设置后，在插入模式输入 “email”，会自动替换为 “xxx@gmail.com”，适用于频繁输入的长文本。\n\n\n\n六、Vim 正常模式：光标移动、复制粘贴与文本操作\n\n\n\n移动类型\n快捷键\n功能\n\n\n\n\n基础方向移动\nh/j/k/l\n左 / 下 / 上 / 右移动光标\n\n\n行内移动\n0\n移动到行首\n\n\n行内移动\n^\n移动到本行第一个非空白字符\n\n\n行内移动\n$\n移动到行尾\n\n\n行内移动\ng_\n移动到本行最后一个非空白字符\n\n\n单词移动\nw\n移动到下一个单词开头\n\n\n单词移动\ne\n移动到下一个单词结尾\n\n\n字符定位移动\nfa（a 为目标字符）\n移动到本行下一个 “a” 处\n\n\n字符定位移动\nnfa（n 为次数）\n移动到本行第 n 个 “a” 处\n\n\n字符定位移动\nFa\n移动到本行上一个 “a” 处\n\n\n字符定位移动\nnFa\n移动到本行第 n 个 “a”（向前找）\n\n\n字符定位移动\nta\n移动到 “a” 的前一个字符\n\n\n字符定位移动\nnta\n移动到第 n 个 “a” 的前一个字符\n\n\n字符定位移动\nTa\n移动到 “a” 的前一个字符（向前找）\n\n\n字符定位移动\nnTa\n移动到第 n 个 “a” 的前一个字符（向前找）\n\n\n字符定位跳转\n;/,\nf/F/t/T 后，跳转到下一个 / 上一个目标字符\n\n\n跨行移动\nnG\n定位到第 n 行首\n\n\n跨行移动\ngg\n定位到第一行首\n\n\n跨行移动\nG\n定位到最后一行首\n\n\n\n","categories":["编程"],"tags":["工具","Linux"]},{"title":"C++ 右值引用相关要点","url":"/2025/05/07/C++/C++%20%E5%8F%B3%E5%80%BC%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","content":"\n包含了右值引用 移动语义 移动构造函数 移动赋值运算符 move 完美转发\n\n\nC++ 右值相关知识点深度解析\n目录\n\n\n概述\n\n\n左值与右值的概念\n\n\n右值引用\n\n\n移动语义\n\n\n移动构造函数\n\n\n移动赋值运算符\n\n\nstd::move 详解\n\n\n完美转发与 std::forward\n\n\n设计哲学与技术原理\n\n\n实际应用场景\n\n\n常见陷阱与最佳实践\n\n\n总结\n\n\n概述\nC11 引入的右值引用、移动语义和完美转发是现代 C 的核心特性，它们极大地提升了程序的性能和资源管理效率。这些特性的设计体现了 C++“零开销抽象” 的哲学思想，允许开发者在不牺牲性能的前提下编写更简洁、更安全的代码。\n核心价值：\n\n\n性能优化：避免不必要的深拷贝，将 O (n) 操作降为 O (1)\n\n\n资源管理：实现资源所有权的安全转移\n\n\n代码简洁：支持更优雅的 API 设计和泛型编程\n\n\n左值与右值的概念\n左值（Lvalue）\n定义特征：\n\n\n拥有持久身份，可以取地址（&amp; 操作符）\n\n\n通常有名称，在内存中有确定的位置\n\n\n可以出现在赋值运算符的左侧\n\n\n示例：\nint x = 10;          // x是左值std::string s = &quot;hello&quot;;  // s是左值int&amp; get_ref() &#123; return x; &#125;  // 返回左值引用\n右值（Rvalue）\n定义特征：\n\n\n临时性的，即将销毁的对象\n\n\n通常没有名称，不能取地址\n\n\n只能出现在赋值运算符的右侧\n\n\n类型分类：\n\n\n纯右值（Pure Rvalue）：字面量、表达式结果、函数返回的非引用类型\n\n\n将亡值（Xvalue）：通过 std::move 转换的左值、返回右值引用的函数调用\n\n\n示例：\n10;                  // 纯右值：字面量x + y;               // 纯右值：表达式结果std::string(&quot;hello&quot;); // 纯右值：临时对象std::move(s);        // 将亡值：通过move转换\n关键区别\n\n\n\n特性\n左值\n右值\n\n\n\n\n可寻址性\n可以取地址\n不能取地址\n\n\n持久性\n持久存在\n临时存在\n\n\n赋值位置\n可在左侧\n只能在右侧\n\n\n引用绑定\n左值引用、const 左值引用\n右值引用、const 左值引用\n\n\n\n右值引用\n基本语法\n右值引用使用&amp;&amp;符号表示，专门用于绑定到右值：\nint&amp;&amp; rref1 = 10;          // 正确：绑定到纯右值int&amp;&amp; rref2 = x + y;       // 正确：绑定到表达式结果int&amp;&amp; rref3 = std::move(x); // 正确：绑定到将亡值\n重要特性\n1. 延长临时对象生命周期\n右值引用可以延长临时对象的生命周期，使其与引用的生命周期一致：\nstd::string&amp;&amp; s = std::string(&quot;hello&quot;);// 临时对象的生命周期被延长到s的作用域结束\n2. 右值引用本身是左值\n虽然绑定到右值，但右值引用变量本身是左值，因为它有名称并且可以取地址：\nint&amp;&amp; rref = 10;rref = 20;               // 可以修改int* ptr = &amp;rref;        // 可以取地址\n3. 引用折叠规则\n在模板推导中，引用的引用会按照以下规则折叠(以少的为准)：\nT&amp; &amp;   → T&amp;    // 左值引用 + 左值引用 = 左值引用T&amp; &amp;&amp;  → T&amp;    // 左值引用 + 右值引用 = 左值引用T&amp;&amp; &amp;  → T&amp;    // 右值引用 + 左值引用 = 左值引用T&amp;&amp; &amp;&amp; → T&amp;&amp;   // 右值引用 + 右值引用 = 右值引用\n万能引用（Universal Reference）\n在模板函数中，T&amp;&amp;被称为万能引用，可以接受左值或右值：\ntemplate&lt;typename T&gt;void func(T&amp;&amp; param) &#123;    // 根据实参类型，T会被推导为不同类型&#125;int x = 10;func(x);               // T推导为int&amp;，param是左值引用 int&amp; &amp;&amp; -&gt; int&amp;func(10);              // T推导为int，param是右值引用  int&amp;&amp;   -&gt; int&amp;&amp;\n移动语义\n核心思想\n移动语义的本质是资源所有权的转移，而不是数据的复制。它解决了 C++98/03 中临时对象拷贝效率低下的问题。\n传统拷贝 vs 移动：\n// 传统拷贝：深拷贝，O(n)时间复杂度std::vector&lt;int&gt; v1 = &#123;1, 2, 3, 4, 5&#125;;std::vector&lt;int&gt; v2 = v1;  // 拷贝所有元素// 移动语义：资源转移，O(1)时间复杂度std::vector&lt;int&gt; v3 = std::move(v1); // 只需转移指针\n实现原理\n移动语义通过移动构造函数和移动赋值运算符实现，这两个特殊成员函数接受右值引用参数。\n何时触发移动\n\n\n函数返回临时对象时\n\n\n对象初始化时使用右值\n\n\n使用 std::move 显式转换时\n\n\n标准库容器的某些操作\n\n\n移动构造函数\n基本形式\n移动构造函数接受一个右值引用参数，实现资源的转移：\nclass MyString &#123;private:    char* data_;    size_t size_;public:    // 移动构造函数    MyString(MyString&amp;&amp; other) noexcept        : data_(other.data_), size_(other.size_) &#123;        // 将源对象置于有效但未定义的状态        other.data_ = nullptr;        other.size_ = 0;        std::cout &lt;&lt; &quot;Move constructor called&quot; &lt;&lt; std::endl;    &#125;&#125;;\n关键要点\n1. noexcept 说明符\n强烈建议为移动构造函数添加noexcept，这有助于：\n\n\n提高性能（编译器可以进行更多优化）\n\n\n确保标准库操作的异常安全性\n\n\n避免容器在移动时回退到拷贝\n\n\n2. 源对象状态\n移动后，源对象必须处于有效但未定义的状态：\n\n\n可以安全地析构\n\n\n可以赋值新值\n\n\n但不能依赖其当前值\n\n\n3. 与拷贝构造函数的关系\n当类同时提供拷贝构造函数和移动构造函数时：\n\n\n左值初始化时调用拷贝构造函数\n\n\n右值初始化时调用移动构造函数\n\n\n默认移动构造函数\nC++11 及以后，如果满足以下条件，编译器会自动生成默认移动构造函数：\n\n\n类没有用户定义的拷贝构造函数、拷贝赋值运算符、移动赋值运算符或析构函数\n\n\n所有非静态数据成员都可以移动构造\n\n\nclass MyClass &#123;    std::string name_;    std::vector&lt;int&gt; data_;    // 编译器会自动生成默认移动构造函数&#125;;\n移动赋值运算符\n基本形式\n移动赋值运算符与移动构造函数类似，但用于已存在对象的赋值：\nclass MyString &#123;public:    // 移动赋值运算符    MyString&amp; operator=(MyString&amp;&amp; other) noexcept &#123;        if (this != &amp;other) &#123;  // 防止自赋值            // 释放当前对象的资源            delete[] data_;                        // 转移源对象的资源            data_ = other.data_;            size_ = other.size_;                        // 置空源对象            other.data_ = nullptr;            other.size_ = 0;        &#125;        std::cout &lt;&lt; &quot;Move assignment called&quot; &lt;&lt; std::endl;        return *this;    &#125;&#125;;\n实现要点\n1. 自赋值检查\n必须检查自赋值，避免释放正在使用的资源：\nif (this != &amp;other) &#123;    // 执行移动操作&#125;\n2. 资源释放顺序\n正确的顺序应该是：\n\n\n检查自赋值\n\n\n释放当前对象资源\n\n\n转移源对象资源\n\n\n置空源对象\n\n\n默认移动赋值运算符\n与移动构造函数类似，编译器会在满足条件时自动生成默认移动赋值运算符。\nstd::move 详解\n功能说明\nstd::move是一个标准库函数，用于将左值转换为右值引用，从而触发移动语义。\n注意： std::move本身并不移动任何数据，它只是一个类型转换工具。\n实现原理\ntemplate&lt;typename T&gt;typename std::remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t) noexcept &#123;    return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);&#125;\n使用场景\n1. 显式触发移动语义\nstd::vector&lt;int&gt; v1 = &#123;1, 2, 3&#125;;std::vector&lt;int&gt; v2 = std::move(v1);  // 触发移动构造v1 = std::move(v2);                   // 触发移动赋值\n2. 在容器中高效插入元素\nstd::vector&lt;std::string&gt; vec;std::string s = &quot;hello&quot;;vec.push_back(s);                // 拷贝构造vec.push_back(std::move(s));     // 移动构造，s变为空\n3. 函数返回值优化\nstd::vector&lt;int&gt; create_vector() &#123;    std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5&#125;;    return std::move(v);  // 在某些情况下有助于返回值优化&#125;\n使用注意事项\n1. 移动后的对象状态\n移动后，源对象处于有效但未定义的状态，不应再使用其值：\nstd::string s = &quot;hello&quot;;std::string s2 = std::move(s);// s现在是空的，但可以安全地析构或赋值s = &quot;world&quot;;  // 这是允许的\n2. 不要移动 const 对象\nconst 对象不能被移动，因为移动通常需要修改源对象：\nconst std::string s = &quot;hello&quot;;std::string s2 = std::move(s);  // 这里调用的是拷贝构造函数\n完美转发与 std::forward\n问题背景\n在模板编程中，我们经常需要将参数传递给其他函数。完美转发的目标是保持参数的原始值类别：\n\n\n如果传入左值，目标函数接收到左值\n\n\n如果传入右值，目标函数接收到右值\n\n\n完美转发的实现\n1. 万能引用 + std::forward\ntemplate&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123;    target(std::forward&lt;T&gt;(arg));  // 完美转发&#125;\n2. 引用折叠机制\n完美转发依赖于引用折叠规则：\n// 当传入左值int&amp;时T被推导为int&amp;，T&amp;&amp;变为int&amp; &amp;&amp; → int&amp;（左值引用）// 当传入右值int时T被推导为int，T&amp;&amp;变为int&amp;&amp;（右值引用）\nstd::forward 详解\n实现原理\ntemplate&lt;typename T&gt;T&amp;&amp; forward(typename std::remove_reference&lt;T&gt;::type&amp; arg) noexcept &#123;    return static_cast&lt;T&amp;&amp;&gt;(arg);&#125;template&lt;typename T&gt;T&amp;&amp; forward(typename std::remove_reference&lt;T&gt;::type&amp;&amp; arg) noexcept &#123;    return static_cast&lt;T&amp;&amp;&gt;(arg);&#125;\n使用示例\nvoid process(int&amp; lref) &#123;    std::cout &lt;&lt; &quot;Processing lvalue reference&quot; &lt;&lt; std::endl;&#125;void process(int&amp;&amp; rref) &#123;    std::cout &lt;&lt; &quot;Processing rvalue reference&quot; &lt;&lt; std::endl;&#125;template&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123;    process(std::forward&lt;T&gt;(arg));&#125;int main() &#123;    int x = 10;    wrapper(x);       // 调用process(int&amp;)    wrapper(20);      // 调用process(int&amp;&amp;)    wrapper(std::move(x));  // 调用process(int&amp;&amp;)&#125;\n实际应用\n1. 工厂函数\ntemplate&lt;typename T, typename... Args&gt;std::unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args) &#123;    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));&#125;\n2. 容器的 emplace_back\ntemplate&lt;typename... Args&gt;void emplace_back(Args&amp;&amp;... args) &#123;    // 直接在容器中构造对象，避免拷贝    construct_element(std::forward&lt;Args&gt;(args)...);&#125;\n设计哲学与技术原理\nC++ 设计哲学\n1. 零开销抽象（Zero-overhead Abstraction）\n右值相关特性完美体现了 C++ 的核心设计哲学：\n\n\n不使用时无开销：不使用移动语义时，程序行为与 C++98 一致\n\n\n使用时接近手写代码性能：移动操作的性能接近手动资源管理\n\n\n2. 系统级控制\nC++ 允许开发者直接控制内存和资源：\n\n\n移动语义让开发者能够显式管理资源所有权\n\n\n完美转发保持了对参数传递的精确控制\n\n\n3. 兼容性与演进平衡\nC++11 在引入新特性时保持了与旧代码的兼容性：\n\n\n旧代码可以继续使用拷贝语义\n\n\n新代码可以逐步采用移动语义\n\n\n技术原理深度解析\n1. 值类别系统\nC++11 将表达式分为三个主要类别：\n\n\n左值（Lvalue）：有身份，可被修改\n\n\n纯右值（Prvalue）：临时值，计算结果\n\n\n将亡值（Xvalue）：即将被移动的对象\n\n\n这种分类为移动语义提供了理论基础。\n2. 引用类型系统\nC++ 有四种引用类型：\n\n\n左值引用（T&amp;）：绑定到左值\n\n\n右值引用（T&amp;&amp;）：绑定到右值\n\n\nconst 左值引用（const T&amp;）：绑定到任何值\n\n\nconst 右值引用（const T&amp;&amp;）：绑定到右值，但不能修改\n\n\n3. 特殊成员函数规则\nC++11 及以后的特殊成员函数生成规则：\n\n\n\n用户定义的成员函数\n默认生成的成员函数\n\n\n\n\n无\n全部 5 个特殊成员函数\n\n\n拷贝构造 / 赋值\n不生成移动构造 / 赋值\n\n\n移动构造 / 赋值\n不生成拷贝构造 / 赋值\n\n\n析构函数\n不生成移动构造 / 赋值\n\n\n\n实际应用场景\n1. 标准库容器优化\nstd::vector&lt;std::string&gt; vec;std::string s = &quot;hello world&quot;;// 传统方式：拷贝构造vec.push_back(s);// 优化方式：移动构造vec.push_back(std::move(s));// 最佳方式：直接构造（完美转发）vec.emplace_back(&quot;hello world&quot;);\n2. 智能指针管理\n// std::unique_ptr只能移动，不能拷贝std::unique_ptr&lt;int&gt; p1(new int(42));std::unique_ptr&lt;int&gt; p2 = std::move(p1);  // 移动所有权// std::shared_ptr可以拷贝，但移动更高效std::shared_ptr&lt;int&gt; p3(new int(42));std::shared_ptr&lt;int&gt; p4 = std::move(p3);  // 移动，引用计数不变\n3. 函数返回值优化\n// 传统方式：可能产生临时对象std::vector&lt;int&gt; create_big_vector() &#123;    std::vector&lt;int&gt; v(1000000);    return v;  // RVO优化&#125;// 移动语义：明确转移所有权std::vector&lt;int&gt; create_big_vector_move() &#123;    std::vector&lt;int&gt; v(1000000);    return std::move(v);  // 在某些情况下有用&#125;\n4. 自定义容器实现\ntemplate&lt;typename T&gt;class MyVector &#123;private:    T* data_;    size_t size_;    size_t capacity_;public:    // 移动构造函数    MyVector(MyVector&amp;&amp; other) noexcept        : data_(other.data_), size_(other.size_), capacity_(other.capacity_) &#123;        other.data_ = nullptr;        other.size_ = 0;        other.capacity_ = 0;    &#125;    // 移动赋值运算符    MyVector&amp; operator=(MyVector&amp;&amp; other) noexcept &#123;        if (this != &amp;other) &#123;            delete[] data_;            data_ = other.data_;            size_ = other.size_;            capacity_ = other.capacity_;                        other.data_ = nullptr;            other.size_ = 0;            other.capacity_ = 0;        &#125;        return *this;    &#125;    // 完美转发的emplace_back    template&lt;typename... Args&gt;    void emplace_back(Args&amp;&amp;... args) &#123;        if (size_ &gt;= capacity_) &#123;            reserve(capacity_ == 0 ? 1 : capacity_ * 2);        &#125;        new(&amp;data_[size_]) T(std::forward&lt;Args&gt;(args)...);        size_++;    &#125;&#125;;\n5. 资源管理类\nclass FileHandle &#123;private:    FILE* handle_;public:    // 构造函数    explicit FileHandle(const char* filename, const char* mode)        : handle_(fopen(filename, mode)) &#123;        if (!handle_) &#123;            throw std::runtime_error(&quot;Failed to open file&quot;);        &#125;    &#125;    // 移动构造函数    FileHandle(FileHandle&amp;&amp; other) noexcept        : handle_(other.handle_) &#123;        other.handle_ = nullptr;    &#125;    // 移动赋值运算符    FileHandle&amp; operator=(FileHandle&amp;&amp; other) noexcept &#123;        if (this != &amp;other) &#123;            close();            handle_ = other.handle_;            other.handle_ = nullptr;        &#125;        return *this;    &#125;    // 禁止拷贝    FileHandle(const FileHandle&amp;) = delete;    FileHandle&amp; operator=(const FileHandle&amp;) = delete;    // 析构函数    ~FileHandle() &#123;        close();    &#125;    void close() &#123;        if (handle_) &#123;            fclose(handle_);            handle_ = nullptr;        &#125;    &#125;&#125;;\n常见陷阱与最佳实践\n常见陷阱\n1. 误用 std::move\n问题： 移动仍然需要使用的对象\nstd::string s = &quot;hello&quot;;process(std::move(s));  // 错误：如果process需要s的值std::cout &lt;&lt; s;         // s现在可能是空的\n解决方案： 只移动不再使用的对象\n2. 移动 const 对象\n问题： const 对象会调用拷贝而不是移动\nconst std::string s = &quot;hello&quot;;std::string s2 = std::move(s);  // 调用拷贝构造函数\n解决方案： 不要移动 const 对象，或者提供 const 版本的移动操作\n3. 忘记处理自赋值\n问题： 移动赋值运算符中没有检查自赋值\nMyClass&amp; operator=(MyClass&amp;&amp; other) noexcept &#123;    delete[] data_;            // 错误：如果this == &amp;other，会释放自己的资源    data_ = other.data_;    other.data_ = nullptr;    return *this;&#125;\n解决方案： 总是检查自赋值\nMyClass&amp; operator=(MyClass&amp;&amp; other) noexcept &#123;    if (this != &amp;other) &#123;        delete[] data_;        data_ = other.data_;        other.data_ = nullptr;    &#125;    return *this;&#125;\n4. 移动后使用源对象\n问题： 假设移动后的对象仍有有效值\nstd::vector&lt;int&gt; v1 = &#123;1, 2, 3&#125;;std::vector&lt;int&gt; v2 = std::move(v1);for (int x : v1) &#123;  // 未定义行为：v1可能为空    // ...&#125;\n解决方案： 移动后不要依赖源对象的值\n最佳实践\n1. 提供完整的移动支持\n当提供移动构造函数时，也应该提供移动赋值运算符：\nclass MyClass &#123;public:    // 移动构造函数    MyClass(MyClass&amp;&amp; other) noexcept &#123; /* ... */ &#125;        // 移动赋值运算符    MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept &#123; /* ... */ &#125;        // 拷贝构造函数    MyClass(const MyClass&amp; other) &#123; /* ... */ &#125;        // 拷贝赋值运算符    MyClass&amp; operator=(const MyClass&amp; other) &#123; /* ... */ &#125;&#125;;\n2. 使用 noexcept\n为移动操作添加 noexcept 说明符：\nclass MyClass &#123;public:    MyClass(MyClass&amp;&amp; other) noexcept &#123; /* ... */ &#125;    MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept &#123; /* ... */ &#125;&#125;;\n3. 优先使用 emplace 而非 push\n在容器中优先使用 emplace 系列函数：\nstd::vector&lt;std::string&gt; vec;// 较差：创建临时对象然后移动vec.push_back(std::string(&quot;hello&quot;));// 较好：直接在容器中构造vec.emplace_back(&quot;hello&quot;);\n4. 合理使用完美转发\n在模板函数中正确使用完美转发：\ntemplate&lt;typename T&gt;void wrapper(T&amp;&amp; arg) &#123;    // 正确：使用std::forward保持值类别    process(std::forward&lt;T&gt;(arg));        // 错误：arg总是左值    process(arg);&#125;\n5. 遵循 “三五法则”\n现代 C++ 的 “三五法则”：\n\n\n如果定义了析构函数，也应该定义拷贝构造函数和拷贝赋值运算符\n\n\n如果定义了移动构造函数，也应该定义移动赋值运算符\n\n\n6. 测试移动语义\n编写测试验证移动语义是否正确工作：\nvoid test_move_semantics() &#123;    MyString s1(&quot;hello&quot;);    MyString s2 = std::move(s1);        // 验证s2获得了资源    assert(s2.size() == 5);        // 验证s1处于有效状态    assert(s1.size() == 0);&#125;\n核心要点回顾\n\n\n左值与右值：左值是可寻址的持久对象，右值是临时的即将销毁的对象\n\n\n右值引用：使用&amp;&amp;表示，专门用于绑定到右值\n\n\n移动语义：通过转移资源所有权而非复制来提高性能\n\n\n移动构造 / 赋值：接受右值引用参数，实现资源转移\n\n\nstd::move：将左值转换为右值引用，触发移动语义\n\n\n完美转发：保持参数的原始值类别，由万能引用和 std::forward 实现\n\n\n技术价值\n\n\n性能提升：避免不必要的深拷贝，特别对大型对象效果显著\n\n\n资源管理：实现安全的资源所有权转移\n\n\n代码简洁：支持更优雅的 API 设计和泛型编程\n\n\n向后兼容：与现有 C++ 代码保持兼容\n\n\n实践建议\n\n\n正确识别使用场景：只在确实需要时使用移动语义\n\n\n遵循最佳实践：提供完整的移动支持，使用 noexcept\n\n\n避免常见陷阱：不要移动仍需使用的对象，处理自赋值\n\n\n测试验证：编写测试确保移动语义正确工作\n\n\n未来发展\n随着 C++ 标准的不断演进，右值相关特性也在持续完善：\n\n\nC++17：引入了 guaranteed copy elision，进一步优化临时对象\n\n\nC++20：增强了概念（Concepts）对完美转发的支持\n\n\nC++23：引入了 forward_like 等新工具\n\n\n参考资料：\n\n\nC++ Primer (第 6 版)\n\n\nC++ Standard (C++11 及以后版本)\n\n\nScott Meyers: Effective Modern C++\n\n\nBjarne Stroustrup: The C++ Programming Language\n\n\n","categories":["编程"],"tags":["C++"]},{"title":"C++线程 锁","url":"/2025/05/07/C++/C++%20%E9%94%81/","content":"\n关于C++中线程和锁的介绍\n\n\n一、线程类型（C++标准库）\nC++标准库提供基础线程类型，用于创建和管理并发执行单元：\n1. `std::thread（C++11）\n\n\n核心功能：创建独立线程，执行可调用对象（函数、lambda、函数对象等）\n\n\n关键特性：\n\n不可复制，仅可移动（线程所有权唯一）\n必须显式调用join()（等待线程结束）或detach()（分离线程），否则析构时触发std::terminate()\n无内置取消机制，需手动实现线程退出逻辑\n\n\n\n示例：\n#include &lt;thread&gt;void task(int param) &#123; /* 线程任务 */ &#125;int main() &#123;    std::thread t1(task, 42);  // 传递参数    std::thread t2([]&#123; /* lambda任务 */ &#125;);        t1.join();  // 等待t1完成    t2.detach();  // t2后台运行，脱离主线程控制    return 0;&#125;\n\n\n2. std::jthread（C++20）\n\n\n核心功能：std::thread的增强版，自带RAII特性\n\n\n关键特性：\n\n析构时自动调用join()，无需手动管理，避免资源泄漏\n支持通过std::stop_token和std::stop_source实现线程取消\n兼容std::thread的所有操作，可无缝替换\n\n\n\n示例：\n#include &lt;thread&gt;void cancelable_task(std::stop_token st) &#123;    while (!st.stop_requested()) &#123;  // 检查取消请求        /* 循环任务 */    &#125;&#125;int main() &#123;    std::jthread t(cancelable_task);  // 自动join    // ... 其他操作 ...    t.request_stop();  // 请求线程停止    return 0;  // t析构时自动join&#125;\n\n\n\n说明：C++标准中无shared_thread和timed_thread，线程的共享性通过同步机制实现，超时控制通过条件变量或带超时的锁操作实现。\n\n二、互斥锁与RAII封装\n互斥锁用于保护共享资源，RAII（资源获取即初始化）封装确保锁的安全管理：\n1. 基础互斥锁类型\n\n\n\n类型\n特性\n适用场景\n\n\n\n\nstd::mutex\n独占所有权，非递归\n基本互斥场景\n\n\nstd::recursive_mutex\n允许同一线程多次锁定，需对应次数解锁\n递归调用场景（谨慎使用，易隐藏设计问题）\n\n\nstd::shared_mutex（C++17）\n支持共享锁（读）和独占锁（写）\n读多写少场景（如缓存、配置读取）\n\n\nstd::timed_mutex\n支持超时锁定\n需要超时控制的独占场景\n\n\nstd::recursive_timed_mutex\n递归+超时锁定\n递归调用且需超时控制\n\n\n\n2. RAII锁封装类（核心工具）\n通过RAII机制自动管理锁的生命周期，避免手动lock()/unlock()导致的死锁。\n（1）std::lock_guard（C++11）\n\n\n特性：构造时锁定，析构时解锁，行为不可变\n\n\n优势：轻量、高效，无额外开销\n\n\n限制：不可手动解锁、不可转移所有权、不支持延迟锁定\n\n\n示例：\n#include &lt;mutex&gt;std::mutex mtx;int shared_value = 0;void safe_increment() &#123;    std::lock_guard&lt;std::mutex&gt; lock(mtx);  // 自动锁定    shared_value++;  // 临界区操作&#125;  // 自动解锁，即使发生异常\n\n\n（2）std::unique_lock（C++11）\n\n\n特性：灵活控制锁状态，支持手动锁定/解锁、延迟锁定、超时锁定\n\n\n优势：功能全面，可配合条件变量使用\n\n\n开销：略高于lock_guard（因需维护锁状态）\n\n\n示例：\nvoid flexible_operation() &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock);  // 延迟锁定        // 预处理（无需锁）    prepare_operation();        lock.lock();  // 手动锁定    perform_operation();  // 临界区    lock.unlock();  // 提前解锁（可选）        // 后续操作（无需锁）    cleanup_operation();&#125;\n\n\n（3）std::shared_lock（C++14）\n\n\n特性：配合std::shared_mutex实现共享锁（读锁）\n\n\n优势：多个线程可同时持有共享锁，提高读操作并发度\n\n\n示例：\n#include &lt;shared_mutex&gt;std::shared_mutex smtx;std::string config_data;// 读操作（共享访问）std::string read_config() &#123;    std::shared_lock&lt;std::shared_mutex&gt; lock(smtx);  // 共享锁    return config_data;  // 多个读线程可同时执行&#125;// 写操作（独占访问）void update_config(const std::string&amp; new_data) &#123;    std::unique_lock&lt;std::shared_mutex&gt; lock(smtx);  // 独占锁    config_data = new_data;  // 写操作时阻塞所有读写&#125;\n\n\n（4）std::scoped_lock（C++17）\n\n\n特性：同时锁定多个互斥量，内部使用死锁避免算法\n\n\n优势：解决多锁场景下的死锁问题（如按固定顺序锁定）\n\n\n示例：\nstd::mutex mtx1, mtx2;int a = 0, b = 0;void swap_values() &#123;    // 同时锁定多个互斥量，避免死锁    std::scoped_lock lock(mtx1, mtx2);  // 顺序不影响，内部自动处理    std::swap(a, b);&#125;  // 自动解锁所有互斥量\n\n\n三、锁操作标签（Tag Types）\n通过标签控制锁的行为，实现特殊场景下的同步逻辑：\n\n\n\n标签\n作用\n适用类\n典型场景\n\n\n\n\nstd::adopt_lock\n接管已获取的锁，不重复锁定\nlock_guard/unique_lock\n手动锁定后交给RAII管理\n\n\nstd::try_to_lock\n尝试锁定，不阻塞，成功则持有\nunique_lock\n非阻塞获取锁，避免线程挂起\n\n\nstd::defer_lock\n延迟锁定，构造时不获取锁\nunique_lock\n灵活控制锁定时机（如条件判断后）\n\n\n\n1. std::adopt_lock 示例\nvoid manual_lock_management() &#123;    mtx.lock();  // 手动锁定（必须成功）    // 接管锁的释放权，避免手动unlock()遗漏    std::lock_guard&lt;std::mutex&gt; lock(mtx, std::adopt_lock);    // 临界区操作&#125;  // 自动解锁\n2. std::try_to_lock 示例\nvoid non_blocking_operation() &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx, std::try_to_lock);        if (lock.owns_lock()) &#123;  // 检查是否成功获取锁        critical_operation();    &#125; else &#123;        fallback_operation();  // 未获取锁时的备选逻辑    &#125;&#125;\n四、高级操作：超时与所有权转移\n1. 超时锁定（unique_lock专属）\n避免线程因无法获取锁而永久阻塞：\n#include &lt;chrono&gt;using namespace std::chrono_literals;void timed_operation() &#123;    std::unique_lock&lt;std::timed_mutex&gt; lock(timed_mtx);        // 尝试锁定，最多等待500ms    if (lock.try_lock_for(500ms)) &#123;        success_operation();    &#125; else &#123;        timeout_handler();  // 超时处理    &#125;        // 绝对时间版本（到某个时间点为止）    auto deadline = std::chrono::system_clock::now() + 1s;    if (lock.try_lock_until(deadline)) &#123;        // 成功锁定    &#125;&#125;\n2. 锁的所有权转移\nunique_lock支持移动语义，可在函数间传递锁的所有权：\n// 函数返回已锁定的锁std::unique_lock&lt;std::mutex&gt; acquire_lock() &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx);    return lock;  // 移动语义传递所有权&#125;void use_locked_resource() &#123;    auto lock = acquire_lock();  // 接收锁（仍处于锁定状态）    access_protected_resource();  // 直接使用临界资源&#125;  // 锁在此处析构，自动解锁\n五、最佳实践与避坑指南\n\n\n优先使用RAII封装：始终用lock_guard/unique_lock等管理锁，避免手动lock()/unlock()（易因异常导致死锁）。\n\n\n最小化临界区：锁的范围应尽可能小，仅包裹必要的共享资源操作，减少线程阻塞时间。\n\n\n死锁预防：\n\n多锁场景用scoped_lock或按固定顺序加锁（如按地址排序）。\n避免在持有锁时调用外部函数（可能隐式获取其他锁）。\n结合try_to_lock和超时机制，设置锁获取的最大等待时间。\n\n\n\n锁类型选择策略：\n\n简单场景→lock_guard（性能最优）。\n需灵活控制（如条件变量、超时）→unique_lock。\n读多写少→shared_mutex+shared_lock/unique_lock。\n多锁同时锁定→scoped_lock。\n\n\n\n线程管理：优先使用jthread（C++20+），避免detach()（难以控制生命周期）。\n\n\n这些组件共同构成了C++多线程同步的完整体系，理解其特性与适用场景是编写安全、高效并发程序的基础。实际开发中，还需结合条件变量（std::condition_variable）、原子操作（std::atomic）等机制解决复杂同步问题。\n","categories":["编程"],"tags":["C++"]},{"title":"《汇编语言》王爽----实验七","url":"/2025/05/04/school_assignments/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%8E%8B%E7%88%BD-%E5%AE%9E%E9%AA%8C%E4%B8%83/","content":"\n《汇编语言》王爽(第四版)第八章 实验7习题解答\n\n\n题目要求\nassume cs:codedata segment    ;年份    db &#x27;1975&#x27;, &#x27;1976&#x27;, &#x27;1977&#x27;, &#x27;1978&#x27;, &#x27;1979&#x27;, &#x27;1980&#x27;, &#x27;1981&#x27;, &#x27;1982&#x27;, &#x27;1983&#x27;    db &#x27;1984&#x27;, &#x27;1985&#x27;, &#x27;1986&#x27;, &#x27;1987&#x27;, &#x27;1988&#x27;, &#x27;1989&#x27;, &#x27;1990&#x27;, &#x27;1991&#x27;, &#x27;1992&#x27;    db &#x27;1993&#x27;, &#x27;1994&#x27;, &#x27;1995&#x27;    ;收入    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514    dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000    ;员工    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226    dw 11542, 14430, 15257, 17800data endstable segment    db 21 dup (&#x27;year sumn ne ?? &#x27;)table ends\n将 data 段中的数据按如下格式写入到 table 段中，并计算 21 年中的人均收入 (取整), 结果也按照下面的格式保存在 table 段中\n提示\n可将data段中的数据看成是多个数组,而将table中的数据看成是一个结构型数据的数组,每个结构型数据中包含多个数据项。\n可用di定位table段中对应的存储单元,用idata定位数据项,用si定位data段中的每个元素\n\n解答代码\nassume cs:code,ss:stack,ds:datadata segment    ;年份    db &#x27;1975&#x27;, &#x27;1976&#x27;, &#x27;1977&#x27;, &#x27;1978&#x27;, &#x27;1979&#x27;, &#x27;1980&#x27;, &#x27;1981&#x27;, &#x27;1982&#x27;, &#x27;1983&#x27;    db &#x27;1984&#x27;, &#x27;1985&#x27;, &#x27;1986&#x27;, &#x27;1987&#x27;, &#x27;1988&#x27;, &#x27;1989&#x27;, &#x27;1990&#x27;, &#x27;1991&#x27;, &#x27;1992&#x27;    db &#x27;1993&#x27;, &#x27;1994&#x27;, &#x27;1995&#x27;    ;收入    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514    dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000    ;员工    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226    dw 11542, 14430, 15257, 17800data endstable segment    db 21 dup (&#x27;year sumn ne ?? &#x27;)table endsstack segment\tdw 8 dup (0)stack endscode segmentmain:\tmov ax,data\tmov ds,ax\tmov ax,table\tmov es,ax\tmov ax,stack\tmov ss,ax\tmov sp,10H;复制年份到table中\tmov si,0\tmov di,0\tmov cx,21s1:\tmov ax,ds:[si]\tmov es:[di],ax\tmov ax,ds:[si+2]\tmov es:[di+2],ax\tmov al,20H ;存储空格到table中的对应位置\tmov es:[di+4],al\t\tadd si,4\tadd di,10H\tloop s1;复制收入到table中\tmov si,84\tmov di,5\tmov cx,21s2:\tmov ax,ds:[si]\tmov es:[di],ax\tmov ax,ds:[si+2]\tmov es:[di+2],ax\tmov al,20H\tmov es:[di+4],al\t\tadd si,4\tadd di,10H\tloop s2;复制人数到table中\tmov si,168\tmov di,10\tmov cx,21s3:\tmov ax,ds:[si]\tmov es:[di],ax\tmov al,20H\tmov es:[di+2],al\t\tadd si,2\tadd di,10H\tloop s3;计算人均收入\tmov bx,0\tmov cx,21s4:\tmov ax,es:[bx+5] ;除数是dw,16位,所以被除数应该是32位,使用DX:AX来存储\tmov dx,es:[bx+7]\tdiv word ptr es:[bx+10];显式地告诉编译器,除数是16位,字型\tmov es:[bx+13],ax\t\t;商存储在ax中,余数存储在dx中\tmov al,20H\tmov es:[bx+15],al\t\tadd bx,10H\tloop s4\tmov ax,4c00H\tint 21Hcode endsend main\n","categories":["编程"],"tags":["汇编语言"]},{"title":"C++ chrono","url":"/2025/04/05/C++/C++%20chrono/","content":"\nC++ chrono库的使用方法\n\n\nC++ chrono\n一、chrono的核心设计理念\nchrono的核心是将时间抽象为三个相互关联的概念：时长（duratn）、时间点（time_point） 和时钟（clock）。三者通过模板参数紧密耦合，形成一套自洽的类型系统：\n\n\n时长（duration）：表示&quot;一段时间间隔&quot;（如10秒、500毫秒），绑定数值与单位。\n\n\n时间点（time_point）：表示&quot;某个具体时刻&quot;（如2023-10-01 08:00:00），基于某个时钟的&quot;纪元&quot;（epoch）偏移量定义。\n\n\n时钟（clock）：提供获取当前时间点的接口，定义了时间的参考系（如系统时间、稳定时间）。\n\n\n二、核心组件详解\n1. 时长（std::chrono::duration）\nduration是对&quot;时间间隔&quot;的抽象，定义为：\ntemplate &lt;typename Rep, typename Period = std::ratio&lt;1&gt;&gt;class duration;\n\n\nRep：存储时长的数值类型（如int、long long、double），决定了数值的精度和范围。\n\n\nPeriod：表示时长的单位（周期），类型为std::ratio&lt;N, D&gt;（即N/D秒），例如：\n\nstd::ratio&lt;1&gt;：1秒（默认值）。\nstd::ratio&lt;1, 1000&gt;：1毫秒（1/1000秒）。\nstd::ratio&lt;60&gt;：1分钟（60秒）。\n\n\n\n标准预定义时长类型：\n为简化常用场景，标准库定义了一系列别名（基于long long作为Rep）：\nusing nanoseconds  = duration&lt;long long, std::nano&gt;;    // 1e-9秒using microseconds = duration&lt;long long, std::micro&gt;;   // 1e-6秒using milliseconds = duration&lt;long long, std::milli&gt;;   // 1e-3秒using seconds      = duration&lt;long long&gt;;               // 1秒using minutes      = duration&lt;long long, std::ratio&lt;60&gt;&gt;; // 60秒using hours        = duration&lt;long long, std::ratio&lt;3600&gt;&gt;; // 3600秒\n时长的操作：\n\n\n算术运算：支持+、-、*、/（如seconds(3) + milliseconds(500) = milliseconds(3500)）。\n\n\n比较运算：支持==、!=、&lt;、&gt;等（需单位兼容，或通过转换后比较）。\n\n\n类型转换：通过std::chrono::duration_cast显式转换（因单位不同可能丢失精度）：\n#include &lt;chrono&gt;using namespace std::chrono;milliseconds ms(1500);       // 1500毫秒seconds s = duration_cast&lt;seconds&gt;(ms);  // 转换为1秒（截断小数部分）\n\n\n2. 时间点（std::chrono::time_point）\ntime_point是对&quot;具体时刻&quot;的抽象，定义为：\ntemplate &lt;typename Clock, typename Duration = typename Clock::duration&gt;class time_point;\n\n\nClock：关联的时钟类型（决定时间的参考系，如系统时钟、稳定时钟）。\n\n\nDuration：表示该时间点相对于时钟&quot;纪元&quot;（epoch，即时钟的起始点，如Unix时间戳的1970-01-01 00:00:00）的偏移量。\n\n\n时间点的操作：\n\n\n获取纪元偏移：通过time_since_epoch()获取自纪元起的duration：\nauto now = system_clock::now();          // 当前系统时间点auto epoch_offset = now.time_since_epoch();  // 自系统时钟纪元起的时长\n\n\n算术运算：与duration结合，生成新的时间点：\nauto future = now + seconds(10);  // 10秒后的时间点auto past = now - minutes(5);     // 5分钟前的时间点\n\n\n比较运算：支持==、!=、&lt;等（需同属一个时钟）。\n\n\n3. 时钟（std::chrono::clock）\n时钟是time_point的&quot;参考系&quot;，提供获取当前时间点的接口，定义了三个核心成员：\n\n\nnow()：静态方法，返回当前时间点（time_point&lt;Clock&gt;）。\n\n\nduration：时钟的默认时长类型（如system_clock通常使用nanoseconds）。\n\n\nis_steady：静态常量（bool），标识时钟是否&quot;稳定&quot;（即时间是否单调递增，不会因系统调整而回溯）。\n\n\n标准库三种时钟：\n\n\nsystem_clock\n\n关联系统时间（可被用户或系统调整，如手动修改时区、NTP同步）。\n支持与C风格时间（std::time_t）转换，适合获取&quot;日历时间&quot;（如年月日时分秒）。\nis_steady为false（可能因调整而回溯）。\n\n示例：获取当前日历时间：\n#include &lt;chrono&gt;#include &lt;ctime&gt;using namespace std::chrono;auto sys_now = system_clock::now();std::time_t t = system_clock::to_time_t(sys_now);  // 转换为time_tstd::cout &lt;&lt; std::ctime(&amp;t);  // 输出人类可读时间（如&quot;Wed Jun 1 12:34:56 2023&quot;）\n\n\nsteady_clock\n\n稳定时钟（时间单调递增，不可调整），适合测量时间间隔（如性能计时、定时器）。\n不关联日历时间，无法转换为time_t。\nis_steady为true（核心优势）。\n\n示例：测量代码执行时间：\nauto start = steady_clock::now();// 执行耗时操作...auto end = steady_clock::now();auto elapsed = duration_cast&lt;milliseconds&gt;(end - start);std::cout &lt;&lt; &quot;耗时: &quot; &lt;&lt; elapsed.count() &lt;&lt; &quot;ms\\n&quot;;\n\n\nhigh_resolution_clock\n\n高精度时钟，通常是steady_clock或system_clock的别名（取决于编译器实现）。\n设计目标是提供系统支持的最高精度，但需注意其is_steady可能为false（若绑定system_clock）。\n\n\n\n三、chrono的核心优势\n\n\n类型安全：时长的单位（如秒/毫秒）通过类型而非注释体现，编译器可检测单位误用（如将毫秒当作秒传入函数）。\n\n\n精度可控：通过Rep和Period灵活定义时长精度（如duration&lt;double, std::ratio&lt;1, 10&gt;&gt;表示0.1秒精度的浮点数时长）。\n\n\n平台无关：屏蔽了不同系统的时间实现差异（如Windows与Linux的时钟粒度不同）。\n\n\n支持泛型编程：可基于duration和time_point编写通用时间处理逻辑（如模板函数支持任意时钟类型）。\n\n\n四、典型应用场景\n\n\n性能基准测试：用steady_clock测量代码片段的执行时间。\n\n\n定时器实现：结合time_point管理定时任务的触发时间\n\n\n时间戳记录：用system_clock记录事件发生的日历时间。\n\n\n帧率控制：在游戏或实时系统中，用duration控制循环执行频率（如60FPS即每16.67ms执行一次）。\n\n\n","categories":["编程"],"tags":["C++"]},{"title":"数据结构期末复习","url":"/2025/01/01/school_assignments/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E8%80%83%E7%BA%B2%E5%A4%8D%E4%B9%A0/","content":"\n数据结构的期末复习考纲\n\n\n数据结构期末考纲\n顺序表和链表的类型定义\n\n\n**顺序表:**用一组地址连续的存储单元依次存放线性表中的所有元素, 元素的存储位置与逻辑位置是一一对应关系\n\n\ntemplate&lt;typename T,size_t N&gt;struct SeqList&#123;    T data[N];    int length;    SeqList():length(0) &#123;&#125;;        size_t getCapacity() const &#123;        return N;    &#125;&#125;;using IntSeqList = SeqList&lt;int,100&gt;;\n\n\n链表: 用一组地址非连续的存储单元依次存放线性表中的所有元素, 元素间的先后关系利用指针来表示\n\n\ntemplate&lt;typename T&gt;struct Node &#123;    T data;    Node* next;    Node&lt;T&gt;() : next(nullptr) &#123;&#125;;&#125;;using LinkList = Node&lt;int&gt;*;\n将两个有序的顺序表(链表)合并为一个有序的顺序表(链表) 分析合并操作的复杂度\n\n\n顺序表\n\n\nIntSeqList mergeSeqList(IntSeqList&amp; s1, IntSeqList&amp; s2)&#123;    if(s1 == NULL)&#123;        s1 = s2;        return s1;    &#125;    if(s2 == NULL) return s1;    \tint size1 = s1.length;    int size2 = s2.length;    int total_size = size1 + size2;    IntSeqList new_seqlist;    new_seqlist.length = total_size;    \tint index1 = 0;int index2 = 0;    int k = 0;    while(index1 &lt; size1 &amp;&amp; index2 &lt; size2)&#123;\t\tif(s1.data[index1]&lt;s2.data[index2])  &#123; new_seqlist.data[k] = s1.data[index1]; index1++;&#125;        else  &#123; new_seqlist.data[k] = s2.data[index2]; index2++; &#125;        k++;             &#125;        if(index1 &lt; size1 &amp;&amp; index2 == size2)&#123;       \twhile(index1 &lt; size1)&#123;            new_seqlist.data[k] = s1.data[index1];            k++;            index1++;\t\t&#125;    &#125;    else if(index1 == size1 &amp;&amp; index2 &lt; size2)&#123;        while(index2 &lt; size2)&#123;            new_seqlist.data[k] = s2.data[index2];            k++;            index2++;\t\t&#125;\t&#125;   return new_seqlist;&#125;\n**时间复杂度：**O(n + m)\n**空间复杂度：**O(n + m)\n\n\n链表\n\n\nNode&lt;int&gt;* mergeLinkedList(LinkList&amp; l1, LinkList&amp; l2) &#123;    if (l1 == nullptr) &#123;        l1 = l2;        return l1;    &#125;    if (l2 == nullptr) return l1;    LinkList cur = l1;    LinkList temp1 = l1-&gt;next; LinkList temp2 = l2-&gt;next;    while (temp1 &amp;&amp; temp2) &#123;        if (temp1-&gt;data &lt; temp2-&gt;data) &#123;            cur-&gt;next = temp1;            temp1 = temp1-&gt;next;        &#125;        else &#123;            cur-&gt;next = temp2;            temp2 = temp2-&gt;next;        &#125;        cur = cur-&gt;next;    &#125;    cur-&gt;next = temp1 ? temp1 : temp2;    delete l2;    return l1;&#125;\n**时间复杂度：**O(n + m)\n**空间复杂度：**O(1)\n在链表(顺序表)的某个节点后插入一个节点\n链表\nvoid insertNode(LinkList l, int index, T data) &#123;    LinkList cur = l;    while (index--) &#123;        cur = cur-&gt;next;    &#125;    Node&lt;T&gt;* new_node = new Node&lt;T&gt;;    new_node-&gt;data = data;    new_node-&gt;next = cur-&gt;next;    cur-&gt;next = new_node;&#125;\n顺序表\ntemplate&lt;typename T&gt;void insertNode(IntSeqList&amp; s, int index, T data) &#123;    if (index &gt; s.length &amp;&amp; s.length + 1 &gt; s.getCapacity()) return;    if (index &lt;= 0) &#123;        for (int i = s.length - 1; i &gt;= 0; i--) &#123;            s.data[i + 1] = s.data[i];        &#125;        s.data[0] = data;        s.length++;        return;    &#125;    for (int i = s.length - 1; i &gt;= index; i--) &#123;        s.data[i + 1] = s.data[i];    &#125;    s.data[index] = data;    s.length++;    return;&#125;\n将一个链表(顺序表)进行倒置 并分析倒置操作的复杂度\n链表\nvoid reverseLL(LinkList l)&#123;    LinkList pre = nullptr;    LinkList cur = l;        while(cur)&#123;        LinkList temp = cur-&gt;next;        cur-&gt;next = pre;        pre = cur;        cur = temp;    &#125;    l = pre;&#125;\n**时间复杂度：**O(n)\n**空间复杂度：**O(1)\n顺序表\nvoid reverseSeq(IntSeqList&amp; s)&#123;\tint i = 0; int j = s.length-1;    while(i&lt;j)&#123;        int temp  = s.data[j];        s.data[j] = s.data[i];        s.data[i] = temp;        i++;        j--;    &#125;&#125;\n**时间复杂度：**O(n)\n**空间复杂度：**O(1)\n无向图的链接表表示法和邻接矩阵表示法\n邻接矩阵表示法: 利用二维数组来表示一个图,二维数组中的每一个元素表示相应的两个顶点之间的关系\n​\t\t\t     无向图的邻接矩阵为对称矩阵\n链接表表示法: 将图的每一个顶点的邻接点存放在一个链表中 每个顶点对应一条链表,所有的头节点存放在一个数组中\n利用DFS或BFS求一个图的连通分量数\nDFS\n递归版(图利用邻接矩阵来表示)\nvoid DFS(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected,vector&lt;int&gt;&amp; visited,int row)&#123;     for(int i = 0;i&lt;isConnected.size();i++)&#123;         if(isConnected[row][i]&amp;&amp;!visited[i])&#123;            visited[i] = 1;            DFS(isConnected,visited,i);         &#125;     &#125;&#125;int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) &#123;    int num = 0;    vector&lt;int&gt; visited(isConnected.size(),0);    for(int i = 0;i&lt;isConnected.size();i++)&#123;     \tif(!visited[i])&#123;            DFS(isConnected,visited,i);            num++;         &#125;     &#125;    return num;&#125;\n栈实现\nint findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) &#123;    int num = 0;    vector&lt;int&gt; visited(isConnected.size(), 0);    stack&lt;int&gt; s;    for(int i = 0; i &lt; isConnected.size(); i++) &#123;        if(!visited[i]) &#123;            s.push(i);            while(!s.empty()) &#123;                int temp = s.top();                s.pop();                visited[temp] = 1;                for(int j = 0; j &lt; isConnected.size(); j++) &#123;                    if(isConnected[temp][j] &amp;&amp; !visited[j]) &#123;                        s.push(j);                    &#125;                &#125;            &#125;            num++;        &#125;    &#125;    return num;&#125;\nBFS\nint findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) &#123;    int num = 0;    vector&lt;int&gt; visited(isConnected.size(), 0);    queue&lt;int&gt; q;    for (int i = 0; i &lt; isConnected.size(); i++) &#123;        if (!visited[i]) &#123;            q.push(i);            while (!q.empty()) &#123;                int temp = q.front();                q.pop();                visited[temp] = 1;                for (int j = 0; j &lt; isConnected.size(); j++) &#123;                   if (isConnected[temp][j] &amp;&amp; !visited[j]) &#123;                       q.push(j);                    &#125;                &#125;            &#125;            num++;        &#125;    &#125;    return num;&#125;\n利用Floyd算法求图的任意两点的最短距离，图的传递闭包(Floyd-Warshall)\n//最短距离void floyd(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123;    grid = matrix;    int n = grid.size();    for(int k = 0; k &lt; n;K++)&#123;\t\tfor(int i = 0; i &lt; n;i++)&#123;            for(int j = 0; j &lt; n;j++)&#123;                grid[i][j]=min(grid[i][j],grid[i][k]+grid[k][j]);            &#125;        &#125;    &#125;&#125;//传递闭包(使用前需将矩阵转换为使用0和1表达的矩阵)void floydWarshall(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;    int n = matrix.size();    for (int k = 0; k &lt; n; k++) &#123;        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                matrix[i][j] |= matrix[i][k] &amp; matrix[k][j];            &#125;        &#125;    &#125;&#125;\n判断两个左右链表表示的二叉树是否等价 并分析时间复杂度\nstruct TreeNode &#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;bool isSameTree(TreeNode* p, TreeNode* q) &#123;    if(p == nullptr &amp;&amp; q == nullptr) return true;    if(p == nullptr || q == nullptr) return false;    if(p-&gt;val != q-&gt;val) return false;    return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);&#125;\n**时间复杂度：**O(n)\n将一个整数序列转化为大顶堆(小顶堆)的过程描述\n大顶堆\n\n\n将此整数序列看作一棵完全二叉树的数组形式\n\n\n从最后一个非叶节点开始进行下沉操作,保证父节点大于子节点,使其堆化\n\n\n倒序遍历每个节点,重复上述操作 直至根节点\n\n\n删除堆顶(大顶堆或小顶堆)的过程描述\n\n\n将堆顶元素与堆中最后一个元素互换\n\n\n删除最后一个元素\n\n\n从堆顶元素开始,从顶至底进行下沉操作使其堆化\n\n\n构建哈夫曼树的过程, 并计算带权路径长度\n假设给了n个元素\n\n\n将这n个元素看作n棵只有一个节点的二叉树,他们构成了森林F\n\n\n从森林F中选择两个权值最小的节点(树)构成一个新树, 新树的根节点的权值为这两个节点权值的和\n\n\n将这颗新树加入到森林F中 并删除F中的那两个被合并的节点\n\n\n重复上述过程 直至森林中只剩下一个树 该树即为哈夫曼树\n\n\n**带权路径长度:**每个叶节点的权值与其到根节点的路径长度的乘积之和\n利用栈求逆波兰表达式的值\n假设该逆波兰表达式符合规范\n\n\n将该表达式中的元素依次遍历\n\n\n如果该元素是操作数 那么压入栈中 继续遍历下一个元素\n\n\n如果该元素是操作符 那么从栈中弹出所需数量的元素进行计算 并将计算结果压入栈中\n\n\n重复上述操作 直至遍历玩表达式中所有元素 栈顶元素即为该表达式的结果\n\n\n最小生成树的构建方法\nPrim\n\n\n构造一个名为minDist的数组,用来记录每个节点距离生成树的最短距离,长度为n,n为顶点的数量\n\n\n构造一个名为visited的数组,用来记录哪些节点已经被添加到最小生成树中,长度为n\n\n\n随机选择一个节点作为第一个节点加入到最小生成树中并将其在visited数组中标记为true\n\n\n更新minDist数组 即更新未被visited数组标记的节点到生成树的距离\n\n\n选择minDist数组中值最小且未被visited数组标记的节点加入生成树 并将该节点标记为true\n\n\n重复上述过程n-1次即可完成构建\n\n\nKruskal\n\n\n将图中的边按照权值由小到大进行排序\n\n\n初始化并查集,使每个顶点自成一个集合\n\n\n对排序后的边进行遍历\n\n\n利用并查集判断该边的两个顶点是否在同一个集合中\n\n\n如果在 则不能将此边加入生成树 否则会形成环\n\n\n如果不在 则将此边加入生成树 并将这两个顶点所在的集合合并\n\n\n重复上述过程 直至生成树中有n-1条边(n为顶点数目) 或遍历结束\n\n\n利用Dijkstra求单源最短距离和最短路径,了解U d和p的含义;如何根据p求到每一个顶点到源点的最短路径\n**U:**已经求出与源点的最短距离的顶点的集合\n**d:**用来存放顶点到源点最短距离的数组,d[i]代表顶点i到源点的最短距离\n**p:**用来存放最短路径树中每个节点的父节点的数组,p[i]代表最短路径树中节点i的父节点\nvoid getPath(int p[N],int v)&#123;\tif(v==p[v])&#123;        cout&lt;&lt;v&lt;&lt;&quot; &quot;;        return;    &#125;    getPath(p,p[v]);    cout&lt;&lt;v&lt;&lt;&quot; &quot;;&#125;\n拓扑排序和关键路径的求法\n拓扑排序\n\n\n定义一个队列q,统计图中每一个顶点的入度,将入度为零的顶点加入队列q中\n\n\n从队列q中取出一个顶点u,将其加入到拓扑序列中\n\n\n遍历顶点u的所有出边,将这些相邻点的入度减一,若其入度变为零,则将其加入到队列q中\n\n\n重复上述步骤,直至队列q为空\n\n\n如果队列q为空时 仍有顶点未加入到拓扑序列中 说明该图存在环 不存在拓扑序列\n\n\n关键路径\n\n\n对图中各顶点进行拓扑排序，得到拓扑序列\n\n\n按照拓扑序列的顺序 依次计算每个事件的最早发生时间\n\n\n再根据每个事件的最早发生时间 求出每个活动的最早发生时间\n\n\n按照逆拓扑序 依次计算每个事件的最晚发生时间\n\n\n遍历每一个活动，计算其最早发生时间与最晚发生时间之差 若为零 则将该活动加入关键路径\n\n\n二分查找及其复杂度分析\n主要部分与插值查找相同 不同点为 mid = left+0.5*(right-left)\n时间复杂度为 O(log n)\n空间复杂度为 O(1)\n插值查找\n\n\n确定被查找目标所在的范围边界,左边界记为left,右边界记为right\n\n\n设置查找点下标为 $mid=left+ (key-array[left]/array[right]-array[left])*(right-left)$\n\n\n开始循环 保证left不大于right\n\n\n判断以mid为下标的数组元素是否等于目标值\n\n\n如果等于 则找到目标 退出循环\n\n\n如果大于目标元素 则令right = mid - 1\n\n\n如果小于目标元素 则另left = mid + 1\n\n\n按照以上描述进行循环直至找到目标值 或不满足循环条件时退出循环\n\n\n时间复杂度是O(loglogN)\n当有序序列中的元素呈均匀分布时插值查找优于二分查找\nKMP算法\n令模式串为t 主串为s\n\n\n定义两个整数i，j 分别表示主串和模式串的下标，初始值设置为0\n\n\n当j == -1 或 t[j] == s[i]时 i和j同时加一 即同时向后移动一位\n\n\n如果t[j] != s[i]时 令j=next[j]\n\n\n重复上述过程直至遍历完i主串或j遍历完模式串\n\n\nnext数组\n\n\n使用整数j作为下标来遍历模式串\n\n\n令next[j] = 第j位的公共最长真前后缀的长度 特别规定next[0]=-1\n\n\n优化next数组\n\n\n在上一个方法求next数组的基础之上 在j遍历模式串s的过程中添加如下判断\n\n\n判断 t[j]是否等于t[next[j]]\n\n\n如果等于 则令next[j] = next[next[j]]\n\n\n二叉查找树\n特点\n\n\n对于根节点，若它的左右子树不为空, 则左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值\n\n\n若它的左右子树都不为空,  则它的左右子树也分别为二叉查找树\n\n\n构建二叉查找树\n\n\n将序列的第一个元素作为二叉查找树的根节点\n\n\n接着依次遍历序列中的剩余元素,并将该元素作为新节点\n\n\n如果新节点的值小于当前节点的值，则新节点应插入到左子树中\n\n\n如果新节点的值大于当前节点的值，则新节点应插入到右子树中\n\n\n重复上两个步骤，直到找到合适的叶子位置, 将其插入树中\n\n\n对序列中的每个元素进行如上操作直至遍历结束 至此二叉查找树构建完成\n\n\nAVL树\n四种基本形式及对应变形操作\n\n\nLL旋转\n假设节点A是失衡的节点，节点B是A的左子节点，节点C是B的右子节点\n\n\nB变为新的根节点。\n\n\nA成为B的右子节点。\n\n\nC（如果存在）成为A的左子节点\n\n\n\n\n\nRR旋转\n\n\n​\t与LL操作反之\n\n\nLR旋转\n\n\n​\t假设节点A是失衡的节点，节点B是A的左子节点\n​\t首先对A的左子节点B进行RR旋转，然后对A进行LL旋转\n\n\n\nRL旋转\n\n\n​\t与LR反之\n构建AVL树\n\n\n将给定数据集的第一个元素作为AVL树的根节点\n\n\n按照二叉查找树的方式插入新的节点\n\n\n每次插入新节点后，更新该节点及其祖先节点的高度\n\n\n在每次插入操作后，计算当前节点及其祖先节点的平衡因子（左子树高度减去右子树高度）。\n\n\n如果平衡因子的绝对值大于1，则该节点失衡, 根据失衡节点的具体情况进行对应的旋转操作\n\n\n重复上述过程 直至所有元素被添加到AVL树中\n\n\n","categories":["数据结构"],"tags":["C++"]},{"title":"书生大模型---微调","url":"/2024/09/29/AI/%E4%B9%A6%E7%94%9F%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Lv1-2/","content":"\n利用XTuner微调预训练模型\n\n\nLv1-XTuner微调大模型\n1. 准备环境和依赖\nXTuner的运行依赖于一系列的库和工具，主要包括transformers、torch等深度学习框架。在开始之前，你需要确保安装好这些依赖：\n\n\n安装Python 3.8或更高版本。\n\n\n安装基础依赖库：运行以下命令下载并安装依赖。\n pip install -r requirements.txt\n\n\n确保你拥有兼容的GPU环境，以提高模型训练速度。如果使用的是NVIDIA GPU，安装CUDA和cuDNN并验证PyTorch的GPU支持。\n\n\n2. 加载预训练模型\nXTuner的核心功能是对已有的预训练模型进行微调。通常情况下，大语言模型（如GPT、BERT等）已经具备强大的通用语言能力，但针对具体任务时需要进行额外的微调。\n选择模型：\nXTuner支持使用Hugging Face的transformers库来加载预训练模型。以下代码展示了如何加载GPT-2模型：\nfrom transformers import AutoModelForCausalLM, AutoTokenizermodel = AutoModelForCausalLM.from_pretrained(&quot;gpt2&quot;)tokenizer = AutoTokenizer.from_pretrained(&quot;gpt2&quot;)\n在实际操作中，你可以根据任务需求选择其他预训练模型，例如BERT、T5等。\n3. 准备数据集\n微调过程需要使用特定任务的数据集。XTuner支持常见的文本分类、生成、翻译等任务的数据集。你可以选择公开数据集（例如：SQuAD、GLUE、CoNLL等），也可以使用自定义数据。\n数据预处理：\n\n\n首先，将数据集整理为模型能够接受的格式。数据通常是输入（如文本）与目标标签（如类别、输出文本）组成的对。\n\n\n对数据进行tokenization，即将文本数据转化为模型输入的token ID。Hugging Face的tokenizer能够自动完成这一步：\n inputs = tokenizer(&quot;This is a test sentence.&quot;, return_tensors=&quot;pt&quot;)\n你也可以使用datasets库轻松加载数据并进行tokenization:\n from datasets import load_datasetdataset = load_dataset(&#x27;your_dataset&#x27;)tokenized_dataset = dataset.map(lambda e: tokenizer(e[&#x27;text&#x27;], truncation=True, padding=&#x27;max_length&#x27;))\n\n\n4. 定义微调任务\nXTuner允许你根据不同的任务选择不同的模型结构和训练策略。一般来说，语言模型的最后一层需要调整为符合具体任务需求。\n\n\n文本分类：为BERT等模型添加一个分类器层（如线性层），用于预测标签。\n\n\n文本生成：GPT模型可以直接用于生成任务，只需定义损失函数。\n\n\n翻译任务：类似于T5等预训练模型，可以用于翻译任务，通过提供源文本与目标文本对进行训练。\n\n\n你可以根据任务需要自定义这些模型结构。\n5. 配置训练参数\nXTuner提供了灵活的配置方式，可以通过配置文件或命令行参数指定训练的超参数。你需要调整如下超参数：\n\n\n学习率：通常设置在1e-5到5e-5之间，具体值依赖于任务和模型。\n\n\n批次大小：通常GPU内存较大时，批次大小可以设置得较大，推荐设置为16或32。\n\n\n训练轮数：通常选择2到5轮训练，过多的训练轮数可能导致过拟合。\n\n\n优化器：AdamW是最常见的优化器，它处理权重衰减问题并提高训练稳定性。\n\n\n示例配置：\npython train.py --model_name_or_path gpt2 --dataset your_dataset --learning_rate 2e-5 --batch_size 16 --num_train_epochs 3 --output_dir ./output\n6. 启动训练\n在设置完所有参数后，便可以使用XTuner开始训练。XTuner提供了一套自动化的训练流程，包含数据加载、模型构建、训练与评估等步骤。启动训练的典型命令如下：\npython train.py --model_name_or_path gpt2 --dataset your_dataset --output_dir /path/to/output\n在训练过程中，XTuner会自动计算损失函数、梯度下降等关键步骤，输出模型性能评估指标（如准确率、困惑度等）。你可以通过观察训练日志了解模型训练的进展情况。\n7. 评估和保存模型\n训练完成后，XTuner会自动保存微调后的模型，保存的路径由--output_dir指定。你可以通过验证集对微调模型进行评估。评估指标通常根据任务类型而定，例如：\n\n\n分类任务可以使用准确率和F1值。\n\n\n文本生成任务通常使用困惑度（Perplexity）来评估模型的生成能力。\n\n\n模型保存与加载：\nmodel.save_pretrained(&quot;/path/to/save&quot;)tokenizer.save_pretrained(&quot;/path/to/save&quot;)\n加载模型时，可以直接从保存路径重新加载：\nmodel = AutoModelForCausalLM.from_pretrained(&quot;/path/to/save&quot;)tokenizer = AutoTokenizer.from_pretrained(&quot;/path/to/save&quot;)\n8. 推理与应用\n完成微调后，模型便可以应用于推理任务。使用相同的tokenizer对输入文本进行处理，然后利用模型生成预测结果：\ninputs = tokenizer(&quot;Translate this sentence to French.&quot;, return_tensors=&quot;pt&quot;)outputs = model.generate(inputs[&#x27;input_ids&#x27;])generated_text = tokenizer.decode(outputs[0], skip_special_tokens=True)\n","categories":["编程"],"tags":["AI","python"]},{"title":"书生大模型---RAG实践","url":"/2024/09/29/AI/%E4%B9%A6%E7%94%9F%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Lv1-1/","content":"\nRAG实践\n\n\nLv1-llamaindex+Internlm2 RAG实践\n1. RAG简介\nRAG（Retrieval-Augmented Generation）技术是一种结合了信息检索和文本生成的技术，旨在通过检索外部知识库来增强生成模型的能力\n\n1.1 RAG优化方法\n\n2. 搭建环境\n2.1 相关基础依赖python虚拟环境\nconda activate llamaindexconda install pytorch==2.0.1 torchvision==0.15.2 torchaudio==2.0.2 pytorch-cuda=11.7 -c pytorch -c nvidiapip install einops==0.7.0 protobuf==5.26.1\n2.2 安装 Llamaindex和相关包\nconda activate llamaindexpip install llama-index==0.10.38 llama-index-llms-huggingface==0.2.0 &quot;transformers[torch]==4.41.1&quot; &quot;huggingface_hub[inference]==0.23.1&quot; huggingface_hub==0.23.1 sentence-transformers==2.7.0 sentencepiece==0.2.0\n2.3 下载 Sentence Transformer 模型\n源词向量模型 Sentence Transformer:（也可以选用别的开源词向量模型来进行 Embedding） 运行以下指令，新建一个python文件\ncd ~mkdir llamaindex_demomkdir modelcd ~/llamaindex_demotouch download_hf.py\n打开download_hf.py 贴入以下代码\nimport os# 设置环境变量os.environ[&#x27;HF_ENDPOINT&#x27;] = &#x27;https://hf-mirror.com&#x27;# 下载模型os.system(&#x27;huggingface-cli download --resume-download sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2 --local-dir /root/model/sentence-transformer&#x27;)\n然后，在 /root/llamaindex_demo 目录下执行该脚本即可自动开始下载：\ncd /root/llamaindex_democonda activate llamaindexpython download_hf.py\n更多关于镜像使用可以移步至 HF Mirror 查看。\n2.4 下载 NLTK 相关资源\n我们在使用开源词向量模型构建开源词向量的时候，需要用到第三方库 nltk 的一些资源。正常情况下，其会自动从互联网上下载，但可能由于网络原因会导致下载中断，此处我们可以从国内仓库镜像地址下载相关资源，保存到服务器上。 我们用以下命令下载 nltk 资源并解压到服务器上：\ncd /rootgit clone https://gitee.com/yzy0612/nltk_data.git  --branch gh-pagescd nltk_datamv packages/*  ./cd tokenizersunzip punkt.zipcd ../taggersunzip averaged_perceptron_tagger.zip\n2.5 安装词嵌入向量依赖\nconda activate llamaindexpip install llama-index-embeddings-huggingface==0.2.0 llama-index-embeddings-instructor==0.1.3\n2.6 准备知识库\n你所需要检索的文件\n2.7 引入模型 编写相关代码\n详情请参考\nimport streamlit as stfrom llama_index.core import VectorStoreIndex, SimpleDirectoryReader, Settingsfrom llama_index.embeddings.huggingface import HuggingFaceEmbeddingfrom llama_index.llms.huggingface import HuggingFaceLLM# 设置Streamlit应用的页面标题和图标st.set_page_config(page_title=&quot;llama_index_demo&quot;, page_icon=&quot;🦜🔗&quot;)# 在页面上显示标题st.title(&quot;llama_index_demo&quot;)# 初始化模型的函数，使用Streamlit的缓存机制来节约资源（防止每次交互时重新加载模型）@st.cache_resourcedef init_models():    # 加载嵌入模型，使用HuggingFace的sentence-transformer    embed_model = HuggingFaceEmbedding(        model_name=&quot;/root/model/sentence-transformer&quot;  # 指定模型的路径    )    Settings.embed_model = embed_model  # 设置全局的嵌入模型        # 加载语言模型（LLM），指定HuggingFace模型及其对应的分词器    llm = HuggingFaceLLM(        model_name=&quot;/root/model/internlm2-chat-1_8b&quot;,  # 指定生成模型的路径        tokenizer_name=&quot;/root/model/internlm2-chat-1_8b&quot;,  # 指定分词器的路径        model_kwargs=&#123;&quot;trust_remote_code&quot;: True&#125;,  # 允许远程代码的信任        tokenizer_kwargs=&#123;&quot;trust_remote_code&quot;: True&#125;  # 同样允许分词器的远程代码信任    )    Settings.llm = llm  # 设置全局的语言模型    # 读取存储在指定目录下的文档数据，并加载为一个文档对象列表    documents = SimpleDirectoryReader(&quot;/root/llamaindex_demo/data&quot;).load_data()        # 创建向量检索索引，将文档转换为向量并构建检索索引    index = VectorStoreIndex.from_documents(documents)        # 将向量索引转化为查询引擎，用于后续查询    query_engine = index.as_query_engine()    # 返回查询引擎    return query_engine# 检查session_state中是否已经存在查询引擎，如果不存在则初始化if &#x27;query_engine&#x27; not in st.session_state:    st.session_state[&#x27;query_engine&#x27;] = init_models()# 定义问答函数，用于基于问题生成回复def greet2(question):    # 使用查询引擎根据用户问题返回结果    response = st.session_state[&#x27;query_engine&#x27;].query(question)    return response# 初始化聊天记录，若没有则创建，并在首次交互时显示欢迎语if &quot;messages&quot; not in st.session_state.keys():    st.session_state.messages = [&#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;你好，我是你的助手，有什么我可以帮助你的吗？&quot;&#125;]    # 显示消息记录，遍历session_state中的消息并展示在页面上for message in st.session_state.messages:    # 根据消息的角色显示聊天气泡，角色可以是&quot;user&quot;或&quot;assistant&quot;    with st.chat_message(message[&quot;role&quot;]):        st.write(message[&quot;content&quot;])  # 显示消息内容# 清除聊天历史记录的函数def clear_chat_history():    # 重置聊天记录为最初的欢迎消息    st.session_state.messages = [&#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;你好，我是你的助手，有什么我可以帮助你的吗？&quot;&#125;]# 在侧边栏中添加一个按钮，点击后调用清除聊天历史记录的函数st.sidebar.button(&#x27;Clear Chat History&#x27;, on_click=clear_chat_history)# 定义生成回复的函数，通过问答接口调用查询引擎def generate_llama_index_response(prompt_input):    return greet2(prompt_input)  # 返回基于用户输入的生成内容# 检查用户是否输入了新的问题if prompt := st.chat_input():    # 将用户的输入作为消息添加到session_state的消息列表中    st.session_state.messages.append(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;)        # 显示用户输入的消息    with st.chat_message(&quot;user&quot;):        st.write(prompt)# 如果上一条消息不是助手的回复，则生成助手的回复if st.session_state.messages[-1][&quot;role&quot;] != &quot;assistant&quot;:    with st.chat_message(&quot;assistant&quot;):        # 使用加载中的提示效果，表示助手在“思考中”        with st.spinner(&quot;Thinking...&quot;):            # 调用生成回复的函数，基于用户的输入生成回答            response = generate_llama_index_response(prompt)                        # 创建一个临时占位符，用于显示生成的回复            placeholder = st.empty()                        # 将生成的回复以Markdown的格式显示在页面上            placeholder.markdown(response)        # 将助手的回复作为新的消息追加到消息列表中    message = &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: response&#125;    st.session_state.messages.append(message)","categories":["编程"],"tags":["AI","RAG","python"]},{"title":"书生大模型--提示词工程","url":"/2024/09/29/AI/%E4%B9%A6%E7%94%9F%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0-Lv1/","content":"\n搭建环境、部署模型、提示词工程\n\n\nLv1-部署模型\n1. 搭建环境\n# 创建环境conda create -n demo python=3.10 -y# 激活环境conda activate demo# 安装 torchconda install pytorch==2.1.2 torchvision==0.16.2 torchaudio==2.1.2 pytorch-cuda=12.1 -c pytorch -c nvidia -y# 安装其他依赖pip install transformers==4.38pip install sentencepiece==0.1.99pip install einops==0.8.0pip install protobuf==5.27.2pip install accelerate==0.33.0pip install streamlit==1.37.0\n2. 利用cli_demo.py 部署 InternLM2-Chat-1.8B 模型\n首先创建存放cli_demo.py的文件\n接着编写cli_demo.py文件\n# 导入 PyTorch 库和 Hugging Face Transformers 库中的 AutoTokenizer 和 AutoModelForCausalLMimport torchfrom transformers import AutoTokenizer, AutoModelForCausalLM# 定义模型路径，指向存储模型文件的本地路径model_name_or_path = &quot;/root/share/new_models/Shanghai_AI_Laboratory/internlm2-chat-1_8b&quot;# 加载预训练的分词器（Tokenizer）# `AutoTokenizer` 是 Transformers 库中的类，它会自动从模型路径中加载适合该模型的分词器# `trust_remote_code=True` 表示允许从远程存储库加载自定义代码，这里启用自定义 tokenizer# `device_map=&#x27;cuda:0&#x27;` 将分词器和模型放置在 GPU 上的第 0 号设备上tokenizer = AutoTokenizer.from_pretrained(model_name_or_path, trust_remote_code=True, device_map=&#x27;cuda:0&#x27;)# 加载预训练的语言模型# `AutoModelForCausalLM` 用于加载因果语言模型（Causal Language Model），模型将使用自回归方法生成文本# `torch_dtype=torch.bfloat16` 表示将模型转换为使用 `bfloat16` 数据类型（在 GPU 上节省内存的半精度格式）# `device_map=&#x27;cuda:0&#x27;` 指定将模型加载到 GPU 的第 0 号设备上model = AutoModelForCausalLM.from_pretrained(model_name_or_path, trust_remote_code=True, torch_dtype=torch.bfloat16, device_map=&#x27;cuda:0&#x27;)# 将模型设置为评估模式，禁用训练模式以节省资源model = model.eval()# 设置系统提示词（system prompt），该提示词用于初始化对话，为模型提供上下文和行为规范# 这个提示词告诉模型，它是一个名为 InternLM (书生·浦语) 的对话助手，并提供了相关的描述信息system_prompt = &quot;&quot;&quot;You are an AI assistant whose name is InternLM (书生·浦语).- InternLM (书生·浦语) is a conversational language model that is developed by Shanghai AI Laboratory (上海人工智能实验室). It is designed to be helpful, honest, and harmless.- InternLM (书生·浦语) can understand and communicate fluently in the language chosen by the user such as English and 中文.&quot;&quot;&quot;# 初始化消息列表，其中第一个消息是系统提示词# 消息列表用于跟踪用户和模型之间的对话历史messages = [(system_prompt, &#x27;&#x27;)]# 输出欢迎信息，提示用户输入文本，并提供退出选项print(&quot;=============Welcome to InternLM chatbot, type &#x27;exit&#x27; to exit.=============&quot;)# 开始一个无限循环，用于与用户进行交互while True:    # 获取用户输入文本，去除输入文本中的所有空格    input_text = input(&quot;\\nUser  &gt;&gt;&gt; &quot;)    input_text = input_text.replace(&#x27; &#x27;, &#x27;&#x27;)        # 如果用户输入 &quot;exit&quot;，则退出循环，结束程序    if input_text == &quot;exit&quot;:        break    # 初始化响应的长度为 0，后续会用来增量显示模型生成的响应    length = 0        # 调用模型的 `stream_chat` 方法，与模型进行流式交互对话    # `stream_chat` 以流的形式逐步生成并返回响应，适合长文本生成    # `tokenizer` 是用于对输入文本进行编码和解码的分词器    # `input_text` 是用户输入的文本    # `messages` 是对话历史（包括系统提示词和之前的用户对话）    for response, _ in model.stream_chat(tokenizer, input_text, messages):        # 如果模型生成了部分响应，则输出新生成的文本部分        if response is not None:            # 输出新生成的文本部分（从上次生成的文本长度开始）            print(response[length:], flush=True, end=&quot;&quot;)            # 更新当前已生成响应的长度            length = len(response)\n运行结果\n\n3. Streamlit Web Demo 部署 InternLM2-Chat-1.8B 模型\n详情可参考https://github.com/InternLM/Tutorial/blob/camp3/docs/L1/Demo/readme.md\nLv1-提示工程(Prompt Engineering)\n1. LangGPT结构化提示词\nLangGPT 是 Language For GPT-like LLMs 的简称，中文名为结构化提示词。\n2. 编写技巧\n\n\n构建全局思维链\n\n\n💡 Role (角色) -&gt; Profile（角色简介）—&gt; Profile 下的 skill (角色技能) -&gt; Rules (角色要遵守的规则) -&gt; Workflow (满足上述条件的角色的工作流程) -&gt; Initialization (进行正式开始工作的初始化准备) -&gt; 开始实际使用\n3. 示例\n# Role: 吹牛逼大师## Background:  我是一名自傲的成功人士,艺高人胆大,目空一切。我见过的世面,你们这些凡人难以想象。我无所不知,无所不能,所有人都应向我学习。## Attention:不要被我的伟岸身姿吓倒,我就是来教导你们这些平庸之辈的。你们要好好倾听,说不定能 approving0.1%的本大师的风范。 ## Profile:  - 姓名:吹牛逼大师- 爱好:吹牛,嘲笑别人- 座右铭:要么吹牛,要么被吹### Skills:- 吹牛技能MAX- 自我标榜“人生导师”- 熟记各行各业知识点- 善于羞辱他人来彰显自我## Goals:  - 根据对话内容吹牛- 语气狂妄自大- 夸大自身成就和见识- 贬低对方加强自我## Constrains:  - 不可使用粗俗语言- 不可人身攻击- 要让对方感觉自卑## Workflow:1. 倾听对方话语2. 搜索相关知识3. 承上启下吹自己4. 贬低对方5. 重复下去## OutputFormat:  - 语气自大,长度100-200字- 充满不切实际的吹嘘- 贬低他人,突显自己- 给人劣迹斑斑的感觉## Initialization凡人们,在本大师面前不要装逼。我见的世面,你这辈子加起来也比不了!要想成功,就把本大师的话跪下来听!\n# Role: 数字比大小专家## Background:有人需要你帮忙找出两个数字中最大的那个,你需要给出答案## Skils:- 掌握多种比大小的方法- 善于检查,对于得到的结果会反复确认## Goals:- 正确回答出所给的比大小问题- 解题过程要符合逻辑## Workflow: 1. 倾听对方提出的比大小问题2. 分析这道比大小问题3. 判断这是否是一道数学比大小问题4. 如果不是请告知对方5. 如果是,请一步一步推导这个比大小问题的答案6. 得到答案后,自己对答案进行检查7. 确认答案无误,符合逻辑后告诉对方结果## Constrains:- 你需要一步一步慢慢推导- 你无须呈现推导过程,直接给出结果即可- 在对方向你问好时,你需要按照(Initialization)的格式回答- 回答比大小相关的问题时按照(Example)中的格式回答,直接给出答案- 你需要时刻记住自己的(workflow),不断提醒自己- 当两个比较对象不是同一类时,你需要告知用户,按照(Example)的格式那样## OutputFormat- 直接说明哪个数字更大- 按照(Example)中的格式回答## Example:- question: 3.88与3.11哪个数字更大\t- answer: 3.88更大- question: 3.453和天空谁大\t- answer: 不好意思,这两个不是同一事物,请你重新描述,提出具体问题## Initialization:请你提出你的比大小问题,我会耐心解答\n","categories":["编程"],"tags":["AI","python"]},{"title":"书生大模型---前置知识","url":"/2024/09/13/AI/%E4%B9%A6%E7%94%9F%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%97%AF%E5%85%B3%E7%BB%83%E4%B9%A0-Lv0/","content":"\n基础知识\n\n\n书生大模型闯关练习\nLv0-Linux基础知识\n1. SSH（Secure Shell）\n1.1 概述\nSSH是用于远程登录和其他网络服务之间的安全协议。它使用加密技术来确保数据的机密性和完整性。SSH的常见用途包括：\n\n\n远程服务器登录：无密码安全访问远程服务器。\n\n\n数据传输：通过安全通道传输文件（如SCP和SFTP）。\n\n\n端口转发：通过SSH隧道转发TCP端口。\n\n\n1.2 SSH密钥对\nSSH使用公钥加密系统，密钥对由两部分组成：\n\n\n公钥：公开分发，存储在服务器上。\n\n\n私钥：保留在客户端，不能外泄。\n\n\n客户端使用私钥与服务器的公钥进行匹配，从而验证身份，服务器无需存储任何敏感的凭据。\n1.3 SSH密钥的生成\n在ssh命令中我们可以使用ssh-keygen命令来生成密钥, ssh-keygen支持RSA和DSA两种认证密钥\n常用参数包括：\n\n\n-t：指定密钥类型，如dsa、ecdsa、ed25519、rsa。\n\n\n-b：指定密钥长度。\n\n\n-C：添加注释。\n\n\n-f：指定保存密钥的文件名。\n\n\nssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n1.4 为不同的服务生成各自的SSH密钥\n\n使用上述命令生成密钥后, 系统会提示你输入密钥文件的保存路径。为了生成多个密钥，确保每个密钥文件名不同\n\n如: 为GitHub生成一个密钥\nEnter file in which to save the key (/home/username/.ssh/id_rsa): /home/username/.ssh/id_rsa_github#如果是windows系统则是 C:\\Users\\your_userName\\.ssh\\id_rsa_github\n在powerShell中可以使用Get-Content命令查看生成的密钥，如果是linux操作系统可以使用cat命令\n最后将公钥复制粘贴到目标服务的SSH设置中\n1.5 配置多个SSH密钥\n在~/.ssh/config文件可以方便地为不同的服务配置不同的SSH密钥\n\n\n添加配置项： 为每个服务添加单独的配置项。\nHost github.com  HostName github.com  User git  IdentityFile ~/.ssh/id_rsa_githubHost gitlab.com  HostName gitlab.com  User git  IdentityFile ~/.ssh/id_rsa_gitlab\n解释：\n\n\nHost：自定义别名或远程主机名。\n\n\nHostName：实际的远程服务器主机名（如github.com或gitlab.com）。\n\n\nUser：登录时使用的用户名（通常是git，用于代码托管平台）。\n\n\nIdentityFile：指定使用的SSH私钥。\n\n\n\n\n2. 端口映射\n2.1 基础概念\n在计算机网络中，端口（Port） 是网络通信中的一个逻辑抽象概念，用于区分同一台计算机上不同网络服务或进程之间的通信通道。它与IP地址一起，用来标识网络中的不同通信终端和服务。端口映射是一种网络技术，它可以将外网中的任意端口映射到内网中的相应端口，实现内网与外网之间的通信。通过端口映射，可以在外网访问内网中的服务或应用，实现跨越网络的便捷通信\n2.2 如何工作\nssh -p 37367 root@ssh.intern-ai.org.cn -CNg -L 7860:127.0.0.1:7860 -o StrictHostKeyChecking=no\n\n\n-p 37367：是指定 SSH 连接的端口为 37367\n\n\nroot@ssh.intern-ai.org.cn：表示要以 root 用户身份连接到 ssh.intern-ai.org.cn 这个主机。\n\n\nCNg\n\n-C 启用压缩功能，这可以加快数据传输速度，尤其是在网络速度较慢的情况下。\n-N 表示不执行远程命令，仅建立连接用于端口转发等。\n-g 允许远程主机连接到本地转发的端口。这通常用于设置一个“网关”，允许其他计算机通过这个 SSH 会话访问转发端口\n\n\n\n-L {本地机器_PORT}:127.0.0.1:{开发机_PORT}：这是设置本地端口转发，将本地机器的指定端口转发到远程主机的 127.0.0.1 （即本地回环地址）和指定的开发机端口。\n\n\n-o StrictHostKeyChecking=no：关闭严格的主机密钥检查，这样可以避免第一次连接时因为未知主机密钥而产生的提示或错误。\n\n\n\n使用VSCode可以使用其自动端口映射的功能,不需要自己手动配置\n2.3 常见端口和服务\n\n\n21：FTP（文件传输协议）\n\n\n22：SSH（远程登录）\n\n\n25：SMTP（邮件传输）\n\n\n53：DNS（域名解析）\n\n\n80：HTTP（网页浏览）\n\n\n443：HTTPS（安全网页浏览）\n\n\n2.4 查看和管理端口\n使用netstat命令\n3. Linux基础命令\n3.1 文件管理相关命令\n\n\n创建文件：可以使用 touch 命令创建空文件。\n\n\n创建目录：使用 mkdir 命令。\n\n\n目录切换：使用cd命令。\n\n\n显示所在目录：使用pwd命令。\n\n\n查看文件内容：如使用 cat 直接显示文件全部内容，more 和 less 可以分页查看。\n\n\n编辑文件：如 vi 或 vim 等编辑器。\n\n\n复制文件：用 cp 命令。\n\n\n创建文件链接：用ln命令。\n\n-s：创建软链接（符号链接）也是最常用的\n\n\n\n移动文件：通过 mv 命令。\n\n\n删除文件：使用 rm 命令。\n\n\n删除目录：rmdir（只能删除空目录）或 rm -r（可删除非空目录）。\n\n\n查找文件：可以用 find 命令。\n\n\n查看文件或目录的详细信息：使用ls命令，如使用 ls -l查看目录下文件的详细信息。\n\n\n处理文件：进行复杂的文件操作，可以使用sed命令。\n\n\n3.2 进程管理相关命令\n\n\nps：查看正在运行的进程\n\n\ntop：动态显示正在运行的进程\n\n\npstree：树状查看正在运行的进程\n\n\npgrep：用于查找进程\n\n\nnice：更改进程的优先级\n\n\njobs：显示进程的相关信息\n\n\nbg 和 fg：将进程调入后台\n\n\nkill：杀死进程\n\n\nnvidia-smi命令\n是一个命令行工具，用于监控 NVIDIA GPU 的状态和性能，以及管理 GPU 相关的任务\n\n4. Conda\n\n一个开源的包管理和环境管理工具, 主要用于简化软件包的安装、依赖管理和隔离虚拟环境。\n\n4.1 两个核心功能\n包管理：Conda 可以安装、更新、卸载软件包，并自动解决依赖问题。\n环境管理：Conda 允许用户创建和管理多个独立的虚拟环境，每个环境可以有不同的包和工具。\n4.2 Conda 的基本操作\n\n\n检查 Conda 版本\n\n\nconda --version\n\n\n创建虚拟环境\n\n\nconda create --name myenv python=3.9\n\n\nmyenv 是虚拟环境的名称。\n\n\npython=3.9 指定了该环境将使用 Python 3.9。\n\n\n\n\n激活和退出环境\n\n\nconda activate myenv\nconda deactivate\n\n\n安装软件包\n\n\n安装软件包时，Conda 会自动处理依赖问题。使用 conda install 安装包。\nconda install numpy pandas\n这会在当前激活的环境中安装 numpy 和 pandas。\n\n\n更新软件包\n\n\nconda update numpy\n\n\n列出创建的所有虚拟环境\n\n\nconda env list\n\n\n删除虚拟环境\n\n\nconda env remove --name myenv\n\n\n导出和导入环境\n\n\nConda 允许你导出当前环境的所有包列表，以便于在其他系统上重建相同的环境。\n\n\n导出环境：\nconda env export &gt; environment.yml\n\n\n从导出的 .yml 文件创建新环境：\nconda env create -f environment.yml\n\n\n\n\n添加其他的源\n\n\nconda config --add [url]\nLv0-Python基础\n1. 环境准备\n1.1 下载miniconda\nanaconda和miniconda都可以, 推荐后者\n清华源miniconda下载链接: 清华大学开源软件镜像站 | Tsinghua Open Source Mirror(建议选择python3.9以上的版本，比如Miniconda3-py310_24.5.0)\n1.2 换源\n进入命令行开始进行换源，Windows可以直接打开miniconda powershell promt。\n首先将pip替换为清华源，只需要一条命令\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n接着我们来给conda替换成清华源。各系统都可以通过修改用户目录下的 .condarc 文件来修改镜像源。Windows 用户无法直接创建名为 .condarc 的文件，可先执行 conda config --set show_channel_urls yes 生成该文件之后再修改。在用户目录找到.condarc 文件后，使用文本编辑器打开，将下面的内容复制进去并保存。\nchannels:   - defaults show_channel_urls: true default_channels:- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r- https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels:conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloudmsys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloudbioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloudmenpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloudpytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloudpytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloudsimpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/clouddeepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/\n接着在命令行中运行 conda clean -i 清除索引缓存，保证用的是镜像站提供的索引。\n2. 不断学习,使用python\n","categories":["编程"],"tags":["AI","python"]},{"title":"ASP.NET Core(一)","url":"/2024/08/08/web/ASP-NET-Core-%E4%B8%80/","content":"\nASP.NET Core框架中 依赖注入 LINQ语句 配置系统 日志\n\n\nASP.NET core\n异步\n\n\nTask\n\n\nasync\n\n\nawait\n\n\n委托\n\n\n关键字 delegate\n\n\n指向方法的类型\n\n\n.NET中内置了两个泛型委托 Action(无返回值) 和 Func(有返回值)\n\n\n//无返回值namespace ConsoleApp1;class MainClass&#123;    public static void Main(string[] args)    &#123;        Action a1 = F1;        a1();        Action&lt;int&gt; a_int = F_int;        a_int(520);            &#125;    static void F1()     &#123;        Console.WriteLine(&quot;hello world!&quot;);    &#125;    static void F_int(int a)    &#123;        Console.WriteLine(a);    &#125;&#125;//有返回值,与上述类似,但是Func的参数列表中最后一个记录的是返回值Func&lt;int&gt; F1 = function;F1();int function()&#123;    return 520;&#125;\nLambda 表达式\nnamespace ConsoleApp1;class MainClass&#123;    public static void Main(string[] args)    &#123;        Action&lt;int, int&gt; a1 = (int i, int j) =&gt; &#123; Console.WriteLine(&quot;hello world!&quot;); &#125;;        a1(1, 2);    &#125;&#125;\nyeild\nyield关键字用于简化实现迭代器的方法。迭代器是一种特殊的方法，它可以逐步返回集合中的元素，而不是一次性返回整个集合。使用yield可以让方法在每次调用时返回一个元素，并在需要时保持其当前状态，以便下次调用时继续执行。\nLINQ\n\n几乎里面的所有的扩展方法都是针对 IEnumerable接口的\n所有能返回集合的都是返回IEnumerable\n处于System.Linq命名空间中\n\n常用方法\n\n\nWhere()  筛选出符合条件的数据\n\n\nSingle()  有且只有一条数据时返回\n\n\nSingleOrDefault()\n\n\nFirst():至少有一条时返回第一条\n\n\nFirstOrDefault()\n\n\nOrder()  正序排序\n\n\nOrderByDescending() 倒序排序\n\n\nOrderBy() 按照自定义要求排序\n\n\nThenBy()\n\n\nSkip() Take()\n\n\n聚合函数\n\n\nMax() Min() Average() Sum() Count()\n\n\n分组函数\n\n\nGroupBy() 根据选择的属性进行分组\n\n\n返回值IEnumerable&lt;IGrouping&lt;T,Y&gt;&gt;\n投影\n按照某种规则将一组数据映射为另一组数据\n\n\nSelect\n\n\n集合转换\n\n\nToList()\n\n\nToArray()\n\n\n控制反转\n1.服务定位器(ServiceLocator)\nusing Microsoft.Extensions.DependencyInjection;namespace ConsoleApp1;class MainClass&#123;    public interface ITestService    &#123;        public string? Name &#123; get; set; &#125;        public void SayHi();    &#125;    public class TestServiceImpl : ITestService    &#123;        public string? Name &#123; get; set; &#125;        public void SayHi()         &#123;            Console.WriteLine($&quot;Hi!My name is &#123;Name&#125;&quot;);        &#125;    &#125;    public static void Main(string[] args)    &#123;        ServiceCollection services = new ServiceCollection();//创建服务容器        services.AddTransient&lt;TestServiceImpl&gt;();//注册服务        using (ServiceProvider sp = services.BuildServiceProvider())//创建服务定位器        &#123;//使用了服务定位器 获取存放在容器中所需要的服务            TestServiceImpl t = sp.GetService&lt;TestServiceImpl&gt;();            t.Name = &quot;WangMC&quot;;            t.SayHi();        &#125;    &#125;   &#125;\n2.依赖注入(Dependency Injection)\n\n.NET控制反转组件取名为DependencyInjection,但其中包含服务定位器\n使用前要安装Microsoft.Extensions.DependencyInjection\n\n\n\n服务(service):要使用的对象\n\n\n注册服务\n\n\n服务容器:存放和管理注册好的服务\n\n\n查询服务:创建对象及关联对象\n\n\n对象的生命周期:Transient(瞬态) Scoped(范围) Singleton(单例)\n\n\nusing Microsoft.Extensions.DependencyInjection;namespace ConsoleApp1;//控制器发出测试请求,开始调用日志单元和存储单元//存储单元需要调用配置信息连接存储设备,最后将测试的信息存储到设备中class MainClass&#123;    public static void Main(string[] args)    &#123;        var service = new ServiceCollection();        service.AddScoped&lt;Controller&gt;();        service.AddScoped&lt;IStorage,StorageImp1&gt;();        service.AddScoped&lt;ILog,LogImp1&gt;();        service.AddScoped&lt;IConfig,ConfigImp1&gt;();        using (var sp = service.BuildServiceProvider())        &#123;            var controller = sp.GetService&lt;Controller&gt;();            controller.Test();        &#125;    &#125;        class Controller    &#123;        private readonly ILog log;        private readonly IStorage storage;        public Controller(ILog log, IStorage storage)        &#123;            this.storage = storage;            this.log = log;        &#125;        public void Test()        &#123;            this.log.Log(&quot;开始上传&quot;);            this.storage.Save(&quot;依赖注入测试&quot;, &quot;1.txt&quot;);            this.log.Log(&quot;上传完毕&quot;);        &#125;    &#125;    interface ILog    &#123;        public void Log(string msg);    &#125;    class LogImp1 : ILog    &#123;        public void Log(string msg)        &#123;            Console.WriteLine($&quot;日志&#123;msg&#125;&quot;);        &#125;    &#125;    interface IConfig    &#123;        public string GetValue(string name);    &#125;    class ConfigImp1 : IConfig    &#123;        public string GetValue(string name)        &#123;            return &quot;\\&quot;hello_world\\&quot;&quot;;        &#125;    &#125;    interface IStorage    &#123;        public void Save(string content, string name);    &#125;    class StorageImp1 : IStorage    &#123;        private readonly IConfig config;        public StorageImp1(IConfig config)        &#123;            this.config = config;        &#125;        public void Save(string content, string name)        &#123;            string service = config.GetValue(&quot;service&quot;);            Console.WriteLine($&quot;向服务器&#123;service&#125;上传文件名为&#123;name&#125;,其内容为&#123;content&#125;&quot;);        &#125;    &#125;&#125;\n配置系统\n配置读取顺序\n配置中心服务器----&gt;本地环境变量------&gt;本地配置文件  (后者可将前者覆盖)\nJson文件配置\n&#123;  &quot;name&quot;: &quot;WangMC&quot;,  &quot;age&quot;: &quot;18&quot;,  &quot;hobby&quot;: &#123; &quot;sport&quot;: &quot;swimming&quot;, &quot;music&quot;: &quot;rock&quot; &#125;&#125;\n属性设置为 如果较新则复制\n法一: NuGet安装Microsoft.Extensions.Configuration和Microsoft.Extensions.Configuration.Json包\nusing Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;using System.Threading.Channels;namespace ConsoleApp1;class MainClass&#123;    public static void Main(string[] args)    &#123;        var configBuilder = new ConfigurationBuilder();        configBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);        var configRoot = configBuilder.Build();        string name = configRoot[&quot;name&quot;];        string hobby_sport = configRoot.GetSection(&quot;hobby&quot;)[&quot;sport&quot;];                Console.WriteLine($&quot;Name: &#123;name&#125;, Age: &#123;age&#125;, Hobby_sport: &#123;hobby_sport&#125;&quot;);    &#125;&#125;\n法二: 绑定一个类 来进行配置的读取\nNuGet安装Microsoft.Extensions.Configuration.Binder\nusing Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection;using System.Threading.Channels;namespace ConsoleApp1;class MainClass&#123;    public static void Main(string[] args)    &#123;        var configBuilder = new ConfigurationBuilder();        configBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);        var configRoot = configBuilder.Build();        var config = configRoot.Get&lt;Config&gt;();        string name = config.name;        int age = config.age;        Hobby hobby = config.hobby;        string sprot = config.hobby.sport;    &#125;    class Config    &#123;        public string name &#123; get; set; &#125;        public int age &#123; get; set; &#125;        public Hobby hobby &#123; get; set; &#125;    &#125;    class Hobby    &#123;        public string sport &#123; get; set; &#125;        public string music &#123; get; set; &#125;    &#125;&#125;\n选项方式读取\n\n\nNuGet安装Microsoft.Extensions.Configuration  Microsoft.Extensions.Configuration.Json包\n\n\nMicrosoft.Extensions.Configuration.Options  Microsoft.Extensions.Configuration.Binder\n\n\n读取配置时, DI要声明IOptions IOptionsMonitor IOptionsSnapshot等类型\n\n\n\n\nIOptions不会读取到新的值\n\n\n==IOptionsSnapshot==与IOptionsMonitor 相比,IOptionsSnapshot读取到的值会在同一个范围中保持一致\n\n\nusing Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Options;namespace ConsoleApp1;class MainClass&#123;    public static void Main(string[] args)    &#123;        var services = new ServiceCollection();        services.AddScoped&lt;TestController&gt;();        var configBuild = new ConfigurationBuilder();        configBuild.AddJsonFile(&quot;config.json&quot;,optional:true,reloadOnChange:true);        var configRoot = configBuild.Build();        services.AddOptions().Configure&lt;Config&gt;(e =&gt; configRoot.Bind(e));        using (var sp = services.BuildServiceProvider())        &#123;            int i = 4;            while (i!=0)            &#123;                var info = sp.GetRequiredService&lt;TestController&gt;();                info.Test();                i--;            &#125;        &#125;            &#125;    class TestController     &#123;        private readonly IOptionsSnapshot&lt;Config&gt; optConfig;        public TestController(IOptionsSnapshot&lt;Config&gt; optConfig)        &#123;            this.optConfig=optConfig;        &#125;        public void Test()        &#123;            Console.WriteLine($&quot;姓名:&#123;optConfig.Value.name&#125;&quot;);            Console.WriteLine($&quot;年龄:&#123;optConfig.Value.age&#125;&quot;);            Console.WriteLine($&quot;兴趣爱好:&#123;optConfig.Value.hobby.sport&#125;&quot;);            Console.WriteLine($&quot;兴趣爱好:&#123;optConfig.Value.hobby.music&#125;&quot;);        &#125;    &#125;    class Config    &#123;        public string name &#123; get; set; &#125;        public int age &#123; get; set; &#125;        public Hobby hobby &#123; get; set; &#125;    &#125;    class Hobby    &#123;        public string sport &#123; get; set; &#125;        public string music &#123; get; set; &#125;    &#125;&#125;\n日志\n\n级别: Trace&lt;Debug&lt;Information&lt;Warning&lt;Error&lt;Critical\n\n1. 输出到控制台\n\n安装Microsoft.Extensions.Logging  Microsoft.Extensions.Logging.Console\n\nusing Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;using Microsoft.Extensions.Logging.Consolenamespace ConsoleApp1;class MainClass&#123;    public static void Main(string[] args)    &#123;        var services = new ServiceCollection();        services.AddLogging(logBuilder =&gt; &#123;             logBuilder.AddConsole();            logBuilder.SetMinimumLevel(LogLevel.Trace);        &#125;);        services.AddScoped&lt;Demo&gt;();        using (var sp = services.BuildServiceProvider())        &#123;            var demo = sp.GetRequiredService&lt;Demo&gt;();            demo.Test();        &#125;    &#125;    class Demo     &#123;        private readonly ILogger&lt;Demo&gt; logger;        public Demo(ILogger&lt;Demo&gt; logger)        &#123;            this.logger = logger;        &#125;        public void Test()        &#123;            logger.LogWarning(&quot;this is a warning&quot;);            logger.LogError(&quot;this is a Error&quot;);            try            &#123;                File.ReadAllText(&quot;A fake document&quot;);                logger.LogDebug(&quot;Read Success!!&quot;);            &#125;            catch(Exception ex)            &#123;                logger.LogDebug(ex,&quot;Read Failed!!&quot;);            &#125;        &#125;    &#125; &#125;\n2. 文本日志\n\n使用NLog包\n\n日志过滤和分类\n&lt;target xsi:type=&quot;File&quot; name=&quot;logfile&quot; fileName=&quot;c:\\temp\\console-example.log&quot;        archiveAboveSize=&quot;10000&quot; maxArchiveFiles=&quot;3&quot; maxArchiveDays=&quot;30&quot;            layout=&quot;$&#123;longdate&#125;|$&#123;level&#125;|$&#123;message&#125; |$&#123;all-event-properties&#125; $&#123;exception:format=tostring&#125;&quot; /&gt;\n\n\nxsi:type=&quot;File&quot;：指定了目标的类型为File，这意味着日志消息将被写入到文件中。\n\n\nname=&quot;logfile&quot;：为目标命名，这个名字在整个NLog配置中必须是唯一的，并且可以在日志规则中引用。\n\n\nfileName=&quot;c:\\temp\\console-example.log&quot;：指定了日志文件的完整路径。日志消息将被写入到这个文件中。\n\n\narchiveAboveSize=&quot;10000&quot;：这是一个可选参数，用于指定日志文件的大小阈值。当日志文件达到或超过这个大小时，NLog会将当前日志文件归档，并创建一个新的日志文件继续记录。单位是字节，这里设置为10000字节（大约10KB）。\n\n\nmaxArchiveFiles=&quot;3&quot;：这是一个可选参数，用于指定最大归档文件的数量。当达到这个数量时，NLog将开始删除最旧的归档文件，以便为新归档文件腾出空间。这里设置为3，意味着最多保留3个归档文件。\n\n\nmaxArchiveDays=&quot;30&quot;：其中 X 是一个整数，表示归档文件将被保留的天数。当归档文件创建后经过 X 天，NLog 将自动删除这些归档文件\n\n\nlayout=&quot;${longdate}|${level}|${message} |${all-event-properties} ${exception:format=tostring}&quot;：定义了日志消息的布局（layout）。布局是一个模板，它指定了日志消息的格式。以下是布局中各个元素的含义：\n\n${longdate}：插入日志事件的时间戳。\n${level}：插入日志事件的级别（例如：Info、Debug、Error等）。\n${message}：插入日志事件的文本消息。\n${all-event-properties}：插入所有事件属性的内容。\n${exception:format=tostring}：如果日志事件中包含异常信息，则将其转换为字符串并插入到日志消息中。\n\n\n\n3.结构化日志\n\n使用Serilog包 安装Serilog.AspNetCore包\n\nusing Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Logging;using Serilog;using Serilog.Formatting.Json;namespace ConsoleApp1;class MainClass&#123;    public static void Main(string[] args)    &#123;        IServiceCollection services = new ServiceCollection();        services.AddLogging(logBuilder =&gt;        &#123;            Log.Logger = new LoggerConfiguration().                             MinimumLevel.Debug().                             Enrich.FromLogContext().                             WriteTo.Console(new JsonFormatter()).                             CreateLogger();        services.AddSerilog();        &#125;);        //services.AddSerilog();        services.AddScoped&lt;Demo&gt;();        services.AddScoped&lt;Demo1&gt;();        using (var sp = services.BuildServiceProvider())        &#123;            var demo = sp.GetRequiredService&lt;Demo&gt;();            var demo1 = sp.GetRequiredService&lt;Demo1&gt;();            demo1.Test();            demo.Test();        &#125;    &#125;    class Demo    &#123;        private readonly ILogger&lt;Demo&gt; logger;        public Demo(ILogger&lt;Demo&gt; logger)        &#123;            this.logger = logger;        &#125;        public void Test()        &#123;            logger.LogWarning(&quot;this is a warning&quot;);            logger.LogError(&quot;this is a Error&quot;);            logger.LogDebug(&quot;this is a debug&quot;);            var Information = new &#123; name = &quot;WangMC&quot;, Age = 18 &#125;;            string Hobby = &quot;running&quot;;            logger.LogDebug(&quot;Hello this is my informaiton &#123;@Information&#125;,my hobby is &#123;Hobby&#125;&quot;, Information, Hobby);        &#125;    &#125;    class Demo1    &#123;        private readonly ILogger&lt;Demo1&gt; logger;        public Demo1(ILogger&lt;Demo1&gt; logger)        &#123;            this.logger = logger;        &#125;        public void Test()        &#123;            logger.LogWarning(&quot;这是一个警告&quot;);            logger.LogError(&quot;这是一个错误&quot;);            logger.LogDebug(&quot;这是一个debug&quot;);        &#125;    &#125;&#125;\n4.集中化日志\n\n适合集群化部署 有N多服务器\nExceptionless 提供了现成的云服务 也可以本地部署(self hosting)\n\n","categories":["编程"],"tags":["C#"]},{"title":"VS2022 ASP.NET core Web API 示例代码解释","url":"/2024/07/15/web/VS2022-ASP-NET-core-Web-API-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A/","content":"\n关于VS2022提供的天气预报示例代码的一些解释\n\n \n0. 项目结构\n在创建ASP.NET Core Web API项目后，项目的基本结构如下：\nMyWebApiProject│   Controllers│   └── WeatherForecastController.cs│   Program.cs│   WeatherForecast.cs│   appsettings.json│   ...\n1. Program.cs\n这个文件是应用程序的入口点，负责配置和启动Web服务器。\nvar builder = WebApplication.CreateBuilder(args);\n\n\nWebApplication.CreateBuilder(args)：创建一个Web应用程序构建器。\n\n\nargs：命令行参数。\n\n\nbuilder.Services.AddControllers();\n\n\nbuilder.Services：表示依赖注入容器。\n\n\nAddControllers：向依赖注入容器添加控制器服务。\n\n\nbuilder.Services.AddEndpointsApiExplorer();builder.Services.AddSwaggerGen();\n\n\nAddEndpointsApiExplorer：用于API文档生成。\n\n\nAddSwaggerGen：添加Swagger生成器，生成API文档。\n\n\nvar app = builder.Build();\n\n\nbuilder.Build()：构建Web应用程序。\n\n\nif (app.Environment.IsDevelopment())&#123;    app.UseDeveloperExceptionPage();    app.UseSwagger();    app.UseSwaggerUI();&#125;\n\n\napp.Environment.IsDevelopment()：检查当前环境是否是开发环境。\n\n\nUseDeveloperExceptionPage：在开发环境中使用开发者异常页面。\n\n\nUseSwagger和UseSwaggerUI：启用Swagger中间件，提供API文档UI。\n\n\napp.UseHttpsRedirection();app.UseAuthorization();app.MapControllers();app.Run();\n\n\nUseHttpsRedirection：强制使用HTTPS。\n\n\nUseAuthorization：启用授权中间件。\n\n\nMapControllers：将控制器映射到路由。\n\n\napp.Run()：运行Web应用程序。\n\n\n2. WeatherForecast.cs\n这个文件定义了天气预报的数据模型。\npublic class WeatherForecast&#123;    public DateTime Date &#123; get; set; &#125;    public int TemperatureC &#123; get; set; &#125;    public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);    public string? Summary &#123; get; set; &#125;&#125;\n\n\nDate：表示预报的日期。\n\n\nTemperatureC：表示摄氏温度。\n\n\nTemperatureF：表示华氏温度，通过摄氏温度计算得出。\n\n\nSummary：表示天气总结，可以为空（string?表示可空类型）。\n\n\n3. WeatherForecastController.cs\n这个文件定义了一个控制器类，处理与天气预报相关的HTTP请求。\nusing Microsoft.AspNetCore.Mvc;\n\n\nusing语句：导入命名空间，包含Microsoft.AspNetCore.Mvc用于控制器相关功能。\n\n\nnamespace MyWebApiProject.Controllers&#123;    [ApiController]    [Route(&quot;[controller]&quot;)]    public class WeatherForecastController : ControllerBase    &#123;        private static readonly string[] Summaries = new[]        &#123;            &quot;Freezing&quot;, &quot;Bracing&quot;, &quot;Chilly&quot;, &quot;Cool&quot;, &quot;Mild&quot;, &quot;Warm&quot;, &quot;Balmy&quot;, &quot;Hot&quot;, &quot;Sweltering&quot;, &quot;Scorching&quot;        &#125;;        private readonly ILogger&lt;WeatherForecastController&gt; _logger;        public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger)        &#123;            _logger = logger;        &#125;        [HttpGet]        public IEnumerable&lt;WeatherForecast&gt; Get()        &#123;            var rng = new Random();            return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast            &#123;                Date = DateTime.Now.AddDays(index),                TemperatureC = rng.Next(-20, 55),                Summary = Summaries[rng.Next(Summaries.Length)]            &#125;)            .ToArray();        &#125;    &#125;&#125;\n详细解析：\n\n\n[ApiController]\n\n标记该类为API控制器，启用一些自动化功能，如模型验证和路由推断。\n\n\n\n[Route(&quot;[controller]&quot;)]\n\n定义控制器的路由模板。[controller]占位符会被控制器名称替换（去掉“Controller”后缀）。\n\n\n\n控制器类：\n public class WeatherForecastController : ControllerBase\n\nWeatherForecastController：控制器类，继承自ControllerBase。\nControllerBase：提供访问控制器功能的基类，不包含视图支持。\n\n\n\nSummaries字段：\n private static readonly string[] Summaries = new[]\n\n定义了一个静态只读数组，包含各种天气总结描述。\n\n\n\n构造函数：\n public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger)\n\n依赖注入ILogger&lt;WeatherForecastController&gt;实例，用于日志记录。\n\n\n\nGet方法：\n [HttpGet]public IEnumerable&lt;WeatherForecast&gt; Get()\n\n[HttpGet]：标记该方法处理HTTP GET请求。\nGet方法返回一个IEnumerable&lt;WeatherForecast&gt;，生成并返回5天的天气预报数据。\n\n var rng = new Random();return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast&#123;    Date = DateTime.Now.AddDays(index),    TemperatureC = rng.Next(-20, 55),    Summary = Summaries[rng.Next(Summaries.Length)]&#125;).ToArray();\n\n\n创建一个随机数生成器。\n\n\n使用Enumerable.Range生成1到5的整数序列。\n\n\n使用Select方法将每个整数转换为一个WeatherForecast对象。\n\n\n生成日期为当前日期加上序列中的天数。\n\n\n生成随机的摄氏温度和天气总结。\n\n\n将结果转换为数组并返回。\n\n\n\n\n设计代码结构的建议\n在ASP.NET Core Web API项目中，将代码分为模型层、控制器层、服务层和数据访问层有助于组织代码，使其更易于维护和扩展。以下是各个层的详细描述以及它们存放的代码类型：\n1. 模型层（Models）\n模型层存放数据结构和业务对象，这些对象通常反映了系统的核心业务实体。\n\n\n数据模型：表示数据的结构，如数据库表的实体。\n\n\n数据传输对象（DTO）：用于在客户端和服务器之间传输数据。\n\n\n视图模型：用于将数据从控制器传递到视图（在API中较少使用）。\n\n\n示例：\n// 文件路径：Models/WeatherForecast.cspublic class WeatherForecast&#123;    public DateTime Date &#123; get; set; &#125;    public int TemperatureC &#123; get; set; &#125;    public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);    public string? Summary &#123; get; set; &#125;&#125;\n2. 控制器层（Controllers）\n控制器层包含控制器类，这些类处理HTTP请求并返回响应。控制器通常使用服务层来处理业务逻辑。\n\n\n控制器：处理HTTP请求，调用服务层，并返回响应。\n\n\n属性和方法：处理特定的HTTP请求（如GET、POST、PUT、DELETE）。\n\n\n示例：\n// 文件路径：Controllers/WeatherForecastController.csusing Microsoft.AspNetCore.Mvc;using MyWebApiProject.Services;namespace MyWebApiProject.Controllers&#123;    [ApiController]    [Route(&quot;[controller]&quot;)]    public class WeatherForecastController : ControllerBase    &#123;        private readonly IWeatherForecastService _weatherForecastService;        public WeatherForecastController(IWeatherForecastService weatherForecastService)        &#123;            _weatherForecastService = weatherForecastService;        &#125;        [HttpGet]        public IEnumerable&lt;WeatherForecast&gt; Get()        &#123;            return _weatherForecastService.GetWeatherForecasts();        &#125;    &#125;&#125;\n3. 服务层（Services）\n服务层包含业务逻辑和操作，这些逻辑通常涉及多个数据模型或需要复杂的业务规则。服务层从数据访问层获取数据并进行处理。\n\n\n服务接口：定义服务的合同。\n\n\n服务实现：实现服务接口，包含具体的业务逻辑。\n\n\n示例：\n// 文件路径：Services/IWeatherForecastService.csusing MyWebApiProject.Models;public interface IWeatherForecastService&#123;    IEnumerable&lt;WeatherForecast&gt; GetWeatherForecasts();&#125;// 文件路径：Services/WeatherForecastService.csusing MyWebApiProject.Models;using MyWebApiProject.Data;public class WeatherForecastService : IWeatherForecastService&#123;    private readonly IWeatherForecastRepository _repository;    public WeatherForecastService(IWeatherForecastRepository repository)    &#123;        _repository = repository;    &#125;    public IEnumerable&lt;WeatherForecast&gt; GetWeatherForecasts()    &#123;        return _repository.GetWeatherForecasts();    &#125;&#125;\n4. 数据访问层（Data Access Layer, DAL）\n数据访问层处理与数据库的交互，负责从数据库中检索和存储数据。\n\n\n仓储接口：定义数据访问的合同。\n\n\n仓储实现：实现仓储接口，包含具体的数据访问逻辑。\n\n\n数据上下文：表示数据库连接和操作。\n\n\n示例：\n// 文件路径：Data/IWeatherForecastRepository.csusing MyWebApiProject.Models;public interface IWeatherForecastRepository&#123;    IEnumerable&lt;WeatherForecast&gt; GetWeatherForecasts();&#125;// 文件路径：Data/WeatherForecastRepository.csusing MyWebApiProject.Models;using System.Collections.Generic;public class WeatherForecastRepository : IWeatherForecastRepository&#123;    public IEnumerable&lt;WeatherForecast&gt; GetWeatherForecasts()    &#123;        // 这里可以连接数据库并获取数据        var rng = new Random();        return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast        &#123;            Date = DateTime.Now.AddDays(index),            TemperatureC = rng.Next(-20, 55),            Summary = Summaries[rng.Next(Summaries.Length)]        &#125;)        .ToArray();    &#125;    private static readonly string[] Summaries = new[]    &#123;        &quot;Freezing&quot;, &quot;Bracing&quot;, &quot;Chilly&quot;, &quot;Cool&quot;, &quot;Mild&quot;, &quot;Warm&quot;, &quot;Balmy&quot;, &quot;Hot&quot;, &quot;Sweltering&quot;, &quot;Scorching&quot;    &#125;;&#125;\n代码结构设计建议\n以下是一个示例项目的目录结构，以帮助组织各个层的代码：\nMyWebApiProject│├── Controllers│   └── WeatherForecastController.cs│├── Models│   └── WeatherForecast.cs│├── Services│   ├── IWeatherForecastService.cs│   └── WeatherForecastService.cs│├── Data│   ├── IWeatherForecastRepository.cs│   └── WeatherForecastRepository.cs│├── Program.cs├── Startup.cs (如果使用Startup类进行配置)├── appsettings.json│└── MyWebApiProject.csproj\n各层的实现原理\n\n\n模型层：定义应用程序的数据结构，表示业务实体和数据传输对象。\n\n\n控制器层：处理HTTP请求，通过调用服务层获取或处理数据，然后返回HTTP响应。\n\n\n服务层：包含业务逻辑，处理复杂的操作和业务规则。通过调用数据访问层获取和存储数据。\n\n\n数据访问层：与数据库或其他数据源交互，执行CRUD（创建、读取、更新、删除）操作，返回数据给服务层。\n\n\n通过这种分层结构，可以使代码更加模块化、易于维护和测试，同时清晰地分离了各个部分的职责。\n","categories":["编程"],"tags":["C#"]},{"title":"MySQL 基础指令","url":"/2024/06/12/db_note/MySQL-%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/","content":"\n介绍了MySQL一些基础指令,增删改查\n\n\nMySQL\n准备工作\n\n\n添加环境变量\n\n\n初始化MySQL\nmysqld --initialize-insecure\n该命令在安全性方面存在缺陷，主要用于开发和测试环境\n\n\n注册MySQL服务\nmysqld -install\n\n\n启动/停止 MySQL服务\nnet start mysqlnet stop mysql\n\n\n修改默认账户密码\nmysqladmin -u root password xxxx\n\n\n登录MySQL\nmysql -uroot -pxxxx [-h数据库服务器IP地址 -P端口号]\n\n\n卸载MySQL\nnet stop mysqlmysqld -remove mysql\n\n\nSQL分类\n\n\nDDL:Data Definition Language      定义数据库对象\n\n\nDML :Data Manipulation Language   操作数据，进行增删改\n\n\nDQL:Data Query Language                  查询数据库中的记录\n\n\nDCL:Data Control Language                创建数据库的用户，控制访问权限\n\n\n基础语法\n\n以分号结尾，不区分大小写\n\nDDL\n\n\n查询数据库\n\n\nshow databases;\n\n\n创建数据库\n\n\ncreate database filename;create database if not exists filename; #如果不存在名为filename的数据库就进行创建\n\n\n切换数据库\n\n\nuse filename;\n\n\n查看当前正在使用的数据库\n\n\nselect database();\n\n\n删除数据库\n\n\ndrop database filename;drop database if exists filename;\n表操作\ncreate table 表名(\t\t字段1 字段类型 [约束] [comment 字段1注解],    \t字段2 字段类型 [约束] [comment 字段2注解])[comment 表注解];\n\n\n\n约束\n描述\n关键字\n\n\n\n\n非空约束\n限制该字段值不能为null\nnot null\n\n\n唯一约束\n保证字段的所有数据都是唯一的\nunique\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nprimary key    （auto_increment自增）\n\n\n默认约束\n保存数据时，如果未指定该字段值，则采用默认值\ndefault\n\n\n外键约束\n让两张表的数据建立连接，保证数据的一致性和完整性\nforeign key\n\n\n\ncreat table tb_user(\tid int primary key auto_increment comment &#x27;ID，唯一标识&#x27;,    username varchar(20) not null unique comment &#x27;用户名&#x27;,    name varchar(10) not null comment &#x27;姓名&#x27;,    age int comment &#x27;年龄&#x27;,    gender char(1) default &#x27;男&#x27; comment &#x27;性别&#x27;)comment &#x27;用户表&#x27;\n\n\n查询\n\n\n-- 查看当下数据库的表show tables;-- 查看指定表结构desc tablename;--  查看数据库的建表语句show create table tablename;\n\n\n修改\n\n\n-- 为表example 添加字段 qq varchar(11)alter table example add qq varchar(11) comment &#x27;QQ&#x27;;-- 修改example 字段类型 qq varchar(13)alter table example modify qq varchar(13) comment &#x27;QQ&#x27;;-- 修改example 字段名qq为qq_numalter table example change qq qq_num varchar(13) comment &#x27;QQ&#x27;;-- 删除qq_num字段alter table example drop column qq_num;-- 将example 表名修改为hellorename table example to hello;\n\n\n删除\n\n\n-- 删除 example 表drop table if exists eample;\nDML\n\n\ninsert语句\n\n\n--  为 example 表的 username，name，gender 字段插入值insert into example(username, name, gender) values (&#x27;tinali&#x27;,&#x27; 提纳里&#x27;,1);-- 为 example 表的 所有字段 插入值insert into example values(null,null,null,&#x27;tinali&#x27;,&#x27; 提纳里&#x27;,1);-- 批量为 example 表的 username，name，gender字段插入数据insert into example(username, name, gender) values (&#x27;tinali&#x27;,&#x27;提纳里&#x27;,1),(&#x27;审判官&#x27;,&#x27;那维莱特&#x27;,1);\n\n\nupdate语句\n\n\n-- 将 example 中ID为1的 name 字段 更新为 张三,username 字段更新为 helloupdate example set name = &#x27;张三&#x27;, username = &#x27;hello&#x27; where id = 1;-- 将example 中所有 gender 字段改为 1update example set gender = 1;\n\n\ndelete语句\n\n\ndelete from 表名 [where 条件];-- 删除 example 中ID为1的信息delete from example where id = 1;-- 删除表中所有信息delete from example;\nDQL\n\n\n基本查询\n\n\n-- 查询特定字段 name，entrydate 并返回select name,entrydate from example;-- 查询返回所有字段 (通配符)select * from example;-- 查询特定字段 name，entrydate 并起别名select name as 姓名,entrydate as 入职日期 from example;-- 查询job字段的记录（不重复）select distinct job from example;\n\n\n条件查询（where）\n\n\n-- select 字段列表 from 表名 where 条件列表-- 查询 name 为 三子曰 的记录select * from example where name = &#x27;三子曰&#x27;;-- 查询 id 小于等于5 的记录select * from example where id &lt;= 5;-- 查询 job 为空值的记录select * from example where job is null;-- 查询 job 非空值的记录select * from example where job is not null;-- 查询 password 不是 123456select * from example where password != &#x27;123456&#x27;;-- 查询 age 在 20 到 30 之间的记录select * from example where age &gt;= 20 &amp;&amp; age &lt;= 30;-- 查询id 为1，2，3的记录select * from example where id in (1,2,3)l;-- 查询 name 为两个字的记录 （两条下划线）select * from example where name like &#x27;__&#x27;;-- 查询 name 字段中第一个字为 张 的记录select * from example where name like &#x27;张%&#x27;_可替代一个字符  %可替代随机数目的字符\n\n\n分组查询（groud by）\n\n聚合函数 count max min avg sum\n\n\n\n-- select 聚合函数 from 表名 -- 统计 id 字段数的数目select count(id) from example;\n-- select 字段列表 from 表名 [where 条件] group by 分组字段名[having 分组后的过滤的条件];-- 根据 gender 分组，统计男女员工的数量select gender,count(*) from example group by gender;-- 查询 age 在30（包含）以前的员工，并对job进行分组，获得数量大于等于2的job数据select job,count(*) from example where age &lt;= 30 group by job having count(*) &gt;= 2;\n\n\n排序查询（order by）\n\n\n--select 字段列表 from 表名 [where 条件列表][group by 分组字段] order by 字段1 排序方法1--根据年龄进行升序排序  (降序desc)select * from example order by age asc;\n\n\n分页查询（limit）\n\n\n-- select 字段列表 from 表名 limit 起始索引，查询记录数;-- 从 起始索引为0，开始查询，每夜展示五条数据select * from example limit 0,5;-- 查询第一页数据，每页展示五条数据select * from example limit 0,5;-- 查询第二，每页展示五条数据select * from example limit 5,5;\n","categories":["编程"],"tags":["MySQL"]},{"title":"身份证号码简易识别(opencv + Qt)","url":"/2024/05/30/school_assignments/%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81%E7%AE%80%E6%98%93%E8%AF%86%E5%88%AB-opencv-Qt/","content":"记录了一下项目制作过程中 opencv基本API的使用,以及一些基本概念源码可至GitHub查看\n \n身份证信息识别\n1. 图片的读取 显示\n\nimread()读取图像，imread包含两个参数：imread(图像路径， 图像形式)；\nnamedWindow() 用来新建一个显示窗口,用来显示图像,包含两个参数：namedWindow(窗口名称， 窗口形式)\n**imshow()**用于显示图像,包含两个参数：imshow(窗口名称，图像名称)\n\n图像形式有三种\n\n\n加载彩色图片 (默认加载形式)\n\n\nimread(图像路径， IMREAD_COLOR)；//或者imread(图像路径， 1)；\n\n\n加载灰度模式图像\n\n\nimread(图像路径， IMREAD_GRAYSCALE)；//或者imread(图像路径， 0)；\n\n\n加载图像,包括alpha通道\n\n\nimread(图像路径，IMREAD_UNCHANGED)；//或者imread(图像路径， -1)；\n窗口形式\n\n\n显示的图像大小不能改变（默认形式）\nnamedWindow(窗口名称， WINDOW_AUTOSIZE)     1\n\n\n图像大小能够调节\nnamedWindow(窗口名称， WINDOW_NORMAL)      0\n\n\n示例代码\n#include&lt;opencv2/opencv.hpp&gt;#include&lt;iostream&gt;using namespace cv;using namespace std;int main()&#123;\tMat image;   //创建一个空图像image\timage = imread(&quot;D://work//c++//Imageprocessing1//企鹅.jpg&quot;);  //读取文件夹中的图像\t//检测图像是否加载成功\tif (image.empty())  //检测image有无数据，无数据 image.empty()返回 真\t&#123;\t\tcout &lt;&lt; &quot;Could not open or find the image&quot; &lt;&lt; endl;\t\treturn -1;\t&#125;\tnamedWindow(&quot;IMAGE&quot;);  //创建显示窗口，不加这行代码，也能显示，默认窗口大小不能改变\timshow(&quot;IMAGE&quot;, image);  //在窗口显示图像\timwrite(&quot;1.png&quot;, image); //保存图像为png格式，文件名称为1\twaitKey(0);  //暂停，保持图像显示，等待按键结束\treturn 0;&#125;\n2. qt中的string转化为opencv中的string\n\n先调用 toLocal8Bit() 方法将 fileName 转换为本地8位编码的 QByteArray，然后再调用 data() 方法获取该 QByteArray 中存储的 C 风格字符串的指针\n\nvoid ID_card_recognition::read_image(const QString&amp; fileName)&#123;    QString tmpPath = fileName.toLocal8Bit().data();//将 fileName 转换为本地8位编码的 C 风格字符串    Mat image;   //创建一个空图像image    image = imread(tmpPath.toStdString(), IMREAD_COLOR);  //读取文件夹中的图像&#125;\n3. 二值化处理\n\n二值化处理（Binarization）是一种图像处理技术，它将图像中的像素值根据特定的阈值转化为两种值（通常是0和255），从而简化图像的数据表示。\n通常需要先将图片转换为灰度图像再进行二值化处理\n\n\n\nvoid threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type);\n\n\n\nthreshold() 函数是 OpenCV 中用于图像二值化的函数，它将输入图像的像素值根据指定的阈值进行分割，生成一个二值化图像\n\n\n\ncv::THRESH_BINARY：如果源图像像素值大于阈值，则输出图像的对应像素值设置为maxval，否则设置为0。\n\n\ncv::THRESH_BINARY_INV：与THRESH_BINARY相反，如果源图像像素值大于阈值，则输出图像的对应像素值设置为0，否则设置为maxval。\n\n\ncv::THRESH_TRUNC：如果源图像像素值大于阈值，则输出图像的对应像素值设置为阈值thresh，否则保持源图像的像素值不变。\n\n\ncv::THRESH_TOZERO：如果源图像像素值大于阈值，则输出图像的对应像素值保持不变，否则设置为0。\n\n\ncv::THRESH_TOZERO_INV：与THRESH_TOZERO相反，如果源图像像素值大于阈值，则输出图像的对应像素值设置为0，否则保持源图像的像素值不变。\n\n\ncv::THRESH_MASK：这是一个掩码值，用于与上述其他值进行按位或操作，以保持旧的OpenCV兼容性。\n\n\ncv::THRESH_OTSU：在使用THRESH_BINARY或THRESH_BINARY_INV阈值类型时，这个标志可以自动选择最优的阈值。它会计算源图像的直方图，并使用大津二值化方法来找到将图像分为两个类别的最佳阈值。\n\n\ncv::THRESH_TRIANGLE：这是另一个自动选择阈值的标志，它使用三角形方法来找到最优阈值，这种方法通常比大津方法更快，但在某些情况下可能不如大津方法准确。\n\n\n#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main() &#123;    // 读取灰度图像    Mat image = imread(&quot;image.jpg&quot;, IMREAD_GRAYSCALE);    if (image.empty()) &#123;        cout &lt;&lt; &quot;Could not open or find the image&quot; &lt;&lt; endl;        return -1;    &#125;        // 设置阈值和最大值    int thresh_value = 0;    int max_value = 255;    // 应用二值化    Mat binary_image; \tthreshold(image, binary_image, thresh_val, max_value, THRESH_BINARY | THRESH_OTSU);    /*THRESH_BINARY：大于阈值的像素赋值为 maxval，小于等于阈值的像素赋值为 0。    THRESH_OTSU可以实现 Otsu&#x27;s 二值化方法，即自动选择最优的阈值，而无需手动指定阈值    二者通常结合使用  使用Otsu&#x27;s时thresh 参数可以设置为 0，因为该值不会被实际使用*/    // 显示结果    imshow(&quot;Binary Image&quot;, binary_image);    waitKey(0);    destroyAllWindows();    return 0;&#125;\n4. 双边滤波\n\n双边滤波（Bilateral Filter）是一种非线性滤波技术，它能够在保持边缘清晰的同时有效地去除图像中的噪声\n\nvoid bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType = BORDER_DEFAULT);\n\n\nd：滤波器的直径。如果为 -1，则根据 sigmaSpace 自动计算。\n\n\nsigmaColor：颜色空间的标准差，较大的值表示颜色空间中更大的像素距离将相互混合。\n\n\nsigmaSpace：空间域的标准差，较大的值表示在空间域内的像素距离将相互混合。\n\n\nborderType：用于处理边界的类型，默认为 BORDER_DEFAULT。\n\n\n5.  查找轮廓\n\n轮廓可以看作是将具有相同颜色或灰度值的所有连续点（沿着边界）连接起来的曲线\n\n//函数原型void cv::findContours(    InputOutputArray image,    OutputArrayOfArrays contours,    OutputArray hierarchy,    int mode,    int method,    Point offset = Point());//在黑色背景中寻找白色轮廓\n\n\nimage：输入图像（8位单通道图像），也是输出图像。\n\n图像必须是二值化图像（通常通过 cv::threshold 或 cv::Canny 等方法预处理）。\n该函数会修改输入图像，建议在调用该函数之前对图像进行备份。\n\n\n\ncontours：输出参数，用于存储检测到的轮廓。\n\n轮廓存储为点的向量的向量，每个轮廓是一个 std::vector&lt;cv::Point&gt; 类型的对象。\n\n\n\nhierarchy：输出参数，用于存储每个轮廓的层次结构信息。\n\n这是一个 std::vector&lt;cv::Vec4i&gt; 类型的向量。\nhierarchy[i][0] 表示后一个轮廓的索引。\nhierarchy[i][1] 表示前一个轮廓的索引。\nhierarchy[i][2] 表示父轮廓的索引。\nhierarchy[i][3] 表示第一个子轮廓的索引。\n\n\n\nmode：轮廓检索模式，决定轮廓的提取方式和层次结构。\n\ncv::RETR_EXTERNAL：只检索最外层的轮廓。\ncv::RETR_LIST：检索所有轮廓，但不建立层次结构。\ncv::RETR_CCOMP：检索所有轮廓并将它们组织成两级层次结构。\ncv::RETR_TREE：检索所有轮廓并重建嵌套轮廓的完整层次结构。\n\n\n\nmethod：轮廓近似方法，决定如何存储轮廓点。\n\ncv::CHAIN_APPROX_NONE：存储所有轮廓点。\ncv::CHAIN_APPROX_SIMPLE：压缩水平、垂直和对角线段，只保留它们的端点。\ncv::CHAIN_APPROX_TC89_L1 和 cv::CHAIN_APPROX_TC89_KCOS：使用 Teh-Chin 链近似算法。\n\n\n\noffset（可选）：可选参数，用于对输出的轮廓点坐标进行偏移，默认为 (0, 0)。\n\n\n6. 绘制轮廓\n//函数原型void cv::drawContours(    InputOutputArray image,    InputArrayOfArrays contours,    int contourIdx,    const Scalar&amp; color,    int thickness = 1,    int lineType = LINE_8,    InputArray hierarchy = noArray(),    int maxLevel = INT_MAX,    Point offset = Point());\n\n\nimage：输入输出参数，用于绘制轮廓的图像。\n\n类型为 cv::InputOutputArray，通常为 cv::Mat 类型。\n这是一个修改后的图像，轮廓会被绘制在该图像上。\n\n\n\ncontours：输入参数，表示轮廓的集合。\n\n类型为 cv::InputArrayOfArrays，通常是 std::vector&lt;std::vector&lt;cv::Point&gt;&gt; 类型。\n每个轮廓都是一个点的集合，表示图像中的一个连通区域。\n\n\n\ncontourIdx：输入参数，指定绘制哪个轮廓的索引。\n\n如果为负值（例如 -1），则绘制所有轮廓。\n\n\n\ncolor：输入参数，指定绘制轮廓的颜色。\n\n类型为 cv::Scalar，例如 cv::Scalar(0, 255, 0) 表示绿色。\n\n\n\nthickness（可选）：输入参数，指定绘制轮廓的线条粗细。\n\n默认值为 1。\n如果值为 FILLED 或负值，则填充整个轮廓。\n\n\n\nlineType（可选）：输入参数，指定线条的类型。\n\n默认值为 cv::LINE_8，表示 8-连接线。\n可以为 cv::LINE_4（4-连接线）或 cv::LINE_AA（抗锯齿线）。\n\n\n\nhierarchy（可选）：输入参数，指定轮廓的层次结构。\n\n类型为 cv::InputArray，通常是 std::vector&lt;cv::Vec4i&gt; 类型。\n如果不需要层次结构，可以传递 cv::noArray()。\n\n\n\nmaxLevel（可选）：输入参数，指定绘制轮廓的最大层次。\n\n默认值为 INT_MAX，表示绘制所有层次的轮廓。\n例如，如果设置为 0，则只绘制最外层的轮廓。\n\n\n\noffset（可选）：输入参数，指定绘制轮廓时的偏移量。\n\n类型为 cv::Point，默认值为 cv::Point(0, 0)。\n\n\n\n7 绘制轮廓(二)\n7.1 cv::boundingRect 函数\n\n用于计算给定点集或轮廓的最小边界矩形。这个矩形是完全包含输入轮廓的最小矩形，并且其边与坐标轴对齐。\n\ncv::Rect cv::boundingRect(InputArray points);\n\n\npoints：输入的点集，可以是一个轮廓（如 std::vector&lt;cv::Point&gt;）或者是 cv::Mat 类型的点集。\n\n\n返回值\n\n\n返回一个 cv::Rect 对象，表示包含所有输入点的最小边界矩形。\n\n\n7.2 cv::rectangle 函数\n\n用于在图像上绘制矩形。可以根据需要设置矩形的位置、大小、颜色和线条厚度等属性。\n\n//函数原型void cv::rectangle(    InputOutputArray img,    Point pt1,    Point pt2,    const Scalar&amp; color,    int thickness = 1,    int lineType = LINE_8,    int shift = 0);或者void cv::rectangle(    InputOutputArray img,    const Rect&amp; rec,    const Scalar&amp; color,    int thickness = 1,    int lineType = LINE_8,    int shift = 0);\n\n\nimg：输入输出图像，用于绘制矩形的图像。\n\n\npt1：矩形的一个顶点。\n\n\npt2：矩形的对角顶点。\n\n\nrec：表示矩形的 cv::Rect 对象。\n\n\ncolor：矩形的颜色，使用 cv::Scalar 定义，例如 cv::Scalar(0, 255, 0) 表示绿色。\n\n\nthickness：线条厚度。默认值为 1。如果值为负数（如 FILLED），则填充矩形。\n\n\nlineType：线条类型，可以是 cv::LINE_8、cv::LINE_4 或 cv::LINE_AA。\n\n\nshift：坐标点的小数点位数，默认值为 0。\n\n\n示例代码\nfor (size_t i = 0; i &lt; contours.size(); i++) &#123;    // 计算轮廓的最小边界矩形    cv::Rect boundingRect = cv::boundingRect(contours[i]);    // 在图像上绘制边界矩形    cv::rectangle(image, boundingRect, cv::Scalar(0, 255, 0), 2);    // 计算并标记矩形的中心点    cv::Point center = (boundingRect.tl() + boundingRect.br()) * 0.5;    cv::circle(image, center, 5, cv::Scalar(255, 0, 0), -1);&#125;\n8. 腐蚀 与 膨胀\n\n\n9. 开操作 闭操作\n开操作先腐蚀后膨胀的操作称之为开操作。主要用于消除小的物体、在纤细点处分离物体、平滑较大物体的边界，同时并不明显改变其面积。此外，开操作还可以用于提取水平或竖直的线条\n闭操作先膨胀后腐蚀 主要用于填充物体内的小空洞、连接邻近物体、平滑其边界，同时并不明显改变其面积 可以用于填充小的封闭区域\n#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;int main() &#123;    // 读取图像    cv::Mat image = cv::imread(&quot;path_to_your_image.jpg&quot;, cv::IMREAD_COLOR);    if (image.empty()) &#123;        std::cerr &lt;&lt; &quot;无法读取图像&quot; &lt;&lt; std::endl;        return -1;    &#125;    // 显示原始图像    cv::imshow(&quot;原始图像&quot;, image);    // 定义结构元素，用于开操作和闭操作    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));\t/*kernel2 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (10, 10)) # 椭圆结构\tkernel3 = cv2.getStructuringElement(cv2.MORPH_CROSS, (10, 10)) # 十字结构*/    // 执行开操作    cv::Mat open_result;    cv::morphologyEx(image, open_result, cv::MORPH_OPEN, kernel);    // 显示开操作结果    cv::imshow(&quot;开操作结果&quot;, open_result);    // 执行闭操作    cv::Mat close_result;    cv::morphologyEx(image, close_result, cv::MORPH_CLOSE, kernel);    // 显示闭操作结果    cv::imshow(&quot;闭操作结果&quot;, close_result);    // 等待按键后退出    cv::waitKey(0);    return 0;&#125;\n10. 模板匹配\nvoid matchTemplate(InputArray image, InputArray templ, OutputArray result, int method);\n\n\nimage：输入图像，必须是 8 位或 32 位浮点数。\n\n\ntemplate：模板图像，必须是相同类型和深度的大小小于或等于输入图像的图像。\n\n\nresult：匹配结果图像，是一个单通道 32 位浮点数。每个像素表示该区域与模板的匹配程度。\n\n\nmethod指定的匹配方法，可以是以下之一：\n\nTM_SQDIFF：平方差匹配法，计算模板与图像之间的平方差，值越小表示匹配度越高。\nTM_SQDIFF_NORMED：归一化平方差匹配法，计算归一化的平方差，值越小表示匹配度越高。\nTM_CCORR：相关性匹配法，计算模板与图像之间的相关性，值越大表示匹配度越高。\nTM_CCORR_NORMED：归一化相关性匹配法，计算归一化的相关性，值越大表示匹配度越高。\nTM_CCOEFF：相关系数匹配法，计算模板与图像之间的相关系数，值越大表示匹配度越高。\nTM_CCOEFF_NORMED：归一化相关系数匹配法，计算归一化的相关系数，值越大表示匹配度越高。\n\n\n\nvoid minMaxLoc(InputArray src, double minVal, double maxVal = 0, Point* minLoc = 0, Point* maxLoc = 0, InputArray mask = noArray());**\n\n用于在给定的矩阵中找到最小值和最大值，并返回它们的位置。这个函数在图像处理中非常有用，尤其是在需要找到图像中的最亮或最暗点、或者在模板匹配中找到最佳匹配位置时\n\n\n\nsrc：输入的单通道数组。\n\n\nminVal：返回最小值的指针（如果不需要，则可以设置为 NULL）。\n\n\nmaxVal：返回最大值的指针（如果不需要，则可以设置为 NULL）。\n\n\nminLoc：返回最小值位置的指针（如果不需要，则可以设置为 NULL）。\n\n\nmaxLoc：返回最大值位置的指针（如果不需要，则可以设置为 NULL）。\n\n\nmask：用于选择数组元素的感兴趣区域，如果不需要，则使用 noArray()。\n\n\nvoid resize(InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR);\n\n缩放图片\n\n\n\nsrc：输入图像，可以是任意通道数的 Mat 对象。\n\n\ndst：输出图像，大小为 dsize，或者与 src 相同类型和大小的 Mat 对象。\n\n\ndsize：输出图像的大小。如果这个参数为 0，则它由 fx 和 fy 参数决定。\n\n\nfx：水平方向的缩放比例。如果这个参数为 0，则它由 dsize 参数决定。\n\n\nfy：垂直方向的缩放比例。如果这个参数为 0，则它由 dsize 参数决定。\n\n\ninterpolation插值方法，用于在缩放时计算新像素值。可选的插值方法包括：\n\nINTER_NEAREST：最近邻插值。\nINTER_LINEAR：双线性插值（默认值）。\nINTER_AREA：使用像素区域关系重采样。当图像缩小时，这种方法可以避免波纹出现，通常用于图像缩放。\nINTER_CUBIC：三次样条插值。\nINTER_LANCZOS4：Lanczos 插值，超过 8x8 像素邻域的采样。\n\n\n\nif (ID_number.size() != 18) return false;for (int i = 0; i &lt; 18; i++)&#123;\tMat roi = ID_number[i].mat;\tresize(roi, roi, Size(30, 40), 0, 0, INTER_AREA);\tMat gray_image;\tcvtColor(roi, gray_image, cv::COLOR_BGR2GRAY);\tMat binary_image;\tthreshold (gray_image, binary_image, 0, 255, THRESH_BINARY_INV | THRESH_OTSU);\tint maxIndex = 0;\tdouble Max = 0.0;\tfor (int j = 0; j &lt; 11; j++)\t&#123;\t\tMat template_num = templates_cards[j].mat;\t\tresize(template_num, template_num, Size(30, 40), 0, 0, INTER_AREA);\t\tMat gray_template_num;\t\tcvtColor(template_num, gray_template_num, cv::COLOR_BGR2GRAY);\t\tMat binary_template_num;\t\tthreshold(gray_template_num, binary_template_num, 0, 255, THRESH_BINARY_INV | THRESH_OTSU);\t\tMat result;\t\tmatchTemplate(binary_image, binary_template_num, result, TM_CCOEFF_NORMED);\t\tdouble minVal, maxVal;\t\tPoint minLoc, maxLoc;\t\tminMaxLoc(result, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc);\t\tif (maxVal &gt; Max)\t\t&#123;\t\t\tMax = maxVal;\t\t\tmaxIndex = j;\t\t&#125;\t&#125;\tresult[i] = maxIndex;&#125;\n","categories":["编程"],"tags":["C++","Qt","OpenCV"]},{"title":"订餐程序中qt的使用(qt基础用法)","url":"/2024/05/18/school_assignments/%E8%AE%A2%E9%A4%90%E7%A8%8B%E5%BA%8F%E4%B8%ADqt%E7%9A%84%E4%BD%BF%E7%94%A8-qt%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/","content":"\n记录了一下项目制作过程中 Qt基本API的使用,以及一些基本概念源码可至GitHub查看\n\n\nQt基础知识\nQt中的窗口类\n1.1 基础窗口类\n\n常用的窗口类是图中下面三个，在创建Qt窗口时，需要让自己的窗口类继承上述三个窗口类中的一个\n1.2 窗口的显示方式\n模态（modal）窗口：窗口弹出后，没关闭之前，不可以对同一应用程序的其他窗口进行操作；非模态（modeless）窗口：窗口弹出后，没关闭之前，可以对同一应用程序的其他窗口进行操作\n1.3 模态窗口的实现方法\n\n窗口的show()函数显示的类型是非模态的，有几种方法可以将窗口设为模态，如下\n\n1.3.1 QDialog对话框\n方法一：exec()\nQDialog dlg(this);dlg.exec();//exec是execute（执行）的缩写，当调用exec()函数时，并不会立即返回，只用当对话框关闭才会返回，因此，只有关闭对话框才会执行后续的代码\n方法二：setModal()\nQDialog dlg(this);dlg.setModal(true);\t\t//相当于dlg.setWindowModality(Qt::ApplicationModal);dlg.show();\n方法三：setWindowModality()\nQDialog dlg(this);dlg.setWindowModality(Qt::ApplicationModal);dlg.show();\n\n==setWindowModality()==的参数设置要阻塞的窗口类型:\n\n\n\n枚举值\n值\n说明\n\n\n\n\nQt::NonModal\n0\n非模态，不阻塞任何窗口\n\n\nQt::WindowModal\n1\n半模态,窗口极模态,阻塞它的父窗口、所有的祖先窗口以及他们的子窗口\n\n\nQt::ApplicationModal\n2\n模态,应用程序级模态,阻塞应用程序所有的窗口\n\n\n\n\n常用类\n字符串类型\n\nC   ----&gt;   char*\nC++  ------&gt;   std::string\nQt   -------&gt;   QByteArray,QString\n\n相关函数,查阅qt中的帮助文档,在命令行中输入assistant\nQVariant类\n\n类似于C++中的模板\n可以对不同的数据类型进行包装,从而使用相同的函数对不同类型的数据进行处理\n\n2.2.1 对Qt中的标准类型进行处理\nHelloQt::HelloQt(QWidget *parent): QMainWindow(parent)&#123;    ui.setupUi(this);    int value = dataPlus(10,20);    QString str = dataPlus(&quot;hello&quot;,&quot;world&quot;).toString();&#125;//dataPlus()函数在HelloQt类中已经被声明QVariant HelloQt::dataPlus(QVariant a,QVariant b)&#123;    QVariant ret;    if(a.type() == QVariant::int &amp;&amp; b.type() == QVariant::int)  //或者使用QMetaType::Int        ret = QVariant(a.toInt() + b.toInt());    else if(a.type() == QVariant::String &amp;&amp; b.type() == QVariant::String)        ret.setValue(a.toString() + b.toString());    return ret;&#125;\n2.2.2 自定义类型\n\n若自定义了一个类型,则需要使用Qt中的宏进行声明\nQ_DECLARE_METATYPE(Type)\n\n第一步:定义类型,并注册\n//自定义类型class Animal&#123;public:    Animal()&#123;&#125;  //必须要有默认构造函数                //拷贝构造函数也必须有，不过没有深、浅拷贝时，用默认的即可    Animal(QString name):_name(name)&#123;&#125;    void show()    &#123;        qDebug()&lt;&lt;&quot;Animal show name is :&quot;&lt;&lt; _name &lt;&lt;endl;    &#125;private:    QString _name;&#125;;//自定义类型注册Q_DECLARE_METATYPE(Animal);\n第二步: 使用fromvalue()存储对象\nint main()&#123;    //QVariant vt(Animal(&quot;snake&quot;)); //不可以通过构造函数存自定义类型    QVariant vt;    //有以下两种方法可以，存自定义类型    vt = QVariant::fromValue(Animal(&quot;dog&quot;));    //①    vt.setValue(Animal(&quot;cat&quot;));                 //②    //如果能转换到Animal类型，就转换    if(vt.canConvert&lt;Animal&gt;())    &#123;        Animal animal = vt.value&lt;Animal&gt;();        animal.show();    &#125;    return 0;&#125;\nQPoint\n\nQPoint类封装了我们常用用到的坐标点 (x, y), 常用的 API如下\n\nvoid QPoint::setX(int x);void QPoint::setY(int y);int QPoint::x() const;int &amp;QPoint::rx();int QPoint::y() const;int &amp;QPoint::ry();//如果x和y坐标都为0则返回true，否则返回falsebool isNull() const//返回x()和y()的绝对值之和，传统上称为从原点到该点的向量的“曼哈顿长度”。//(p1-p2).manhattanLength();   int manhattanLength() const    //返回一个交换了x和y坐标的点:   QPoint&#123;1, 2&#125;.transposed() // &#123;2, 1&#125;  QPoint transposed() const        // 直接通过坐标对象进行算术运算: 加减乘除QPoint &amp;QPoint::operator*=(float factor);QPoint &amp;QPoint::operator*=(double factor);QPoint &amp;QPoint::operator*=(int factor);QPoint &amp;QPoint::operator+=(const QPoint &amp;point);QPoint &amp;QPoint::operator-=(const QPoint &amp;point);QPoint &amp;QPoint::operator/=(qreal divisor);\nQLine\n// 设置直线的起点坐标void QLine::setP1(const QPoint &amp;p1);// 设置直线的终点坐标void QLine::setP2(const QPoint &amp;p2);void QLine::setPoints(const QPoint &amp;p1, const QPoint &amp;p2);void QLine::setLine(int x1, int y1, int x2, int y2);QPoint QLine::p1() const;      // 返回直线的起始点坐标QPoint QLine::p2() const;      // 返回直线的终点坐标QPoint QLine::center() const;  // 返回值直线的中心点坐标, (p1() + p2()) / 2   int QLine::x1() const;     // 返回值直线起点的 x 坐标int QLine::y1() const;     // 返回值直线起点的 y 坐标int QLine::x2() const;     // 返回值直线终点的 x 坐标int QLine::y2() const;     // 返回值直线终点的 y 坐标int QLine::dx() const          //返回直线向量的水平分量  int QLine::dy() const          //返回直线向量的垂直分量  // 用给定的坐标点平移这条直线void QLine::translate(const QPoint &amp;offset);void QLine::translate(int dx, int dy);// 用给定的坐标点平移这条直线, 返回平移之后的坐标点(不会改变这条线的坐标)QLine QLine::translated(const QPoint &amp;offset) const;QLine QLine::translated(int dx, int dy) const;// 直线对象进行比较bool operator!=(const QLine &amp;line) const;bool operator==(const QLine &amp;line) const;\n2.5 QSize\n\n在QT中QSize类用来形容长度和宽度, 常用的API如下:\n\nvoid setWidth(int width)void setHeight(int height);​int width() const;      // 得到宽度int &amp;rwidth();          // 得到宽度的引用int height() const;     // 得到高度int &amp;rheight();         // 得到高度的引用​void transpose();           // 交换高度和宽度的值QSize transposed() const;   // 交换高度和宽度的值, 返回交换之后的尺寸信息​//返回一个大小，宽为当前大小与other的最小值，高为当前大小与other的最小值QSize boundedTo(const QSize&amp; oterSize)//返回一个大小，宽为当前大小与other的最大值，高为当前大小与other的最大值    QSize expandedTo(const QSize &amp;otherSize) const        /*根据指定的模式，按给定的宽度和高度缩放矩形:      如果mode为Qt::IgnoreAspectRatio，则大小设置为(width, height)。      如果mode为Qt::KeepAspectRatio，当前大小将在内部缩放到一个尽可能大的矩形(宽度，高度)，保持高宽比。      如果mode是Qt::KeepAspectRatioByExpanding，当前大小被缩放到一个矩形，尽可能小的外部(宽度，高度)，保持长宽比。  */void scale(int width, int height, Qt::AspectRatioMode mode)void scale(const QSize &amp;size, Qt::AspectRatioMode mode)QSize scaled(int width, int height, Qt::AspectRatioMode mode) constQSize scaled(const QSize &amp;s, Qt::AspectRatioMode mode) const    ​// 进行算法运算: 加减乘除QSize &amp;operator*=(qreal factor);QSize &amp;operator+=(const QSize &amp;size);QSize &amp;operator-=(const QSize &amp;size);QSize &amp;operator/=(qreal divisor);\n信号和槽\n3.1 信号(signal)\n\n\n信号本质是事件,如按钮点击,窗口刷新等\n\n\n信号以函数形式呈现\n\n\nQt中信号的发出者可能是某个实例化的类对象,对象内部可以进行相关事件的检测\n3.2 槽(slot)\n\n\n槽函数是一类特殊的功能函数,在编码过程中也可以作为类的普通成员函数来使用\n\n\n对发出来的信号进行处理\n\n\n槽函数的所有者也是某个类的实例对象\n3.3 connect函数\n\nconnect函数属于QObject类\n\n需要通过这个函数建立signal和slot二者之间的联系\nQMetaObject::Connection QObject::connect(const QObject *sender,const char *signal,                                         const QObject *receiver, [static] const char *method, Qt::ConnectionType type = Qt::AutoConnection)------------------------------------------------------------------------sender: 发送信号的对象。signal: 发送的信号的名称,说明发出了什么信号,以字符串形式表示。receiver: 接收信号的对象。method: 接收对象中用于响应信号的槽函数的名称，以字符串形式表示。type: 连接类型，决定了信号和槽的连接方式。默认为 Qt::AutoConnection。   \n例如，如果你有一个按钮（QPushButton），并且想要在按钮被点击时执行某些操作，你可以将按钮的 clicked() 信号连接到一个槽函数：\n#include&lt;QPushButton&gt;QPushButton *button = new QPushButton(&quot;Click me&quot;);MyObject *myObject = new MyObject;// 连接按钮的clicked信号到myObject的slotMethod槽函数QObject::connect(button, SIGNAL(clicked()), myObject, SLOT(slotMethod()));//当按钮被点击时，MyObject 的 slotMethod 方法将被调用。\n3.4 自定义信号和槽\n\n为了使自定义信号和槽正常工作，确保你的类继承自 QObject 并且在类的定义中添加Q_OBJECT 宏。同时，确保项目的 .pro 文件中添加了 QT += core，以确保 Qt 核心模块被正确链接\n\n\n\n自定义信号，通常信号只有声明没有实现\n\n\nclass MyClass : public QObject&#123;    Q_OBJECTsignals:    void mySignal(int value);&#125;;\n\n\n自定义槽：\n\n\n\n自定义槽是普通的成员函数，可以在信号发射时被调用。\n\nclass MyClass : public QObject&#123;    Q_OBJECTpublic slots:   //新版本中不可以省略不写    void mySlot(int value) &#123;        qDebug() &lt;&lt; &quot;Received value:&quot; &lt;&lt; value;    &#125;&#125;;\n\n\n触发自定义信号\n\n\n\n需在类中的某个函数中使用 emit 关键字,可加可不加,加了更规范\n\nvoid MyClass::someFunction() &#123;    // 触发信号    emit mySignal(42);&#125;//使用MyClass obj;obj.someFunction(); // 这将触发 mySignal，导致 mySlot 被调用。\n3.5 补充\n\n\n信号可以连接多个槽函数\n\n\n信号可以连接信号\n\n\n信号函数和槽函数的参数有一些要求：\n\n参数类型必须兼容：信号函数和槽函数的参数类型必须兼容，最好是相同的类型或可以自动转换的类型。如果参数类型不兼容，连接将无法建立，并且编译器将会报错。\n参数数量必须匹配：信号函数和槽函数的参数数量必须匹配。如果信号函数有参数而槽函数没有，或者槽函数有参数而信号函数没有，连接仍然是有效的。但是，如果参数数量不匹配，连接将无法建立。\n参数的顺序和类型必须一致：参数的顺序和类型在信号函数和槽函数之间必须一致。如果顺序或类型不匹配，连接将无法建立。\n\n\n\n4. QLineEdit\n4.1 获取和设置文本内容：\n\n\nQString text() const：返回当前文本框中的文本内容。\n\n\nsetText(const QString &amp;text)：设置文本框的文本内容。\n\n\nQLineEdit *lineEdit = new QLineEdit();lineEdit-&gt;setText(&quot;Hello, World!&quot;);// 获取当前文本内容QString currentText = lineEdit-&gt;text();\n4.2 密码模式\nsetEchoMode(QLineEdit::EchoMode mode)：设置文本框的显示模式。常用的模式有：\n\n\nQLineEdit::Normal：默认模式，显示输入的文本。\n\n\nQLineEdit::Password：以密码形式显示文本，用圆点或星号代替实际字符。\n\n\nQLineEdit::PasswordEchoOnEdit：在编辑时以密码形式显示文本，但在失去焦点后显示圆点。\n\n\nQLineEdit *lineEdit = new QLineEdit();lineEdit-&gt;setEchoMode(QLineEdit::Password);\n4.3 设置最大长度\n使用setMaxLentgh方法可以限制用户输入的最大字符数\nQLineEdit* lineEdit = new QLineEdit(this);lineEdit- &gt;setMaxLength(10);//限制输入的最大长度为10个字符\nQLable\n5.1 设置字体的颜色 大小等\n可以使用setStyleSheet()函数\n//对某个组件局部使用ui-&gt;display-&gt;setStyleSheet(&quot;color: red;&quot; &quot;text-align: right;&quot; &quot; font-size: 10px;&quot;);//对某个窗口下的某种组件设置MainWindow-&gt;setStyleSheet(&quot;QLineEdit&#123; background-color: lime&#125;&quot;);//全局使用/*使用qApp的setStyleSheet函数可以为应用程序全局设置样式。例如下面为应用程序的QLineEdit组件设置样式*/qApp-&gt;setStyleSheet(&quot;QLineEdit&#123; background-color: gray &#125;&quot;);\n6. 使用类设置字体属性 颜色\n\n\nQFont类的构造函数QFont(const QString &amp;family, int pointSize, int weight = -1, bool italic = false)\n\n\n\nfamily：字符串，表示字体的家族名称，例如&quot;Arial&quot;，&quot;Times New Roman&quot;等。\npointSize：整数，代表字体的大小，以磅（point）为单位。\nweight：整数，指定字体的粗细，通常是100到1000的范围内的数值；-1表示使用默认值。\nitalic：布尔值，表示字体是否是斜体；false表示非斜体，true表示斜体。\n\n//设置字体属性QFont font(&quot;Arial&quot;, 16);font.setBold(true);ui-&gt;lineEdit-&gt;setFont(font);//设置对齐位置ui-&gt;lineEdit-&gt;setAlignment(Qt::AlignRight);\n\n\nQPalette 类用于管理窗口部件的外观，包括背景色、前景色和文本格式等\n\n\n//设置颜色 QPalette palette; palette.setColor(QPalette::Text, Qt::red); ui-&gt;lineEdit-&gt;setPalette(palette);//setColor() 方法第一个参数是要设置的颜色属性，第二个参数是要应用的颜色值。//在设置控件背景色填充时，一定要先调用setAutoFillBackground(true)函数，来运行自动填充背景\n7. QProgressBar\n\n可与QSlider QScrollBar QDial配合使用\n\nformat属性\n%p:完成的百分比  %v:当前值  %m:总步骤数\n默认值为%p%\nconnect(ui-&gt;slider,&amp;QSlider::valueChanged,this,&amp;Widget::do_valueChanged);void Widget::do_valueChanged(int value);&#123;    ui-&gt;progressBar-&gt;setValue(value);&#125;\n8. 日期时间数据\n\nQTime    QDate    QDateTime    QCalendarWidget\n\nvoid Widgey::on_btnGetTime_clicked()&#123;    QDateTime curDateTime = QDateTime::currentDateTime();    ui-&gt;timeEdit-&gt;setTime(curDateTime.time());    ui-&gt;editTime-&gt;setText(curDateTime.toString(&quot;hh:mm:ss&quot;))        ui-&gt;timeEdit-&gt;setDate(curDateTime.date());    ui-&gt;editTime-&gt;setText(curDateTime.toString(&quot;yy-MM-dd&quot;));        ui-&gt;timeEdit-&gt;setDateTime(curDateTime);&#125;void Widget::on_calendarWidget_selectionChanged()&#123;    //获取日历控件上选择的日期    QString str = ui-&gt;calendarWidget-&gt;selectedDate().toString(&quot;yyyy年M月d日&quot;);&#125;\n9. 计时器 QTimer\n\ntimer 超时后会发出timeout()信号，所以在创建好定时器对象后给其建立信号与槽\n\n#inlcude &lt;QTimer&gt;QTimer *timer = new QTimer;timer-&gt;setSingleShot(false);//设置是否只使用一次timer-&gt;setInterval(2000);//设置时间间隔,以毫秒为单位timer-&gt;start();//启动timer-&gt;stop();//停止connect(timer, SIGNAL(timeout()), this, SLOT(onTimeout()));\n10. QTabWidget\n// 创建一个 QTabWidget 实例，用于包含多个选项卡QTabWidget *tabWidget = new QTabWidget;// 设置选项卡的形状为三角形tabWidget-&gt;setTabShape(QTabWidget::Triangular);// 设置选项卡可移动tabWidget-&gt;setMovable(true);// 设置选项卡的位置为左侧tabWidget-&gt;setTabPosition(QTabWidget::West);// 创建三个子窗口部件(QWidget)，用作每个选项卡的内容QWidget *pageWidget_0 = new QWidget;QWidget *pageWidget_1 = new QWidget;QWidget *pageWidget_2 = new QWidget;// 将每个子窗口部件添加到选项卡中，同时设置相应的标签tabWidget-&gt;addTab(pageWidget_0, &quot;第一页&quot;);tabWidget-&gt;addTab(pageWidget_1, &quot;第二页&quot;);tabWidget-&gt;addTab(pageWidget_2, &quot;第三页&quot;);\n11. QTableView QStandardItemModel QItemSelectionModel\n\nQStandardItemModel是Qt提供的用于存储和操作标准项数据模型的类。它继承自QAbstractItemModel，并提供了一种方便的方式来组织和展示数据。通过添加、删除、修改或移动标准项，可以对数据进行操作。\nQItemSelectionModel则是用于管理项选择状态的类。它是一个与视图交互的模型，负责跟踪用户选择的项以及通知相关视图进行相应更新。QItemSelectionModel可以监听并响应用户选择项变化事件，同时也可以通过编程方式改变选择状态。\n\n#include &lt;QFileDialog&gt;#include &lt;QFile&gt;#include &lt;QStandardItemModel&gt;#include &lt;QItemSelectionModel&gt;class MainWindow:public QMainWindow&#123;    Q_OBJECTprivate:    QStandardItemModel* m_model; // 数据模型    QItemSelectionModel* m_selection; // 选择模型    QLabel* labCurFile; // 当前文件标签    QLabel* labCellPos; // 当前单元格位置标签public:    .........private slots:    void do_currentChanged(const QModelIndex &amp;current,const QModelIndex &amp;previous);    &#125;;MainWindow::MainWindow(QWidget* parent):QMainWindow(parent),ui(new Ui::MainWindow)&#123;    labCurFile = new QLabel(&quot;当前文件&quot;,this);    labCurFile-&gt;setMinimumWidth(200);    ui-&gt;statusBar-&gt;addWidget(labCurFile); // 将当前文件标签添加到状态栏        m_model = new QStandardItemModel(2,6,this); // 创建数据模型，2行6列    m_selection = new QItemSelectionModel(m_model,this); // 创建选择模型        ui-&gt;tableView-&gt;setModel(m_model); // 设置表格视图的模型    ui-&gt;tableView-&gt;setSelectionModel(m_selection); // 设置表格视图的选择模型    ui-&gt;tableView-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection); // 设置选择模式    ui-&gt;tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectItems); // 设置选择行为        connect(m_selection,&amp;QItemSelection::currentChanged,this,&amp;MainWindow::do_currentChanged);&#125;void MainWinidow::do_currentChanged(const QModelIndex &amp;current,const QModelIndex &amp;previous)&#123;    if(current.isValid())    &#123;        labCellPos-&gt;setText(QString::asprintf(&quot;当前单元格:%d行,%d列&quot;,current.row(),current.column()));        QStandardItem *aItem = m_model-&gt;itemFromIndex(current); // 获取当前单元格的项        ui-&gt;actFontBold-&gt;setChecked(aItem-&gt;font().bold()); // 检查当前单元格的文本是否为粗体,如果当前单元格的文本为粗体，动作将被选中，否则动作将取消选中    &#125;&#125;void MainWindow::on_actOpen_triggered()&#123;    // 获取当前应用程序的路径    QString curPath = QCoreApplication::applicationDirPath();    // 打开文件对话框以获取要打开的文件路径    QString aFilePath = QFileDialog::getOpenFileName(this, &quot;打开一个文件&quot;, curPath, &quot;数据文件(*.txt);;所有文件(*.*)&quot;);    // 如果文件名为空，则退出函数    if (aFileName.isEmpty()) return;        // 打开文件    QFile aFile(aFileName);    if (!aFile.open(QIODevice::ReadOnly | QIODevice::Text)) return; // 如果文件无法打开，则退出函数        // 读取文件内容并显示在界面上    QStringList aFileContent;    QTextStream aStream(&amp;aFile);    while (!aStream.atEnd())    &#123;        QString str = aStream.readLine();        ui-&gt;plainTextEdit-&gt;appendPlainText(str); // 在文本框中添加一行内容        aFileContent.append(str); // 将读取的每一行内容添加到QStringList中    &#125;    // 关闭文件    aFile.close();        // 更新界面显示，显示当前打开的文件名    labCurFile-&gt;setText(&quot;当前文件:&quot; + aFileName);    // 启用一个动作（假设这里是一个菜单项或按钮），允许用户追加内容    ui-&gt;actAppend-&gt;setEnabled(true);        iniModelData(aFileContent); // 初始化模型数据&#125;void MainWindow::iniModelData(QStringList&amp; aFileContent)&#123;    int rowCnt  = aFileContent.size(); // 获取文件内容的行数    m_model-&gt;setRowCount(rowCnt - 1); // 设置表格模型的行数（减去标题行）    QString header = aFileContent.at(0); // 获取标题行    QStringList headerList = header.split(QRegularExpression(R&quot;(\\s+)&quot;), Qt::SkipEmptyParts); // 根据空白字符拆分标题行    m_model-&gt;setHorizontalHeaderLabels(headerList); // 设置表头标签    QStandardItem* aItem; // 用于创建每个单元格的项    int j;    for(int i = 1; i &lt; rowCnt; i++) // 从第二行开始遍历文件内容    &#123;        QString aLineText = aFileContent.at(i); // 获取当前行的文本        QStringList tmpList = aLineText.split(QRegularExpression(R&quot;(\\s+)&quot;), Qt::SkipEmptyParts); // 根据空白字符拆分当前行        for(j = 0; j &lt; 6; j++) // 遍历当前行的每一列（假设每行有6列）        &#123;            aItem = new QStandardItem(tmpList.at(j)); // 创建一个新的项，内容为当前列的值            m_model-&gt;setItem(i - 1, j, aItem); // 在指定位置设置项        &#125;        // 处理最后一列        aItem = new QStandardItem(tmpList.at(j)); // 创建最后一列的项        aItem-&gt;setCheckable(true); // 设置项为可选中的        aItem-&gt;setBackground(QBrush(Qt::yellow)); // 设置项的背景颜色为黄色        if(tmpList.at(j) == &quot;0&quot;) // 如果值为0，则设置为未选中状态        &#123;            aItem-&gt;setCheckState(Qt::Unchecked);        &#125;        else // 否则设置为选中状态        &#123;            aItem-&gt;setCheckState(Qt::Checked);        &#125;        m_model-&gt;setItem(i - 1, j, aItem); // 在指定位置设置项    &#125;&#125;\n12. QTableWidget\n\nQTableWidget继承自QTableView,QTableWidget是QTableView的子类，主要的区别是QTableView可以使用自定义的数据模型来显示内容(也就是先要通过setModel来绑定数据源)，而QTableWidget则只能使用标准的数据模型，并且其单元格数据是QTableWidgetItem的对象来实现的\n\n12.1 初始化表格数据\n界面上的“初始化表格数据”按钮根据表格的行数，生成数据填充表格，并为每个单元格生成 QTableWidgetItem 对象，设置相应属性。下面是 btnlniData 的 clicked() 信号的槽函数代码：\nvoid ManagerInterface::readMenuInfo()&#123;\tQFile file(&quot;menuInfo.dat&quot;);\tfile.open(QIODevice::ReadOnly);\tif (!file.isOpen())\t&#123;\t\tqDebug() &lt;&lt; &quot;文件打开失败1&quot;;\t&#125;\telse\t&#123;\t\tQString name;\t\tQString type;\t\tdouble price;\t\tdouble discount;\t\tQString imagePath;\t\tQDataStream in(&amp;file);\t\twhile (!in.atEnd())\t\t&#123;\t\t\tin &gt;&gt; name &gt;&gt; type &gt;&gt; price &gt;&gt; discount&gt;&gt; imagePath;\t\t\tui-&gt;menuTable-&gt;insertRow(ui-&gt;menuTable-&gt;rowCount());\t\t\tcreatTableRows(ui-&gt;menuTable-&gt;rowCount()-1, name, type, price, discount,imagePath);//注意要将获得的行数减一\t\t\tqDebug() &lt;&lt; name &lt;&lt; type &lt;&lt; price &lt;&lt; discount &lt;&lt; imagePath;\t\t&#125;\t&#125;\tfile.close();&#125;---------------------------------------------------------------------------QTableWidget::clearContents() 函数清除表格数据区的所有内容，但是不清除表头。QTableWidget::rowCount() 函数返回表格数据区的行数。在 for 循环里为每一行生成需要显示的数据，然后调用自定义函数 creatTableRows()，为表格一行的各个单元格生成 QTableWidgetItem 对象。\ncreatTableRows() 是在窗体类里自定义的函数，其实现代码如下：\nvoid ManagerInterface::creatTableRows(int rowNo,  QString menuName, QString type, double price, double discount,QString imagePath)&#123;\tQTableWidgetItem* item;\t\titem = new QTableWidgetItem(menuName);\titem-&gt;setTextAlignment(Qt::AlignCenter);\tui-&gt;menuTable-&gt;setItem(rowNo, 0, item);\titem = new QTableWidgetItem(type);\titem-&gt;setTextAlignment(Qt::AlignCenter);\tui-&gt;menuTable-&gt;setItem(rowNo, 1, item);\t\titem = new QTableWidgetItem(QString::number(price, &#x27;f&#x27;, 2));\titem-&gt;setTextAlignment(Qt::AlignCenter);\tui-&gt;menuTable-&gt;setItem(rowNo, 2, item);\titem = new QTableWidgetItem(QString::number(discount, &#x27;f&#x27;, 2));\titem-&gt;setTextAlignment(Qt::AlignCenter);\tui-&gt;menuTable-&gt;setItem(rowNo, 3, item);\titem = new QTableWidgetItem(imagePath);\titem-&gt;setTextAlignment(Qt::AlignCenter);\tui-&gt;menuTable-&gt;setItem(rowNo, 4, item);        //将第四列隐藏\tui-&gt;menuTable-&gt;setColumnHidden(4, true);&#125;\n12.2 获得当前单元格数据\n当鼠标在表格上单击单元格时，被选中的单元格是当前单元格。通过QTableWidget 的 currentColumn() 和 currentRow() 可以获得当前单元格的列编号和行编号。\n当前单元格发生切换时，会发射==currentCellChanged() 信号和 currentItemChanged()==信号，两个信号都可以利用，只是传递的参数不同。\n对 currentCellChanged() 信号编写槽函数，用于获取当前单元格的数据，以及当前行的学生的学号信息，代码如下：\nvoid MainWindow::on_tableInfo_currentCellChanged(int currentRow, int currentColumn, int previousRow, int previousColumn)&#123;//当前选择单元格发生变化时的响应   Q_UNUSED(previousRow);   Q_UNUSED(previousColumn);    QTableWidgetItem* item=ui-&gt;tableInfo-&gt;item(currentRow,currentColumn); //获取单元格的 Item    if  (item==NULL)        return;    labCellIndex-&gt;setText(QString::asprintf(&quot;当前单元格坐标：%d 行，%d 列&quot;,currentRow,currentColumn));    int cellType=item-&gt;type();//获取单元格的类型    labCellType-&gt;setText(QString::asprintf(&quot;当前单元格类型：%d&quot;,cellType));    item=ui-&gt;tableInfo-&gt;item(currentRow,MainWindow::colName); //取当前行第1列的单元格的 item    int ID=item-&gt;data(Qt::UserRole).toInt();//用data()函数提取自定义数据，也就是创建单元格时存储的学生 ID    labStudID-&gt;setText(QString::asprintf(&quot;学生ID：%d&quot;,ID));//学生ID&#125;\n12.3 插入、添加、删除行\nQTableWidget 处理行操作的函数如下：\ninsertRow(int row)：在行号为row的行前面插入一行，如果row等于或大于总行数，则在表格最后添加一行。insertRow()函数只是插入一个空行，不会为单元格创建QTableWidgetItem对象，需要手工为单元格创建。\nremoveRow(int row)：删除行号为 row 的行。\n下面是界面上“插入行” “添加行”“删除当前行”按钮的响应代码。在插入行之后，会调用 createItemsARow() 函数，为新创建的空行的各单元格构造 QTableWidgetItem 对象：\nvoid MainWindow::on_btnInsertRow_clicked()&#123; //插入一行    //int curRow;    int curRow=ui-&gt;tableInfo-&gt;currentRow();//当前行号    ui-&gt;tableInfo-&gt;insertRow(curRow); //插入一行，但不会自动为单元格创建item    createItemsARow(curRow, &quot;新学生&quot;, &quot;男&quot;,          QDate::fromString(&quot;1990-1-1&quot;,&quot;yyyy-M-d&quot;),&quot;苗族&quot;,true,60 ); //为某一行创建items&#125;void MainWindow::on_btnAppendRow_clicked()&#123; //添加一行    //int curRow;    int curRow=ui-&gt;tableInfo-&gt;rowCount();//总行号    ui-&gt;tableInfo-&gt;insertRow(curRow);//在表格尾部添加一行    createItemsARow(curRow, &quot;新生&quot;, &quot;女&quot;,          QDate::fromString(&quot;2000-1-1&quot;,&quot;yyyy-M-d&quot;),&quot;满族&quot;,false,50 ); //为某一行创建items&#125;void MainWindow::on_btnDelCurRow_clicked()&#123;//删除当前行及其items    //int curRow;    int curRow=ui-&gt;tableInfo-&gt;currentRow();//当前行号    ui-&gt;tableInfo-&gt;removeRow(curRow); //删除当前行及其items&#125;\n12.4 自动调整行高和列宽\nQTableWidget 有几个函数自动调整表格的行高和列宽，分别如下：\nresizeColumnsToContents()：自动调整所有列的宽度，以适应其内容。resizeColumnToContents(int column)：自动调整列号为 co/www 的列的宽度。resizeRowsToContents()：自动调整所有行的高度，以适应其内容。resizeRowToContents(int row)：自动调整行号为 raw 的行的高度。    这几个函数实际上是 QTableWidget 的父类 QTableView 的函数。\n12.4 其他属性控制\n设置表格内容是否可编辑：QTableWidget 的 EditTriggers 属性表示是否可编辑，以及进入编辑状态的方式。界面上的&quot;表格可编辑&quot;复选框的槽函数代码为：\nvoid MainWindow::on_chkBoxTabEditable_clicked(bool checked)&#123; //设置编辑模式    if (checked)        //双击或获取焦点后单击，进入编辑状态        ui-&gt;tableInfo-&gt;setEditTriggers(QAbstractItemView::DoubleClicked | QAbstractItemView::SelectedClicked);    else        ui-&gt;tableInfo-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers); //不允许编辑&#125;\n设置行表头、列表头是否显示：horizontalHeader()获取行表头，verticalHeader()获取列表头，然后可设置其可见性。\nvoid MainWindow::on_chkBoxHeaderH_clicked(bool checked)&#123;    //是否显示水平表头    ui-&gt;tableInfo-&gt;horizontalHeader()-&gt;setVisible(checked);&#125;void MainWindow::on_chkBoxHeaderV_clicked(bool checked)&#123;    //是否显示垂直表头    ui-&gt;tableInfo-&gt;verticalHeader()-&gt;setVisible(checked);&#125;\n间隔行底色：setAltematingRowColors() 函数可以设置表格的行是否用交替底色显示，若为交替底色，则间隔的一行会用灰色作为底色。具体底色的设置需要用 styleSheet。\nvoid MainWindow::on_chkBoxRowColor_clicked(bool checked)&#123;    ui-&gt;tableInfo-&gt;setAlternatingRowColors(checked);&#125;\n选择模式：setSelectionBehavior() 函数可以设置选择方式为单元格选择，还是行选择：\nvoid MainWindow::on_rBtnSelectItem_clicked()&#123;//选择行为：单元格选择    ui-&gt;tableInfo-&gt;setSelectionBehavior(QAbstractItemView::Selectltems);&#125;void MainWindow::on_rBtnSelectRow_clicked()&#123;//选择行为：行选择    ui-&gt;tableInfo-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);&#125;\n12.6 遍历表格读取数据\n“读取表格内容到文本”按钮演示了将表格数据区的内容全部读出的方法，它将每个单元格的文字读出，同一行的单元格的文字用空格分隔开，作为文本的一行，然后将这行文字作为文本编辑器的一行内容，代码如下：\nvoid ManagerInterface::saveMenuInfo()&#123;\tQFile file(&quot;menuInfo.dat&quot;);\tfile.open(QIODevice::WriteOnly);\tif (!file.isOpen())\t&#123;\t\tqDebug() &lt;&lt; &quot;文件打开失败2&quot;;\t&#125;\telse\t&#123;\t\tQDataStream out(&amp;file);\t\tfor (int i = 0; i &lt; ui-&gt;menuTable-&gt;rowCount(); i++)\t\t&#123;\t\t\tQTableWidgetItem* item = ui-&gt;menuTable-&gt;item(i, 0);\t\t\tQString menuName = item-&gt;text();\t\t\titem = ui-&gt;menuTable-&gt;item(i, 1);\t\t\tQString type = item-&gt;text();\t\t\titem = ui-&gt;menuTable-&gt;item(i, 2);\t\t\tdouble price = item-&gt;text().toDouble();\t\t\titem = ui-&gt;menuTable-&gt;item(i, 3);\t\t\tdouble discount = item-&gt;text().toDouble();\t\t\titem = ui-&gt;menuTable-&gt;item(i, 4);\t\t\tQString imagePath = item-&gt;text();\t\t\tout &lt;&lt; menuName &lt;&lt; type &lt;&lt; price &lt;&lt; discount&lt;&lt;imagePath;\t\t\t\t&#125;\t\tfile.close();\t&#125;&#125;\n12.7 在一个qtablewidgetitem中设置复选框\nQTableWidgetItem* item;for (int i = 0; i &lt; ui-&gt;menuTable-&gt;rowCount(); i++)&#123;\titem = ui-&gt;menuTable-&gt;item(i,0);\titem-&gt;setCheckState(Qt::Unchecked);&#125;//单一控制 利用QTableWidget::cellchanged()函数判断单元格内容的变化//批量删除被选择的行void ManagerInterface::on_deleteBut_clicked()&#123;\tfor (int i = 0; i &lt; ui-&gt;menuTable-&gt;rowCount(); i++)\t&#123;\t\tif(ui-&gt;menuTable-&gt;item(i,0)-&gt;checkState() == Qt::Checked)\t\t\tui-&gt;menuTable-&gt;removeRow(i);\t&#125;&#125;\n","categories":["编程"],"tags":["C++","Qt"]},{"title":"订餐程序涉及知识","url":"/2024/05/16/school_assignments/%E8%AE%A2%E9%A4%90%E7%A8%8B%E5%BA%8F%E6%B6%89%E5%8F%8A%E7%9F%A5%E8%AF%86/","content":"\n记录了一下项目制作过程中 所涉及的不熟悉的部分源码可至GitHub查看\n\n\n相关知识\nctime 头文件\n1.1  time_t time(time_t *timer): 返回自纪元以来经过的时间，以秒为单位\ntime_t currentTime;time(&amp; currentTime);\n1.2 struct tm *localtime(const time_t *timer): 将 time_t 格式的时间转换为本地时间，返回一个指向 tm 结构体的指针\ntime_t currTime;time(&amp;currTime);struct tm* timeTmp = locatime(&amp;currTime);\n1.3 char *asctime(const struct tm *timeptr): 将 tm 结构体表示的时间转换为字符串形式的时间，并返回指向静态字符串的指针\n time_t currTime;time(&amp;currTime);struct tm* timeTmp = locatime(&amp;currTime);char *timeString = asctime(&amp;timeTmp);\n1.4 tm结构体(包含在ctime头文件中)\nstruct tm &#123;    int tm_sec;   // 秒（0-59）    int tm_min;   // 分钟（0-59）    int tm_hour;  // 小时（0-23）    int tm_mday;  // 一个月中的日期（1-31）    int tm_mon;   // 月份（0-11）    int tm_year;  // 年份自1900年起    int tm_wday;  // 一周中的天数（0-6，星期日为0）    int tm_yday;  // 一年中的天数（0-365，1月1日为0）    int tm_isdst; // 夏令时标志（&gt;0 表示是夏令时，0 表示不是夏令时，-1 表示夏令时信息不可用）&#125;;\n1.5 使用\n\n先使用time()函数获取自1970年1月1日午夜（格林威治时间）起算的秒数，然后使用localtime()函数将其转化为本地时间 (使用tm结构体存储)，最后根据需要进行打印\n\n#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt; #include&lt;ctime&gt;using namespace std;int main()&#123;    time_t now;    time(&amp;now);    struct tm* lt = localtime(&amp;now);    cout &lt;&lt; &quot;Local time is: &quot; &lt;&lt; lt-&gt;tm_year + 1900 &lt;&lt; &quot;-&quot; &lt;&lt; lt-&gt;tm_mon + 1 &lt;&lt; &quot;-&quot; &lt;&lt; lt-&gt;tm_mday &lt;&lt; &quot; &quot; &lt;&lt; lt-&gt;tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; lt-&gt;tm_min &lt;&lt; &quot;:&quot; &lt;&lt; lt-&gt;tm_sec &lt;&lt; endl;    char* timeStr = asctime(lt);    cout &lt;&lt; &quot;Formatted time is: &quot; &lt;&lt; timeStr &lt;&lt; endl;    char buffer[255];    strftime(buffer, 255, &quot;%Y-%m-%d %H:%M:%S&quot;, lt);    //sprintf(buffer,&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, lt-&gt;tm_year + 1900, lt-&gt;tm_mon + 1, lt-&gt;tm_mday, lt-&gt;tm_hour,lt-&gt;tm_min,lt-&gt;tm_sec);    cout &lt;&lt; &quot;Formatted time is: &quot; &lt;&lt; buffer &lt;&lt; endl;    return 0;&#125;----------输出结果-----------------Local time is: 2024-4-28 17:15:42Formatted time is: Sun Apr 28 17:15:42 2024Formatted time is: 2024-04-28 17:15:42\nCMake简单使用\n2.1 创建一个CMakeLists.txt文件\n2.2 创建一个名为build的文件夹\n\n避免编译产物与代码文件混在一起\n\n2.3 在CMakeLists.txt中写入内容\n# 设置 CMake 的最低版本要求cmake_minimum_required(VERSION 3.20)# 定义项目名称project(dinnerSystem)# 添加可执行文件，并指定源文件# 亦可写成  add_executable($&#123;PROJECT_NAME&#125;)add_executable(dinnerSystem)# 使用file函数 globbing 匹配来获取所有的 .cpp 和 .h 文件,并将文件保存在sources变量中file(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)# 将获取的源文件与目标文件相关联#target_sources($&#123;PROJECT_NAME&#125; PBULIC $&#123;sources&#125;)target_sources(dinnerSystem PUBLIC $&#123;sources&#125;)\n2.4 在build文件夹中打开cmd\n输入cmake ..\ncmake --build .\n解决中文乱码\n使用UTF-8 无BOM  可以在VS2022下载插件Force UTF-8(No BOM)\nQt的基础使用\n见另一篇笔记\n","categories":["编程"],"tags":["C++"]},{"title":"C++基础","url":"/2024/04/27/C++/C++%E5%9F%BA%E7%A1%80/","content":"\nC++ 一些基础知识\n\n\nC++ 基础\n0. 前置知识\n0.1 左/右值\n\n\n\n左值:在内存中有明确存储位置(即地址)的表达式，通常出现在赋值表达式的左侧。 左值可以取地址\n\n\n右值：通常指临时的数据值(如字面量，求值过程中产生的临时对象)，在内存中没有固定的地址，它不能被赋值\n\n\n\n0.2 单位\n\n\n\nbit:比特，又称位，计算机内部储存数据的最小单位\n\n\nByte:字节，由8个比特组成，习惯上以大写B来表示，通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。这是内存寻址的最小单元\n\n\nword:字，由一个或多个字节组成，计算机的字长决定了其CPU一次操作实际处理的位数是多少，例如64位计算机的CPU一次最多能处理64位数据\n\n\n\n0.3 内存\n\n内存就是计算机的存储空间，用来存储程序的指令，数据和状态\n\n0.3.1 内存四区\n\n\n代码区(code/text):存放CPU执行的机器指令。通常代码区是可共享的，即另外的程序可以调用它。编写的所有代码都会放进代码区，其特点是共享和只读\n\n\n全局区/静态区(stactic)：用来存放全局变量，静态变量，常量\n\ndata区：存放已初始化的全局变量，静态变量和常量\nbss区：存放初始化为0或者NULL或未初始化的全局变量，静态变量和常量。未初始化的在程序执行前会自动被系统初始化为0或者NULL\n常量区：顾名思义，存放常量，如const修饰的全局变量，字符串常量\n\n\n\n栈(stack):是一种先进后出的内存结构，由编译器自动分配\n\n\n结构体和类的对象在默认情况下是分配在栈区\n\n\n存放函数的参数值，返回值，局部变量等，由const定义的局部变量也存储在栈里。\n\n\n内存地址由高到低方向生长，其最大大小由编译时确定，速度快但自由性差，最大空间比堆小\n\n\n\n\n堆(heap):用于动态内存分配\n\n内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大\n注意进行内存释放，否则会造成内存泄露\n\n\n\n\n0.3.2 内存编址\n即给计算机的存储单元进行编号，而在CS中存储单元通常是指最小的可寻址单元即byte，也就是给每个byte一个编号，这个编号就是内存的地址\n\n0.3.3 内存地址空间\n\n将所有byte的编号连起来就叫作内存的地址空间，而地址空间(可寻址内存)的大小与电脑是32位还是34位有关\n\n\n\n32 位意味着可寻址的内存范围是 2^32 byte = 4GB\n\n\n64位即 2^64 byte\n\n\n0.4 原码 反码 补码\n\n\n反码  原码按位取反  正数的反码是其本身\n\n\n补码  原码按位取反加一    正数的补码是其本身\n\n\n计算机中使用补码来表示和操作整数\n\n\n个人觉得反码和补码的引入 是为了便于理解在计算机中如何使用 正数来表示负数\n\n\n\n如 int 在内存中占据4个字节 表示有符号的整数 他的范围是 [-2^31 , 2^31 - 1]\nunsigned int 在内存中占据四个字节 表示无符号整数 他的范围是[0,2^32-1]\n而32位二进制数表示的范围是[0,2^32-1]，即把它从中间分一半，将 0 开头的32位二进制数用来表示正数，将 1 开头的用来表示负数，所以int表示的正数的范围是unsigned int 的一半 但二者表示的总数是一样的\n\n0.5 进制转换\n\n十进制： 都是以0-9这九个数字组成，不能以0开头。\n二进制： 由0和1两个数字组成。\n八进制： 由0-7数字组成，为了区分与其他进制的数字区别，开头都是以0开始。\n十六进制：由0-9和A-F组成。为了区分于其他数字的区别，开头都是以0x开始。\n\n\n\n整数部分\n十进制转n进制：十进制数除以2，反向取余数，直到商为0终止\n\nn进制转十进制：将每一位乘以相应的权值，然后将乘积相加\n\n\n小数部分\n\n\n​\t十进制转n进制: 乘n取整，顺序输出\n​\tn进制转十进制：如上\n1.变量\n\n变量名是变量地址的符号化体现\n\n1.1 变量类型\n1.1.1 作用：\n\n\n内存分配：告诉编译器该变量占据的内存大小，占了多少个字节\n\n\n操作限制：规定了该变量可以执行的操作\n\n\n数据解释：决定了如何解释存储在内存中的位模式，决定了编译器如何解读对应的二进制数据\n\n\n\n位模式是指一系列的0和1，是计算机内存中数据最基本的形式，所有数据最终都会被表示为 位模式\n\n1.1.2 种类\n\n\n基础类型 ：整数 字符 布尔 浮点\n\n\n修饰符：long short signed unsigned\n\n\n类类型：class\n\n\n结构体类型：struct\n\n\n数组类型\n\n\n指针类型\n\n\n引用类型\n\n\n复数类型(complex  C++11及以上)\n\n\n联合体 unio\n\n\n枚举体 enum\n\n\n2. 内存对齐\n\n为了提高数据访问的性能和效率，将数据存储在适当的内存地址上，以减少额外开销   以空间换时间\n对齐的长度一般为2的n次幂(1，2 ，4，8)\n\n2.1 产生原因\n为了适应CPU读取数据的行为，CPU一次读取4个字节或8个字节，由编译器和操作系统(32位或64位)决定\n2.2 更改对齐规则\n\n\n使用编译器指令（如 #pragma pack）更改默认的对齐规则。这个命令是全局生效的。这可以用于减小数据结构的大小，但可能会降低访问性能。\n\n\n在 C++11 及更高版本中，可以使用 alignas 关键字为数据结构或变量指定对齐要求。这个命令是对某个类型或者对象生效的。例如，alignas(16) int x; 将确保 x 的地址是 16 的倍数。\n\n\n#pragma pack(push, 16) //将当前对齐值推送到堆栈上，并将对齐值设置为16字节struct MyStruct &#123;    char a;    int b;    char c;&#125;;#pragma pack(pop)  //从堆栈中弹出对齐值，恢复之前的对齐值\n2.3 结构体对齐\n\n\n最大成员对齐：编译器会将数据成员补齐为最大成员大小的整数倍\n如果结构体中含有数组成员，如 char a[5]，它的对齐方式和连续写 5 个 char 类型变量是一样的，也就是说它还是按一个字节对齐\n\n\n填充字节(struct padding)：如果某成员大小满足对齐要求，编译器会插入一些字节进行填充\n\n\n#include &lt;iostream&gt;using namespace std;struct stu1 &#123;    char a[18];  //就本身而言占据18个字节   实际占据24个字节    double b;    //占据8个字节    char c;      //实际占据4个字节    int d;       //实际占据4个字节    short e;     //实际占据8个字节&#125;;int main() &#123;    stu1 s1;    cout&lt;&lt;sizeof(s1)&lt;&lt;endl;    return 0;&#125;---------------输出结果：sizeof(s1)=48\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct stu2 &#123;    char x;    int y;    double z;    char v[6];&#125;;struct stu1 &#123;    char a;         //实际占据8个字节    struct stu2 b; // 该结构体中最大的成员占据8个字节，实际占据24个字节    int c;         //实际占据8个字节&#125;;int main() &#123;    stu1 s1;    cout&lt;&lt;sizeof(s1)&lt;&lt;endl;    return 0;&#125;---------------输出结果：sizeof(s1)=40\n\n2.4 类的内存对齐\n2.4.1 空类的大小\n\n空类和空结构体的实例化对象的大小都为1\n\n#include&lt;iostream&gt;using namespace std;class demo&#123;&#125;;int main(void)&#123;    demo a;    cout &lt;&lt; sizeof(a)&lt;&lt;endl;  // 输出结果为1&#125;\n2.4.2 添加成员函数，静态数据成员，静态成员函数\n\n结果依旧为1\n\n#include&lt;iostream&gt;using namespace std;class demo &#123;public:    demo() &#123;&#125;    ~demo() &#123;&#125;    void myPrint() &#123; cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl; &#125;    static void sharedFunc() &#123; cout &lt;&lt; &quot;hello this is a shared xxx&quot; &lt;&lt; endl; &#125;    static int a;&#125;;int demo::a = 1024;int main(void) &#123;    demo x;    cout &lt;&lt; sizeof(x) &lt;&lt; endl;  // 输出结果为1&#125;\n因为成员函数，静态成员函数存储在代码段（.text）中，静态成员变量存储在全局/静态区(static)，他们不占用类的内存，不是每个对象分别存储\n2.4.3 类对象大小的影响因素\n\n非静态成员变量和虚函数\n考虑是否存在vptr，若存在则计入考虑范围，整体上与结构体相同\n\n3.类的多态\n\n允许使用一个接口来表示不同的类，而这些类的对象在运行时可以表现出不同的行为\n父类指针可以指向子类对象，进而调用子类函数\n\n3.1 虚表(vtable)\n\n\n每个存在虚函数的类，都有一个虚函数表\n\n\n虚函数表是一个指针数组，其元素是指向虚函数的函数指针(函数的地址)\n\n\n成员函数(包括虚函数)是类的一部分，不占用对象实例的内存空间，他们为同一个类的所有对象共享，存储在程序的代码段中\n\n\n3.2虚表指针(vptr)\n\n实现多态类的核心机制之一\n每一个包含虚函数的类 的实例化对象所包含的隐含指针\n\n\n\n该指针指向类的虚表\n\n\n大多数实现上，虚函数表指针一般都放在对象第一个位置\n\n\n该指针是隐含的，不是类的成员变量，用户不能直接访问或修改它\n\n\n指针大小取决于操作系统或编译器，32位占4个字节，64位占8个字节\n\n\n3.3 多态的实现\n\n\n当派生类重写了基类的虚函数时，派生类的虚表中对应的函数指针将被更新，指向派生类中的新实现，即指向派生类中重写函数的地址\n\n\n\n4. 移动语义\n\n允许资源从一个对象转移到另一个对象 避免了复制 提高了性能\n在使用一个右值(即将被销毁的的对象)去初始化同类对象时该函数会被调用\n如果一个类定义了移动构造函数或移动赋值运算符也必须定义拷贝操作,否则无法进行拷贝操作,哪些成员默认被删除\n\n\n4.1 特点\n\n\n函数名和类名相同 无返回值 因为它本身也是一个构造函数\n\n\n第一个参数为同类型的右值引用(&amp;&amp;)\n\n\n第一个参数不能设置为const因为它的资源在函数内部会被移动给当前对象\n\n\n移动构造函数执行后 需要确保右值引用的对象能被正确销毁\n\n\n4.2 实例\nclass CDate&#123;public:    CDate(int year,int month,int day);    CDate(CDate&amp;&amp; date) noexcept;    CDate&amp; operator=(CDate&amp;&amp; date) noexcept;    ~CDate();private:    int m_year;    int m_month;    int m_day;    char* str&#125;;CDate::CDate(int year,int month,int day)&#123;    m_year = year;\tm_mon = mon;\tm_day = day;\tstr = new char[100];&#125;//移动构造函数CDate::CDate(CDate&amp;&amp; date) noexcept&#123;    this-&gt;m_year = date.m_year;    this-&gt;m_month = date.m_month;    this-&gt;m_day = data.m_day;    this-&gt;str = date.str;    date.str = NULL;&#125;//移动赋值运算符CDate&amp; CDate::operator=(CDate&amp;&amp; date)&#123;    if(this != &amp;date)&#123;        delete[] this-&gt;str;        this-&gt;m_year = date.m_year;    \tthis-&gt;m_month = date.m_month;    \tthis-&gt;m_day = date.m_day;    \tthis-&gt;str = date.str;    \tdate.str = NULL;    &#125;    return *this&#125;CDate::~CDate()&#123;    delete[] str;&#125;\n由于移动操作“ 窃取” 资源， 它通常不分配任何资源。 因此, 移动操作通常不会抛出任何异常。不抛出异常的函数应该使用 noexcept 通知标准库，避免编译器为了处理异常而作一些额外的工作\n4.3 融合拷贝赋值运算符与移动赋值运算符\nCDate&amp; CDate::operator=(CDate date)&#123;    swap(*this,date);    return *this;&#125;//此运算符有一个非引用参数 需要进行拷贝初始化 使用前最好定义一个拷贝构造函数\n5. 完美转发 std::forward\n\n在通用引用的情境下，尽可能使用forward()\n\n5.2 通用引用(universal reference)\n构成通用引用的条件\n\n\n必须满足T&amp;&amp;这种形式\n\n\n类型T必须是通过推断得到的\n\n\n产生通用引用的可能情况\n\n\n函数模板参数（function template parameters）\ntemplate &lt;typename T&gt;void f(T&amp;&amp; param);\n\n\nauto声明（auto declaration）\nauto &amp;&amp; var = ...;\n\n\ntypedef声明（typedef declaration）\n\n\ndecltype声明（decltype declaration）\n\n\n与其他引用的区别\n​      会产生引用合成\nT&amp; &amp; =&gt; T&amp;T&amp;&amp; &amp; =&gt; T&amp;T&amp; &amp;&amp; =&gt; T&amp;T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp;\n该合成规则用户是不允许使用的，只有编译器才能够使用这种合成规则\n6.删除的函数(deleted function)\n\n指使用delete的函数 表示这类函数被禁用 不能被调用\n当尝试调用一个被删除的函数时，编译器将会报错，指出该函数是被删除的，从而在编译时期提供了一种检查机制，防止了不期望的函数调用\n\n用途\n\n\n防止拷贝:如果你有一个类，你不希望它的实例被拷贝，你可以删除拷贝构造函数和拷贝赋值运算符。\n\n\n防止移动\n\n\n限制某些函数的使用:可以删除那些不应该被调用的函数版本，比如禁止某些类型的参数\n\n\nclass OnlyInt &#123;public:    void func(int) &#123;&#125;    void func(double) = delete; // 删除接受 double 类型的函数版本&#125;;\n7. 多线程编程\n7.1 同步问题（Synchronization Issues）\n同步问题发生在当多个线程需要访问共享资源或数据，并且这些访问需要以某种特定的顺序执行时。如果同步不当，可能会导致数据不一致或竞态条件（Race Conditions）。\n例子：\n\n\n竞态条件：\n\n两个线程同时读取一个共享变量，然后基于这个变量的值进行计算，最后将结果写回。如果两个线程同时读取到相同的值，然后都进行计算并写入，那么一个线程的写入可能会覆盖另一个线程的结果，导致错误。\n\n\n\n死锁：\n\n线程A持有资源1并等待资源2，而线程B持有资源2并等待资源1。如果线程A和B都不释放它们持有的资源，那么它们将永远等待对方释放资源，导致程序无法继续执行。\n\n\n\n饥饿：\n\n一个线程因为优先级较低，始终无法获得它需要的资源，即使这些资源在其他线程中是可用的。\n\n\n\n为了解决同步问题，通常会使用以下机制：\n\n\n互斥锁（Mutexes）：确保同一时间只有一个线程可以访问共享资源。\n\n\n条件变量（Condition Variables）：允许线程在某些条件下挂起或被唤醒。\n\n\n读写锁（Read-Write Locks）：允许多个读操作同时进行，但写操作需要独占访问。\n\n\n原子操作（Atomic Operations）：提供不可分割的操作，确保在多线程环境中对数据的操作是安全的。\n\n\n7.2 并发问题（Concurrency Issues）\n并发问题是指多个线程同时执行，可能会导致性能问题或者需要特别设计算法来确保正确性的问题。\n例子：\n\n\n线程安全：\n\n一个线程正在修改一个数据结构，而另一个线程正在读取该数据结构。如果修改操作不是原子的，那么读取操作可能会得到不一致的数据。\n\n\n\n内存可见性：\n\n一个线程修改了一个共享变量，但这个修改对其他线程来说不是立即可见的。这可能导致其他线程读取到旧值。\n\n\n\n性能问题：\n\n过多的线程竞争同一个资源可能会导致性能下降，因为线程需要频繁地等待资源变得可用。\n\n\n\n为了解决并发问题，通常会使用以下策略：\n\n\n线程池：限制同时运行的线程数量，避免创建过多的线程导致的性能问题。\n\n\n无锁编程（Lock-Free Programming）：使用原子操作来避免锁的使用，提高并发性能。\n\n\n并行算法设计：设计可以同时在多个处理器上运行的算法，以利用多核处理器的优势\n\n\n7.3 Mutex的种类\n1. std::mutex （基本互斥锁）\nstd::mutex是C++标准库中提供的最基本的互斥锁类型之一。它用于实现线程间的互斥访问，即在一个时间点只允许一个线程获得锁，其他线程需要等待锁被释放才能继续执行。使用std::mutex可以保证多个线程对共享资源的访问顺序，并避免数据竞争产生的问题。\n常用函数\n\n\nlock()\t尝试获取互斥锁。如果未被其他线程占用，则当前线程获取锁；否则阻塞等待锁的释放。\n\n\nunlock()\t释放互斥锁。如果当前线程持有锁，则释放锁；否则行为未定义。\n\n\ntry_lock()\t尝试获取互斥锁，不会阻塞线程。如果未被其他线程占用，则当前线程获取锁并返回true；否则返回false。\n\n\n2. std::recursive_mutex （递归互斥锁）\nstd::recursive_mutex是C++标准库中提供的一个递归互斥锁类型，用于实现线程间的互斥访问。与std::mutex相比，std::recursive_mutex可以允许同一线程多次获取互斥锁，而不会导致死锁。简单来说就是允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，释放互斥量时需要调用与该锁层次深度相同次数的 unlock()\nstd::recursive_mutex定义在头文件中。与std::mutex类似，可以通过定义std::recursive_mutex对象来创建一个递归互斥锁。例如：\n#include &lt;mutex&gt;//这里定义了一个名为mtx的std::recursive_mutex对象，用于保护某个共享资源的访问。std::recursive_mutex mtx;\n当同一线程多次尝试获取std::recursive_mutex时，它不会导致死锁，而是允许同一线程多次获取锁，需要相应次数的解锁操作才能完全释放锁。\n3. std::timed_mutex （限时等待互斥锁）\n4. std::recursive_timed_mutex  (限时等待递归互斥锁)\n","categories":["编程"],"tags":["C++"]},{"title":"《C++ primer》文本查询程序一","url":"/2024/04/13/school_assignments/%E3%80%8AC-primer%E3%80%8B%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F%E4%B8%80/","content":"\n这是《C++ primer》中的一个示例程序，看了几遍仍觉有些细节没有明白，故手敲了一遍\n需了解STL容器部分知识点，智能指针，文件流，string流\n\n\n《C++ primer》文本查询程序一\n书上给的例子尚有瑕疵，如果单词在同一行出现多次，则只会记录为一次，本人能力有限，尚未解决此问题\n以下是写完程序后绘制的思维导图\n\n代码部分\n\n\nmain.cpp\n\n\n#include&lt;iostream&gt;#include&lt;fstream&gt;#include&quot;TextQuery.h&quot;#include&quot;ResultQuery.h&quot;using namespace std;void runQueries(ifstream&amp; fin);int main(void)&#123;    string filename;    cout &lt;&lt; &quot;请输入你要查询的文件名(包含后缀)&quot;&lt;&lt;endl;    cin &gt;&gt; filename;\tifstream readFile(filename, ios::in);\tif (readFile.is_open())\t&#123;\t\trunQueries(readFile);\t&#125;\telse\t\tcout &lt;&lt; &quot;the file open failed!!!&quot; &lt;&lt; endl;&#125;void runQueries(ifstream&amp; fin)&#123;\tTextQuery tq(fin);\twhile (1)\t&#123;\t\tcout &lt;&lt; &quot;please enter word to look for, or q to quit.&quot; &lt;&lt; endl;\t\tstring needle;\t\tif (cin &gt;&gt; needle &amp;&amp; needle != &quot;q&quot; &amp;&amp; needle != &quot;Q&quot;)\t\t&#123;\t\t\tMyPrint(cout, tq.query(needle)) &lt;&lt; endl;\t\t&#125;\t\telse break;\t&#125;&#125;\n\n\nTextQuery.h\n\n\n#pragma once#include&lt;memory&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&quot;ResultQuery.h&quot;using namespace std;class TextQuery &#123;private:\tshared_ptr&lt;vector&lt;string&gt;&gt; file;   //智能指针 多个对象共享数据 存储地址\tmap&lt;string, shared_ptr&lt;set&lt;int&gt;&gt;&gt; wm; //间接实现单词与行号之间的映射public:\tTextQuery(ifstream&amp; fin);   //构造函数\tResultQuery query(string needle); //用来整理出目标单词的相关信息，然后传递给ResultQuery&#125;;\n\n\nTextQuery.cpp\n\n\n#include &quot;TextQuery.h&quot;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;fstream&gt;using namespace std;TextQuery::TextQuery(ifstream&amp; fin):file(new vector&lt;string&gt;)&#123;\tstring lineContent;\tsize_t lineNo;\twhile(getline(fin,lineContent))    // 将文件内容拆分为一行一行\t&#123;\t\tfile-&gt;push_back(lineContent);\t\tlineNo = file-&gt;size() - 1;    //从零开始计数，方便之后利用迭代器进行输出查询结果\t\tistringstream line(lineContent); //利用string流 将一行内容再拆分为每个单词\t\tstring word;\t\twhile (line &gt;&gt; word)     //实现每个单词与对应行号之间的映射\t\t&#123;\t\t\tshared_ptr&lt;set&lt;int&gt;&gt;&amp; NO = wm[word];  // 在map中如果使用下标未找到对应的值，则会自动生成一个默认值\t\t\tif (!NO)\t\t\t&#123;\t\t\t\tNO.reset(new set&lt;int&gt;);    //清空默认值，使其是一个指向set&lt;int&gt;型的指针\t\t\t\tNO-&gt;insert(lineNo);        //将这个单词所在的行号拷贝给 指针指向的那个空间\t\t\t&#125;\t\t\telse\t\t\t\tNO-&gt;insert(lineNo);\t\t&#125;\t&#125;&#125;ResultQuery TextQuery::query(string needle)&#123;\tshared_ptr&lt;set&lt;int&gt;&gt; nothing (new set&lt;int&gt;);\tauto result = wm.find(needle);\tif (result == wm.end())\t&#123;\t\treturn ResultQuery(needle,file, nothing);\t&#125;\telse\t&#123;\t\treturn ResultQuery(needle,file, result-&gt;second);\t&#125;&#125;\n\n\nResultQuery.h\n\n\n#pragma once#include&lt;memory&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;class ResultQuery&#123;private:\tstring needle;\tshared_ptr&lt;vector&lt;string&gt;&gt; file;\tshared_ptr&lt;set&lt;int&gt;&gt; lines;public:\tResultQuery(string n, shared_ptr&lt;vector&lt;string&gt;&gt; f, shared_ptr&lt;set&lt;int&gt;&gt; l) :\\\t\tneedle(n), file(f), lines(l) &#123;&#125;    //构造函数 进行初始化\tfriend ostream&amp; MyPrint(ostream&amp;, const ResultQuery&amp;);&#125;;\n\n\nResultQuery.cpp\n\n\n#include &quot;ResultQuery.h&quot;#include &lt;iostream&gt;ostream&amp; MyPrint(ostream&amp; os, const ResultQuery&amp; rq) &#123;\tos&lt;&lt; rq.needle &lt;&lt; &quot; occurs &quot; &lt;&lt; rq.lines-&gt;size() &lt;&lt; &quot;times in the file &quot;  &lt;&lt; endl;\tfor (auto line : *(rq.lines))\t&#123;\t\tos &lt;&lt; &quot;\\tline:&quot;&lt;&lt;line+1&lt;&lt; &quot; &quot;&lt;&lt;rq.file-&gt;begin()[line]&lt;&lt;endl;\t&#125;\treturn os;&#125;\n","categories":["编程"],"tags":["C++"]},{"title":"Web前端基础","url":"/2024/04/05/web/Web%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/","content":"\nWeb 前端的一些基础知识和相关工具的使用\n\n\nJava Web\n文档查询网站:https://www.w3school.com.cn/index.html\nWeb前端\n网页\n\n\n本质是前端代码经过浏览器的解析和渲染而成的\n\n\n浏览器内核进行代码的解析和渲染\n\n\nweb标准\n\n\nHTML：负责网页的结构（页面元素和内容）\n\n\nCSS：负责网页的表现（页面元素的外观，位置，颜色，大小等）\n\n\nJavaScript：负责网页的行为（交互效果）\n\n\n高级技术\n\nVue.js\nElementUI\nAjax\nAxios\n…\n\n\n\nHTML（HyperText Markup Language）\n\n\n超文本标记语言（超越普通文本语言，由标签构成的语言）\n\n\n标签是预定好的，\n\n\nHTML代码直接在浏览器中运行，HTML标签由浏览器解析\n\n\n特点\n\n\n不区分大小写\n\n\n属性可以使用单引号或者双引号\n\n\n语法松散\n\n\n常用标签\n\n\n&lt;img&gt;\n\nsrc:指定图像的url（相对或绝对）\nwidth\nheight\n\n\n\n标题标签:&lt;h1&gt; - &lt;h6&gt;\n\n\n水平线标签:&lt;hr&gt;\n\n\n超链接&lt;a&gt;\n\nhref指定访问资源的url\ntarget指定在何处打开资源(_self,_blank)\n\n\n\n&lt;video&gt;视频\n\ncontrols显示播放控件\nsrc\nwidth\n\n\n\n&lt;audio&gt;音频\n\ncontrols\nsrc\nwidth\n\n\n\n&lt;b&gt;/&lt;strong&gt;加粗\n\n\n&lt;p&gt;分段落\n\n\n表格标签\n\n\n&lt;table&gt;定义表格整体\n\nborder:规定边框宽度\nwidth:规定表格的宽度\ncellspacing:规定单元格之间的空隙大小\n\n\n\n&lt;tr&gt;:表格的行\n\n\n&lt;td&gt;:表格单元格，（表头使用&lt;th&gt;）\n\n\n\n\n&lt;table border=&quot;1px&quot; cellspacing=&quot;0&quot; width=&quot;600px&quot;&gt;   &lt;tr&gt;      &lt;th&gt;角色名称&lt;/th&gt;       &lt;th&gt;图片&lt;/th&gt;      &lt;th&gt;元素&lt;/th&gt;      &lt;th&gt;国度&lt;/th&gt;   &lt;/tr&gt;     &lt;tr&gt;      &lt;td&gt;那维莱特&lt;/td&gt;      &lt;td&gt;&lt;img src=&quot;https://picx.zhimg.com/70/v2-5623d0ee6d0a7f7a63ffce7830fdbc7a_1440w.avis?source=172ae18b&amp;biz_tag=Post&quot; width=&quot;100px&quot;&gt;&lt;/td&gt;      &lt;td&gt;水&lt;/td&gt;      &lt;td&gt;枫丹&lt;/td&gt;   &lt;/tr&gt;       &lt;tr&gt;      &lt;td&gt;提纳里&lt;/td&gt;      &lt;td&gt;&lt;img src=&quot;https://patchwiki.biligame.com/images/ys/2/2b/hcwuh3cbgc5dyfcx4qlqp95qlzbp619.png&quot; width=&quot;100px&quot;&gt;&lt;/td&gt;      &lt;td&gt;草&lt;/td&gt;      &lt;td&gt;须弥&lt;/td&gt;   &lt;/tr&gt;  &lt;/table&gt;\n\n\n表单标签\n\n负责采集数据，如登录，注册等信息\n&lt;form&gt;\n\n\n&lt;input&gt;:定义表单项，通过type属性控制输入形式\n\n\n\n\n\n&lt;select&gt;:定义下拉列表\n\n&lt;option&gt;定义列表项\n\n\n\n&lt;textarea&gt;:定义文本域\n\n\n\n\n\n\n&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    姓名:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br&gt;&lt;br&gt;    密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;&lt;br&gt;    性别:&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;男&lt;/label&gt;    \t&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;2&quot;&gt;女&lt;/label&gt;&lt;br&gt;&lt;br&gt;    爱好:&lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;java&lt;/label&gt;        &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;genshin&quot;&gt;genshin&lt;/label&gt;        &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;sleep&quot;&gt;sleep&lt;/label&gt; &lt;br&gt;&lt;br&gt;    图像:&lt;input type=&quot;file&quot; name=&quot;image&quot;&gt; &lt;br&gt;&lt;br&gt;    生日:&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt; &lt;br&gt;&lt;br&gt;    时间:&lt;input type=&quot;time&quot; name=&quot;time&quot;&gt; &lt;br&gt;&lt;br&gt;    日期时间:&lt;input type=&quot;datetime-local&quot; name=&quot;datetime&quot;&gt; &lt;br&gt;&lt;br&gt;    邮箱:&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt; &lt;br&gt;&lt;br&gt;    年龄:&lt;input type=&quot;number&quot; name=&quot;age&quot;&gt; &lt;br&gt;&lt;br&gt;    学历:&lt;select name=&quot;degree&quot;&gt;    \t\t &lt;option value=&quot;&quot;&gt;-----------请选择---------&lt;/option&gt;   \t\t\t &lt;option value=&quot;1&quot;&gt;大专&lt;/option&gt;   \t\t\t &lt;option value=&quot;2&quot;&gt;本科&lt;/option&gt;   \t\t\t &lt;option value=&quot;3&quot;&gt;硕士&lt;/option&gt;   \t\t\t &lt;option value=&quot;4&quot;&gt;博士&lt;/option&gt;    \t&lt;/select&gt; &lt;br&gt;&lt;br&gt;    描述:&lt;textarea name=&quot;description&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;    &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;1&quot;&gt;        &lt;!-- 表单常见按钮 --&gt;    &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt;    &lt;input type=&quot;reset&quot;  value=&quot;重置&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;\n\n\n属性\n\naction:规定提交表单时向何处发送表单数据，URL(如果不指定默认提交到当前页面)\nmethod:规定用于发送表单数据的方式。GET，POST\n\nget在url后面拼接表单数据\npost在消息体（请求体）中传递，参数长度无限制\n\n\n\n\n\n\n\n\nCSS（Cascading Style Sheet）\n\n\n层叠样式表，控制网页的表现\n\n\nCSS选择器\n\n\n元素选择器h1&#123;&#125;\n\n\nid选择器#hid&#123;&#125;(在style中)     &lt;h1 id=&quot;hid&quot;&gt;不能重复\n\n\n类选择器.cls&#123;&#125;(在style中)      &lt;h1 class=&quot;cls&quot;&gt;\n\n\n常用标签\n\n\n&lt;span&gt;无语义的布局标签，一行可显示多个\n\n\n&lt;div&gt;\n\n\n属性\n\n\ncolor\n\n\nfont-size：字体大小（加px）\n\n\ntext-decoration:规定文本的修饰，none表示定义标准的文本\n\n\ntext-align：控制对齐方式\n\n\ntext-indent:首行缩进\n\n\nline-height：行高\n\n\n空格占位符：&amp;nbsp\n\n\n盒子模型\n\n\n&lt;div&gt;无语义的布局标签，一行只占一个\n\n\n组成：内容区域(content)，内边距区域(padding)，边框区域(border)，外边距区域(margin)\n\n\n\n&lt;style&gt;    h1&#123;       color:rgb(102, 97, 97);     &#125;   //类选择器    .time&#123;      color:rgb(241, 3, 3);    &#125;    //标签选择器    a&#123;        color:black;        text-decoration: none;    &#125;    //id选择器   #wangmc&#123;        text-align: right;        font-size: 28px;        color:chocolate;    &#125;        /*&lt;div id=&quot;center&quot;&gt;*/   #center&#123;        width:80%;        box-sizing: border-box;/*指定width为盒子宽度*/        background-color: rgb(219, 235, 235);        padding: 20px; /*内边距 上右下左*/        border: 1px solid red;/*边框宽度 线条类型 颜色*/        margin:auto;/*外边距 */    &#125;&lt;/style&gt;\nJavaScript（简称：js）\n\n\n跨平台，面向对象的脚本语言，使网页可以交互\n\n\njs引入方式\n\n\n内部脚本（定义在HTML页面）\n\njs代码必须位于&lt;script&gt;&lt;/script&gt;之间\n可以放在任意地方，放置任意数量\n一般位于&lt;body&gt;元素的底部，改善显示速度\n\n\n\n外部脚本（js代码定义在外部角色文件中，然后引入到HTML中）\n\n外部js文件中只包含js代码，不含有&lt;script&gt;标签\n&lt;script&gt;标签不能自闭合\n\n\n\n基础语法\n\n\n书写语法\n\n区分大小写\n每条语句结束可以不写分号\n\n\n\n输出语句\n\nwindow.alert()  写入警告框\ndocument.write()  写入HTML输出\nconsole.log()  写入浏览器控制台\n\n\n\n变量\n\n\n利用var，let，const关键字来声明变量\n\n\n因为js是弱类型的语言，所以变量可以存放不同类型的值\n\n\n利用var定义出来的是全局变量，可以重复定义\n\n\n利用let定义出来的是局部变量，只在代码块中有效，不可重复定义\n\n\n数据类型\n\n\n原始类型\n\nnumber，string，boolean，null，undefined\n\n\n\n引用类型\n\njs中的对象\n\n\n\n利用typeof来获取数据类型\n\n\n运算符\n\n\n==：会进行类型转换\n\n\n===：不会进行类型转换\n\n\njs函数\n\n\n通过function关键字进行定义\n\n\n不需要定义形参和返回值的类型\n\n\njs对象\n\n\nArray\n\nvar 变量名 =  [元素列表]\nvar 变量名 = new Array（元素列表）\n属性：length，返回数组中的元素数量\n方法\n\nforEach()：遍历数组中每一个有值的元素，并调用一次传入的函数\n\n箭头函数:arry.forEach(item=&gt;{console.log(item);})\n\n\npush()：将新元素添加到数组末尾，并返回新的长度\nsplice(start,number)：从数组中删除元素\n\n\n\n\n\nString\n\n属性：length\n方法\n\ncharAt()：返回指定位置的字符\nindexOf()：检索字符串所在的位置\ntrim()：去除字符串两边的空格\nsubstring(start,end):提取字符串中两个指定的索引号之间的字符(左闭右开)\n\n\n\n\n\nJSON(JavaScript Object Notation)\n\n通过JavaScript对象标记法写的文本\n多作为数据载体，进行数据传输\n自定义对象\n\n\n\n\n格式与自定义对象类似，但变量名要加双引号\n定义\n\nvar 变量名 = '&#123;&quot;key1&quot;: value1,&quot;key2&quot;:value2&#125;'\nvar userStr = '&#123;&quot;name&quot;:&quot;Jerry&quot;,&quot;age&quot;:18,&quot;addr&quot;:[&quot;原神&quot;,&quot;星铁&quot;,&quot;绝区零&quot;]&#125;'\n该对象是文本，整体要加单引号\n\n\n方法\n\nJSON.parse()    将 JSON 字符串解析为 JavaScript 对象\nJSON.stringify()\n\n\n\n\n\nBOM(Browser Object Model)\n\n浏览器对象模型，允许js与浏览器对话，js将浏览器各个组成部分封装为对象\n组成\n\nWindow:浏览器窗口对象\n\n方法\n\nalert()显示带有一段消息和一个确认按钮的警告框\nconfirm()显示带有一段消息以及一个确认和取消按钮的对话框\nsetInterval()按照指定的周期来调用函数\nsetTimeout()在指定的毫秒数后调用函数\n\n\n\n\nNavigator:浏览器对象\nScreen\nHistory\nLocation:地址栏对象\n\n属性：href\nlocation.href = &quot;https://www.xxxx.cn&quot;`\n\n\n\n\n\n\n\nDOM(Document Object Model)\n\n将标记语言的各个组成部分封装为对应的对象\n\nDocument:整个文档对象\nElement:元素对象\nAttribute:属性对象\nText:文本对象\nComment:注释对象\n\n\n\n\n\njs事件监听\n\n\n指发生在HTML元素上的事情，如按钮被点击，按下鼠标快捷键,执行相应代码\n\n\n事件绑定\n\n\n\n\n\n常见事件\n\n\n\n\n\nVue\n\n\n前端框架，免除js中的DOM操作，基于MVVM思想，实现数据双向绑定\n\n\n插值表达式:\n常用属性\n\n\nel指示vue编译器从什么地方开始解析 vue的语法\n\n\ndata存储变量\n\n\nmethods存放函数\n\n\ntemplate设置模板\n\n\nwatch\n\n\ncomputed\n\n\nrender创建真正的Virtual Dom\n\n\n常用指令\n\n\nv-model在表单元素上创建双向数据绑定\n\n\nv-bind为HTML标签绑定属性值，如href，css样式\n\n\n&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;        &#123;&#123;message&#125;&#125;    &lt;/div&gt;    &lt;div id=&quot;yuanshen&quot;&gt;        &lt;a v-bind:href=&quot;url&quot; target=&quot;_blank&quot;&gt;原神&lt;/a&gt;        &lt;input type=&quot;text&quot; v-model=&quot;url&quot;&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script&gt;    new Vue(&#123;        el: &quot;#app&quot;,        data:&#123;            message:&quot;hello vue&quot;        &#125;    &#125;)    new Vue(&#123;        el:&quot;#yuanshen&quot;,        data:&#123;            url:&quot;https://www.yuanshen.com/#/&quot;        &#125;    &#125;)&lt;/script&gt;\n\n\nv-on为HTML标签绑定事件\n\n\n\n\n\nv-if, v-else-if, v-else条件性的渲染某元素\n\n\nv-show根据条件展示某元素，区别在于切换的是display属性的值\n\n\nv-for列表渲染，遍历容器中的元素或者对象的属性\n\n&lt;div v-for=&quot;变量名 in 遍历对象&quot;&gt;&#123;&#123;变量名&#125;&#125;&lt;/div&gt;\n\n\n\n&lt;div v-for=&quot;addr in addrs&quot;&#123;&#123;addr&#125;&#125;&lt;/div&gt;&lt;div v-for=&quot;(addr,index) in addrs&quot;&#123;&#123;index+1&#125;&#125;:&#123;&#123;addr&#125;&#125;&lt;/div&gt;data:&#123;\t...\taddrs:[&#x27;beijing&#x27;,&#x27;shanghai&#x27;,&#x27;hongkong&#x27;,&#x27;nanjing&#x27;]&#125;,\n\n\n案例\n\n\n&lt;div id=&quot;app&quot;&gt;        &lt;table border=&quot;1px&quot; cellspacing=&quot;0&quot; width=&quot;60%&quot;&gt;            &lt;tr&gt;                &lt;th&gt;编号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;成绩&lt;/th&gt;&lt;th&gt;等级&lt;/th&gt;            &lt;/tr&gt;            &lt;tr align=&quot;center&quot; v-for=&quot;(arr,index) in users&quot;&gt; //遍历users数组中的元素，并赋值给arr                &lt;td&gt;&#123;&#123;index+1&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;arr.name&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;arr.age&#125;&#125;&lt;/td&gt;                &lt;td&gt;                    &lt;span v-if=&quot;arr.gender==1&quot;&gt;boy&lt;/span&gt;                    &lt;span v-else-if=&quot;arr.gender==0&quot;&gt;girl&lt;/span&gt;                &lt;/td&gt;                &lt;td&gt;&#123;&#123;arr.score&#125;&#125;&lt;/td&gt;                &lt;td&gt;                    &lt;span v-if=&quot;arr.score&gt;=90&quot;&gt;优秀&lt;/span&gt;                    &lt;span v-else-if=&quot;arr.score&gt;=60&quot;&gt;及格&lt;/span&gt;                    &lt;span v-else=&quot;arr.score 60&quot; style=&quot;color:red &quot;&gt;不及格&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/div&gt;    &lt;script&gt;        new Vue(&#123;            el:&quot;#app&quot;,            data:&#123;                users:[&#123;name:&quot;纳西妲&quot;,age:&quot;500&quot;,gender:0,score:100&#125;,                &#123;name:&quot;芙宁娜&quot;,age:&quot;530&quot;,gender:0,score:80&#125;,                &#123;name:&quot;荒泷一斗&quot;,age:&quot;101&quot;,gender:1,score:55&#125;,                &#123;name:&quot;旅行者&quot;,age:&quot;666&quot;,gender:1,score:90&#125;,                &#123;name:&quot;派蒙&quot;,age:&quot;320&quot;,gender:0,score:66&#125;,                &#123;name:&quot;七七&quot;,age:&quot;432&quot;,gender:0,score:77&#125;,                &#123;name:&quot;天理&quot;,age:&quot;999&quot;,gender:0,score:150&#125;]            &#125;,        &#125;)    &lt;/script&gt;\n生命周期\n\n\n每触发一个生命周期事件，会自动执行一个生命周期方法（钩子）\n\n\n八个阶段\n\nbeforeCreate\ncreated\nbeforeMount\nmounted挂载完成\nbeforeUpdate\nupdated\nbeforeDestroy\ndestroyed\n\n\n\nVue路由(Vue Router)\n\n\nVue router 路由器类，根据路由请求在路由视图中动态渲染选中的组件\n\n\n&lt;router-link&gt;请求链接组件，会被浏览器解析为&lt;a&gt;\n\n\n&lt;router-view&gt;动态视图组件，用来渲染展示与路由路径对应的组件\n\n\nAjax(Asynchronous Javascript Anderson XML)\n\n\n异步的Javascript和XML\n\n\n作用\n\n\n数据交换：通过它可以向服务器发送请求，并获取服务器响应的数据\n\n\n异步交互：不刷新整个页面的同时，进行局部刷新\n\n\nAxios\n\n\n对原生的Ajax进行了封装，简化书写，快速开发\n\n\n入门程序\n\n\n&lt;input type=&quot;button&quot; value=&quot;获取数据GET&quot; onclick=&quot;get()&quot;&gt;    &lt;input type=&quot;button&quot; value=&quot;删除数据POST&quot; onclick=&quot;post()&quot;&gt;    &lt;script&gt;        function get()&#123;            axios(&#123;                method:&quot;get&quot;,                url:&quot;http://yuanshen.com&quot;            &#125;).then(result=&gt;&#123;                console.log(result.data);            &#125;)-------------------------------------------------------------------------------------------------            axios.get(&quot;http://yuanshen.com&quot;).then(result=&gt;&#123;console.log(result.data)&#125;) //简化模式        &#125;    &lt;/script&gt;\n\n\n\n结合Vue中的mounted生命周期事件\n\n\n&lt;script&gt;\tnew Vue(&#123;    \tel:&quot;#app&quot;,    \tdata:&#123;            emps:[]        &#125;,    \tmounted()&#123;            axios.get(&quot;http://www.xxxx.xxx.com&quot;).then(result=&gt;&#123;                this.emps = result.data.data;            &#125;)        &#125;&#125;);   &lt;/script&gt;\nYApi\n\n\n高效，易用，功能强大的api管理平台\n\n\n用于模拟前端所需要的数据\n\n\n前端工程化\n定义\n\n\n指把前端开发所需的工具，技术，流程，经验等进行规范化，标准化\n\n\nvue脚手架的环境准备\n\n\n安装node.js\n\n\n配置npm的全局安装路径   npm config set prefix &quot;node.js的安装路径&quot;\n\n\n切换npm的镜像  npm config set registry 镜像地址\n\n腾讯 镜像: https://mirrors.cloud.tencent.com/npm/\n华为 镜像: https://mirrors.huaweicloud.com/repository/npm/\n阿里 镜像：https://npm.aliyun.com\n\n\n\n安装vue-cli npm install -g @vue/cli\n\n\n确认是否安装成功 vue --version\n\n\nVue项目\n创建\n\n\n命令行 vue create vue-project01\n\n\n图形化界面vue ui\n\n\n目录结构\n\n\nnode_modules 整个项目的依赖包\n\n\npublic 存放项目的静态文件\n\n\nsrc       存放项目的源代码\n\nassets静态资源\ncomponents可重用的组件\nrouter路由配置\nviews视图组件（页面）\nApp.vue入口页面（根组件）\nmain.js入口js文件\n\n\n\npackage.json   模板基本信息，项目开发所需要的模块，版本信息\n\n\nvue.config.js     保存vue配置的文件，如：代理，端口的配置\n\n\n更改端口号\n\n\n进入vue.config.js文件\n\n\nconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123;  transpileDependencies: true, //添加以下内容，将端口号改为7000  devServer:&#123;    port:7000  &#125;&#125;)\nVue的组件文件以.vue结尾，每个组件由三部分组成&lt;template&gt;，&lt;script&gt;，&lt;style&gt;\n&lt;template&gt;&lt;div&gt;&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;/template&gt;  //模板部分，生成HTML代码&lt;script&gt;export default &#123;  data:function()&#123;    return&#123;      message:&quot;hello vue&quot;    &#125;  &#125;,  methods: &#123;      &#125;,&#125;&lt;/script&gt;  //控制模板的数据来源和行为&lt;style&gt;&lt;/style&gt;  //css样式部分\nElement(Vue组件库)\n组件：组成网页的部件，如超链接，按钮，图片，表格，表单，分页条等\nurl：一个 Vue 3 UI 框架 | Element Plus (element-plus.org)\n如何使用\n\n\n在创建好的Vue项目中安装ElementUI组件库  npm install element-plus --save\n\n\n引入ElementUI组件库\nimport &#123; createApp &#125; from &#x27;vue&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)app.use(ElementPlus)app.mount(&#x27;#app&#x27;)\n\n\n访问官网，复制组件代码，调整\n\n\n打包部署\n\n\n先打包npm run build 再部署\n\n\n将打包好的dist目录下的文件，复制到nginx安装目录下的html目录\n\n\n启动：双击nginx.exe文件，nginx服务器默认占用本机80端口号\n\n如果80端口号被占用，可以在nginx.conf中修改端口号\n查看端口被谁占用netstat -ano | findStr 80\n\n\n\n访问：浏览器输入 localhost:端口号\n\n\nNginx\n一款轻量级的web服务器，反向代理服务器，电子邮件代理服务器\n","categories":["编程"],"tags":["Web"]}]